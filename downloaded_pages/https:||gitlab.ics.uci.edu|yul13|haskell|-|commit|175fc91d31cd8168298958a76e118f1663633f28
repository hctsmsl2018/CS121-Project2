



GitLab












Menu




Projects
Groups
Snippets


















/








Help







Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab












Menu




Projects
Groups
Snippets


















/








Help







Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab












Menu




Projects
Groups
Snippets



GitLab






GitLab




Menu




Projects
Groups
Snippets




Menu


Projects
Groups
Snippets















/








Help







Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in
















/














/








Help







Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help



Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab




Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


haskell






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Yu Liu haskell
Commits

175fc91d















Commit
175fc91d


authored
Feb 27, 2015
by


darlliu



Browse files




update







parent
a1c71aea













Changes
1




Hide whitespace changes

Inline
Side-by-side















tabular/Tabular.hs








View file @ 175fc91d






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()
















Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


haskell






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


haskell


H
H
haskell




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Yu Liu haskell
Commits

175fc91d















Commit
175fc91d


authored
Feb 27, 2015
by


darlliu



Browse files




update







parent
a1c71aea













Changes
1




Hide whitespace changes

Inline
Side-by-side















tabular/Tabular.hs








View file @ 175fc91d






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()
















Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Yu Liu haskell
Commits

175fc91d







Open sidebar



Yu Liu haskell
Commits

175fc91d




Open sidebar

Yu Liu haskell
Commits

175fc91d


Yu LiuhaskellhaskellCommits
175fc91d








Commit
175fc91d


authored
Feb 27, 2015
by


darlliu



Browse files




update







parent
a1c71aea













Changes
1




Hide whitespace changes

Inline
Side-by-side















tabular/Tabular.hs








View file @ 175fc91d






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()
















Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
175fc91d


authored
Feb 27, 2015
by


darlliu



Browse files




update







parent
a1c71aea













Changes
1




Hide whitespace changes

Inline
Side-by-side















tabular/Tabular.hs








View file @ 175fc91d






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()
















Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
175fc91d


authored
Feb 27, 2015
by


darlliu



Browse files



Commit
175fc91d


authored
Feb 27, 2015
by


darlliu

175fc91dauthoredbydarlliu

update






parent
a1c71aea
















parent
a1c71aea





parent












Changes
1
1


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










tabular/Tabular.hs








View file @ 175fc91d






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()














tabular/Tabular.hs








View file @ 175fc91d






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()












tabular/Tabular.hs








View file @ 175fc91d








tabular/Tabular.hs










View file @ 175fc91d


175fc91d



......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()






......@@ -6,11 +6,13 @@ import qualified Data.Vector as V









import Control.Monad










import Control.Exception as E










import Data.List










import Data.Ord (comparing)










import System.IO










type Text = ByteString -- Change this to change the underlying datatype










type Tabular = V.Vector(V.Vector Text)










type TabularRow = V.Vector Text





















-- File Accessor










-- File accessor










fromFileWith' sep quote fp= do










 let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}










 csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )



......@@ -26,12 +28,33 @@ fromFileWith sep quote fp = E.catch




















fromFile = fromFileWith '\t' Nothing





















-- Write to file as tsv





















showTabular :: Tabular -> String










showTabular t = intercalate "\n" $ V.toList $ rows where










 rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) t





















showTabularM :: Maybe Tabular -> String










showTabularM Nothing = ""










showTabularM (Just t) = showTabular t





















toFile fname t = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle (showTabular t))





















toFile' fname t = case t of 










 Nothing -> return ()










 Just tt -> toFile fname tt










-- Constructor with an ordering





















reorder :: V.Vector Int -> Tabular -> Tabular










reorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)





















reorderM = liftM2 reorder










-- Row accessor, get Nothing in case of error





















header' t = t V.! 0










header t = if V.length t > 0 










 then Just (t V.! 0)










 else Nothing










header t = V.map pack $ t V.! 0





















(#!) :: Tabular -> Int -> Maybe TabularRow










t #! i = if i<0 || i> V.length t 



......@@ -56,11 +79,10 @@ t % i = t >>= (%! i)































(%%!):: Tabular -> String -> Maybe TabularRow










t %%! s = let hd = header t in case hd of










 Nothing -> Nothing 










 Just h -> let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx










t %%! s = let h = header' t in 










 let key = (pack s) `V.elemIndex` h in case key of










 Nothing -> Nothing










 Just idx -> t %! idx





















(%%):: Maybe(Tabular) -> String -> Maybe TabularRow










t %% s = t >>= (%%! s)



......@@ -69,18 +91,18 @@ t %% s = t >>= (%%! s)




















toFloat :: TabularRow ->(V.Vector Float)










toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xs










toFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)










toFloatM = fmap toFloat










toFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)










toFloatM = liftM toFloat





















toString :: TabularRow ->(V.Vector String)










toString xs = V.map (\x -> unpack x) xs










toStringM :: Maybe TabularRow -> Maybe (V.Vector String)










toStringM = fmap toString










toStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)










toStringM = liftM toString





















toBool :: TabularRow ->(V.Vector Bool)










toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xs










toBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)










toBoolM = fmap toBool










toBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)










toBoolM = liftM toBool





















--modifiers 














......@@ -120,9 +142,78 @@ setColN n (Just c) t = let nn = pack n in case nn `V.elemIndex` (header' t) of









--use >>= to modify





















--populators










--addRow < 










--addRow 





















rowAdd' :: TabularRow -> Tabular -> Maybe Tabular





















r `rowAdd'` t = if (V.length r) /= (V.length $ header' t)










 then Nothing










 else Just (t `V.snoc` r)





















rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe Tabular










Nothing `rowAdd` _ = Nothing










_ `rowAdd` Nothing = Nothing










(Just r) `rowAdd` (Just t) = r `rowAdd'` t










t `addRow` r = r `rowAdd` t










--addCol (Name separate) <<





















colAdd' :: (String, TabularRow) -> Tabular -> Maybe Tabular





















(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1










 then Nothing










 else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )





















colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe Tabular










(_, Nothing) `colAdd` _ = Nothing










(_, _ ) `colAdd` Nothing = Nothing










(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t










t `addCol` c = c `colAdd` t
































--Sort and Filter





















filter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Int










filter' f i t = let c = t %! i in case c of 










 Just cc -> V.findIndices f cc










 Nothing -> V.fromList []





















filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)










filterM' f i = liftM ( filter' f i ) 





















filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector Int










filterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> filter' f (-1) t










 Just ii -> filter' f ii t





















filterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)










filterNM f s = liftM (filterN f s)
































sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Int










sort' f i t = let c = (t %! i) in case c of 










 Nothing -> V.fromList $ take (V.length t) [0 ..]










 (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)





















sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)










sortM' f i = liftM (sort' f i)





















sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector Int










sortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of 










 Nothing -> sort' f (-1) t










 Just ii -> sort' f ii t





















sortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)










sortNM f s = liftM (sortN f s)





















-- Utility





















text2Float x = (read $ unpack x ):: Float





















text2String x = unpack x 





















text2Bool x = (read $ unpack x ):: Bool
































main = do










 t <- fromFile "./txts/test_csv.txt"










 let r = t # 0



......@@ -135,4 +226,15 @@ main = do









 putStrLn $ show $ tt#3 










 let ttt = t >>= (setColN "KEGG" c)










 putStrLn $ show $ ttt%%"KEGG"










 let ttt2 = ttt `addRow` r










 let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)










 putStrLn "Testing Adding Column"










 putStrLn $ show $ ttt3 %% "Added Column"










 putStrLn "Testing sorting and filtering"










 putStrLn $ show (ttt % 16)










 putStrLn $ show $ sortM' text2Float 16 ttt










 let os = filterM' (\x -> text2Float x < 1) 16 ttt










 putStrLn $ show os










 putStrLn $ showTabularM $ (reorderM os ttt)










 toFile' "./txts/test_csv_out.txt" (reorderM os ttt)










 return ()


import Control.MonadimportControl.Monadimport Control.Exception as EimportControl.ExceptionasEimport Data.ListimportData.Listimport Data.Ord (comparing)importData.Ord(comparing)import System.IOimportSystem.IOtype Text = ByteString -- Change this to change the underlying datatypetypeText=ByteString-- Change this to change the underlying datatypetype Tabular = V.Vector(V.Vector Text)typeTabular=V.Vector(V.VectorText)type TabularRow = V.Vector TexttypeTabularRow=V.VectorText-- File Accessor-- File AccessorA-- File accessor-- File accessorafromFileWith' sep quote fp= dofromFileWith'sepquotefp=do let myOption = CSVSettings{csvSep=sep, csvQuoteChar=quote}letmyOption=CSVSettings{csvSep=sep,csvQuoteChar=quote} csvData <- readCSVFile myOption fp :: IO ( V.Vector([Text]) )csvData<-readCSVFilemyOptionfp::IO(V.Vector([Text]))fromFile = fromFileWith '\t' NothingfromFile=fromFileWith'\t'Nothing-- Write to file as tsv-- Write to file as tsvshowTabular :: Tabular -> StringshowTabular::Tabular->StringshowTabular t = intercalate "\n" $ V.toList $ rows whereshowTabulart=intercalate"\n"$V.toList$rowswhere rows = V.map (\x -> intercalate "\t" (V.toList (toString x))) trows=V.map(\x->intercalate"\t"(V.toList(toStringx)))tshowTabularM :: Maybe Tabular -> StringshowTabularM::MaybeTabular->StringshowTabularM Nothing = ""showTabularMNothing=""showTabularM (Just t) = showTabular tshowTabularM(Justt)=showTabularttoFile fname t = dotoFilefnamet=do withFile fname WriteMode (\handle -> dowithFilefnameWriteMode(\handle->do hPutStr handle (showTabular t))hPutStrhandle(showTabulart))toFile' fname t = case t of toFile'fnamet=casetof Nothing -> return ()Nothing->return() Just tt -> toFile fname ttJusttt->toFilefnamett-- Constructor with an ordering-- Constructor with an orderingreorder :: V.Vector Int -> Tabular -> Tabularreorder::V.VectorInt->Tabular->Tabularreorder os t = (header' t) `V.cons` (V.map (\x -> t V.! (x+1)) os)reorderost=(header't)`V.cons`(V.map(\x->tV.!(x+1))os)reorderM = liftM2 reorderreorderM=liftM2reorder-- Row accessor, get Nothing in case of error-- Row accessor, get Nothing in case of errorheader' t = t V.! 0header't=tV.!0header t = if V.length t > 0 headert=ifV.lengtht>0 then Just (t V.! 0)thenJust(tV.!0) else NothingelseNothingheader t = V.map pack $ t V.! 0headert=V.mappack$tV.!0(#!) :: Tabular -> Int -> Maybe TabularRow(#!)::Tabular->Int->MaybeTabularRowt #! i = if i<0 || i> V.length t t#!i=ifi<0||i>V.lengtht(%%!):: Tabular -> String -> Maybe TabularRow(%%!)::Tabular->String->MaybeTabularRowt %%! s = let hd = header t in case hd oft%%!s=lethd=headertincasehdof Nothing -> Nothing Nothing->Nothing Just h -> let key = (pack s) `V.elemIndex` h in case key ofJusth->letkey=(packs)`V.elemIndex`hincasekeyof Nothing -> NothingNothing->Nothing Just idx -> t %! idxJustidx->t%!idxt %%! s = let h = header' t in t%%!s=leth=header'tin let key = (pack s) `V.elemIndex` h in case key ofletkey=(packs)`V.elemIndex`hincasekeyof Nothing -> NothingNothing->Nothing Just idx -> t %! idxJustidx->t%!idx(%%):: Maybe(Tabular) -> String -> Maybe TabularRow(%%)::Maybe(Tabular)->String->MaybeTabularRowt %% s = t >>= (%%! s)t%%s=t>>=(%%!s)toFloat :: TabularRow ->(V.Vector Float)toFloat::TabularRow->(V.VectorFloat)toFloat xs = V.map (\x -> (read $ unpack x) :: Float) xstoFloatxs=V.map(\x->(read$unpackx)::Float)xstoFloatM :: Maybe TabularRow -> Maybe (V.Vector Float)toFloatM:: MaybeMaybeTabularRow->MaybeMaybe(V.VectorFloat)toFloatM = fmap toFloattoFloatM=fmapfmaptoFloattoFloatM ::(Monad m )=> m TabularRow -> m (V.Vector Float)toFloatM::((MonadMonad mm ))=>=> mmTabularRow->mm(V.VectorFloat)toFloatM = liftM toFloattoFloatM=liftMliftMtoFloattoString :: TabularRow ->(V.Vector String)toString::TabularRow->(V.VectorString)toString xs = V.map (\x -> unpack x) xstoStringxs=V.map(\x->unpackx)xstoStringM :: Maybe TabularRow -> Maybe (V.Vector String)toStringM:: MaybeMaybeTabularRow->MaybeMaybe(V.VectorString)toStringM = fmap toStringtoStringM=fmapfmaptoStringtoStringM ::(Monad m)=> m TabularRow -> m (V.Vector String)toStringM::((MonadMonad mm))=>=> mmTabularRow->mm(V.VectorString)toStringM = liftM toStringtoStringM=liftMliftMtoStringtoBool :: TabularRow ->(V.Vector Bool)toBool::TabularRow->(V.VectorBool)toBool xs = V.map (\x -> (read $ unpack x) :: Bool) xstoBoolxs=V.map(\x->(read$unpackx)::Bool)xstoBoolM :: Maybe TabularRow -> Maybe (V.Vector Bool)toBoolM::MaybeMaybeTabularRow->MaybeMaybe(V.VectorBool)toBoolM = fmap toBooltoBoolM=fmapfmaptoBooltoBoolM :: (Monad m)=> m TabularRow -> m (V.Vector Bool)toBoolM::((MonadMonad mm))=>=> mmTabularRow->mm(V.VectorBool)toBoolM = liftM toBooltoBoolM=liftMliftMtoBool--modifiers --modifiers --use >>= to modify--use >>= to modify--populators--populators--addRow < --addRow < --addRow --addRow rowAdd' :: TabularRow -> Tabular -> Maybe TabularrowAdd'::TabularRow->Tabular->MaybeTabularr `rowAdd'` t = if (V.length r) /= (V.length $ header' t)r`rowAdd'`t=if(V.lengthr)/=(V.length$header't) then NothingthenNothing else Just (t `V.snoc` r)elseJust(t`V.snoc`r)rowAdd :: Maybe TabularRow -> Maybe Tabular -> Maybe TabularrowAdd::MaybeTabularRow->MaybeTabular->MaybeTabularNothing `rowAdd` _ = NothingNothing`rowAdd`_=Nothing_ `rowAdd` Nothing = Nothing_`rowAdd`Nothing=Nothing(Just r) `rowAdd` (Just t) = r `rowAdd'` t(Justr)`rowAdd`(Justt)=r`rowAdd'`tt `addRow` r = r `rowAdd` tt`addRow`r=r`rowAdd`t--addCol (Name separate) <<--addCol (Name separate) <<colAdd' :: (String, TabularRow) -> Tabular -> Maybe TabularcolAdd'::(String,TabularRow)->Tabular->MaybeTabular(n, c) `colAdd'` t = let nn = pack n in if V.length c /= V.length t - 1(n,c)`colAdd'`t=letnn=packninifV.lengthc/=V.lengtht-1 then NothingthenNothing else Just ( V.zipWith (\x y -> x `V.snoc` y) t ( nn `V.cons` c) )elseJust(V.zipWith(\xy->x`V.snoc`y)t(nn`V.cons`c))colAdd :: (String, Maybe TabularRow) -> Maybe Tabular -> Maybe TabularcolAdd::(String,MaybeTabularRow)->MaybeTabular->MaybeTabular(_, Nothing) `colAdd` _ = Nothing(_,Nothing)`colAdd`_=Nothing(_, _ ) `colAdd` Nothing = Nothing(_,_)`colAdd`Nothing=Nothing(n , Just c) `colAdd` (Just t) = (n,c) `colAdd'` t(n,Justc)`colAdd`(Justt)=(n,c)`colAdd'`tt `addCol` c = c `colAdd` tt`addCol`c=c`colAdd`t--Sort and Filter--Sort and Filterfilter' :: (Text -> Bool) -> Int -> Tabular -> V.Vector Intfilter'::(Text->Bool)->Int->Tabular->V.VectorIntfilter' f i t = let c = t %! i in case c of filter'fit=letc=t%!iincasecof Just cc -> V.findIndices f ccJustcc->V.findIndicesfcc Nothing -> V.fromList []Nothing->V.fromList[]filterM' :: (Monad m)=>(Text -> Bool) -> Int -> m Tabular -> m (V.Vector Int)filterM'::(Monadm)=>(Text->Bool)->Int->mTabular->m(V.VectorInt)filterM' f i = liftM ( filter' f i ) filterM'fi=liftM(filter'fi)filterN :: (Text -> Bool) -> String -> Tabular -> V.Vector IntfilterN::(Text->Bool)->String->Tabular->V.VectorIntfilterN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of filterNfst=leti=(packs)`V.elemIndex`(header't)incaseiof Nothing -> filter' f (-1) tNothing->filter'f(-1)t Just ii -> filter' f ii tJustii->filter'fiitfilterNM :: (Monad m)=>(Text -> Bool) -> String -> m Tabular -> m (V.Vector Int)filterNM::(Monadm)=>(Text->Bool)->String->mTabular->m(V.VectorInt)filterNM f s = liftM (filterN f s)filterNMfs=liftM(filterNfs)sort' :: (Ord a) => (Text -> a) -> Int -> Tabular -> V.Vector Intsort'::(Orda)=>(Text->a)->Int->Tabular->V.VectorIntsort' f i t = let c = (t %! i) in case c of sort'fit=letc=(t%!i)incasecof Nothing -> V.fromList $ take (V.length t) [0 ..]Nothing->V.fromList$take(V.lengtht)[0..] (Just cc) -> V.fromList $ map fst $ sortBy (comparing snd) (V.toList $ V.indexed $ V.map f cc)(Justcc)->V.fromList$mapfst$sortBy(comparingsnd)(V.toList$V.indexed$V.mapfcc)sortM' :: (Ord a, Monad m) => (Text -> a) -> Int -> m Tabular -> m (V.Vector Int)sortM'::(Orda,Monadm)=>(Text->a)->Int->mTabular->m(V.VectorInt)sortM' f i = liftM (sort' f i)sortM'fi=liftM(sort'fi)sortN :: (Ord a) => (Text -> a) -> String -> Tabular -> V.Vector IntsortN::(Orda)=>(Text->a)->String->Tabular->V.VectorIntsortN f s t = let i = (pack s) `V.elemIndex` (header' t) in case i of sortNfst=leti=(packs)`V.elemIndex`(header't)incaseiof Nothing -> sort' f (-1) tNothing->sort'f(-1)t Just ii -> sort' f ii tJustii->sort'fiitsortNM :: (Ord a, Monad m) => (Text -> a) -> String -> m Tabular -> m (V.Vector Int)sortNM::(Orda,Monadm)=>(Text->a)->String->mTabular->m(V.VectorInt)sortNM f s = liftM (sortN f s)sortNMfs=liftM(sortNfs)-- Utility-- Utilitytext2Float x = (read $ unpack x ):: Floattext2Floatx=(read$unpackx)::Floattext2String x = unpack x text2Stringx=unpackxtext2Bool x = (read $ unpack x ):: Booltext2Boolx=(read$unpackx)::Boolmain = domain=do t <- fromFile "./txts/test_csv.txt"t<-fromFile"./txts/test_csv.txt" let r = t # 0letr=t#0 putStrLn $ show $ tt#3 putStrLn$show$tt#3 let ttt = t >>= (setColN "KEGG" c)letttt=t>>=(setColN"KEGG"c) putStrLn $ show $ ttt%%"KEGG"putStrLn$show$ttt%%"KEGG" let ttt2 = ttt `addRow` rletttt2=ttt`addRow`r let ttt3 = ttt2 `addCol` ( "Added Column", ttt2 % 2)letttt3=ttt2`addCol`("Added Column",ttt2%2) putStrLn "Testing Adding Column"putStrLn"Testing Adding Column" putStrLn $ show $ ttt3 %% "Added Column"putStrLn$show$ttt3%%"Added Column" putStrLn "Testing sorting and filtering"putStrLn"Testing sorting and filtering" putStrLn $ show (ttt % 16)putStrLn$show(ttt%16) putStrLn $ show $ sortM' text2Float 16 tttputStrLn$show$sortM'text2Float16ttt let os = filterM' (\x -> text2Float x < 1) 16 tttletos=filterM'(\x->text2Floatx<1)16ttt putStrLn $ show osputStrLn$showos putStrLn $ showTabularM $ (reorderM os ttt)putStrLn$showTabularM$(reorderMosttt) toFile' "./txts/test_csv_out.txt" (reorderM os ttt)toFile'"./txts/test_csv_out.txt"(reorderMosttt) return ()return()









Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview






















Write



Preview











































Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel












Supports Markdown






0%










Try again


or


attach a new file


.




Attach a file




Cancel




Supports Markdown





0%










Try again


or


attach a new file


.




Attach a file




Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Attach a file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






