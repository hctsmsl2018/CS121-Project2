



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


haskell






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Yu Liu haskell
Commits

53255057















Commit
53255057


authored
May 25, 2013
by


darlliu



Browse files




should work now, exercise considered done?







parent
ae6bcd02













Changes
4




Hide whitespace changes

Inline
Side-by-side















cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057





File added













cybert/Cybert.hs








View file @ 53255057






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......














cybert/test_cybert.hs








View file @ 53255057













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"














cybert/tested.txt








View file @ 53255057













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


haskell






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


haskell


H
H
haskell




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Yu Liu haskell
Commits

53255057















Commit
53255057


authored
May 25, 2013
by


darlliu



Browse files




should work now, exercise considered done?







parent
ae6bcd02













Changes
4




Hide whitespace changes

Inline
Side-by-side















cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057





File added













cybert/Cybert.hs








View file @ 53255057






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......














cybert/test_cybert.hs








View file @ 53255057













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"














cybert/tested.txt








View file @ 53255057













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Yu Liu haskell
Commits

53255057







Open sidebar



Yu Liu haskell
Commits

53255057




Open sidebar

Yu Liu haskell
Commits

53255057


Yu LiuhaskellhaskellCommits
53255057








Commit
53255057


authored
May 25, 2013
by


darlliu



Browse files




should work now, exercise considered done?







parent
ae6bcd02













Changes
4




Hide whitespace changes

Inline
Side-by-side















cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057





File added













cybert/Cybert.hs








View file @ 53255057






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......














cybert/test_cybert.hs








View file @ 53255057













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"














cybert/tested.txt








View file @ 53255057













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
53255057


authored
May 25, 2013
by


darlliu



Browse files




should work now, exercise considered done?







parent
ae6bcd02













Changes
4




Hide whitespace changes

Inline
Side-by-side















cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057





File added













cybert/Cybert.hs








View file @ 53255057






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......














cybert/test_cybert.hs








View file @ 53255057













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"














cybert/tested.txt








View file @ 53255057













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
53255057


authored
May 25, 2013
by


darlliu



Browse files



Commit
53255057


authored
May 25, 2013
by


darlliu

53255057authoredbydarlliu

should work now, exercise considered done?






parent
ae6bcd02
















parent
ae6bcd02





parent












Changes
4
4


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057





File added













cybert/Cybert.hs








View file @ 53255057






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......














cybert/test_cybert.hs








View file @ 53255057













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"














cybert/tested.txt








View file @ 53255057













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file














cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057





File added











cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644




View file @ 53255057








cybert/.nfs00000000cd773a9a00005b22



0 â†’ 100644






View file @ 53255057
53255057


File added




File added


File added









cybert/Cybert.hs








View file @ 53255057






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......












cybert/Cybert.hs








View file @ 53255057








cybert/Cybert.hs










View file @ 53255057


53255057



......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......






......@@ -13,7 +13,8 @@









module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 showCybertEntries,










 entriesByFold,



......@@ -30,9 +31,10 @@ module Cybert









{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Data.Maybe










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B



......@@ -44,7 +46,10 @@ data Cybert_entry = NA | Cybert {









 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data



......@@ -57,7 +62,10 @@ cybert_entry = Cybert{









 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],



......@@ -95,8 +103,8 @@ instance Show Cybert_entry where









 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"










 ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}



......@@ -131,19 +139,55 @@ cybertToSet xs = S.fromList xs









--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeader :: B.ByteString -> Maybe (M.Map String Int)










buildHeader s = let ss = B.split '\t' s










 in M.fromList (foldl pred [] ss) where










 pred acc x = let xx = B.unpack x










 in case xx of "meanC" -> acc : ("meanc", idx)










 "meanE" -> acc : ("meane", idx)










 "meanc" -> acc : ("meanc", idx)










 "meane" -> acc : ("meanc", idx)
































lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










lineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]










--take a header and an accumulator, then read the line and append the cybert entry










lineToCybert header xs line = xs










lineToCybert header xs line = xs ++ readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then []










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),










 --this is a must










 genesym = getText header ss "gene_sym",










 --this is of maybe type










 pval = getNum header ss "pval",










 bf = getNum header ss "bonferroni",










 bh = getNum header ss "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]










 --these are one or many










 , raw = s










 --raw info










 } in [cybt]





















loadCybert :: String -> IO (Maybe [Cybert_entry])










loadCybert fname = catch



......@@ -151,14 +195,15 @@ loadCybert fname = catch









 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines)










 in if isNothing header then return Nothing










 else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else return output










 else let header = buildHeader (head mylines);










 output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))










 in if output == (Just []) then return Nothing










 else do 










 putStrLn "Done parsing"










 return output










 ))










 (\err -> do










 if isEOFError err 










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing



......


module CybertmoduleCybert(( Cybert_entry(NA, Cybert,probe,genesym,Cybert_entry(NA,Cybert,probe,genesym, sample, collection, mean,pval,ratio,secondaryRefs,secondaryData),sample,collection,mean,pval,ratio,secondaryRefs,secondaryData), sample, collection, mean, bf, bh, sds, sample,collection,mean,bf,bh,sds, pval,ratio,secondaryRefs,secondaryData),pval,ratio,secondaryRefs,secondaryData), cybert_entry,cybert_entry, showCybertEntries,showCybertEntries, entriesByFold,entriesByFold,{-end module definitions -}{-end module definitions -}import Data.BitsimportData.Bitsimport Data.ListimportData.Listimport Data.MaybeimportData.Maybeimport Data.CharimportData.Charimport System.IOimportSystem.IOimport System.IO.ErrorimportSystem.IO.Errorimport Data.MaybeimportData.Maybeimport qualified Data.Set as SimportqualifiedData.SetasSimport qualified Data.Map as MimportqualifiedData.MapasMimport qualified Data.ByteString.Char8 as BimportqualifiedData.ByteString.Char8asB sample :: [String] ,sample::[String], collection :: Maybe String , --which datasetcollection::MaybeString,--which dataset mean :: Either Float [Float] , --multiple meansmean::EitherFloat[Float],--multiple means sds :: Either Float [Float],sds::EitherFloat[Float], pval :: Float, --the pairwise or ANOVA pvalpval::Float,--the pairwise or ANOVA pval bf :: Float,bf::Float, bh :: Float,bh::Float, ratio :: Either Float [Float], --pairwise ratio or numerous ratiosratio::EitherFloat[Float],--pairwise ratio or numerous ratios secondaryRefs :: M.Map String String , --optional secondary refssecondaryRefs::M.MapStringString,--optional secondary refs secondaryData :: M.Map String Float , --optional secondary datasecondaryData::M.MapStringFloat,--optional secondary data sample = [],sample=[], collection = Nothing,collection=Nothing, mean = Right [],mean=Right[], sds = Right [],sds=Right[], pval = -1,pval=-1, bf = -1,bf=-1, bh = -1,bh=-1, ratio = Left (-1),ratio=Left(-1), secondaryRefs = M.fromList [("","")],secondaryRefs=M.fromList[("","")], secondaryData = M.fromList [("",0)],secondaryData=M.fromList[("",0)], showsPrec _ a s = show a ++ sshowsPrec_as=showa++s show NA = "NA"showNA="NA" show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,showCybert{probe=p,genesym=sym,sample=ss,collection=col,mean=m, pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++(showJustS sym)++"\t"pval=pv,ratio=r,secondaryRefs=_,secondaryData=_,raw=_}=p++"\t"++((showJustSshowJustS symsym))++++""\t\t"" ++(showEitherF m)++"\t"++(show pv)++"\t"++(showJustS col)++++(showEitherFEitherF m)++"\t"++(show pvpv))++"\t"++(showJustSJustS colcol) pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++pval=pv,ratio=r,secondaryRefs=_,secondaryData=_,raw=_}=p++"\t"++ (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)(showJustSJustS symsy)++"\t"++(showJustSJustS colcol)) ++"\t" ++(showEitherFEitherF mm))++++""\t\t""++++((showshow pvpv) -- for each sample-- for each sample{-end format and show routines-}{-end format and show routines-}{-set operation and filtering routines-}{-set operation and filtering routines-}--set operations--set operations{-end set operation and filtering routines-}{-end set operation and filtering routines-}{-IO routines-}{-IO routines-}buildHeader :: B.ByteString -> Maybe (M.Map String Int)buildHeader::B.ByteString->Maybe(M.MapStringInt)buildHeader s = let ss = B.split '\t' sbuildHeaders=letss=B.split'\t's in M.fromList (foldl pred [] ss) whereinM.fromList(foldlpred[]ss)where pred acc x = let xx = B.unpack xpredaccx=letxx=B.unpackx in case xx of "meanC" -> acc : ("meanc", idx)incasexxof"meanC"->acc:("meanc",idx) "meanE" -> acc : ("meane", idx)"meanE"->acc:("meane",idx) "meanc" -> acc : ("meanc", idx)"meanc"->acc:("meanc",idx) "meane" -> acc : ("meanc", idx)"meane"->acc:("meanc",idx)lineToCybert :: (Maybe (M.Map String Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]lineToCybert::(Maybe(M.MapStringInt))->[Cybert_entry]->B.ByteString->[Cybert_entry]buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]buildHeaderPrec::B.ByteString->[(String,B.ByteString)]buildHeaderPrec s = let ss = B.split '\t' sbuildHeaderPrecs=letss=B.split'\t's in map (\x -> (stripQuote $ B.unpack x, x)) ss whereinmap(\x->(stripQuote$B.unpackx,x))sswhere stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xsstripQuote('\"':xs)=maptoLower$take((lengthxs)-1)xs stripQuote xs = map toLower xsstripQuotexs=maptoLowerxsbuildHeader :: B.ByteString -> (M.Map String (Maybe Int) )buildHeader::B.ByteString->(M.MapString(MaybeInt))buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' sbuildHeaders=letss=buildHeaderPrecs;sl=B.split'\t's in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ssinM.fromList$map(\x->(fstx,(sndx)`elemIndex`sl))ssmaybeGet :: [B.ByteString] -> Maybe Int -> B.ByteStringmaybeGet::[B.ByteString]->MaybeInt->B.ByteString[] `maybeGet` _ = B.pack ""[]`maybeGet`_=B.pack""x `maybeGet` Nothing = B.pack ""x`maybeGet`Nothing=B.pack""x `maybeGet` (Just s)= if length x > s then x !! sx`maybeGet`(Justs)=iflengthx>sthenx!!s else B.pack ""elseB.pack""getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe StringgetText::(M.MapString(MaybeInt))->[B.ByteString]->String->MaybeStringgetText header ss id = if id `M.notMember` headergetTextheaderssid=ifid`M.notMember`header then NothingthenNothing else let idx = header M.! idelseletidx=headerM.!id in Just (B.unpack $ ss `maybeGet` idx)inJust(B.unpack$ss`maybeGet`idx)getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> FloatgetNum::(M.MapString(MaybeInt))->[B.ByteString]->String->FloatgetNum header ss id = if id `M.notMember` headergetNumheaderssid=ifid`M.notMember`header then -1 :: Floatthen-1::Float else let idx = header M.! idelseletidx=headerM.!id in read (B.unpack $ ss `maybeGet` idx) :: Floatinread(B.unpack$ss`maybeGet`idx)::FloatgetNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]getNums::(M.MapString(MaybeInt))->[B.ByteString]->[String]->EitherFloat[Float]getNums header ss ids = let nums = map (getNum header ss) idsgetNumsheaderssids=letnums=map(getNumheaderss)ids in if length nums == 1 then Left (nums !! 0)iniflengthnums==1thenLeft(nums!!0) else Right $ filter (not . (== -1)) numselseRight$filter(not.(==-1))numslineToCybert :: (M.Map String (Maybe Int))-> [Cybert_entry] -> B.ByteString -> [Cybert_entry]lineToCybert::(M.MapString(MaybeInt))->[Cybert_entry]->B.ByteString->[Cybert_entry]--take a header and an accumulator, then read the line and append the cybert entry--take a header and an accumulator, then read the line and append the cybert entrylineToCybert header xs line = xslineToCybertheaderxsline=xslineToCybert header xs line = xs ++ readLine line wherelineToCybertheaderxsline=xs++readLinelinewhere readLine s = let ss = B.split '\t' s readLines=letss=B.split'\t's in if length ss /= M.size header then []iniflengthss/=M.sizeheaderthen[] else let cybt= cybert_entry {elseletcybt=cybert_entry{ probe = B.unpack $ ss `maybeGet` (header M.! "probe_id"),probe=B.unpack$ss`maybeGet`(headerM.!"probe_id"), --this is a must--this is a must genesym = getText header ss "gene_sym",genesym=getTextheaderss"gene_sym", --this is of maybe type--this is of maybe type pval = getNum header ss "pval",pval=getNumheaderss"pval", bf = getNum header ss "bonferroni",bf=getNumheaderss"bonferroni", bh = getNum header ss "bh",bh=getNumheaderss"bh", --these are -1 defaulted--these are -1 defaulted mean = getNums header ss $ map ( "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],mean=getNumsheaderss$map("mean"++)["c","e","1","2","3","4","5","6","7"], sds = getNums header ss $ map ( "std" ++ ) ["c","e","1","2","3","4","5","6","7"]sds=getNumsheaderss$map("std"++)["c","e","1","2","3","4","5","6","7"] --these are one or many--these are one or many , raw = s,raw=s --raw info--raw info } in [cybt]}in[cybt]loadCybert :: String -> IO (Maybe [Cybert_entry])loadCybert::String->IO(Maybe[Cybert_entry])loadCybert fname = catchloadCybertfname=catch contents <- B.hGetContents handlecontents<-B.hGetContentshandle let mylines = B.split '\n' contentsletmylines=B.split'\n'contents if length mylines <= 1 then return Nothingiflengthmylines<=1thenreturnNothing else let header = buildHeader (head mylines)elseletheader=buildHeader(headmylines) in if isNothing header then return NothinginifisNothingheaderthenreturnNothing else let output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))elseletoutput=(Just(foldl(lineToCybertheader)[](drop1mylines))) in if output == (Just []) then return Nothinginifoutput==(Just[])thenreturnNothing else return outputelsereturnoutput else let header = buildHeader (head mylines);elseletheader=buildHeader(headmylines); output = (Just (foldl (lineToCybert header) [] (drop 1 mylines)))output=(Just(foldl(lineToCybertheader)[](drop1mylines))) in if output == (Just []) then return Nothinginifoutput==(Just[])thenreturnNothing else do elsedo putStrLn "Done parsing"putStrLn"Done parsing" return outputreturnoutput )))) (\err -> do(\err->do if isEOFError err ifisEOFErrorerr  if isEOFError errifisEOFErrorerr then dothendo putStrLn "File is empty or truncated."putStrLn"File is empty or truncated." return NothingreturnNothing








cybert/test_cybert.hs








View file @ 53255057













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"












cybert/test_cybert.hs








View file @ 53255057








cybert/test_cybert.hs










View file @ 53255057


53255057










import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 exportCybert [c,d] "tested.txt"










 exportGeneSyms [c,d] "syms.txt"










 exportProbes [c,d] "probes.txt"










 some <- loadCybert "tested.txt"










 putStrLn (show some)









 {-










     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










     -}










 ssome@(Just some)<- loadCybert "test.txt"










 exportGeneSyms some "tested.txt"


import CybertimportCybertmain = domain=do let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}letc=cybert_entry{genesym=(Just"Sym"),mean=(Right[1,2,3])} let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}letd=cybert_entry{genesym=(Just"Sym2"),mean=(Right[1,2,3])} exportCybert [c,d] "tested.txt"exportCybert[c,d]"tested.txt" exportGeneSyms [c,d] "syms.txt"exportGeneSyms[c,d]"syms.txt" exportProbes [c,d] "probes.txt"exportProbes[c,d]"probes.txt" some <- loadCybert "tested.txt"some<-loadCybert"tested.txt" putStrLn (show some)putStrLn(showsome) {-{-     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}     -let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}     -let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}     -}     -} ssome@(Just some)<- loadCybert "test.txt"ssome@(Justsome)<-loadCybert"test.txt" exportGeneSyms some "tested.txt"exportGeneSymssome"tested.txt"








cybert/tested.txt








View file @ 53255057













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file












cybert/tested.txt








View file @ 53255057








cybert/tested.txt










View file @ 53255057


53255057










NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file













NONE	Sym	1.0	2.0	3.0	-1.0	N/A










NONE	Sym2	1.0	2.0	3.0	-1.0	N/A




\ No newline at end of file









DDR1










RFC2










HSPA6










PAX8










GUCA1A










UBA7










THRA










PTPN21










CCL5










CYP2E1










EPHB3










ESRRA










CYP2A6










SCARB1










TTLL12










WFDC2










MAPK1










MAPK1










ADAM32










SPATA17










PRR22










PRR22










PXK










PXK










VPS18










MSANTD3










SLC46A1










SLC46A1










TIMD4










SLC39A5










ZDHHC11










ATP6V1E2










CILP2










CILP2










PIGX










TMEM196










SLC39A13










BEST4










AKD1










CORO6










TMEM106A










TMEM106A










ALG10










ALG10










TTC39C










NEXN










C15orf40










RAX2










MFAP3










EYA3










GIMAP1










GIMAP1










GIMAP1










KLK8










CCDC65










CCDC65










FAM122C










FAM122C










CCDC11










CCDC11










RBBP6










CENPBD1










TRIOBP










TRIOBP










CATSPER1










HOXD4










GSC










SP7










PDE7A










CNOT7










CRYZL1










PRSS33










PRSS33










C19orf26










C19orf26










MCMDC2










TIRAP










LEAP2










MSI2










SCIN










SCIN










CTCFL










C4orf33










C4orf33










C4orf33










ZNF333










FAM18B2










RDH10










RDH10










SRSF12










FAM71A










FAM71A










GAPT










C8orf47










C8orf47










C1orf65










ENTHD1










ENTHD1










TSSK3




\ No newline at end of file


NONE	Sym	1.0	2.0	3.0	-1.0	N/ANONE	Sym2	1.0	2.0	3.0	-1.0	N/ADDR1RFC2HSPA6PAX8GUCA1AUBA7THRAPTPN21CCL5CYP2E1EPHB3ESRRACYP2A6SCARB1TTLL12WFDC2MAPK1MAPK1ADAM32SPATA17PRR22PRR22PXKPXKVPS18MSANTD3SLC46A1SLC46A1TIMD4SLC39A5ZDHHC11ATP6V1E2CILP2CILP2PIGXTMEM196SLC39A13BEST4AKD1CORO6TMEM106ATMEM106AALG10ALG10TTC39CNEXNC15orf40RAX2MFAP3EYA3GIMAP1GIMAP1GIMAP1KLK8CCDC65CCDC65FAM122CFAM122CCCDC11CCDC11RBBP6CENPBD1TRIOBPTRIOBPCATSPER1HOXD4GSCSP7PDE7ACNOT7CRYZL1PRSS33PRSS33C19orf26C19orf26MCMDC2TIRAPLEAP2MSI2SCINSCINCTCFLC4orf33C4orf33C4orf33ZNF333FAM18B2RDH10RDH10SRSF12FAM71AFAM71AGAPTC8orf47C8orf47C1orf65ENTHD1ENTHD1TSSK3









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






