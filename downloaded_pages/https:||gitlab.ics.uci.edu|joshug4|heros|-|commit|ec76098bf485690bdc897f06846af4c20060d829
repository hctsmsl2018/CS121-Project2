



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

ec76098b















Commit
ec76098b


authored
Jan 05, 2015
by


Johannes Lerch



Browse files




handling for writing fields / excluding access paths







parent
7527a0d4













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ ec76098b






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......














src/heros/alias/FieldReference.java








View file @ ec76098b






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......














src/heros/alias/FlowFunction.java








View file @ ec76098b






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......














test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......














test/heros/alias/Fact.java








View file @ ec76098b






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......














test/heros/alias/TestHelper.java








View file @ ec76098b






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

ec76098b















Commit
ec76098b


authored
Jan 05, 2015
by


Johannes Lerch



Browse files




handling for writing fields / excluding access paths







parent
7527a0d4













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ ec76098b






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......














src/heros/alias/FieldReference.java








View file @ ec76098b






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......














src/heros/alias/FlowFunction.java








View file @ ec76098b






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......














test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......














test/heros/alias/Fact.java








View file @ ec76098b






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......














test/heros/alias/TestHelper.java








View file @ ec76098b






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

ec76098b







Open sidebar



Joshua Garcia heros
Commits

ec76098b




Open sidebar

Joshua Garcia heros
Commits

ec76098b


Joshua GarciaherosherosCommits
ec76098b








Commit
ec76098b


authored
Jan 05, 2015
by


Johannes Lerch



Browse files




handling for writing fields / excluding access paths







parent
7527a0d4













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ ec76098b






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......














src/heros/alias/FieldReference.java








View file @ ec76098b






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......














src/heros/alias/FlowFunction.java








View file @ ec76098b






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......














test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......














test/heros/alias/Fact.java








View file @ ec76098b






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......














test/heros/alias/TestHelper.java








View file @ ec76098b






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
ec76098b


authored
Jan 05, 2015
by


Johannes Lerch



Browse files




handling for writing fields / excluding access paths







parent
7527a0d4













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ ec76098b






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......














src/heros/alias/FieldReference.java








View file @ ec76098b






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......














src/heros/alias/FlowFunction.java








View file @ ec76098b






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......














test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......














test/heros/alias/Fact.java








View file @ ec76098b






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......














test/heros/alias/TestHelper.java








View file @ ec76098b






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
ec76098b


authored
Jan 05, 2015
by


Johannes Lerch



Browse files



Commit
ec76098b


authored
Jan 05, 2015
by


Johannes Lerch

ec76098bauthoredbyJohannes Lerch

handling for writing fields / excluding access paths






parent
7527a0d4
















parent
7527a0d4





parent












Changes
8
8


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPathUtil.java








View file @ ec76098b






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......














src/heros/alias/FieldReference.java








View file @ ec76098b






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......














src/heros/alias/FlowFunction.java








View file @ ec76098b






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......














test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......














test/heros/alias/Fact.java








View file @ ec76098b






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......














test/heros/alias/TestHelper.java








View file @ ec76098b






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......














src/heros/alias/AccessPathUtil.java








View file @ ec76098b






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......












src/heros/alias/AccessPathUtil.java








View file @ ec76098b








src/heros/alias/AccessPathUtil.java










View file @ ec76098b


ec76098b



......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......






......@@ -10,6 +10,11 @@









 ******************************************************************************/










package heros.alias;





















import java.util.ArrayList;





















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {



......@@ -20,34 +25,49 @@ public class AccessPathUtil {









 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 if(prefixAccessPath.length > factAccessPath.length)










 return false;










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(!prefixAccessPath[i].equals(factAccessPath[i]))










 return false;










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 










 return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.ArrayList;importjava.util.ArrayList;import com.google.common.base.Optional;importcom.google.common.base.Optional;import heros.alias.FieldReference.Any;importheros.alias.FieldReference.Any;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;public class AccessPathUtil {publicclassAccessPathUtil{  FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();FieldReference[]prefixAccessPath=prefixCandidate.getAccessPath(); FieldReference[] factAccessPath = fact.getAccessPath();FieldReference[]factAccessPath=fact.getAccessPath(); if(prefixAccessPath.length > factAccessPath.length)if(prefixAccessPath.length>factAccessPath.length) return false;returnfalse;  for(int i=0; i<prefixAccessPath.length; i++) {for(inti=0;i<prefixAccessPath.length;i++){ if(!prefixAccessPath[i].equals(factAccessPath[i]))if(!prefixAccessPath[i].equals(factAccessPath[i])) return false;returnfalse; if(i < factAccessPath.length) {if(i<factAccessPath.length){ if(!prefixAccessPath[i].includes(factAccessPath[i]))if(!prefixAccessPath[i].includes(factAccessPath[i])) return false;returnfalse; }} else if(!(prefixAccessPath[i] instanceof Any))elseif(!(prefixAccessPath[i]instanceofAny)) return false; returnfalse; }}  return true;returntrue; }}  public static <D extends FieldSensitiveFact<?, D>> D applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<DextendsFieldSensitiveFact<?,D>>DDapplyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<DextendsFieldSensitiveFact<?,D>>OptionalOptional<<DD>>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact))if(!isPrefixOf(summary.getSourceFact(),sourceFact)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();FieldReference[]abstractAccessPath=summary.getSourceFact().getAccessPath(); FieldReference[] concreteAccessPath = sourceFact.getAccessPath();FieldReference[]concreteAccessPath=sourceFact.getAccessPath(); FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();FieldReference[]abstractAccessPath=summary.getSourceFact().getAccessPath(); FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();FieldReference[]targetAccessPath=summary.getTargetFact().getAccessPath();  FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];FieldReference[]resultAccessPath=newFieldReference[targetAccessPath.length+concreteAccessPath.length-abstractAccessPath.length]; //copy old access path//copy old access path System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);System.arraycopy(targetAccessPath,0,resultAccessPath,0,targetAccessPath.length);  //copy delta access path that was omitted while creating the abstracted source fact//copy delta access path that was omitted while creating the abstracted source fact System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);System.arraycopy(concreteAccessPath,abstractAccessPath.length,resultAccessPath,targetAccessPath.length,concreteAccessPath.length-abstractAccessPath.length); ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);ArrayList<FieldReference>result=newArrayList<>(targetAccessPath.length+concreteAccessPath.length-abstractAccessPath.length); int lastSpecificField = -1;intlastSpecificField=-1; for(int i=0; i< targetAccessPath.length; i++) {for(inti=0;i<targetAccessPath.length;i++){ result.add(targetAccessPath[i]);result.add(targetAccessPath[i]); if(targetAccessPath[i] instanceof SpecificFieldReference)if(targetAccessPath[i]instanceofSpecificFieldReference) lastSpecificField = i;lastSpecificField=i; }}  return summary.getTargetFact().cloneWithAccessPath(resultAccessPath);returnsummary.getTargetFact().cloneWithAccessPath(resultAccessPath); for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {for(inti=abstractAccessPath.length;i<concreteAccessPath.length;i++){ if(lastSpecificField+1 < result.size()) {if(lastSpecificField+1<result.size()){ Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));Optional<?extendsFieldReference>mergedFieldRef=concreteAccessPath[i].merge((Any)result.get(lastSpecificField+1)); if(!mergedFieldRef.isPresent())if(!mergedFieldRef.isPresent()) return Optional.absent();returnOptional.absent();  result.set(lastSpecificField+1, mergedFieldRef.get());result.set(lastSpecificField+1,mergedFieldRef.get()); lastSpecificField++;lastSpecificField++; } else {}else{ result.add(concreteAccessPath[i]);result.add(concreteAccessPath[i]); }} }} return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(newFieldReference[result.size()]))); }} public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {publicstatic<DextendsFieldSensitiveFact<?,D>>DcloneWithConcatenatedAccessPath(Dfact,FieldReference...fieldRefs){








src/heros/alias/FieldReference.java








View file @ ec76098b






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}












src/heros/alias/FieldReference.java








View file @ ec76098b








src/heros/alias/FieldReference.java










View file @ ec76098b


ec76098b



......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}






......@@ -10,16 +10,28 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {



......@@ -27,6 +39,26 @@ public interface FieldReference {









 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)



......@@ -77,7 +109,28 @@ public interface FieldReference {









 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;



......@@ -103,5 +156,6 @@ public interface FieldReference {









 return false;










 return true;










 }





















 }










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FieldReference.Any;importheros.alias.FieldReference.Any;import java.util.ArrayList;importjava.util.ArrayList;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public interface FieldReference {publicinterfaceFieldReference{ boolean includes(FieldReference fieldReference);booleanincludes(FieldReferencefieldReference);  boolean isIncludedBy(SpecificFieldReference specificFieldRef);booleanisIncludedBy(SpecificFieldReferencespecificFieldRef);  boolean isIncludedBy(Any anyFieldRef);booleanisIncludedBy(AnyanyFieldRef);  Optional<? extends FieldReference> merge(Any fieldReference);Optional<?extendsFieldReference>merge(AnyfieldReference);  public static class Any implements FieldReference {publicstaticclassAnyimplementsFieldReference{ Set<String> excludedFieldNames = Sets.newHashSet();Set<String>excludedFieldNames=Sets.newHashSet(); private Set<String> excludedFieldNames = Sets.newHashSet();privateprivate Set<String>excludedFieldNames=Sets.newHashSet();  public Any(String...excludedFieldNames) {publicAny(String...excludedFieldNames){ for (int i = 0; i < excludedFieldNames.length; i++) {for(inti=0;i<excludedFieldNames.length;i++){ }} }}  public boolean includes(FieldReference fieldReference) {publicbooleanincludes(FieldReferencefieldReference){ return fieldReference.isIncludedBy(this);returnfieldReference.isIncludedBy(this); }} @Override@Override public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {publicbooleanisIncludedBy(SpecificFieldReferencespecificFieldRef){ return false;returnfalse; }} @Override@Override public boolean isIncludedBy(Any anyFieldRef) {publicbooleanisIncludedBy(AnyanyFieldRef){ return true;returntrue; }}  public Optional<Any> merge(Any fieldReference) {publicOptional<Any>merge(AnyfieldReference){ ArrayList<String> list = new ArrayList<>(excludedFieldNames);ArrayList<String>list=newArrayList<>(excludedFieldNames); list.addAll(fieldReference.excludedFieldNames);list.addAll(fieldReference.excludedFieldNames); return Optional.of(new Any(list.toArray(new String[list.size()])));returnOptional.of(newAny(list.toArray(newString[list.size()]))); }}  @Override@Override public String toString() {publicStringtoString(){ if(excludedFieldNames.size() == 0)if(excludedFieldNames.size()==0) public String toString() {publicStringtoString(){ return fieldName;returnfieldName; }}  public boolean includes(FieldReference fieldReference) {publicbooleanincludes(FieldReferencefieldReference){ return fieldReference.isIncludedBy(this);returnfieldReference.isIncludedBy(this); }} @Override@Override public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {publicbooleanisIncludedBy(SpecificFieldReferencespecificFieldRef){ return specificFieldRef.fieldName.equals(fieldName);returnspecificFieldRef.fieldName.equals(fieldName); }} @Override@Override public boolean isIncludedBy(Any anyFieldRef) {publicbooleanisIncludedBy(AnyanyFieldRef){ return !anyFieldRef.excludedFieldNames.contains(fieldName);return!anyFieldRef.excludedFieldNames.contains(fieldName); }}  public Optional<SpecificFieldReference> merge(Any fieldReference) {publicOptional<SpecificFieldReference>merge(AnyfieldReference){ if(fieldReference.excludedFieldNames.contains(fieldName))if(fieldReference.excludedFieldNames.contains(fieldName)) return Optional.absent();returnOptional.absent(); else else return Optional.of(this);returnOptional.of(this); }}  @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; return false;returnfalse; return true;returntrue; }} }}}}








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ ec76098b








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ ec76098b


ec76098b



......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......






......@@ -15,6 +15,7 @@ import heros.DontSynchronize;









import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;



......@@ -32,6 +33,7 @@ import java.util.concurrent.TimeUnit;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;



......@@ -253,16 +255,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {










 D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);










 if(d4.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 



......@@ -376,13 +379,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 }










 }



......@@ -448,8 +453,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);



......@@ -457,18 +462,26 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else {










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 //TODO: if writing field f










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 }










 else










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }



......@@ -488,11 +501,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 



......@@ -512,12 +526,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.



......


import heros.FlowFunctionCache;importheros.FlowFunctionCache;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SynchronizedBy;importheros.SynchronizedBy;import heros.alias.FieldReference.Any;importheros.alias.FieldReference.Any;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;import heros.alias.FlowFunction.AnnotatedFact;importheros.alias.FlowFunction.AnnotatedFact;import heros.solver.CountingThreadPoolExecutor;importheros.solver.CountingThreadPoolExecutor;import org.slf4j.Logger;importorg.slf4j.Logger;import org.slf4j.LoggerFactory;importorg.slf4j.LoggerFactory;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.base.Predicate;importcom.google.common.base.Predicate;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.collect.Sets;importcom.google.common.collect.Sets; if (endSumm != null)if(endSumm!=null) for(SummaryEdge<D, N> summary: endSumm) {for(SummaryEdge<D,N>summary:endSumm){ if(AccessPathUtil.isPrefixOf(summary.getSourceFact(), d3.getFact())) {if(AccessPathUtil.isPrefixOf(summary.getSourceFact(),d3.getFact())){ D d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);Dd4=AccessPathUtil.applyAbstractedSummary(d3.getFact(),summary);  //for each return site//for each return site for(N retSiteN: returnSiteNs) {for(NretSiteN:returnSiteNs){ //compute return-flow function//compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN); //for each target value of the function//for each target value of the function for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4, n)) {for(AnnotatedFact<D>d5:computeReturnFlowFunction(retFunction,d4,n)){ D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());Dd5p_restoredCtx=restoreContextOnReturnedFact(d2,d5.getFact()); propagate(d1, retSiteN, d5p_restoredCtx, n, false);propagate(d1,retSiteN,d5p_restoredCtx,n,false); Optional<D> d4 = AccessPathUtil.applyAbstractedSummary(d3.getFact(), summary);Optional<D>d4=AccessPathUtil.applyAbstractedSummary(d3.getFact(),summary); if(d4.isPresent()) {if(d4.isPresent()){ //for each return site//for each return site for(N retSiteN: returnSiteNs) {for(NretSiteN:returnSiteNs){ //compute return-flow function//compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN); //for each target value of the function//for each target value of the function for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {for(AnnotatedFact<D>d5:computeReturnFlowFunction(retFunction,d4.get(),n)){ D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());Dd5p_restoredCtx=restoreContextOnReturnedFact(d2,d5.getFact()); propagate(d1, retSiteN, d5p_restoredCtx, n, false);propagate(d1,retSiteN,d5p_restoredCtx,n,false); }} }} }} } } FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC);  if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {if(AccessPathUtil.isPrefixOf(d1,incomingEdge.getCalleeSourceFact())){ D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);DconcreteCalleeExitFact=AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(),summaryEdge); Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);Set<AnnotatedFact<D>>callerTargetFacts=computeReturnFlowFunction(retFunction,concreteCalleeExitFact,callSite); // for each incoming-call value// for each incoming-call value for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {for(AnnotatedFact<D>callerTargetAnnotatedFact:callerTargetFacts){ D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact()); propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);propagate(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact,callSite,false); Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);Optional<D>concreteCalleeExitFact=AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(),summaryEdge); if(concreteCalleeExitFact.isPresent()) {if(concreteCalleeExitFact.isPresent()){ Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);Set<AnnotatedFact<D>>callerTargetFacts=computeReturnFlowFunction(retFunction,concreteCalleeExitFact.get(),callSite);  // for each incoming-call value// for each incoming-call value for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {for(AnnotatedFact<D>callerTargetAnnotatedFact:callerTargetFacts){ D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact()); propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);propagate(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact,callSite,false); }} }} }} }} //	  create and set (d1.f, d2.f) on hold//	  create and set (d1.f, d2.f) on hold //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold//	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold  if(d3.getReadField() instanceof SpecificFieldReference) {if(d3.getReadField()instanceofinstanceof SpecificFieldReferenceSpecificFieldReference){ SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();SpecificFieldReferencefieldRef=((SpecificFieldReference)) d3.getReadField(); if(d3.getReadField() != null) {if(d3.getReadField()!=!= nullnull){ SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());SpecificFieldReferencefieldRef=newnew SpecificFieldReference((d3.getReadField());) D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(d1,fieldRef); if(checkForInterestedCallers(d1, n, fieldRef)) {if(checkForInterestedCallers(d1,n,fieldRef)){ propagate(concretizedSourceValue, m, d3.getFact(), null, false);propagate(concretizedSourceValue,m,d3.getFact(),null,false); pauseEdge(concretizedSourceValue, m, d3.getFact());pauseEdge(concretizedSourceValue,m,d3.getFact()); }} }} else {else{ else if(d3.getWrittenField() != null) {elseif(d3.getWrittenField()!=null){ //TODO: double check if concurrency issues may arise//TODO: double check if concurrency issues may arise  //TODO: if writing field f//TODO: if writing field fTODO: // if writing field f// if writing field f // create edge e = (d1, d2.*\{f})// create edge e = (d1, d2.*\{f}) // if d2.*\{f} element of incoming edges// if d2.*\{f} element of incoming edges // 		continue with e// 		continue with e // else // else  //		put e on hold//		put e on hold // always kill (d1, d2)// always kill (d1, d2)  propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false);  Any fieldRef = new Any(d3.getWrittenField());AnyfieldRef=newAny(d3.getWrittenField()); if(checkForInterestedCallers(d1, n, fieldRef)) {if(checkForInterestedCallers(d1,n,fieldRef)){ propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false); } else {}else{ pauseEdge(d1, m, d3.getFact());pauseEdge(d1,m,d3.getFact()); }} }} elseelse propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false); }} }} }} if(calleeSourceFact.equals(zeroValue))if(calleeSourceFact.equals(zeroValue)) return true;returntrue;  if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {if(hasInterestedCallers(calleeSourceFact,calleeMethod,fieldRef)){ D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact,fieldRef); if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {if(!incomingEdgesPrefixedWith(calleeMethod,concretizedSourceValue).isEmpty()){ return true;returntrue; }}  Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); Set<IncomingEdge<D,N>>inc=incomingEdgesPrefixesOf(calleeMethod,calleeSourceFactalleeFact); Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); Set<IncomingEdge<D,N>>inc=incomingEdgesPrefixesOf(calleeMethod,concretizedSourceValueoncretizedValue); for (IncomingEdge<D, N> incomingEdge : inc) {for(IncomingEdge<D,N>incomingEdge:inc){ if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(),incomingEdge.getCallSite(),fieldRef)){ propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? propagate(incomingEdge.getCallerSourceFact().equals(zeroValue)? return false;returnfalse; }}  private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {privatebooleanhasInterestedCallers(DcalleeSourceFact,McalleeMethod,FieldReference...fieldRef){ D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact,fieldRef); Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);Set<IncomingEdge<D,N>>incomingEdges=incomingEdgesPrefixedWith(calleeMethod,concretizedSourceValue); return !incomingEdges.isEmpty();return!incomingEdges.isEmpty(); }}  /**/**	 * Computes the normal flow function for the given set of start and end	 * Computes the normal flow function for the given set of start and end	 * abstractions.	 * abstractions.








src/heros/alias/FlowFunction.java








View file @ ec76098b






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......












src/heros/alias/FlowFunction.java








View file @ ec76098b








src/heros/alias/FlowFunction.java










View file @ ec76098b


ec76098b



......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......






......@@ -43,8 +43,8 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 










 private D fact;










 private FieldReference readField;










 private FieldReference writtenField;










 private String readField;










 private String writtenField;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,7 +53,7 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {










 public AnnotatedFact(D fact, String readField, String writtenField) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;



......@@ -63,11 +63,11 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return fact;










 }










 










 public FieldReference getReadField() {










 public String getReadField() {










 return readField;










 }










 










 public FieldReference getWrittenField() {










 public String getWrittenField() {










 return writtenField;










 }














......


 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {publicstaticclassAnnotatedFact<DextendsFieldSensitiveFact<?,D>>{  private D fact;privateDfact; private FieldReference readField;privateFieldReferenceFieldReferencereadField; private FieldReference writtenField;privateFieldReferenceFieldReferencewrittenField; private String readField;privateStringStringreadField; private String writtenField;privateStringStringwrittenField;  //TODO: Refactor API to make things more intuitive//TODO: Refactor API to make things more intuitive /**/**		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value		 * @param writtenField		 * @param writtenField		 */		 */ public AnnotatedFact(D fact, FieldReference readField, FieldReference writtenField) {publicAnnotatedFact(Dfact,FieldReferenceFieldReference readFieldreadField,, FieldReferenceFieldReferencewrittenField){ public AnnotatedFact(D fact, String readField, String writtenField) {publicAnnotatedFact(Dfact,StringString readFieldreadField,, StringStringwrittenField){ this.fact = fact;this.fact=fact; this.readField = readField;this.readField=readField; this.writtenField = writtenField;this.writtenField=writtenField; return fact;returnfact; }}  public FieldReference getReadField() {publicFieldReferenceFieldReferencegetReadField(){ public String getReadField() {publicStringStringgetReadField(){ return readField;returnreadField; }}  public FieldReference getWrittenField() {publicFieldReferenceFieldReferencegetWrittenField(){ public String getWrittenField() {publicStringStringgetWrittenField(){ return writtenField;returnwrittenField; }}








test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......












test/heros/alias/AccessPathUtilTest.java








View file @ ec76098b








test/heros/alias/AccessPathUtilTest.java










View file @ ec76098b


ec76098b



......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......






......@@ -10,54 +10,128 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertNull;










import static org.junit.Assert.assertTrue;





















import org.junit.Assert;










import org.junit.Test;





















public class AccessPathUtilTest {





















 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testSummaryWithMultipleExcludedFields() {










 assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static heros.alias.AccessPathUtil.applyAbstractedSummary;importstaticheros.alias.AccessPathUtil.applyAbstractedSummary;import static heros.alias.AccessPathUtil.isPrefixOf;importstaticheros.alias.AccessPathUtil.isPrefixOf;import static org.junit.Assert.assertEquals;importstaticorg.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;importstaticorg.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;importstaticorg.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import org.junit.Assert;importorg.junit.Assert;import org.junit.Test;importorg.junit.Test;public class AccessPathUtilTest {publicclassAccessPathUtilTest{ @Test@Test public void testBaseValuePrefixOfFieldAccess() {publicvoidtestBaseValuePrefixOfFieldAccess(){ assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a.f")));assertTrue(AccessPathUtilAccessPathUtil..isPrefixOf(newFact("a"),newFact("a.f"))); assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.f"), new Fact("a")));assertFalse(AccessPathUtilAccessPathUtil..isPrefixOf(newFact("a.f"),newFact("a"))); assertTrue(isPrefixOf(new Fact("a"), new Fact("a.f")));assertTrue(isPrefixOf(newFact("a"),newFact("a.f"))); assertFalse(isPrefixOf(new Fact("a.f"), new Fact("a")));assertFalse(isPrefixOf(newFact("a.f"),newFact("a"))); }}  @Test@Test public void testBaseValueIdentity() {publicvoidtestBaseValueIdentity(){ assertTrue(AccessPathUtil.isPrefixOf(new Fact("a"), new Fact("a")));assertTrue(AccessPathUtilAccessPathUtil..isPrefixOf(newFact("a"),newFact("a"))); assertTrue(isPrefixOf(new Fact("a"), new Fact("a")));assertTrue(isPrefixOf(newFact("a"),newFact("a"))); }}  @Test@Test public void testFieldAccessPrefixOfFieldAccess() {publicvoidtestFieldAccessPrefixOfFieldAccess(){ assertTrue(AccessPathUtil.isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));assertTrue(AccessPathUtil.isPrefixOf(newFact("a.b"),newFact("a.b.c"))); assertFalse(AccessPathUtil.isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));assertFalse(AccessPathUtil.isPrefixOf(newFact("a.b.c"),newFact("a.b"))); assertTrue(isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));assertTrue(isPrefixOf(newFact("a.b"),newFact("a.b.c"))); assertFalse(isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));assertFalse(isPrefixOf(newFact("a.b.c"),newFact("a.b"))); }}  @Test@Test public void testPrefixOfFieldAccessWithExclusion() {publicvoidtestPrefixOfFieldAccessWithExclusion(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a.g"))); assertFalse(isPrefixOf(new Fact("a.g"), new Fact("a^f")));assertFalse(isPrefixOf(newFact("a.g"),newFact("a^f"))); }}  @Test@Test public void testIdentityWithExclusion() {publicvoidtestIdentityWithExclusion(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a^f"))); assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));assertTrue(isPrefixOf(newFact("a^f,g"),newFact("a^f,g"))); }}  @Test@Test public void testDifferentExclusions() {publicvoidtestDifferentExclusions(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a^g"))); }}  @Test@Test public void testMixedFieldAccess() {publicvoidtestMixedFieldAccess(){ assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));assertTrue(isPrefixOf(newFact("a^f.g"),newFact("a.g.g"))); assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));assertFalse(isPrefixOf(newFact("a^f.g"),newFact("a.g.h"))); assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));assertFalse(isPrefixOf(newFact("a^f.g"),newFact("a.f.g"))); assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));assertTrue(isPrefixOf(newFact("a.f"),newFact("a.f^g"))); }}  @Test@Test public void testMultipleExclusions() {publicvoidtestMultipleExclusions(){ assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));assertTrue(isPrefixOf(newFact("a^f,g"),newFact("a^f"))); assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a^f,g"))); }} @Test@Test public void testDifferentAccessPathLength() {publicvoidtestDifferentAccessPathLength(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a.g.h"))); }}  @Test@Test public void testExclusionDoesNotRequireFieldAccess() {publicvoidtestExclusionDoesNotRequireFieldAccess(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a"))); assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));assertTrue(isPrefixOf(newFact("a.f^g"),newFact("a.f"))); assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));assertTrue(isPrefixOf(newFact("a.f^g^h"),newFact("a.f"))); }}  @Test@Test public void testAbstractedSummary() {publicvoidtestAbstractedSummary(){ assertEquals(new Fact("z.f"), AccessPathUtil.applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));assertEquals(newFact("z.f"),AccessPathUtilAccessPathUtil..applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("z")))); assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());assertEquals(newFact("z.f"),applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("z")))..getget());() }}  @Test@Test public void testAbstractedFieldAccessSummary() {publicvoidtestAbstractedFieldAccessSummary(){ assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))));assertEquals(newFact("z.b.c"),AccessPathUtilAccessPathUtil..applyAbstractedSummary(newFact("a.b.c"),newSummaryEdge<>(newFact("a.b"),null,newFact("z.b")))); assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());assertEquals(newFact("z.b.c"),applyAbstractedSummary(newFact("a.b.c"),newSummaryEdge<>(newFact("a.b"),null,newFact("z.b")))..getget());() }}  @Test@Test public void testSummaryIntroducesFieldAccess() {publicvoidtestSummaryIntroducesFieldAccess(){ assertEquals(new Fact("z.b.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))));assertEquals(newFact("z.b.c"),AccessPathUtilAccessPathUtil..applyAbstractedSummary(newFact("a.c"),newSummaryEdge<>(newFact("a"),null,newFact("z.b")))); assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());assertEquals(newFact("z.b.c"),applyAbstractedSummary(newFact("a.c"),newSummaryEdge<>(newFact("a"),null,newFact("z.b")))..getget());() }}  @Test@Test public void testSummaryRemovesFieldAccess() {publicvoidtestSummaryRemovesFieldAccess(){ assertEquals(new Fact("z.c"), AccessPathUtil.applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))));assertEquals(newFact("z.c"),AccessPathUtilAccessPathUtil..applyAbstractedSummary(newFact("a.b.c"),newSummaryEdge<>(newFact("a.b"),null,newFact("z")))); assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());assertEquals(newFact("z.c"),applyAbstractedSummary(newFact("a.b.c"),newSummaryEdge<>(newFact("a.b"),null,newFact("z")))..getget());() }}  @Test@Test public void testNonAbstractedSummary() {publicvoidtestNonAbstractedSummary(){ assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));assertEquals(newFact("z"),AccessPathUtil.applyAbstractedSummary(newFact("a"),newSummaryEdge<>(newFact("a"),null,newFact("z")))); assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());assertEquals(newFact("z"),applyAbstractedSummary(newFact("a"),newSummaryEdge<>(newFact("a"),null,newFact("z"))).get()); }}  @Test@Test public void testSummaryWithExcludedField() {publicvoidtestSummaryWithExcludedField(){ assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());assertEquals(newFact("a.f"),applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^g"))).get()); }}  @Test@Test public void testSummaryWithMultipleExcludedFields() {publicvoidtestSummaryWithMultipleExcludedFields(){ assertEquals(new Fact("a.f^h,i"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());assertEquals(newFact("a.f^h,i"),applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^g^h,i"))).get()); assertEquals(new Fact("a.f.f"), applyAbstractedSummary(new Fact("a.f.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g^h,i"))).get());assertEquals(newFact("a.f.f"),applyAbstractedSummary(newFact("a.f.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^g^h,i"))).get()); }}  @Test@Test public void testIdentityForExclusions() {publicvoidtestIdentityForExclusions(){ assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());assertEquals(newFact("a^f"),applyAbstractedSummary(newFact("a^f"),newSummaryEdge<>(newFact("a"),null,newFact("a"))).get()); assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());assertEquals(newFact("a^f"),applyAbstractedSummary(newFact("a^f"),newSummaryEdge<>(newFact("a"),null,newFact("a^f"))).get()); }}  @Test@Test public void testMergeExclusions() {publicvoidtestMergeExclusions(){ assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());assertEquals(newFact("a^f,g"),applyAbstractedSummary(newFact("a^f"),newSummaryEdge<>(newFact("a"),null,newFact("a^g"))).get()); }}  @Test@Test public void testNullOnImpossibleSubsumption() {publicvoidtestNullOnImpossibleSubsumption(){ assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());assertFalse(applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^f"))).isPresent()); }}  @Test@Test








test/heros/alias/Fact.java








View file @ ec76098b






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......












test/heros/alias/Fact.java








View file @ ec76098b








test/heros/alias/Fact.java










View file @ ec76098b


ec76098b



......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......






......@@ -41,7 +41,7 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);



......@@ -91,7 +91,6 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return result;










 }
































 @Override










 public boolean equals(Object obj) {










 if (this == obj)



......


 if(separator.equals(".")) {if(separator.equals(".")){ accessPath.add(new FieldReference.SpecificFieldReference(identifier));accessPath.add(newFieldReference.SpecificFieldReference(identifier)); } else {}else{ accessPath.add(new FieldReference.Any(identifier));accessPath.add(newFieldReference.Any(identifier)); accessPath.add(new FieldReference.Any(identifier.split(",")));accessPath.add(newFieldReference.Any(identifier..splitsplit((","",")));) }} }} this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);this.accessPath=accessPath.toArray(newFieldReference[accessPath.size()]); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj)








test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......












test/heros/alias/FieldSensitiveSolverTest.java








View file @ ec76098b








test/heros/alias/FieldSensitiveSolverTest.java










View file @ ec76098b


ec76098b



......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......






......@@ -266,7 +266,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 










 helper.runSolver(false, "a");










 }



......@@ -282,11 +282,26 @@ public class FieldSensitiveSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void exclusionOnPotentiallyInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1")),










 callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),










 exitStmt("c").returns(over("a"), to("d")));










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 



......


 helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3","4")).returns(over("e"),to("f"),kill("2^f"2^f"))); exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); exitStmt("d").returns(over("b"),to("e"),flow("3.f".f,"4")).returns(over("e"),to("f"),kill("3.g"3.g"),), killkill(("2.g""2.g" /* 2^f is back substituted to 2.g*//* 2^f is back substituted to 2.g*/)));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3","4")).returns(over("e"),to("f"),kill("2^f"))); exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3.f".f,"4")).returns(over("e"),to("f"),killkill(("3""3"),), kill("2^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void exclusionOnPotentiallyInterestedCaller() {publicvoidexclusionOnPotentiallyInterestedCaller(){ helper.method("foo",helper.method("foo", startPoints("sp"),startPoints("sp"), normalStmt("sp").succ("a", flow("0", "1")),normalStmt("sp").succ("a",flow("0","1")), callSite("a").calls("bar", flow("1", "1^f")).retSite("d", kill("1")));callSite("a").calls("bar",flow("1","1^f")).retSite("d",kill("1")));  helper.method("bar",helper.method("bar", startPoints("b"),startPoints("b"), normalStmt("b").succ("c", flow("1", readField("f"), "2.f")),normalStmt("b").succ("c",flow("1",readField("f"),"2.f")), exitStmt("c").returns(over("a"), to("d")));exitStmt("c").returns(over("a"),to("d")));  helper.runSolver(false, "sp");helper.runSolver(false,"sp"); }}  @Test@Test public void registerPausedEdgeInLateCallers() {publicvoidregisterPausedEdgeInLateCallers(){ helper.method("foo", helper.method("foo",








test/heros/alias/TestHelper.java








View file @ ec76098b






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......












test/heros/alias/TestHelper.java








View file @ ec76098b








test/heros/alias/TestHelper.java










View file @ ec76098b


ec76098b



......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......






......@@ -89,19 +89,19 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 }










 










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());



......@@ -114,7 +114,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 return flow(times, source, new Pair<String, String>(null, null), targets);










 }










 










 public static int times(int times) {



......


 return new ExpectedFlowFunction(times, new Fact(source));returnnewExpectedFlowFunction(times,newFact(source)); }} public static Pair<FieldReference, FieldReference> readField(String fieldName) {publicstaticPair<FieldReferenceFieldReference,, FieldReferenceFieldReference>readField(StringfieldName){ return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());returnnewPair<FieldReferenceFieldReference,, FieldReferenceFieldReference>(>(newnew FieldReferenceFieldReference..SpecificFieldReferenceSpecificFieldReference(fieldName),)newew FieldReferenceFieldReference..AnyAny());() public static Pair<String, String> readField(String fieldName) {publicstaticPair<StringString,, StringString>readField(StringfieldName){ return new Pair<String, String>(fieldName, null);returnnewPair<StringString,, StringString>(>fieldName,nullull); }}  public static Pair<FieldReference, FieldReference> writeField(String fieldName) {publicstaticPair<FieldReferenceFieldReference,, FieldReferenceFieldReference>writeField(StringfieldName){ return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));returnnewPair<FieldReferenceFieldReference,, FieldReferenceFieldReference>(>(newnew FieldReferenceFieldReference..AnyAny(),(), newnew FieldReferenceFieldReference..SpecificFieldReferenceSpecificFieldReference((fieldName));) public static Pair<String, String> writeField(String fieldName) {publicstaticPair<StringString,, StringString>writeField(StringfieldName){ return new Pair<String, String>(null, fieldName);returnnewPair<StringString,, StringString>(>(nullnull,, fieldName); }}  public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,Pair<FieldReferenceFieldReference,, FieldReferenceFieldReference>fieldAccess,String...targets){ public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,Pair<StringString,, StringString>fieldAccess,String...targets){ return flow(1, source, fieldAccess, targets);returnflow(1,source,fieldAccess,targets); }}  public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,Pair<FieldReferenceFieldReference,, FieldReferenceFieldReference>fieldAccess,String...targets){ public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,Pair<StringString,, StringString>fieldAccess,String...targets){ AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];AnnotatedFact<Fact>[]targetFacts=newAnnotatedFact[targets.length]; for(int i=0; i<targets.length; i++) {for(inti=0;i<targets.length;i++){ targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());targetFacts[i]=newAnnotatedFact<Fact>(newFact(targets[i]),fieldAccess.getO1(),fieldAccess.getO2()); }}  public static ExpectedFlowFunction flow(int times, String source, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,String...targets){ return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);returnflow(times,source,newPair<FieldReferenceFieldReference,, FieldReferenceFieldReference>(>(newnew FieldReferenceFieldReference..AnyAny(),(), newnew FieldReferenceFieldReference..AnyAny()),()targets); return flow(times, source, new Pair<String, String>(null, null), targets);returnflow(times,source,newPair<StringString,, StringString>(>(nullnull,, nullnull),targets); }}  public static int times(int times) {publicstaticinttimes(inttimes){









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






