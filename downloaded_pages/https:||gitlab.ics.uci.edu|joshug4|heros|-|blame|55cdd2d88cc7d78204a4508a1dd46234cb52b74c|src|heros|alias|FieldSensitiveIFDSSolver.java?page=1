



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c

















55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1




/*******************************************************************************









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






2




 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






3




4




5




6




7




8




 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






9




 *     Johannes Lerch, Johannes Späth - initial API and implementation









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






10




11




12




 ******************************************************************************/
package heros.alias;










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






13




14




15




16




import heros.DontSynchronize;
import heros.FlowFunctionCache;
import heros.InterproceduralCFG;
import heros.SynchronizedBy;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






17




import heros.alias.AccessPath.Delta;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






18




import heros.alias.AccessPath.PrefixTestResult;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






19




import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






20




import heros.alias.FlowFunction.ConstrainedFact;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






21




import heros.alias.FlowFunction.Constraint;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






22




23




import heros.solver.CountingThreadPoolExecutor;
import heros.solver.IFDSSolver;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






24




import heros.solver.Pair;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






25




26




import heros.solver.PathEdge;










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






27




28




29




30




31




32




import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






33




34




import java.util.Collection;
import java.util.Collections;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






35




36




import java.util.Comparator;
import java.util.Enumeration;









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






37




import java.util.HashMap;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






38




import java.util.Iterator;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






39




import java.util.LinkedList;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






40




import java.util.List;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






41




42




import java.util.Map;
import java.util.Map.Entry;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






43




import java.util.PriorityQueue;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






44




import java.util.Set;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






45




46




47




48




49




50




import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;










handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






51




import com.google.common.base.Optional;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






52




import com.google.common.base.Predicate;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






53




import com.google.common.cache.CacheBuilder;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






54




import com.google.common.collect.HashMultimap;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






55




import com.google.common.collect.Iterators;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






56




import com.google.common.collect.Lists;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






57




import com.google.common.collect.Maps;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






58




import com.google.common.collect.Sets;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






59




import com.sun.org.apache.xpath.internal.axes.IteratorPool;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






60














merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






61




public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85






	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel
			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
	
    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);

    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
    public static final boolean DEBUG = logger.isDebugEnabled();

	protected CountingThreadPoolExecutor executor;
	
	@DontSynchronize("only used by single thread")
	protected int numThreads;
	
	@SynchronizedBy("thread safe data structure, consistent locking when used")
	protected final JumpFunctions<N,D> jumpFn;
	
	@SynchronizedBy("thread safe data structure, only modified internally")
	protected final I icfg;
	
	//stores summaries that were queried before they were computed
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on 'incoming'")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






86




87




	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =
			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






88




89




90




91




	
	//edges going along calls
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on field")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






92




93




	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =
			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






94




	









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






95




	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






96




	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






97




	@DontSynchronize("stateless")









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






98




	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




	
	@DontSynchronize("only used by single thread")
	protected final Map<N,Set<D>> initialSeeds;
	
	@DontSynchronize("benign races")
	public long propagationCount;
	
	@DontSynchronize("stateless")
	protected final D zeroValue;
	
	@DontSynchronize("readOnly")
	protected final FlowFunctionCache<N,D,M> ffCache = null; 
	
	@DontSynchronize("readOnly")
	protected final boolean followReturnsPastSeeds;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






114














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






115




	private LinkedList<PathEdgeProcessingTask> worklist;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






116




117




118




119




120




121




	
	
	/**
	 * Creates a solver for the given problem, which caches flow functions and edge functions.
	 * The solver must then be started by calling {@link #solve()}.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






122




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






123




124




125




126




127




128




129




130




131




		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
	}

	/**
	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling
	 * {@link #solve()}.
	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.
	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






132




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






133




134




135




136




137




138




		if(logger.isDebugEnabled())
			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
		this.zeroValue = tabulationProblem.zeroValue();
		this.icfg = tabulationProblem.interproceduralCFG();		
	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?
				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






139




		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






140




141




142




143




144




145




146




147




148




149




		/*if(flowFunctionCacheBuilder!=null) {
			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);
			flowFunctions = ffCache;
		} else {
			ffCache = null;
		}*/
		this.flowFunctions = flowFunctions;
		this.initialSeeds = tabulationProblem.initialSeeds();
		this.jumpFn = new JumpFunctions<N,D>();
		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






150




		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






151




		this.executor = getExecutor();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






152




		this.worklist = Lists.newLinkedList();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






153




154




155




156




157




158




159




160




	}

	/**
	 * Runs the solver on the configured problem. This can take some time.
	 */
	public void solve() {		
		submitInitialSeeds();
		awaitCompletionComputeValuesAndShutdown();









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






161




		writeDebugFile();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






162




163




164




165




166




167




168




169




170




171




172




	}

	/**
	 * Schedules the processing of initial seeds, initiating the analysis.
	 * Clients should only call this methods if performing synchronization on
	 * their own. Normally, {@link #solve()} should be called instead.
	 */
	protected void submitInitialSeeds() {
		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {
			N startPoint = seed.getKey();
			for(D val: seed.getValue())









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






173




				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






174




175




176




177




178




179




180




181




182




			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
		}
	}

	/**
	 * Awaits the completion of the exploded super graph. When complete, computes result values,
	 * shuts down the executor and returns.
	 */
	protected void awaitCompletionComputeValuesAndShutdown() {









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






183




184




185




186




//		{
//			//run executor and await termination of tasks
//			runExecutorAndAwaitCompletion();
//		}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






187




188




189




190




191




192




		if(logger.isDebugEnabled())
			printStats();

		//ask executor to shut down;
		//this will cause new submissions to the executor to be rejected,
		//but at this point all tasks should have completed anyway









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






193




//		executor.shutdown();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






194




195




196




197




198




		//similarly here: we await termination, but this should happen instantaneously,
		//as all tasks should have completed
		runExecutorAndAwaitCompletion();
	}










field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






199




200




201




202




	protected boolean hasWork() {
		return !worklist.isEmpty();
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






203




204




	private int jobCounter = 0;
	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






205




206




207




208




	/**
	 * Runs execution, re-throwing exceptions that might be thrown during its execution.
	 */
	private void runExecutorAndAwaitCompletion() {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






209




210




211




212




213




214




215




216




217




218




//		try {
//			executor.awaitCompletion();
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//		Throwable exception = executor.getException();
//		if(exception!=null) {
//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);
//		}
		while(!worklist.isEmpty()) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






219




220




//			if(jobCounter % 100_000 == 0)
			









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






221




			PathEdgeProcessingTask current = worklist.removeLast();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






222




223




224




225




226




227




228




229




230




231




232




			int size = worklist.size();
			current.run();
			jobCounter++;
			M method = icfg.getMethodOf(current.edge.getTarget());
//			edgesPerMethod.put(method, current.edge);
//			if(edgesPerMethod.get(method).size() > 10_000) {
//				System.out.println(method);
//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {
//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));
//				}
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






233




			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






234




235




236




				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));
			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






237




238




//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






239




240




241




242




243




244




245




246




247




248




		}
	}

    /**
     * Dispatch the processing of a given edge. It may be executed in a different thread.
     * @param edge the edge to process
     */
    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){
    	// If the executor has been killed, there is little point
    	// in submitting new tasks









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






249




250




251




252




//    	if (executor.isTerminating())
//    		return;
//    	executor.execute(new PathEdgeProcessingTask(edge));
    	worklist.add(new PathEdgeProcessingTask(edge));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






253




254




255




256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




    	propagationCount++;
    }
	
	/**
	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
	 * 
	 * For each possible callee, registers incoming call edges.
	 * Also propagates call-to-return flows and summarized callee flows within the caller. 
	 * 
	 * @param edge an edge whose target node resembles a method call
	 */
	private void processCall(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); // a call node; line 14...

        logger.trace("Processing call to {}", n);

		final D d2 = edge.factAtTarget();
		assert d2 != null;
		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
		
		//for each possible callee
		Collection<M> callees = icfg.getCalleesOfCallAt(n);
		for(M sCalledProcN: callees) { //still line 14
			//compute the call-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






278




			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






279




			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






280




281




282




			
			Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
			//for each result node of the call-flow function









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






283




			for(ConstrainedFact<FieldRef, D> d3: res) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






284




285




286




				//for each callee's start point(s)
				for(N sP: startPointsOf) {
					//create initial self-loop









avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015






287




					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






288




					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






289




290




291




292




				}
				
				//register the fact that <sp,d3> has an incoming edge from <n,d2>
				//line 15.1 of Naeem/Lhotak/Rodriguez









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






293




294




				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);
				if (!addIncoming(sCalledProcN, incomingEdge))









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






295




296




					continue;
				









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






297




				resumeEdges(sCalledProcN, d3.getFact());









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






298




299




				registerInterestedCaller(sCalledProcN, incomingEdge);
				









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






300




301




				
				//line 15.2









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






302




				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






303




304




305




306




307




308




					
				//still line 15.2 of Naeem/Lhotak/Rodriguez
				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,
				//create new caller-side jump functions to the return sites
				//because we have observed a potentially new incoming edge into <sP,d3>
				if (endSumm != null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






309




					for(SummaryEdge<D, N> summary: endSumm) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






310




311




						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);
						if(delta.isPresent()) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






312




313




314




315




316




							//for each return site
							for(N retSiteN: returnSiteNs) {
								//compute return-flow function
								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);
								//for each target value of the function









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






317




								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






318




									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






319




320




321




322




323




324




									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);
									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());
									
									AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);
									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






325




326




								}
							}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






327




						}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






328




329




330




331




332




333




					}
			}
		}
		//line 17-19 of Naeem/Lhotak/Rodriguez		
		//process intra-procedural flows along call-to-return flow functions
		for (N returnSiteN : returnSiteNs) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






334




			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






335




			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






336




				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






337




338




339




		}
	}










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






340




	private void resumeEdges(M method, D factAtMethodStartPoint) {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






341




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






342




343




		if(edges != null) {
			for(PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






344




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






345




346




					if(edges.remove(edge))  {
						logger.trace("RESUME-EDGE: {}", edge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






347




						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






348




349




350




351




352




					}
				}
			}
		}
	}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






353




354




355




356




	
	private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {
		Set<PathEdge<N, D>> edges = pausedEdges.get(method);
		if(edges != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






357




358




359




			if(edges.size() > 100)
				System.out.println("Paused edges for method "+method+": "+edges.size());
			









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






360




			for(final PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






361




				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






362




363




					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);
					









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






364




					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






365




366




367




					
					if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 
							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






368




369




370




						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();
							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






371




								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






372




								incomingEdge.getCallSite(), 









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






373




								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






374




								method,









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






375




								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






376




377




378




379




380




381




382




383




384




						}
						else {
							propagateConstrained(new CallConcretizationPathEdge<>(
									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 
									incomingEdge.getCallSite(), 
									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),
									method,
									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));
						}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






385




					}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






386




387




388




389




				}
			}
		}
	}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






390














FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






391




392




393




394




395




396




397




	/**
	 * Computes the call flow function for the given call-site abstraction
	 * @param callFlowFunction The call flow function to compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the callee's start node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






398




	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






399




			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






400




401




402




403




404




405




406




407




408




409




410




411




		return callFlowFunction.computeTargets(d2);
	}

	/**
	 * Computes the call-to-return flow function for the given call-site
	 * abstraction
	 * @param callToReturnFlowFunction The call-to-return flow function to
	 * compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






412




	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






413




			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






414




415




416




417




418




419




420




421




422




423




424




425




426




427




428




429




430




431




432




433




434




435




436




		return callToReturnFlowFunction.computeTargets(d2);
	}
	
	/**
	 * Lines 21-32 of the algorithm.
	 * 
	 * Stores callee-side summaries.
	 * Also, at the side of the caller, propagates intra-procedural flows to return sites
	 * using those newly computed summaries.
	 * 
	 * @param edge an edge whose target node resembles a method exits
	 */
	protected void processExit(PathEdge<N,D> edge) {
		final N n = edge.getTarget(); // an exit node; line 21...
		M methodThatNeedsSummary = icfg.getMethodOf(n);
		
		final D d1 = edge.factAtSource();
		final D d2 = edge.factAtTarget();
		
		//for each of the method's start points, determine incoming calls
		
		//line 21.1 of Naeem/Lhotak/Rodriguez
		//register end-summary









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






437




438




		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);
		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






439




			return; //FIXME: should never be reached?! -> assert ?









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






440




441




442




		
		//for each incoming call edge already processed
		//(see processCall(..))









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






443




444




445




446




447




448




		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {
			// line 22
			N callSite = incomingEdge.getCallSite();
			// for each return site
			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {
				// compute return-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






449




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






450




				









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






451




				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






452




453




454




					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);
					if(delta.isPresent()) {
						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






455




456




	
						// for each incoming-call value









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






457




						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






458




							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






459




460




461




462




							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());
							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






463




						}









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






464




					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






465




466




				}
			}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






467




468




		}
		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






469




470




471




472




		
		//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow
		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only
		//be propagated into callers that have an incoming edge for this condition









bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015






473




		if(followReturnsPastSeeds && d1 == zeroValue) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






474




475




476




			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
			for(N c: callers) {
				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






477




					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






478




					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






479




480




481




482




483




484




485




					for(ConstrainedFact<FieldRef, D> d5: targets) {
						
						Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());
						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);
					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






486




487




488




489




490




491




				}
			}
			//in cases where there are no callers, the return statement would normally not be processed at all;
			//this might be undesirable if the flow function has a side effect such as registering a taint;
			//instead we thus call the return flow function will a null caller
			if(callers.isEmpty()) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






492




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






493




494




495




496




497




				retFunction.computeTargets(d2);
			}
		}
	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






498




499




500




501




502




503




504




505




506




507




508




509




510




511




512




513




514




515




516




517




518




519




520




521




522




523




524




525




526




527




528




529




530




531




532




533




534




535




536




537




538




539




540




541




542




543




544




545




546




547




548




549




550




551




552




553




554




555




556




557




558




559




560




561




562




563




564




565




566




567




568




569




570




571




572




573




574




575




576




577




578




579




580




581




582




583




584




585




586




587




588




589




590




591




592




593




594




595




596




597




598




599




600




601




602




603




604




605




606




607




608




609




610




611




612




613




614




615




616




617




618




619




620




621




622




623




624




625




626




627




628




629




630




631




632




633




634




635




636




637




638




639




640




641




642




643




644




645




646




647




648




649




650




651




652




653




654




655




656




657




658




659




660




661




662




663




664




665




666




667




668




669




670




671




672




673




674




675




676




677




678




679




680




681




682




683




684




685




686




687




688




689




690




691




692




693




694




695




696




697




698




699




700




701




702




703




704




705




706




707




708




709




710




711




712




713




714




715




716




717




718




719




720




721




722




723




724




725




726




727




728




729




730




731




732




733




734




735




736




737




738




739




740




741




742




743




744




745




746




747




748




749




750




751




752




753




754




755




756




757




758




759




760




761




762




763




764




765




766




767




768




769




770




771




772




773




774




775




776




777




778




779




780




781




782




783




784




785




786




787




788




789




790




791




	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();
	
	private Resolver getResolver(D sourceFact, D targetFact, N stmt) {
		HashKey key = new HashKey(sourceFact, targetFact, stmt);
		if(!returnSiteIncomingEdges.containsKey(key))
			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));
		return returnSiteIncomingEdges.get(key);
	}
	
	private class PausedReturnSiteEdge {

		private Constraint<FieldRef> constraint;
		private PathEdge<N, D> pathEdge;
		private AccessPath<FieldRef> alreadyResolvedAccPath;
		private D concretizedStmtFact;

		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {
			this.constraint = constraint;
			this.pathEdge = pathEdge;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
			this.concretizedStmtFact = concretizedStmtFact;
		}
	}
	
	class Resolver {

		private D sourceFact;
		private N stmt;
		private Set<IncomingFact> incomingFacts = Sets.newHashSet();
		private D targetFact;
		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();

		public Resolver(D sourceFact, D targetFact, N stmt) {
			this.sourceFact = sourceFact;
			this.targetFact = targetFact;
			this.stmt = stmt;
		}

		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {
				if(!fact.getAccessPath().hasResolver())
					throw new AssertionError();
				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))
					throw new AssertionError();
			}
			
			logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);
			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);
			incomingFacts.add(incFact);
			
			for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {
				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {
					propagate(edge.pathEdge, null, false);
					paused.remove(edge);
				}
			}
		}

		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {
			if(!visited.resolver.add(this))
				return false;
			
			alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);
			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);
			
			logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());
			
			boolean resolved = false;
			for(final IncomingFact incFact : incomingFacts) {
				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);
				if(resolved)
					break;
			}
			if(resolved) {
				propagate(pathEdge, null, false);
			} else {
				logger.trace("Pause {} at {}", pathEdge, stmt);
				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));
			}
			return resolved;
		}

		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,
				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {
			
			
			logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);
			
			if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {
				logger.trace("Resolved by incoming fact {}", incFact.fact);
				return true;
			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
				if(incFact.fact.getAccessPath().hasResolver()) {
					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();
					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);
					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(
								incFact.summaryEdge.getSourceFact(), 
								incFact.summaryEdge.getTargetStmt(), 
								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {

									@Override
									public void _propagate(D dSource, N target, D dTarget) {
										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);
									}
						}, decoratingResolver.alreadyResolvedAccPath, visited);
						if(resolved) {
							propagate(pathEdge, null, false);
							return true;
						}
					}
				}
				else {
					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));
					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {
						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);
						return true;
					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
						if(factWithDelta.getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();
							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
							
							final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);
							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);
								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));
								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {
									@Override
									protected void _propagate(D dSource, N target, D dTarget) {
										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);
									}
								};
								
								boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);
								if(resolved) {
									return true;
								}
							}
						}
						else {
							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));
							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);
							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(
									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 
									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {
										@Override
										protected void _propagate(D dSource, N target, D dTarget) {
											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);
										}
									}, visited);
							if(resolved)
								return true;
						}
					}
				}
			}
			return false;
		}
		
		@Override
		public String toString() {
			return stmt.toString();
		}
	}

	private class Visited {
		Set<Resolver> resolver = Sets.newHashSet();
		Map<N, Boolean> visitedCallSites = Maps.newHashMap();
	}
	
	class DecoratingResolver implements SubPathResolver<FieldRef> {
		
		private Resolver resolver;
		private AccessPath<FieldRef> alreadyResolvedAccPath;

		public DecoratingResolver(Resolver resolver) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();
		}
		
		public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
		}
		
		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {
			return resolve(constraint, pathEdge, new Visited());
		}

		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {
			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());
			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			DecoratingResolver other = (DecoratingResolver) obj;
			if (alreadyResolvedAccPath == null) {
				if (other.alreadyResolvedAccPath != null)
					return false;
			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))
				return false;
			if (resolver == null) {
				if (other.resolver != null)
					return false;
			} else if (!resolver.equals(other.resolver))
				return false;
			return true;
		}
		
		@Override
		public String toString() {
			return alreadyResolvedAccPath+ ":"+resolver.toString();
		}

		@Override
		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {
			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));
		}
	}
	
	private class IncomingFact {

		private D fact;
		private Delta<FieldRef> delta;
		private SummaryEdge<D, N> summaryEdge;

		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			this.summaryEdge = summaryEdge;
			this.fact = fact;
			this.delta = delta;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((delta == null) ? 0 : delta.hashCode());
			result = prime * result + ((fact == null) ? 0 : fact.hashCode());
			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			IncomingFact other = (IncomingFact) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (delta == null) {
				if (other.delta != null)
					return false;
			} else if (!delta.equals(other.delta))
				return false;
			if (fact == null) {
				if (other.fact != null)
					return false;
			} else if (!fact.equals(other.fact))
				return false;
			if (summaryEdge == null) {
				if (other.summaryEdge != null)
					return false;
			} else if (!summaryEdge.equals(other.summaryEdge))
				return false;
			return true;
		}

		private FieldSensitiveIFDSSolver getOuterType() {
			return FieldSensitiveIFDSSolver.this;
		}
		
	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






792




793




794




795




796




797




798




799




	/**
	 * Computes the return flow function for the given set of caller-side
	 * abstractions.
	 * @param retFunction The return flow function to compute
	 * @param d2 The abstraction at the exit node in the callee
	 * @param callSite The call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






800




	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






801




			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






802




803




804




805




806




807




808




809




		return retFunction.computeTargets(d2);
	}

	/**
	 * Lines 33-37 of the algorithm.
	 * Simply propagate normal, intra-procedural flows.
	 * @param edge
	 */









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






810




	@SuppressWarnings("unchecked")









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






811




812




813




814




815




816




	private void processNormalFlow(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); 
		final D d2 = edge.factAtTarget();
		
		for (N m : icfg.getSuccsOf(n)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






817




			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






818




819




			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);
			for (ConstrainedFact<FieldRef, D> d3 : res) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






820




				if(d3.getConstraint() != null) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






821




822




823




824




825




					if(d3.getFact().getAccessPath().hasResolver()) {
						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());
						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));
					} else
						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






826




				}









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






827




				else









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






828




					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






829




830




831




832




			}
		}
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






833




	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






834




835




836




		if(fact.equals(zeroValue))
			return zeroValue;
		else









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






837




			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






838




	}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






839




	









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






840




	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






841




		return propagateConstrained(pathEdge, new Visited());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






842




843




	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






844




	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






845




		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






846




		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






847














cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






848




849




850




		boolean propagate = false;
		if(pathEdge.factAtSource().equals(zeroValue))
			propagate = true;









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






851




852




		else if(hasPausedEdges(calleeMethod, pathEdge))
			propagate = false;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






853




854




		else {
			Set<N> callSitesWithInterest = Sets.newHashSet();









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






855




			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






856




				callSitesWithInterest.add(incEdge.getCallSite());









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






857




			}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






858




859




			propagate = !callSitesWithInterest.isEmpty();
			









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






860




861




862




863




864




865




866




			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());
			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);
			
			for(IncomingEdge<D, N> incEdge : candidates) { //potential
				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {
					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)
						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






867




868




				}
				else {









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






869




					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






870




871




872




873




874




875




876




877




878




879




880




881




882




883




884




885




886




887




888




889




890




891




892




893




894




895




896




897




898




899




900




901




902




903




						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();
								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);
								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(
										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));
								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 
										calleeMethod,
										calleeSourceFact), visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}
						}
						else {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
					
								PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),
										calleeMethod,
										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));
								visited.visitedCallSites.put(incEdge.getCallSite(), null);
								boolean result = propagateConstrained(callerEdge, visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






904




						}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






905




					}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






906




				}









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






907




			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






908




		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






909




		









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






910




		if(propagate) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






911




			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






912




913




914




915




916




917




			return true;
		} else {
			pauseEdge(pathEdge);
			return false;
		}
	}









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






918














abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






919




920




921




922




923




924




925




926




927




928




929




930




931




932




933




	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {
		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();
		for(IncomingEdge<D, N> incEdge : candidates) {
			if(result.containsKey(incEdge.getCallSite())) {
				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());
				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {
					result.put(incEdge.getCallSite(), incEdge);
				}
			}
			else
				result.put(incEdge.getCallSite(), incEdge);
		}
		return result.values();
	}










Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






934




935




936




937




	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {
		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);
		if(pe != null) {
			for(PathEdge<N, D> edge : pe) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






938




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






939




940




941




942




943




944




					return true;
			}
		}
		return false;
	}










cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






945




946




	private void pauseEdge(PathEdge<N,D> edge) {
		M method = icfg.getMethodOf(edge.getTarget());









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






947




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






948




949




950




		if(edges.add(edge)) {
			logger.trace("PAUSED: {}: {}", method, edge);
		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






951




952




	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






953




954




955




956




957




958




959




960




	/**
	 * Computes the normal flow function for the given set of start and end
	 * abstractions.
	 * @param flowFunction The normal flow function to compute
	 * @param d1 The abstraction at the method's start node
	 * @param d1 The abstraction at the current node
	 * @return The set of abstractions at the successor node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






961




	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






962




			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






963




964




965




966




967




968




969




970




971




972




973




974




975




976




977




978




979




980




981




982




		return flowFunction.computeTargets(d2);
	}
	
	/**
	 * This method will be called for each incoming edge and can be used to
	 * transfer knowledge from the calling edge to the returning edge, without
	 * affecting the summary edges at the callee.
	 * 
	 * @param d4
	 *            Fact stored with the incoming edge, i.e., present at the
	 *            caller side
	 * @param d5
	 *            Fact that originally should be propagated to the caller.
	 * @return Fact that will be propagated to the caller.
	 */
	protected D restoreContextOnReturnedFact(D d4, D d5) {
		d5.setCallingContext(d4);
		return d5;
	}
	









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






983




984




985




986




	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,
			/* deliberately exposed to clients */ N relatedCallSite) {
		propagate(edge, relatedCallSite, true);
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






987




	









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






988




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






989




990




991




992




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();
	private int cacheHits = 0;
	private int cacheMerges = 0;
	private int cacheOppositePrefix = 0;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






993




994




995




	private int cacheSourceBaseValue = 0;
	private int concretizationEdges = 0;
	private int cacheEquals = 0;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






996




997




	/**
	 * Propagates the flow further down the exploded super graph. 









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






998




	 * @param edge the PathEdge that should be propagated









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






999




1000




	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 






For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next











H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c

















55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1




/*******************************************************************************









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






2




 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






3




4




5




6




7




8




 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






9




 *     Johannes Lerch, Johannes Späth - initial API and implementation









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






10




11




12




 ******************************************************************************/
package heros.alias;










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






13




14




15




16




import heros.DontSynchronize;
import heros.FlowFunctionCache;
import heros.InterproceduralCFG;
import heros.SynchronizedBy;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






17




import heros.alias.AccessPath.Delta;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






18




import heros.alias.AccessPath.PrefixTestResult;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






19




import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






20




import heros.alias.FlowFunction.ConstrainedFact;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






21




import heros.alias.FlowFunction.Constraint;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






22




23




import heros.solver.CountingThreadPoolExecutor;
import heros.solver.IFDSSolver;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






24




import heros.solver.Pair;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






25




26




import heros.solver.PathEdge;










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






27




28




29




30




31




32




import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






33




34




import java.util.Collection;
import java.util.Collections;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






35




36




import java.util.Comparator;
import java.util.Enumeration;









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






37




import java.util.HashMap;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






38




import java.util.Iterator;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






39




import java.util.LinkedList;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






40




import java.util.List;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






41




42




import java.util.Map;
import java.util.Map.Entry;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






43




import java.util.PriorityQueue;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






44




import java.util.Set;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






45




46




47




48




49




50




import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;










handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






51




import com.google.common.base.Optional;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






52




import com.google.common.base.Predicate;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






53




import com.google.common.cache.CacheBuilder;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






54




import com.google.common.collect.HashMultimap;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






55




import com.google.common.collect.Iterators;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






56




import com.google.common.collect.Lists;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






57




import com.google.common.collect.Maps;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






58




import com.google.common.collect.Sets;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






59




import com.sun.org.apache.xpath.internal.axes.IteratorPool;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






60














merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






61




public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85






	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel
			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
	
    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);

    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
    public static final boolean DEBUG = logger.isDebugEnabled();

	protected CountingThreadPoolExecutor executor;
	
	@DontSynchronize("only used by single thread")
	protected int numThreads;
	
	@SynchronizedBy("thread safe data structure, consistent locking when used")
	protected final JumpFunctions<N,D> jumpFn;
	
	@SynchronizedBy("thread safe data structure, only modified internally")
	protected final I icfg;
	
	//stores summaries that were queried before they were computed
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on 'incoming'")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






86




87




	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =
			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






88




89




90




91




	
	//edges going along calls
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on field")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






92




93




	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =
			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






94




	









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






95




	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






96




	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






97




	@DontSynchronize("stateless")









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






98




	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




	
	@DontSynchronize("only used by single thread")
	protected final Map<N,Set<D>> initialSeeds;
	
	@DontSynchronize("benign races")
	public long propagationCount;
	
	@DontSynchronize("stateless")
	protected final D zeroValue;
	
	@DontSynchronize("readOnly")
	protected final FlowFunctionCache<N,D,M> ffCache = null; 
	
	@DontSynchronize("readOnly")
	protected final boolean followReturnsPastSeeds;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






114














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






115




	private LinkedList<PathEdgeProcessingTask> worklist;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






116




117




118




119




120




121




	
	
	/**
	 * Creates a solver for the given problem, which caches flow functions and edge functions.
	 * The solver must then be started by calling {@link #solve()}.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






122




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






123




124




125




126




127




128




129




130




131




		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
	}

	/**
	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling
	 * {@link #solve()}.
	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.
	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






132




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






133




134




135




136




137




138




		if(logger.isDebugEnabled())
			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
		this.zeroValue = tabulationProblem.zeroValue();
		this.icfg = tabulationProblem.interproceduralCFG();		
	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?
				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






139




		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






140




141




142




143




144




145




146




147




148




149




		/*if(flowFunctionCacheBuilder!=null) {
			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);
			flowFunctions = ffCache;
		} else {
			ffCache = null;
		}*/
		this.flowFunctions = flowFunctions;
		this.initialSeeds = tabulationProblem.initialSeeds();
		this.jumpFn = new JumpFunctions<N,D>();
		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






150




		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






151




		this.executor = getExecutor();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






152




		this.worklist = Lists.newLinkedList();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






153




154




155




156




157




158




159




160




	}

	/**
	 * Runs the solver on the configured problem. This can take some time.
	 */
	public void solve() {		
		submitInitialSeeds();
		awaitCompletionComputeValuesAndShutdown();









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






161




		writeDebugFile();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






162




163




164




165




166




167




168




169




170




171




172




	}

	/**
	 * Schedules the processing of initial seeds, initiating the analysis.
	 * Clients should only call this methods if performing synchronization on
	 * their own. Normally, {@link #solve()} should be called instead.
	 */
	protected void submitInitialSeeds() {
		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {
			N startPoint = seed.getKey();
			for(D val: seed.getValue())









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






173




				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






174




175




176




177




178




179




180




181




182




			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
		}
	}

	/**
	 * Awaits the completion of the exploded super graph. When complete, computes result values,
	 * shuts down the executor and returns.
	 */
	protected void awaitCompletionComputeValuesAndShutdown() {









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






183




184




185




186




//		{
//			//run executor and await termination of tasks
//			runExecutorAndAwaitCompletion();
//		}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






187




188




189




190




191




192




		if(logger.isDebugEnabled())
			printStats();

		//ask executor to shut down;
		//this will cause new submissions to the executor to be rejected,
		//but at this point all tasks should have completed anyway









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






193




//		executor.shutdown();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






194




195




196




197




198




		//similarly here: we await termination, but this should happen instantaneously,
		//as all tasks should have completed
		runExecutorAndAwaitCompletion();
	}










field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






199




200




201




202




	protected boolean hasWork() {
		return !worklist.isEmpty();
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






203




204




	private int jobCounter = 0;
	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






205




206




207




208




	/**
	 * Runs execution, re-throwing exceptions that might be thrown during its execution.
	 */
	private void runExecutorAndAwaitCompletion() {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






209




210




211




212




213




214




215




216




217




218




//		try {
//			executor.awaitCompletion();
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//		Throwable exception = executor.getException();
//		if(exception!=null) {
//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);
//		}
		while(!worklist.isEmpty()) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






219




220




//			if(jobCounter % 100_000 == 0)
			









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






221




			PathEdgeProcessingTask current = worklist.removeLast();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






222




223




224




225




226




227




228




229




230




231




232




			int size = worklist.size();
			current.run();
			jobCounter++;
			M method = icfg.getMethodOf(current.edge.getTarget());
//			edgesPerMethod.put(method, current.edge);
//			if(edgesPerMethod.get(method).size() > 10_000) {
//				System.out.println(method);
//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {
//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));
//				}
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






233




			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






234




235




236




				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));
			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






237




238




//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






239




240




241




242




243




244




245




246




247




248




		}
	}

    /**
     * Dispatch the processing of a given edge. It may be executed in a different thread.
     * @param edge the edge to process
     */
    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){
    	// If the executor has been killed, there is little point
    	// in submitting new tasks









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






249




250




251




252




//    	if (executor.isTerminating())
//    		return;
//    	executor.execute(new PathEdgeProcessingTask(edge));
    	worklist.add(new PathEdgeProcessingTask(edge));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






253




254




255




256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




    	propagationCount++;
    }
	
	/**
	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
	 * 
	 * For each possible callee, registers incoming call edges.
	 * Also propagates call-to-return flows and summarized callee flows within the caller. 
	 * 
	 * @param edge an edge whose target node resembles a method call
	 */
	private void processCall(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); // a call node; line 14...

        logger.trace("Processing call to {}", n);

		final D d2 = edge.factAtTarget();
		assert d2 != null;
		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
		
		//for each possible callee
		Collection<M> callees = icfg.getCalleesOfCallAt(n);
		for(M sCalledProcN: callees) { //still line 14
			//compute the call-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






278




			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






279




			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






280




281




282




			
			Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
			//for each result node of the call-flow function









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






283




			for(ConstrainedFact<FieldRef, D> d3: res) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






284




285




286




				//for each callee's start point(s)
				for(N sP: startPointsOf) {
					//create initial self-loop









avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015






287




					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






288




					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






289




290




291




292




				}
				
				//register the fact that <sp,d3> has an incoming edge from <n,d2>
				//line 15.1 of Naeem/Lhotak/Rodriguez









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






293




294




				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);
				if (!addIncoming(sCalledProcN, incomingEdge))









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






295




296




					continue;
				









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






297




				resumeEdges(sCalledProcN, d3.getFact());









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






298




299




				registerInterestedCaller(sCalledProcN, incomingEdge);
				









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






300




301




				
				//line 15.2









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






302




				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






303




304




305




306




307




308




					
				//still line 15.2 of Naeem/Lhotak/Rodriguez
				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,
				//create new caller-side jump functions to the return sites
				//because we have observed a potentially new incoming edge into <sP,d3>
				if (endSumm != null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






309




					for(SummaryEdge<D, N> summary: endSumm) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






310




311




						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);
						if(delta.isPresent()) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






312




313




314




315




316




							//for each return site
							for(N retSiteN: returnSiteNs) {
								//compute return-flow function
								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);
								//for each target value of the function









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






317




								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






318




									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






319




320




321




322




323




324




									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);
									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());
									
									AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);
									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






325




326




								}
							}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






327




						}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






328




329




330




331




332




333




					}
			}
		}
		//line 17-19 of Naeem/Lhotak/Rodriguez		
		//process intra-procedural flows along call-to-return flow functions
		for (N returnSiteN : returnSiteNs) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






334




			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






335




			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






336




				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






337




338




339




		}
	}










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






340




	private void resumeEdges(M method, D factAtMethodStartPoint) {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






341




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






342




343




		if(edges != null) {
			for(PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






344




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






345




346




					if(edges.remove(edge))  {
						logger.trace("RESUME-EDGE: {}", edge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






347




						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






348




349




350




351




352




					}
				}
			}
		}
	}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






353




354




355




356




	
	private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {
		Set<PathEdge<N, D>> edges = pausedEdges.get(method);
		if(edges != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






357




358




359




			if(edges.size() > 100)
				System.out.println("Paused edges for method "+method+": "+edges.size());
			









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






360




			for(final PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






361




				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






362




363




					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);
					









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






364




					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






365




366




367




					
					if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 
							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






368




369




370




						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();
							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






371




								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






372




								incomingEdge.getCallSite(), 









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






373




								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






374




								method,









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






375




								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






376




377




378




379




380




381




382




383




384




						}
						else {
							propagateConstrained(new CallConcretizationPathEdge<>(
									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 
									incomingEdge.getCallSite(), 
									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),
									method,
									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));
						}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






385




					}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






386




387




388




389




				}
			}
		}
	}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






390














FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






391




392




393




394




395




396




397




	/**
	 * Computes the call flow function for the given call-site abstraction
	 * @param callFlowFunction The call flow function to compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the callee's start node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






398




	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






399




			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






400




401




402




403




404




405




406




407




408




409




410




411




		return callFlowFunction.computeTargets(d2);
	}

	/**
	 * Computes the call-to-return flow function for the given call-site
	 * abstraction
	 * @param callToReturnFlowFunction The call-to-return flow function to
	 * compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






412




	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






413




			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






414




415




416




417




418




419




420




421




422




423




424




425




426




427




428




429




430




431




432




433




434




435




436




		return callToReturnFlowFunction.computeTargets(d2);
	}
	
	/**
	 * Lines 21-32 of the algorithm.
	 * 
	 * Stores callee-side summaries.
	 * Also, at the side of the caller, propagates intra-procedural flows to return sites
	 * using those newly computed summaries.
	 * 
	 * @param edge an edge whose target node resembles a method exits
	 */
	protected void processExit(PathEdge<N,D> edge) {
		final N n = edge.getTarget(); // an exit node; line 21...
		M methodThatNeedsSummary = icfg.getMethodOf(n);
		
		final D d1 = edge.factAtSource();
		final D d2 = edge.factAtTarget();
		
		//for each of the method's start points, determine incoming calls
		
		//line 21.1 of Naeem/Lhotak/Rodriguez
		//register end-summary









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






437




438




		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);
		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






439




			return; //FIXME: should never be reached?! -> assert ?









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






440




441




442




		
		//for each incoming call edge already processed
		//(see processCall(..))









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






443




444




445




446




447




448




		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {
			// line 22
			N callSite = incomingEdge.getCallSite();
			// for each return site
			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {
				// compute return-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






449




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






450




				









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






451




				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






452




453




454




					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);
					if(delta.isPresent()) {
						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






455




456




	
						// for each incoming-call value









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






457




						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






458




							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






459




460




461




462




							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());
							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






463




						}









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






464




					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






465




466




				}
			}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






467




468




		}
		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






469




470




471




472




		
		//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow
		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only
		//be propagated into callers that have an incoming edge for this condition









bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015






473




		if(followReturnsPastSeeds && d1 == zeroValue) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






474




475




476




			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
			for(N c: callers) {
				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






477




					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






478




					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






479




480




481




482




483




484




485




					for(ConstrainedFact<FieldRef, D> d5: targets) {
						
						Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());
						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);
					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






486




487




488




489




490




491




				}
			}
			//in cases where there are no callers, the return statement would normally not be processed at all;
			//this might be undesirable if the flow function has a side effect such as registering a taint;
			//instead we thus call the return flow function will a null caller
			if(callers.isEmpty()) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






492




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






493




494




495




496




497




				retFunction.computeTargets(d2);
			}
		}
	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






498




499




500




501




502




503




504




505




506




507




508




509




510




511




512




513




514




515




516




517




518




519




520




521




522




523




524




525




526




527




528




529




530




531




532




533




534




535




536




537




538




539




540




541




542




543




544




545




546




547




548




549




550




551




552




553




554




555




556




557




558




559




560




561




562




563




564




565




566




567




568




569




570




571




572




573




574




575




576




577




578




579




580




581




582




583




584




585




586




587




588




589




590




591




592




593




594




595




596




597




598




599




600




601




602




603




604




605




606




607




608




609




610




611




612




613




614




615




616




617




618




619




620




621




622




623




624




625




626




627




628




629




630




631




632




633




634




635




636




637




638




639




640




641




642




643




644




645




646




647




648




649




650




651




652




653




654




655




656




657




658




659




660




661




662




663




664




665




666




667




668




669




670




671




672




673




674




675




676




677




678




679




680




681




682




683




684




685




686




687




688




689




690




691




692




693




694




695




696




697




698




699




700




701




702




703




704




705




706




707




708




709




710




711




712




713




714




715




716




717




718




719




720




721




722




723




724




725




726




727




728




729




730




731




732




733




734




735




736




737




738




739




740




741




742




743




744




745




746




747




748




749




750




751




752




753




754




755




756




757




758




759




760




761




762




763




764




765




766




767




768




769




770




771




772




773




774




775




776




777




778




779




780




781




782




783




784




785




786




787




788




789




790




791




	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();
	
	private Resolver getResolver(D sourceFact, D targetFact, N stmt) {
		HashKey key = new HashKey(sourceFact, targetFact, stmt);
		if(!returnSiteIncomingEdges.containsKey(key))
			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));
		return returnSiteIncomingEdges.get(key);
	}
	
	private class PausedReturnSiteEdge {

		private Constraint<FieldRef> constraint;
		private PathEdge<N, D> pathEdge;
		private AccessPath<FieldRef> alreadyResolvedAccPath;
		private D concretizedStmtFact;

		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {
			this.constraint = constraint;
			this.pathEdge = pathEdge;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
			this.concretizedStmtFact = concretizedStmtFact;
		}
	}
	
	class Resolver {

		private D sourceFact;
		private N stmt;
		private Set<IncomingFact> incomingFacts = Sets.newHashSet();
		private D targetFact;
		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();

		public Resolver(D sourceFact, D targetFact, N stmt) {
			this.sourceFact = sourceFact;
			this.targetFact = targetFact;
			this.stmt = stmt;
		}

		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {
				if(!fact.getAccessPath().hasResolver())
					throw new AssertionError();
				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))
					throw new AssertionError();
			}
			
			logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);
			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);
			incomingFacts.add(incFact);
			
			for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {
				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {
					propagate(edge.pathEdge, null, false);
					paused.remove(edge);
				}
			}
		}

		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {
			if(!visited.resolver.add(this))
				return false;
			
			alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);
			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);
			
			logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());
			
			boolean resolved = false;
			for(final IncomingFact incFact : incomingFacts) {
				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);
				if(resolved)
					break;
			}
			if(resolved) {
				propagate(pathEdge, null, false);
			} else {
				logger.trace("Pause {} at {}", pathEdge, stmt);
				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));
			}
			return resolved;
		}

		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,
				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {
			
			
			logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);
			
			if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {
				logger.trace("Resolved by incoming fact {}", incFact.fact);
				return true;
			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
				if(incFact.fact.getAccessPath().hasResolver()) {
					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();
					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);
					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(
								incFact.summaryEdge.getSourceFact(), 
								incFact.summaryEdge.getTargetStmt(), 
								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {

									@Override
									public void _propagate(D dSource, N target, D dTarget) {
										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);
									}
						}, decoratingResolver.alreadyResolvedAccPath, visited);
						if(resolved) {
							propagate(pathEdge, null, false);
							return true;
						}
					}
				}
				else {
					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));
					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {
						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);
						return true;
					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
						if(factWithDelta.getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();
							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
							
							final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);
							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);
								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));
								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {
									@Override
									protected void _propagate(D dSource, N target, D dTarget) {
										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);
									}
								};
								
								boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);
								if(resolved) {
									return true;
								}
							}
						}
						else {
							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));
							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);
							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(
									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 
									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {
										@Override
										protected void _propagate(D dSource, N target, D dTarget) {
											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);
										}
									}, visited);
							if(resolved)
								return true;
						}
					}
				}
			}
			return false;
		}
		
		@Override
		public String toString() {
			return stmt.toString();
		}
	}

	private class Visited {
		Set<Resolver> resolver = Sets.newHashSet();
		Map<N, Boolean> visitedCallSites = Maps.newHashMap();
	}
	
	class DecoratingResolver implements SubPathResolver<FieldRef> {
		
		private Resolver resolver;
		private AccessPath<FieldRef> alreadyResolvedAccPath;

		public DecoratingResolver(Resolver resolver) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();
		}
		
		public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
		}
		
		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {
			return resolve(constraint, pathEdge, new Visited());
		}

		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {
			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());
			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			DecoratingResolver other = (DecoratingResolver) obj;
			if (alreadyResolvedAccPath == null) {
				if (other.alreadyResolvedAccPath != null)
					return false;
			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))
				return false;
			if (resolver == null) {
				if (other.resolver != null)
					return false;
			} else if (!resolver.equals(other.resolver))
				return false;
			return true;
		}
		
		@Override
		public String toString() {
			return alreadyResolvedAccPath+ ":"+resolver.toString();
		}

		@Override
		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {
			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));
		}
	}
	
	private class IncomingFact {

		private D fact;
		private Delta<FieldRef> delta;
		private SummaryEdge<D, N> summaryEdge;

		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			this.summaryEdge = summaryEdge;
			this.fact = fact;
			this.delta = delta;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((delta == null) ? 0 : delta.hashCode());
			result = prime * result + ((fact == null) ? 0 : fact.hashCode());
			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			IncomingFact other = (IncomingFact) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (delta == null) {
				if (other.delta != null)
					return false;
			} else if (!delta.equals(other.delta))
				return false;
			if (fact == null) {
				if (other.fact != null)
					return false;
			} else if (!fact.equals(other.fact))
				return false;
			if (summaryEdge == null) {
				if (other.summaryEdge != null)
					return false;
			} else if (!summaryEdge.equals(other.summaryEdge))
				return false;
			return true;
		}

		private FieldSensitiveIFDSSolver getOuterType() {
			return FieldSensitiveIFDSSolver.this;
		}
		
	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






792




793




794




795




796




797




798




799




	/**
	 * Computes the return flow function for the given set of caller-side
	 * abstractions.
	 * @param retFunction The return flow function to compute
	 * @param d2 The abstraction at the exit node in the callee
	 * @param callSite The call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






800




	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






801




			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






802




803




804




805




806




807




808




809




		return retFunction.computeTargets(d2);
	}

	/**
	 * Lines 33-37 of the algorithm.
	 * Simply propagate normal, intra-procedural flows.
	 * @param edge
	 */









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






810




	@SuppressWarnings("unchecked")









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






811




812




813




814




815




816




	private void processNormalFlow(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); 
		final D d2 = edge.factAtTarget();
		
		for (N m : icfg.getSuccsOf(n)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






817




			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






818




819




			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);
			for (ConstrainedFact<FieldRef, D> d3 : res) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






820




				if(d3.getConstraint() != null) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






821




822




823




824




825




					if(d3.getFact().getAccessPath().hasResolver()) {
						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());
						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));
					} else
						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






826




				}









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






827




				else









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






828




					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






829




830




831




832




			}
		}
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






833




	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






834




835




836




		if(fact.equals(zeroValue))
			return zeroValue;
		else









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






837




			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






838




	}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






839




	









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






840




	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






841




		return propagateConstrained(pathEdge, new Visited());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






842




843




	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






844




	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






845




		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






846




		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






847














cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






848




849




850




		boolean propagate = false;
		if(pathEdge.factAtSource().equals(zeroValue))
			propagate = true;









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






851




852




		else if(hasPausedEdges(calleeMethod, pathEdge))
			propagate = false;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






853




854




		else {
			Set<N> callSitesWithInterest = Sets.newHashSet();









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






855




			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






856




				callSitesWithInterest.add(incEdge.getCallSite());









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






857




			}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






858




859




			propagate = !callSitesWithInterest.isEmpty();
			









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






860




861




862




863




864




865




866




			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());
			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);
			
			for(IncomingEdge<D, N> incEdge : candidates) { //potential
				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {
					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)
						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






867




868




				}
				else {









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






869




					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






870




871




872




873




874




875




876




877




878




879




880




881




882




883




884




885




886




887




888




889




890




891




892




893




894




895




896




897




898




899




900




901




902




903




						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();
								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);
								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(
										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));
								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 
										calleeMethod,
										calleeSourceFact), visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}
						}
						else {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
					
								PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),
										calleeMethod,
										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));
								visited.visitedCallSites.put(incEdge.getCallSite(), null);
								boolean result = propagateConstrained(callerEdge, visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






904




						}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






905




					}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






906




				}









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






907




			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






908




		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






909




		









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






910




		if(propagate) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






911




			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






912




913




914




915




916




917




			return true;
		} else {
			pauseEdge(pathEdge);
			return false;
		}
	}









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






918














abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






919




920




921




922




923




924




925




926




927




928




929




930




931




932




933




	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {
		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();
		for(IncomingEdge<D, N> incEdge : candidates) {
			if(result.containsKey(incEdge.getCallSite())) {
				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());
				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {
					result.put(incEdge.getCallSite(), incEdge);
				}
			}
			else
				result.put(incEdge.getCallSite(), incEdge);
		}
		return result.values();
	}










Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






934




935




936




937




	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {
		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);
		if(pe != null) {
			for(PathEdge<N, D> edge : pe) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






938




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






939




940




941




942




943




944




					return true;
			}
		}
		return false;
	}










cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






945




946




	private void pauseEdge(PathEdge<N,D> edge) {
		M method = icfg.getMethodOf(edge.getTarget());









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






947




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






948




949




950




		if(edges.add(edge)) {
			logger.trace("PAUSED: {}: {}", method, edge);
		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






951




952




	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






953




954




955




956




957




958




959




960




	/**
	 * Computes the normal flow function for the given set of start and end
	 * abstractions.
	 * @param flowFunction The normal flow function to compute
	 * @param d1 The abstraction at the method's start node
	 * @param d1 The abstraction at the current node
	 * @return The set of abstractions at the successor node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






961




	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






962




			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






963




964




965




966




967




968




969




970




971




972




973




974




975




976




977




978




979




980




981




982




		return flowFunction.computeTargets(d2);
	}
	
	/**
	 * This method will be called for each incoming edge and can be used to
	 * transfer knowledge from the calling edge to the returning edge, without
	 * affecting the summary edges at the callee.
	 * 
	 * @param d4
	 *            Fact stored with the incoming edge, i.e., present at the
	 *            caller side
	 * @param d5
	 *            Fact that originally should be propagated to the caller.
	 * @return Fact that will be propagated to the caller.
	 */
	protected D restoreContextOnReturnedFact(D d4, D d5) {
		d5.setCallingContext(d4);
		return d5;
	}
	









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






983




984




985




986




	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,
			/* deliberately exposed to clients */ N relatedCallSite) {
		propagate(edge, relatedCallSite, true);
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






987




	









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






988




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






989




990




991




992




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();
	private int cacheHits = 0;
	private int cacheMerges = 0;
	private int cacheOppositePrefix = 0;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






993




994




995




	private int cacheSourceBaseValue = 0;
	private int concretizationEdges = 0;
	private int cacheEquals = 0;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






996




997




	/**
	 * Propagates the flow further down the exploded super graph. 









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






998




	 * @param edge the PathEdge that should be propagated









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






999




1000




	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 






For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next










Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c







Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c




Open sidebar

Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Joshua Garciaherosheros
55cdd2d88cc7d78204a4508a1dd46234cb52b74c










55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1




/*******************************************************************************









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






2




 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






3




4




5




6




7




8




 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






9




 *     Johannes Lerch, Johannes Späth - initial API and implementation









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






10




11




12




 ******************************************************************************/
package heros.alias;










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






13




14




15




16




import heros.DontSynchronize;
import heros.FlowFunctionCache;
import heros.InterproceduralCFG;
import heros.SynchronizedBy;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






17




import heros.alias.AccessPath.Delta;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






18




import heros.alias.AccessPath.PrefixTestResult;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






19




import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






20




import heros.alias.FlowFunction.ConstrainedFact;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






21




import heros.alias.FlowFunction.Constraint;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






22




23




import heros.solver.CountingThreadPoolExecutor;
import heros.solver.IFDSSolver;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






24




import heros.solver.Pair;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






25




26




import heros.solver.PathEdge;










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






27




28




29




30




31




32




import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






33




34




import java.util.Collection;
import java.util.Collections;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






35




36




import java.util.Comparator;
import java.util.Enumeration;









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






37




import java.util.HashMap;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






38




import java.util.Iterator;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






39




import java.util.LinkedList;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






40




import java.util.List;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






41




42




import java.util.Map;
import java.util.Map.Entry;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






43




import java.util.PriorityQueue;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






44




import java.util.Set;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






45




46




47




48




49




50




import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;










handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






51




import com.google.common.base.Optional;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






52




import com.google.common.base.Predicate;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






53




import com.google.common.cache.CacheBuilder;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






54




import com.google.common.collect.HashMultimap;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






55




import com.google.common.collect.Iterators;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






56




import com.google.common.collect.Lists;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






57




import com.google.common.collect.Maps;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






58




import com.google.common.collect.Sets;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






59




import com.sun.org.apache.xpath.internal.axes.IteratorPool;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






60














merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






61




public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85






	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel
			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
	
    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);

    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
    public static final boolean DEBUG = logger.isDebugEnabled();

	protected CountingThreadPoolExecutor executor;
	
	@DontSynchronize("only used by single thread")
	protected int numThreads;
	
	@SynchronizedBy("thread safe data structure, consistent locking when used")
	protected final JumpFunctions<N,D> jumpFn;
	
	@SynchronizedBy("thread safe data structure, only modified internally")
	protected final I icfg;
	
	//stores summaries that were queried before they were computed
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on 'incoming'")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






86




87




	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =
			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






88




89




90




91




	
	//edges going along calls
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on field")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






92




93




	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =
			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






94




	









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






95




	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






96




	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






97




	@DontSynchronize("stateless")









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






98




	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




	
	@DontSynchronize("only used by single thread")
	protected final Map<N,Set<D>> initialSeeds;
	
	@DontSynchronize("benign races")
	public long propagationCount;
	
	@DontSynchronize("stateless")
	protected final D zeroValue;
	
	@DontSynchronize("readOnly")
	protected final FlowFunctionCache<N,D,M> ffCache = null; 
	
	@DontSynchronize("readOnly")
	protected final boolean followReturnsPastSeeds;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






114














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






115




	private LinkedList<PathEdgeProcessingTask> worklist;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






116




117




118




119




120




121




	
	
	/**
	 * Creates a solver for the given problem, which caches flow functions and edge functions.
	 * The solver must then be started by calling {@link #solve()}.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






122




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






123




124




125




126




127




128




129




130




131




		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
	}

	/**
	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling
	 * {@link #solve()}.
	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.
	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






132




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






133




134




135




136




137




138




		if(logger.isDebugEnabled())
			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
		this.zeroValue = tabulationProblem.zeroValue();
		this.icfg = tabulationProblem.interproceduralCFG();		
	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?
				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






139




		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






140




141




142




143




144




145




146




147




148




149




		/*if(flowFunctionCacheBuilder!=null) {
			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);
			flowFunctions = ffCache;
		} else {
			ffCache = null;
		}*/
		this.flowFunctions = flowFunctions;
		this.initialSeeds = tabulationProblem.initialSeeds();
		this.jumpFn = new JumpFunctions<N,D>();
		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






150




		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






151




		this.executor = getExecutor();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






152




		this.worklist = Lists.newLinkedList();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






153




154




155




156




157




158




159




160




	}

	/**
	 * Runs the solver on the configured problem. This can take some time.
	 */
	public void solve() {		
		submitInitialSeeds();
		awaitCompletionComputeValuesAndShutdown();









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






161




		writeDebugFile();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






162




163




164




165




166




167




168




169




170




171




172




	}

	/**
	 * Schedules the processing of initial seeds, initiating the analysis.
	 * Clients should only call this methods if performing synchronization on
	 * their own. Normally, {@link #solve()} should be called instead.
	 */
	protected void submitInitialSeeds() {
		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {
			N startPoint = seed.getKey();
			for(D val: seed.getValue())









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






173




				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






174




175




176




177




178




179




180




181




182




			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
		}
	}

	/**
	 * Awaits the completion of the exploded super graph. When complete, computes result values,
	 * shuts down the executor and returns.
	 */
	protected void awaitCompletionComputeValuesAndShutdown() {









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






183




184




185




186




//		{
//			//run executor and await termination of tasks
//			runExecutorAndAwaitCompletion();
//		}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






187




188




189




190




191




192




		if(logger.isDebugEnabled())
			printStats();

		//ask executor to shut down;
		//this will cause new submissions to the executor to be rejected,
		//but at this point all tasks should have completed anyway









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






193




//		executor.shutdown();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






194




195




196




197




198




		//similarly here: we await termination, but this should happen instantaneously,
		//as all tasks should have completed
		runExecutorAndAwaitCompletion();
	}










field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






199




200




201




202




	protected boolean hasWork() {
		return !worklist.isEmpty();
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






203




204




	private int jobCounter = 0;
	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






205




206




207




208




	/**
	 * Runs execution, re-throwing exceptions that might be thrown during its execution.
	 */
	private void runExecutorAndAwaitCompletion() {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






209




210




211




212




213




214




215




216




217




218




//		try {
//			executor.awaitCompletion();
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//		Throwable exception = executor.getException();
//		if(exception!=null) {
//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);
//		}
		while(!worklist.isEmpty()) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






219




220




//			if(jobCounter % 100_000 == 0)
			









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






221




			PathEdgeProcessingTask current = worklist.removeLast();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






222




223




224




225




226




227




228




229




230




231




232




			int size = worklist.size();
			current.run();
			jobCounter++;
			M method = icfg.getMethodOf(current.edge.getTarget());
//			edgesPerMethod.put(method, current.edge);
//			if(edgesPerMethod.get(method).size() > 10_000) {
//				System.out.println(method);
//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {
//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));
//				}
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






233




			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






234




235




236




				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));
			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






237




238




//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






239




240




241




242




243




244




245




246




247




248




		}
	}

    /**
     * Dispatch the processing of a given edge. It may be executed in a different thread.
     * @param edge the edge to process
     */
    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){
    	// If the executor has been killed, there is little point
    	// in submitting new tasks









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






249




250




251




252




//    	if (executor.isTerminating())
//    		return;
//    	executor.execute(new PathEdgeProcessingTask(edge));
    	worklist.add(new PathEdgeProcessingTask(edge));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






253




254




255




256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




    	propagationCount++;
    }
	
	/**
	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
	 * 
	 * For each possible callee, registers incoming call edges.
	 * Also propagates call-to-return flows and summarized callee flows within the caller. 
	 * 
	 * @param edge an edge whose target node resembles a method call
	 */
	private void processCall(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); // a call node; line 14...

        logger.trace("Processing call to {}", n);

		final D d2 = edge.factAtTarget();
		assert d2 != null;
		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
		
		//for each possible callee
		Collection<M> callees = icfg.getCalleesOfCallAt(n);
		for(M sCalledProcN: callees) { //still line 14
			//compute the call-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






278




			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






279




			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






280




281




282




			
			Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
			//for each result node of the call-flow function









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






283




			for(ConstrainedFact<FieldRef, D> d3: res) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






284




285




286




				//for each callee's start point(s)
				for(N sP: startPointsOf) {
					//create initial self-loop









avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015






287




					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






288




					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






289




290




291




292




				}
				
				//register the fact that <sp,d3> has an incoming edge from <n,d2>
				//line 15.1 of Naeem/Lhotak/Rodriguez









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






293




294




				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);
				if (!addIncoming(sCalledProcN, incomingEdge))









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






295




296




					continue;
				









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






297




				resumeEdges(sCalledProcN, d3.getFact());









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






298




299




				registerInterestedCaller(sCalledProcN, incomingEdge);
				









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






300




301




				
				//line 15.2









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






302




				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






303




304




305




306




307




308




					
				//still line 15.2 of Naeem/Lhotak/Rodriguez
				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,
				//create new caller-side jump functions to the return sites
				//because we have observed a potentially new incoming edge into <sP,d3>
				if (endSumm != null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






309




					for(SummaryEdge<D, N> summary: endSumm) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






310




311




						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);
						if(delta.isPresent()) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






312




313




314




315




316




							//for each return site
							for(N retSiteN: returnSiteNs) {
								//compute return-flow function
								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);
								//for each target value of the function









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






317




								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






318




									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






319




320




321




322




323




324




									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);
									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());
									
									AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);
									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






325




326




								}
							}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






327




						}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






328




329




330




331




332




333




					}
			}
		}
		//line 17-19 of Naeem/Lhotak/Rodriguez		
		//process intra-procedural flows along call-to-return flow functions
		for (N returnSiteN : returnSiteNs) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






334




			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






335




			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






336




				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






337




338




339




		}
	}










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






340




	private void resumeEdges(M method, D factAtMethodStartPoint) {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






341




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






342




343




		if(edges != null) {
			for(PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






344




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






345




346




					if(edges.remove(edge))  {
						logger.trace("RESUME-EDGE: {}", edge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






347




						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






348




349




350




351




352




					}
				}
			}
		}
	}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






353




354




355




356




	
	private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {
		Set<PathEdge<N, D>> edges = pausedEdges.get(method);
		if(edges != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






357




358




359




			if(edges.size() > 100)
				System.out.println("Paused edges for method "+method+": "+edges.size());
			









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






360




			for(final PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






361




				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






362




363




					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);
					









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






364




					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






365




366




367




					
					if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 
							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






368




369




370




						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();
							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






371




								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






372




								incomingEdge.getCallSite(), 









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






373




								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






374




								method,









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






375




								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






376




377




378




379




380




381




382




383




384




						}
						else {
							propagateConstrained(new CallConcretizationPathEdge<>(
									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 
									incomingEdge.getCallSite(), 
									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),
									method,
									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));
						}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






385




					}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






386




387




388




389




				}
			}
		}
	}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






390














FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






391




392




393




394




395




396




397




	/**
	 * Computes the call flow function for the given call-site abstraction
	 * @param callFlowFunction The call flow function to compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the callee's start node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






398




	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






399




			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






400




401




402




403




404




405




406




407




408




409




410




411




		return callFlowFunction.computeTargets(d2);
	}

	/**
	 * Computes the call-to-return flow function for the given call-site
	 * abstraction
	 * @param callToReturnFlowFunction The call-to-return flow function to
	 * compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






412




	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






413




			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






414




415




416




417




418




419




420




421




422




423




424




425




426




427




428




429




430




431




432




433




434




435




436




		return callToReturnFlowFunction.computeTargets(d2);
	}
	
	/**
	 * Lines 21-32 of the algorithm.
	 * 
	 * Stores callee-side summaries.
	 * Also, at the side of the caller, propagates intra-procedural flows to return sites
	 * using those newly computed summaries.
	 * 
	 * @param edge an edge whose target node resembles a method exits
	 */
	protected void processExit(PathEdge<N,D> edge) {
		final N n = edge.getTarget(); // an exit node; line 21...
		M methodThatNeedsSummary = icfg.getMethodOf(n);
		
		final D d1 = edge.factAtSource();
		final D d2 = edge.factAtTarget();
		
		//for each of the method's start points, determine incoming calls
		
		//line 21.1 of Naeem/Lhotak/Rodriguez
		//register end-summary









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






437




438




		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);
		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






439




			return; //FIXME: should never be reached?! -> assert ?









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






440




441




442




		
		//for each incoming call edge already processed
		//(see processCall(..))









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






443




444




445




446




447




448




		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {
			// line 22
			N callSite = incomingEdge.getCallSite();
			// for each return site
			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {
				// compute return-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






449




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






450




				









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






451




				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






452




453




454




					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);
					if(delta.isPresent()) {
						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






455




456




	
						// for each incoming-call value









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






457




						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






458




							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






459




460




461




462




							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());
							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






463




						}









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






464




					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






465




466




				}
			}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






467




468




		}
		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






469




470




471




472




		
		//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow
		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only
		//be propagated into callers that have an incoming edge for this condition









bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015






473




		if(followReturnsPastSeeds && d1 == zeroValue) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






474




475




476




			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
			for(N c: callers) {
				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






477




					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






478




					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






479




480




481




482




483




484




485




					for(ConstrainedFact<FieldRef, D> d5: targets) {
						
						Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());
						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);
					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






486




487




488




489




490




491




				}
			}
			//in cases where there are no callers, the return statement would normally not be processed at all;
			//this might be undesirable if the flow function has a side effect such as registering a taint;
			//instead we thus call the return flow function will a null caller
			if(callers.isEmpty()) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






492




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






493




494




495




496




497




				retFunction.computeTargets(d2);
			}
		}
	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






498




499




500




501




502




503




504




505




506




507




508




509




510




511




512




513




514




515




516




517




518




519




520




521




522




523




524




525




526




527




528




529




530




531




532




533




534




535




536




537




538




539




540




541




542




543




544




545




546




547




548




549




550




551




552




553




554




555




556




557




558




559




560




561




562




563




564




565




566




567




568




569




570




571




572




573




574




575




576




577




578




579




580




581




582




583




584




585




586




587




588




589




590




591




592




593




594




595




596




597




598




599




600




601




602




603




604




605




606




607




608




609




610




611




612




613




614




615




616




617




618




619




620




621




622




623




624




625




626




627




628




629




630




631




632




633




634




635




636




637




638




639




640




641




642




643




644




645




646




647




648




649




650




651




652




653




654




655




656




657




658




659




660




661




662




663




664




665




666




667




668




669




670




671




672




673




674




675




676




677




678




679




680




681




682




683




684




685




686




687




688




689




690




691




692




693




694




695




696




697




698




699




700




701




702




703




704




705




706




707




708




709




710




711




712




713




714




715




716




717




718




719




720




721




722




723




724




725




726




727




728




729




730




731




732




733




734




735




736




737




738




739




740




741




742




743




744




745




746




747




748




749




750




751




752




753




754




755




756




757




758




759




760




761




762




763




764




765




766




767




768




769




770




771




772




773




774




775




776




777




778




779




780




781




782




783




784




785




786




787




788




789




790




791




	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();
	
	private Resolver getResolver(D sourceFact, D targetFact, N stmt) {
		HashKey key = new HashKey(sourceFact, targetFact, stmt);
		if(!returnSiteIncomingEdges.containsKey(key))
			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));
		return returnSiteIncomingEdges.get(key);
	}
	
	private class PausedReturnSiteEdge {

		private Constraint<FieldRef> constraint;
		private PathEdge<N, D> pathEdge;
		private AccessPath<FieldRef> alreadyResolvedAccPath;
		private D concretizedStmtFact;

		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {
			this.constraint = constraint;
			this.pathEdge = pathEdge;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
			this.concretizedStmtFact = concretizedStmtFact;
		}
	}
	
	class Resolver {

		private D sourceFact;
		private N stmt;
		private Set<IncomingFact> incomingFacts = Sets.newHashSet();
		private D targetFact;
		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();

		public Resolver(D sourceFact, D targetFact, N stmt) {
			this.sourceFact = sourceFact;
			this.targetFact = targetFact;
			this.stmt = stmt;
		}

		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {
				if(!fact.getAccessPath().hasResolver())
					throw new AssertionError();
				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))
					throw new AssertionError();
			}
			
			logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);
			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);
			incomingFacts.add(incFact);
			
			for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {
				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {
					propagate(edge.pathEdge, null, false);
					paused.remove(edge);
				}
			}
		}

		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {
			if(!visited.resolver.add(this))
				return false;
			
			alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);
			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);
			
			logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());
			
			boolean resolved = false;
			for(final IncomingFact incFact : incomingFacts) {
				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);
				if(resolved)
					break;
			}
			if(resolved) {
				propagate(pathEdge, null, false);
			} else {
				logger.trace("Pause {} at {}", pathEdge, stmt);
				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));
			}
			return resolved;
		}

		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,
				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {
			
			
			logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);
			
			if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {
				logger.trace("Resolved by incoming fact {}", incFact.fact);
				return true;
			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
				if(incFact.fact.getAccessPath().hasResolver()) {
					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();
					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);
					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(
								incFact.summaryEdge.getSourceFact(), 
								incFact.summaryEdge.getTargetStmt(), 
								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {

									@Override
									public void _propagate(D dSource, N target, D dTarget) {
										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);
									}
						}, decoratingResolver.alreadyResolvedAccPath, visited);
						if(resolved) {
							propagate(pathEdge, null, false);
							return true;
						}
					}
				}
				else {
					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));
					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {
						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);
						return true;
					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
						if(factWithDelta.getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();
							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
							
							final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);
							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);
								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));
								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {
									@Override
									protected void _propagate(D dSource, N target, D dTarget) {
										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);
									}
								};
								
								boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);
								if(resolved) {
									return true;
								}
							}
						}
						else {
							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));
							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);
							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(
									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 
									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {
										@Override
										protected void _propagate(D dSource, N target, D dTarget) {
											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);
										}
									}, visited);
							if(resolved)
								return true;
						}
					}
				}
			}
			return false;
		}
		
		@Override
		public String toString() {
			return stmt.toString();
		}
	}

	private class Visited {
		Set<Resolver> resolver = Sets.newHashSet();
		Map<N, Boolean> visitedCallSites = Maps.newHashMap();
	}
	
	class DecoratingResolver implements SubPathResolver<FieldRef> {
		
		private Resolver resolver;
		private AccessPath<FieldRef> alreadyResolvedAccPath;

		public DecoratingResolver(Resolver resolver) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();
		}
		
		public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
		}
		
		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {
			return resolve(constraint, pathEdge, new Visited());
		}

		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {
			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());
			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			DecoratingResolver other = (DecoratingResolver) obj;
			if (alreadyResolvedAccPath == null) {
				if (other.alreadyResolvedAccPath != null)
					return false;
			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))
				return false;
			if (resolver == null) {
				if (other.resolver != null)
					return false;
			} else if (!resolver.equals(other.resolver))
				return false;
			return true;
		}
		
		@Override
		public String toString() {
			return alreadyResolvedAccPath+ ":"+resolver.toString();
		}

		@Override
		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {
			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));
		}
	}
	
	private class IncomingFact {

		private D fact;
		private Delta<FieldRef> delta;
		private SummaryEdge<D, N> summaryEdge;

		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			this.summaryEdge = summaryEdge;
			this.fact = fact;
			this.delta = delta;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((delta == null) ? 0 : delta.hashCode());
			result = prime * result + ((fact == null) ? 0 : fact.hashCode());
			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			IncomingFact other = (IncomingFact) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (delta == null) {
				if (other.delta != null)
					return false;
			} else if (!delta.equals(other.delta))
				return false;
			if (fact == null) {
				if (other.fact != null)
					return false;
			} else if (!fact.equals(other.fact))
				return false;
			if (summaryEdge == null) {
				if (other.summaryEdge != null)
					return false;
			} else if (!summaryEdge.equals(other.summaryEdge))
				return false;
			return true;
		}

		private FieldSensitiveIFDSSolver getOuterType() {
			return FieldSensitiveIFDSSolver.this;
		}
		
	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






792




793




794




795




796




797




798




799




	/**
	 * Computes the return flow function for the given set of caller-side
	 * abstractions.
	 * @param retFunction The return flow function to compute
	 * @param d2 The abstraction at the exit node in the callee
	 * @param callSite The call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






800




	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






801




			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






802




803




804




805




806




807




808




809




		return retFunction.computeTargets(d2);
	}

	/**
	 * Lines 33-37 of the algorithm.
	 * Simply propagate normal, intra-procedural flows.
	 * @param edge
	 */









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






810




	@SuppressWarnings("unchecked")









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






811




812




813




814




815




816




	private void processNormalFlow(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); 
		final D d2 = edge.factAtTarget();
		
		for (N m : icfg.getSuccsOf(n)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






817




			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






818




819




			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);
			for (ConstrainedFact<FieldRef, D> d3 : res) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






820




				if(d3.getConstraint() != null) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






821




822




823




824




825




					if(d3.getFact().getAccessPath().hasResolver()) {
						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());
						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));
					} else
						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






826




				}









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






827




				else









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






828




					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






829




830




831




832




			}
		}
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






833




	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






834




835




836




		if(fact.equals(zeroValue))
			return zeroValue;
		else









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






837




			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






838




	}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






839




	









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






840




	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






841




		return propagateConstrained(pathEdge, new Visited());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






842




843




	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






844




	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






845




		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






846




		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






847














cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






848




849




850




		boolean propagate = false;
		if(pathEdge.factAtSource().equals(zeroValue))
			propagate = true;









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






851




852




		else if(hasPausedEdges(calleeMethod, pathEdge))
			propagate = false;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






853




854




		else {
			Set<N> callSitesWithInterest = Sets.newHashSet();









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






855




			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






856




				callSitesWithInterest.add(incEdge.getCallSite());









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






857




			}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






858




859




			propagate = !callSitesWithInterest.isEmpty();
			









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






860




861




862




863




864




865




866




			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());
			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);
			
			for(IncomingEdge<D, N> incEdge : candidates) { //potential
				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {
					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)
						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






867




868




				}
				else {









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






869




					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






870




871




872




873




874




875




876




877




878




879




880




881




882




883




884




885




886




887




888




889




890




891




892




893




894




895




896




897




898




899




900




901




902




903




						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();
								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);
								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(
										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));
								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 
										calleeMethod,
										calleeSourceFact), visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}
						}
						else {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
					
								PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),
										calleeMethod,
										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));
								visited.visitedCallSites.put(incEdge.getCallSite(), null);
								boolean result = propagateConstrained(callerEdge, visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






904




						}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






905




					}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






906




				}









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






907




			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






908




		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






909




		









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






910




		if(propagate) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






911




			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






912




913




914




915




916




917




			return true;
		} else {
			pauseEdge(pathEdge);
			return false;
		}
	}









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






918














abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






919




920




921




922




923




924




925




926




927




928




929




930




931




932




933




	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {
		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();
		for(IncomingEdge<D, N> incEdge : candidates) {
			if(result.containsKey(incEdge.getCallSite())) {
				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());
				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {
					result.put(incEdge.getCallSite(), incEdge);
				}
			}
			else
				result.put(incEdge.getCallSite(), incEdge);
		}
		return result.values();
	}










Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






934




935




936




937




	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {
		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);
		if(pe != null) {
			for(PathEdge<N, D> edge : pe) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






938




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






939




940




941




942




943




944




					return true;
			}
		}
		return false;
	}










cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






945




946




	private void pauseEdge(PathEdge<N,D> edge) {
		M method = icfg.getMethodOf(edge.getTarget());









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






947




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






948




949




950




		if(edges.add(edge)) {
			logger.trace("PAUSED: {}: {}", method, edge);
		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






951




952




	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






953




954




955




956




957




958




959




960




	/**
	 * Computes the normal flow function for the given set of start and end
	 * abstractions.
	 * @param flowFunction The normal flow function to compute
	 * @param d1 The abstraction at the method's start node
	 * @param d1 The abstraction at the current node
	 * @return The set of abstractions at the successor node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






961




	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






962




			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






963




964




965




966




967




968




969




970




971




972




973




974




975




976




977




978




979




980




981




982




		return flowFunction.computeTargets(d2);
	}
	
	/**
	 * This method will be called for each incoming edge and can be used to
	 * transfer knowledge from the calling edge to the returning edge, without
	 * affecting the summary edges at the callee.
	 * 
	 * @param d4
	 *            Fact stored with the incoming edge, i.e., present at the
	 *            caller side
	 * @param d5
	 *            Fact that originally should be propagated to the caller.
	 * @return Fact that will be propagated to the caller.
	 */
	protected D restoreContextOnReturnedFact(D d4, D d5) {
		d5.setCallingContext(d4);
		return d5;
	}
	









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






983




984




985




986




	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,
			/* deliberately exposed to clients */ N relatedCallSite) {
		propagate(edge, relatedCallSite, true);
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






987




	









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






988




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






989




990




991




992




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();
	private int cacheHits = 0;
	private int cacheMerges = 0;
	private int cacheOppositePrefix = 0;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






993




994




995




	private int cacheSourceBaseValue = 0;
	private int concretizationEdges = 0;
	private int cacheEquals = 0;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






996




997




	/**
	 * Propagates the flow further down the exploded super graph. 









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






998




	 * @param edge the PathEdge that should be propagated









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






999




1000




	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 






For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next













55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1




/*******************************************************************************









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






2




 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






3




4




5




6




7




8




 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






9




 *     Johannes Lerch, Johannes Späth - initial API and implementation









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






10




11




12




 ******************************************************************************/
package heros.alias;










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






13




14




15




16




import heros.DontSynchronize;
import heros.FlowFunctionCache;
import heros.InterproceduralCFG;
import heros.SynchronizedBy;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






17




import heros.alias.AccessPath.Delta;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






18




import heros.alias.AccessPath.PrefixTestResult;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






19




import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






20




import heros.alias.FlowFunction.ConstrainedFact;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






21




import heros.alias.FlowFunction.Constraint;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






22




23




import heros.solver.CountingThreadPoolExecutor;
import heros.solver.IFDSSolver;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






24




import heros.solver.Pair;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






25




26




import heros.solver.PathEdge;










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






27




28




29




30




31




32




import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






33




34




import java.util.Collection;
import java.util.Collections;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






35




36




import java.util.Comparator;
import java.util.Enumeration;









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






37




import java.util.HashMap;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






38




import java.util.Iterator;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






39




import java.util.LinkedList;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






40




import java.util.List;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






41




42




import java.util.Map;
import java.util.Map.Entry;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






43




import java.util.PriorityQueue;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






44




import java.util.Set;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






45




46




47




48




49




50




import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;










handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






51




import com.google.common.base.Optional;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






52




import com.google.common.base.Predicate;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






53




import com.google.common.cache.CacheBuilder;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






54




import com.google.common.collect.HashMultimap;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






55




import com.google.common.collect.Iterators;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






56




import com.google.common.collect.Lists;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






57




import com.google.common.collect.Maps;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






58




import com.google.common.collect.Sets;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






59




import com.sun.org.apache.xpath.internal.axes.IteratorPool;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






60














merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






61




public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85






	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel
			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
	
    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);

    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
    public static final boolean DEBUG = logger.isDebugEnabled();

	protected CountingThreadPoolExecutor executor;
	
	@DontSynchronize("only used by single thread")
	protected int numThreads;
	
	@SynchronizedBy("thread safe data structure, consistent locking when used")
	protected final JumpFunctions<N,D> jumpFn;
	
	@SynchronizedBy("thread safe data structure, only modified internally")
	protected final I icfg;
	
	//stores summaries that were queried before they were computed
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on 'incoming'")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






86




87




	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =
			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






88




89




90




91




	
	//edges going along calls
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on field")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






92




93




	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =
			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






94




	









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






95




	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






96




	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






97




	@DontSynchronize("stateless")









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






98




	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




	
	@DontSynchronize("only used by single thread")
	protected final Map<N,Set<D>> initialSeeds;
	
	@DontSynchronize("benign races")
	public long propagationCount;
	
	@DontSynchronize("stateless")
	protected final D zeroValue;
	
	@DontSynchronize("readOnly")
	protected final FlowFunctionCache<N,D,M> ffCache = null; 
	
	@DontSynchronize("readOnly")
	protected final boolean followReturnsPastSeeds;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






114














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






115




	private LinkedList<PathEdgeProcessingTask> worklist;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






116




117




118




119




120




121




	
	
	/**
	 * Creates a solver for the given problem, which caches flow functions and edge functions.
	 * The solver must then be started by calling {@link #solve()}.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






122




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






123




124




125




126




127




128




129




130




131




		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
	}

	/**
	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling
	 * {@link #solve()}.
	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.
	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






132




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






133




134




135




136




137




138




		if(logger.isDebugEnabled())
			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
		this.zeroValue = tabulationProblem.zeroValue();
		this.icfg = tabulationProblem.interproceduralCFG();		
	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?
				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






139




		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






140




141




142




143




144




145




146




147




148




149




		/*if(flowFunctionCacheBuilder!=null) {
			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);
			flowFunctions = ffCache;
		} else {
			ffCache = null;
		}*/
		this.flowFunctions = flowFunctions;
		this.initialSeeds = tabulationProblem.initialSeeds();
		this.jumpFn = new JumpFunctions<N,D>();
		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






150




		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






151




		this.executor = getExecutor();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






152




		this.worklist = Lists.newLinkedList();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






153




154




155




156




157




158




159




160




	}

	/**
	 * Runs the solver on the configured problem. This can take some time.
	 */
	public void solve() {		
		submitInitialSeeds();
		awaitCompletionComputeValuesAndShutdown();









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






161




		writeDebugFile();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






162




163




164




165




166




167




168




169




170




171




172




	}

	/**
	 * Schedules the processing of initial seeds, initiating the analysis.
	 * Clients should only call this methods if performing synchronization on
	 * their own. Normally, {@link #solve()} should be called instead.
	 */
	protected void submitInitialSeeds() {
		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {
			N startPoint = seed.getKey();
			for(D val: seed.getValue())









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






173




				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






174




175




176




177




178




179




180




181




182




			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
		}
	}

	/**
	 * Awaits the completion of the exploded super graph. When complete, computes result values,
	 * shuts down the executor and returns.
	 */
	protected void awaitCompletionComputeValuesAndShutdown() {









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






183




184




185




186




//		{
//			//run executor and await termination of tasks
//			runExecutorAndAwaitCompletion();
//		}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






187




188




189




190




191




192




		if(logger.isDebugEnabled())
			printStats();

		//ask executor to shut down;
		//this will cause new submissions to the executor to be rejected,
		//but at this point all tasks should have completed anyway









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






193




//		executor.shutdown();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






194




195




196




197




198




		//similarly here: we await termination, but this should happen instantaneously,
		//as all tasks should have completed
		runExecutorAndAwaitCompletion();
	}










field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






199




200




201




202




	protected boolean hasWork() {
		return !worklist.isEmpty();
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






203




204




	private int jobCounter = 0;
	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






205




206




207




208




	/**
	 * Runs execution, re-throwing exceptions that might be thrown during its execution.
	 */
	private void runExecutorAndAwaitCompletion() {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






209




210




211




212




213




214




215




216




217




218




//		try {
//			executor.awaitCompletion();
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//		Throwable exception = executor.getException();
//		if(exception!=null) {
//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);
//		}
		while(!worklist.isEmpty()) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






219




220




//			if(jobCounter % 100_000 == 0)
			









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






221




			PathEdgeProcessingTask current = worklist.removeLast();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






222




223




224




225




226




227




228




229




230




231




232




			int size = worklist.size();
			current.run();
			jobCounter++;
			M method = icfg.getMethodOf(current.edge.getTarget());
//			edgesPerMethod.put(method, current.edge);
//			if(edgesPerMethod.get(method).size() > 10_000) {
//				System.out.println(method);
//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {
//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));
//				}
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






233




			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






234




235




236




				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));
			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






237




238




//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






239




240




241




242




243




244




245




246




247




248




		}
	}

    /**
     * Dispatch the processing of a given edge. It may be executed in a different thread.
     * @param edge the edge to process
     */
    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){
    	// If the executor has been killed, there is little point
    	// in submitting new tasks









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






249




250




251




252




//    	if (executor.isTerminating())
//    		return;
//    	executor.execute(new PathEdgeProcessingTask(edge));
    	worklist.add(new PathEdgeProcessingTask(edge));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






253




254




255




256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




    	propagationCount++;
    }
	
	/**
	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
	 * 
	 * For each possible callee, registers incoming call edges.
	 * Also propagates call-to-return flows and summarized callee flows within the caller. 
	 * 
	 * @param edge an edge whose target node resembles a method call
	 */
	private void processCall(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); // a call node; line 14...

        logger.trace("Processing call to {}", n);

		final D d2 = edge.factAtTarget();
		assert d2 != null;
		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
		
		//for each possible callee
		Collection<M> callees = icfg.getCalleesOfCallAt(n);
		for(M sCalledProcN: callees) { //still line 14
			//compute the call-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






278




			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






279




			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






280




281




282




			
			Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
			//for each result node of the call-flow function









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






283




			for(ConstrainedFact<FieldRef, D> d3: res) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






284




285




286




				//for each callee's start point(s)
				for(N sP: startPointsOf) {
					//create initial self-loop









avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015






287




					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






288




					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






289




290




291




292




				}
				
				//register the fact that <sp,d3> has an incoming edge from <n,d2>
				//line 15.1 of Naeem/Lhotak/Rodriguez









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






293




294




				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);
				if (!addIncoming(sCalledProcN, incomingEdge))









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






295




296




					continue;
				









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






297




				resumeEdges(sCalledProcN, d3.getFact());









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






298




299




				registerInterestedCaller(sCalledProcN, incomingEdge);
				









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






300




301




				
				//line 15.2









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






302




				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






303




304




305




306




307




308




					
				//still line 15.2 of Naeem/Lhotak/Rodriguez
				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,
				//create new caller-side jump functions to the return sites
				//because we have observed a potentially new incoming edge into <sP,d3>
				if (endSumm != null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






309




					for(SummaryEdge<D, N> summary: endSumm) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






310




311




						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);
						if(delta.isPresent()) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






312




313




314




315




316




							//for each return site
							for(N retSiteN: returnSiteNs) {
								//compute return-flow function
								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);
								//for each target value of the function









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






317




								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






318




									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






319




320




321




322




323




324




									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);
									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());
									
									AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);
									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






325




326




								}
							}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






327




						}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






328




329




330




331




332




333




					}
			}
		}
		//line 17-19 of Naeem/Lhotak/Rodriguez		
		//process intra-procedural flows along call-to-return flow functions
		for (N returnSiteN : returnSiteNs) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






334




			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






335




			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






336




				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






337




338




339




		}
	}










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






340




	private void resumeEdges(M method, D factAtMethodStartPoint) {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






341




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






342




343




		if(edges != null) {
			for(PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






344




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






345




346




					if(edges.remove(edge))  {
						logger.trace("RESUME-EDGE: {}", edge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






347




						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






348




349




350




351




352




					}
				}
			}
		}
	}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






353




354




355




356




	
	private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {
		Set<PathEdge<N, D>> edges = pausedEdges.get(method);
		if(edges != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






357




358




359




			if(edges.size() > 100)
				System.out.println("Paused edges for method "+method+": "+edges.size());
			









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






360




			for(final PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






361




				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






362




363




					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);
					









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






364




					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






365




366




367




					
					if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 
							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






368




369




370




						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();
							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






371




								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






372




								incomingEdge.getCallSite(), 









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






373




								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






374




								method,









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






375




								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






376




377




378




379




380




381




382




383




384




						}
						else {
							propagateConstrained(new CallConcretizationPathEdge<>(
									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 
									incomingEdge.getCallSite(), 
									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),
									method,
									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));
						}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






385




					}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






386




387




388




389




				}
			}
		}
	}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






390














FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






391




392




393




394




395




396




397




	/**
	 * Computes the call flow function for the given call-site abstraction
	 * @param callFlowFunction The call flow function to compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the callee's start node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






398




	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






399




			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






400




401




402




403




404




405




406




407




408




409




410




411




		return callFlowFunction.computeTargets(d2);
	}

	/**
	 * Computes the call-to-return flow function for the given call-site
	 * abstraction
	 * @param callToReturnFlowFunction The call-to-return flow function to
	 * compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






412




	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






413




			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






414




415




416




417




418




419




420




421




422




423




424




425




426




427




428




429




430




431




432




433




434




435




436




		return callToReturnFlowFunction.computeTargets(d2);
	}
	
	/**
	 * Lines 21-32 of the algorithm.
	 * 
	 * Stores callee-side summaries.
	 * Also, at the side of the caller, propagates intra-procedural flows to return sites
	 * using those newly computed summaries.
	 * 
	 * @param edge an edge whose target node resembles a method exits
	 */
	protected void processExit(PathEdge<N,D> edge) {
		final N n = edge.getTarget(); // an exit node; line 21...
		M methodThatNeedsSummary = icfg.getMethodOf(n);
		
		final D d1 = edge.factAtSource();
		final D d2 = edge.factAtTarget();
		
		//for each of the method's start points, determine incoming calls
		
		//line 21.1 of Naeem/Lhotak/Rodriguez
		//register end-summary









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






437




438




		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);
		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






439




			return; //FIXME: should never be reached?! -> assert ?









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






440




441




442




		
		//for each incoming call edge already processed
		//(see processCall(..))









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






443




444




445




446




447




448




		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {
			// line 22
			N callSite = incomingEdge.getCallSite();
			// for each return site
			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {
				// compute return-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






449




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






450




				









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






451




				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






452




453




454




					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);
					if(delta.isPresent()) {
						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






455




456




	
						// for each incoming-call value









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






457




						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






458




							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






459




460




461




462




							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());
							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






463




						}









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






464




					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






465




466




				}
			}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






467




468




		}
		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






469




470




471




472




		
		//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow
		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only
		//be propagated into callers that have an incoming edge for this condition









bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015






473




		if(followReturnsPastSeeds && d1 == zeroValue) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






474




475




476




			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
			for(N c: callers) {
				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






477




					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






478




					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






479




480




481




482




483




484




485




					for(ConstrainedFact<FieldRef, D> d5: targets) {
						
						Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());
						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);
					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






486




487




488




489




490




491




				}
			}
			//in cases where there are no callers, the return statement would normally not be processed at all;
			//this might be undesirable if the flow function has a side effect such as registering a taint;
			//instead we thus call the return flow function will a null caller
			if(callers.isEmpty()) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






492




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






493




494




495




496




497




				retFunction.computeTargets(d2);
			}
		}
	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






498




499




500




501




502




503




504




505




506




507




508




509




510




511




512




513




514




515




516




517




518




519




520




521




522




523




524




525




526




527




528




529




530




531




532




533




534




535




536




537




538




539




540




541




542




543




544




545




546




547




548




549




550




551




552




553




554




555




556




557




558




559




560




561




562




563




564




565




566




567




568




569




570




571




572




573




574




575




576




577




578




579




580




581




582




583




584




585




586




587




588




589




590




591




592




593




594




595




596




597




598




599




600




601




602




603




604




605




606




607




608




609




610




611




612




613




614




615




616




617




618




619




620




621




622




623




624




625




626




627




628




629




630




631




632




633




634




635




636




637




638




639




640




641




642




643




644




645




646




647




648




649




650




651




652




653




654




655




656




657




658




659




660




661




662




663




664




665




666




667




668




669




670




671




672




673




674




675




676




677




678




679




680




681




682




683




684




685




686




687




688




689




690




691




692




693




694




695




696




697




698




699




700




701




702




703




704




705




706




707




708




709




710




711




712




713




714




715




716




717




718




719




720




721




722




723




724




725




726




727




728




729




730




731




732




733




734




735




736




737




738




739




740




741




742




743




744




745




746




747




748




749




750




751




752




753




754




755




756




757




758




759




760




761




762




763




764




765




766




767




768




769




770




771




772




773




774




775




776




777




778




779




780




781




782




783




784




785




786




787




788




789




790




791




	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();
	
	private Resolver getResolver(D sourceFact, D targetFact, N stmt) {
		HashKey key = new HashKey(sourceFact, targetFact, stmt);
		if(!returnSiteIncomingEdges.containsKey(key))
			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));
		return returnSiteIncomingEdges.get(key);
	}
	
	private class PausedReturnSiteEdge {

		private Constraint<FieldRef> constraint;
		private PathEdge<N, D> pathEdge;
		private AccessPath<FieldRef> alreadyResolvedAccPath;
		private D concretizedStmtFact;

		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {
			this.constraint = constraint;
			this.pathEdge = pathEdge;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
			this.concretizedStmtFact = concretizedStmtFact;
		}
	}
	
	class Resolver {

		private D sourceFact;
		private N stmt;
		private Set<IncomingFact> incomingFacts = Sets.newHashSet();
		private D targetFact;
		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();

		public Resolver(D sourceFact, D targetFact, N stmt) {
			this.sourceFact = sourceFact;
			this.targetFact = targetFact;
			this.stmt = stmt;
		}

		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {
				if(!fact.getAccessPath().hasResolver())
					throw new AssertionError();
				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))
					throw new AssertionError();
			}
			
			logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);
			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);
			incomingFacts.add(incFact);
			
			for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {
				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {
					propagate(edge.pathEdge, null, false);
					paused.remove(edge);
				}
			}
		}

		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {
			if(!visited.resolver.add(this))
				return false;
			
			alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);
			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);
			
			logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());
			
			boolean resolved = false;
			for(final IncomingFact incFact : incomingFacts) {
				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);
				if(resolved)
					break;
			}
			if(resolved) {
				propagate(pathEdge, null, false);
			} else {
				logger.trace("Pause {} at {}", pathEdge, stmt);
				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));
			}
			return resolved;
		}

		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,
				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {
			
			
			logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);
			
			if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {
				logger.trace("Resolved by incoming fact {}", incFact.fact);
				return true;
			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
				if(incFact.fact.getAccessPath().hasResolver()) {
					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();
					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);
					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(
								incFact.summaryEdge.getSourceFact(), 
								incFact.summaryEdge.getTargetStmt(), 
								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {

									@Override
									public void _propagate(D dSource, N target, D dTarget) {
										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);
									}
						}, decoratingResolver.alreadyResolvedAccPath, visited);
						if(resolved) {
							propagate(pathEdge, null, false);
							return true;
						}
					}
				}
				else {
					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));
					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {
						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);
						return true;
					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
						if(factWithDelta.getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();
							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
							
							final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);
							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);
								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));
								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {
									@Override
									protected void _propagate(D dSource, N target, D dTarget) {
										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);
									}
								};
								
								boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);
								if(resolved) {
									return true;
								}
							}
						}
						else {
							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));
							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);
							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(
									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 
									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {
										@Override
										protected void _propagate(D dSource, N target, D dTarget) {
											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);
										}
									}, visited);
							if(resolved)
								return true;
						}
					}
				}
			}
			return false;
		}
		
		@Override
		public String toString() {
			return stmt.toString();
		}
	}

	private class Visited {
		Set<Resolver> resolver = Sets.newHashSet();
		Map<N, Boolean> visitedCallSites = Maps.newHashMap();
	}
	
	class DecoratingResolver implements SubPathResolver<FieldRef> {
		
		private Resolver resolver;
		private AccessPath<FieldRef> alreadyResolvedAccPath;

		public DecoratingResolver(Resolver resolver) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();
		}
		
		public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
		}
		
		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {
			return resolve(constraint, pathEdge, new Visited());
		}

		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {
			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());
			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			DecoratingResolver other = (DecoratingResolver) obj;
			if (alreadyResolvedAccPath == null) {
				if (other.alreadyResolvedAccPath != null)
					return false;
			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))
				return false;
			if (resolver == null) {
				if (other.resolver != null)
					return false;
			} else if (!resolver.equals(other.resolver))
				return false;
			return true;
		}
		
		@Override
		public String toString() {
			return alreadyResolvedAccPath+ ":"+resolver.toString();
		}

		@Override
		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {
			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));
		}
	}
	
	private class IncomingFact {

		private D fact;
		private Delta<FieldRef> delta;
		private SummaryEdge<D, N> summaryEdge;

		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			this.summaryEdge = summaryEdge;
			this.fact = fact;
			this.delta = delta;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((delta == null) ? 0 : delta.hashCode());
			result = prime * result + ((fact == null) ? 0 : fact.hashCode());
			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			IncomingFact other = (IncomingFact) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (delta == null) {
				if (other.delta != null)
					return false;
			} else if (!delta.equals(other.delta))
				return false;
			if (fact == null) {
				if (other.fact != null)
					return false;
			} else if (!fact.equals(other.fact))
				return false;
			if (summaryEdge == null) {
				if (other.summaryEdge != null)
					return false;
			} else if (!summaryEdge.equals(other.summaryEdge))
				return false;
			return true;
		}

		private FieldSensitiveIFDSSolver getOuterType() {
			return FieldSensitiveIFDSSolver.this;
		}
		
	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






792




793




794




795




796




797




798




799




	/**
	 * Computes the return flow function for the given set of caller-side
	 * abstractions.
	 * @param retFunction The return flow function to compute
	 * @param d2 The abstraction at the exit node in the callee
	 * @param callSite The call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






800




	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






801




			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






802




803




804




805




806




807




808




809




		return retFunction.computeTargets(d2);
	}

	/**
	 * Lines 33-37 of the algorithm.
	 * Simply propagate normal, intra-procedural flows.
	 * @param edge
	 */









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






810




	@SuppressWarnings("unchecked")









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






811




812




813




814




815




816




	private void processNormalFlow(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); 
		final D d2 = edge.factAtTarget();
		
		for (N m : icfg.getSuccsOf(n)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






817




			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






818




819




			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);
			for (ConstrainedFact<FieldRef, D> d3 : res) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






820




				if(d3.getConstraint() != null) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






821




822




823




824




825




					if(d3.getFact().getAccessPath().hasResolver()) {
						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());
						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));
					} else
						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






826




				}









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






827




				else









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






828




					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






829




830




831




832




			}
		}
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






833




	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






834




835




836




		if(fact.equals(zeroValue))
			return zeroValue;
		else









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






837




			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






838




	}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






839




	









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






840




	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






841




		return propagateConstrained(pathEdge, new Visited());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






842




843




	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






844




	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






845




		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






846




		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






847














cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






848




849




850




		boolean propagate = false;
		if(pathEdge.factAtSource().equals(zeroValue))
			propagate = true;









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






851




852




		else if(hasPausedEdges(calleeMethod, pathEdge))
			propagate = false;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






853




854




		else {
			Set<N> callSitesWithInterest = Sets.newHashSet();









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






855




			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






856




				callSitesWithInterest.add(incEdge.getCallSite());









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






857




			}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






858




859




			propagate = !callSitesWithInterest.isEmpty();
			









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






860




861




862




863




864




865




866




			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());
			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);
			
			for(IncomingEdge<D, N> incEdge : candidates) { //potential
				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {
					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)
						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






867




868




				}
				else {









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






869




					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






870




871




872




873




874




875




876




877




878




879




880




881




882




883




884




885




886




887




888




889




890




891




892




893




894




895




896




897




898




899




900




901




902




903




						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();
								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);
								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(
										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));
								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 
										calleeMethod,
										calleeSourceFact), visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}
						}
						else {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
					
								PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),
										calleeMethod,
										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));
								visited.visitedCallSites.put(incEdge.getCallSite(), null);
								boolean result = propagateConstrained(callerEdge, visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






904




						}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






905




					}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






906




				}









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






907




			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






908




		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






909




		









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






910




		if(propagate) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






911




			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






912




913




914




915




916




917




			return true;
		} else {
			pauseEdge(pathEdge);
			return false;
		}
	}









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






918














abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






919




920




921




922




923




924




925




926




927




928




929




930




931




932




933




	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {
		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();
		for(IncomingEdge<D, N> incEdge : candidates) {
			if(result.containsKey(incEdge.getCallSite())) {
				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());
				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {
					result.put(incEdge.getCallSite(), incEdge);
				}
			}
			else
				result.put(incEdge.getCallSite(), incEdge);
		}
		return result.values();
	}










Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






934




935




936




937




	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {
		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);
		if(pe != null) {
			for(PathEdge<N, D> edge : pe) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






938




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






939




940




941




942




943




944




					return true;
			}
		}
		return false;
	}










cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






945




946




	private void pauseEdge(PathEdge<N,D> edge) {
		M method = icfg.getMethodOf(edge.getTarget());









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






947




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






948




949




950




		if(edges.add(edge)) {
			logger.trace("PAUSED: {}: {}", method, edge);
		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






951




952




	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






953




954




955




956




957




958




959




960




	/**
	 * Computes the normal flow function for the given set of start and end
	 * abstractions.
	 * @param flowFunction The normal flow function to compute
	 * @param d1 The abstraction at the method's start node
	 * @param d1 The abstraction at the current node
	 * @return The set of abstractions at the successor node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






961




	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






962




			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






963




964




965




966




967




968




969




970




971




972




973




974




975




976




977




978




979




980




981




982




		return flowFunction.computeTargets(d2);
	}
	
	/**
	 * This method will be called for each incoming edge and can be used to
	 * transfer knowledge from the calling edge to the returning edge, without
	 * affecting the summary edges at the callee.
	 * 
	 * @param d4
	 *            Fact stored with the incoming edge, i.e., present at the
	 *            caller side
	 * @param d5
	 *            Fact that originally should be propagated to the caller.
	 * @return Fact that will be propagated to the caller.
	 */
	protected D restoreContextOnReturnedFact(D d4, D d5) {
		d5.setCallingContext(d4);
		return d5;
	}
	









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






983




984




985




986




	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,
			/* deliberately exposed to clients */ N relatedCallSite) {
		propagate(edge, relatedCallSite, true);
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






987




	









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






988




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






989




990




991




992




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();
	private int cacheHits = 0;
	private int cacheMerges = 0;
	private int cacheOppositePrefix = 0;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






993




994




995




	private int cacheSourceBaseValue = 0;
	private int concretizationEdges = 0;
	private int cacheEquals = 0;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






996




997




	/**
	 * Propagates the flow further down the exploded super graph. 









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






998




	 * @param edge the PathEdge that should be propagated









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






999




1000




	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 






For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next









55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink




55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java





55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag








55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag





55cdd2d88cc7d78204a4508a1dd46234cb52b74c

Switch branch/tag





Switch branch/tag



Switch branch/tagSwitch branch/tag
heros

src

heros

alias

FieldSensitiveIFDSSolver.java
Find file
Normal viewHistoryPermalink




FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1




/*******************************************************************************









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






2




 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






3




4




5




6




7




8




 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






9




 *     Johannes Lerch, Johannes Späth - initial API and implementation









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






10




11




12




 ******************************************************************************/
package heros.alias;










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






13




14




15




16




import heros.DontSynchronize;
import heros.FlowFunctionCache;
import heros.InterproceduralCFG;
import heros.SynchronizedBy;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






17




import heros.alias.AccessPath.Delta;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






18




import heros.alias.AccessPath.PrefixTestResult;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






19




import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






20




import heros.alias.FlowFunction.ConstrainedFact;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






21




import heros.alias.FlowFunction.Constraint;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






22




23




import heros.solver.CountingThreadPoolExecutor;
import heros.solver.IFDSSolver;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






24




import heros.solver.Pair;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






25




26




import heros.solver.PathEdge;










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






27




28




29




30




31




32




import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






33




34




import java.util.Collection;
import java.util.Collections;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






35




36




import java.util.Comparator;
import java.util.Enumeration;









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






37




import java.util.HashMap;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






38




import java.util.Iterator;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






39




import java.util.LinkedList;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






40




import java.util.List;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






41




42




import java.util.Map;
import java.util.Map.Entry;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






43




import java.util.PriorityQueue;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






44




import java.util.Set;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






45




46




47




48




49




50




import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;










handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






51




import com.google.common.base.Optional;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






52




import com.google.common.base.Predicate;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






53




import com.google.common.cache.CacheBuilder;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






54




import com.google.common.collect.HashMultimap;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






55




import com.google.common.collect.Iterators;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






56




import com.google.common.collect.Lists;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






57




import com.google.common.collect.Maps;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






58




import com.google.common.collect.Sets;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






59




import com.sun.org.apache.xpath.internal.axes.IteratorPool;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






60














merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






61




public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85






	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel
			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
	
    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);

    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
    public static final boolean DEBUG = logger.isDebugEnabled();

	protected CountingThreadPoolExecutor executor;
	
	@DontSynchronize("only used by single thread")
	protected int numThreads;
	
	@SynchronizedBy("thread safe data structure, consistent locking when used")
	protected final JumpFunctions<N,D> jumpFn;
	
	@SynchronizedBy("thread safe data structure, only modified internally")
	protected final I icfg;
	
	//stores summaries that were queried before they were computed
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on 'incoming'")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






86




87




	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =
			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






88




89




90




91




	
	//edges going along calls
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on field")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






92




93




	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =
			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






94




	









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






95




	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






96




	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






97




	@DontSynchronize("stateless")









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






98




	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




	
	@DontSynchronize("only used by single thread")
	protected final Map<N,Set<D>> initialSeeds;
	
	@DontSynchronize("benign races")
	public long propagationCount;
	
	@DontSynchronize("stateless")
	protected final D zeroValue;
	
	@DontSynchronize("readOnly")
	protected final FlowFunctionCache<N,D,M> ffCache = null; 
	
	@DontSynchronize("readOnly")
	protected final boolean followReturnsPastSeeds;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






114














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






115




	private LinkedList<PathEdgeProcessingTask> worklist;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






116




117




118




119




120




121




	
	
	/**
	 * Creates a solver for the given problem, which caches flow functions and edge functions.
	 * The solver must then be started by calling {@link #solve()}.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






122




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






123




124




125




126




127




128




129




130




131




		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
	}

	/**
	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling
	 * {@link #solve()}.
	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.
	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






132




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






133




134




135




136




137




138




		if(logger.isDebugEnabled())
			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
		this.zeroValue = tabulationProblem.zeroValue();
		this.icfg = tabulationProblem.interproceduralCFG();		
	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?
				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






139




		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






140




141




142




143




144




145




146




147




148




149




		/*if(flowFunctionCacheBuilder!=null) {
			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);
			flowFunctions = ffCache;
		} else {
			ffCache = null;
		}*/
		this.flowFunctions = flowFunctions;
		this.initialSeeds = tabulationProblem.initialSeeds();
		this.jumpFn = new JumpFunctions<N,D>();
		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






150




		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






151




		this.executor = getExecutor();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






152




		this.worklist = Lists.newLinkedList();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






153




154




155




156




157




158




159




160




	}

	/**
	 * Runs the solver on the configured problem. This can take some time.
	 */
	public void solve() {		
		submitInitialSeeds();
		awaitCompletionComputeValuesAndShutdown();









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






161




		writeDebugFile();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






162




163




164




165




166




167




168




169




170




171




172




	}

	/**
	 * Schedules the processing of initial seeds, initiating the analysis.
	 * Clients should only call this methods if performing synchronization on
	 * their own. Normally, {@link #solve()} should be called instead.
	 */
	protected void submitInitialSeeds() {
		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {
			N startPoint = seed.getKey();
			for(D val: seed.getValue())









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






173




				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






174




175




176




177




178




179




180




181




182




			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
		}
	}

	/**
	 * Awaits the completion of the exploded super graph. When complete, computes result values,
	 * shuts down the executor and returns.
	 */
	protected void awaitCompletionComputeValuesAndShutdown() {









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






183




184




185




186




//		{
//			//run executor and await termination of tasks
//			runExecutorAndAwaitCompletion();
//		}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






187




188




189




190




191




192




		if(logger.isDebugEnabled())
			printStats();

		//ask executor to shut down;
		//this will cause new submissions to the executor to be rejected,
		//but at this point all tasks should have completed anyway









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






193




//		executor.shutdown();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






194




195




196




197




198




		//similarly here: we await termination, but this should happen instantaneously,
		//as all tasks should have completed
		runExecutorAndAwaitCompletion();
	}










field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






199




200




201




202




	protected boolean hasWork() {
		return !worklist.isEmpty();
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






203




204




	private int jobCounter = 0;
	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






205




206




207




208




	/**
	 * Runs execution, re-throwing exceptions that might be thrown during its execution.
	 */
	private void runExecutorAndAwaitCompletion() {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






209




210




211




212




213




214




215




216




217




218




//		try {
//			executor.awaitCompletion();
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//		Throwable exception = executor.getException();
//		if(exception!=null) {
//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);
//		}
		while(!worklist.isEmpty()) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






219




220




//			if(jobCounter % 100_000 == 0)
			









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






221




			PathEdgeProcessingTask current = worklist.removeLast();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






222




223




224




225




226




227




228




229




230




231




232




			int size = worklist.size();
			current.run();
			jobCounter++;
			M method = icfg.getMethodOf(current.edge.getTarget());
//			edgesPerMethod.put(method, current.edge);
//			if(edgesPerMethod.get(method).size() > 10_000) {
//				System.out.println(method);
//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {
//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));
//				}
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






233




			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






234




235




236




				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));
			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






237




238




//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






239




240




241




242




243




244




245




246




247




248




		}
	}

    /**
     * Dispatch the processing of a given edge. It may be executed in a different thread.
     * @param edge the edge to process
     */
    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){
    	// If the executor has been killed, there is little point
    	// in submitting new tasks









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






249




250




251




252




//    	if (executor.isTerminating())
//    		return;
//    	executor.execute(new PathEdgeProcessingTask(edge));
    	worklist.add(new PathEdgeProcessingTask(edge));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






253




254




255




256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




    	propagationCount++;
    }
	
	/**
	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
	 * 
	 * For each possible callee, registers incoming call edges.
	 * Also propagates call-to-return flows and summarized callee flows within the caller. 
	 * 
	 * @param edge an edge whose target node resembles a method call
	 */
	private void processCall(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); // a call node; line 14...

        logger.trace("Processing call to {}", n);

		final D d2 = edge.factAtTarget();
		assert d2 != null;
		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
		
		//for each possible callee
		Collection<M> callees = icfg.getCalleesOfCallAt(n);
		for(M sCalledProcN: callees) { //still line 14
			//compute the call-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






278




			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






279




			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






280




281




282




			
			Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
			//for each result node of the call-flow function









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






283




			for(ConstrainedFact<FieldRef, D> d3: res) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






284




285




286




				//for each callee's start point(s)
				for(N sP: startPointsOf) {
					//create initial self-loop









avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015






287




					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






288




					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






289




290




291




292




				}
				
				//register the fact that <sp,d3> has an incoming edge from <n,d2>
				//line 15.1 of Naeem/Lhotak/Rodriguez









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






293




294




				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);
				if (!addIncoming(sCalledProcN, incomingEdge))









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






295




296




					continue;
				









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






297




				resumeEdges(sCalledProcN, d3.getFact());









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






298




299




				registerInterestedCaller(sCalledProcN, incomingEdge);
				









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






300




301




				
				//line 15.2









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






302




				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






303




304




305




306




307




308




					
				//still line 15.2 of Naeem/Lhotak/Rodriguez
				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,
				//create new caller-side jump functions to the return sites
				//because we have observed a potentially new incoming edge into <sP,d3>
				if (endSumm != null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






309




					for(SummaryEdge<D, N> summary: endSumm) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






310




311




						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);
						if(delta.isPresent()) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






312




313




314




315




316




							//for each return site
							for(N retSiteN: returnSiteNs) {
								//compute return-flow function
								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);
								//for each target value of the function









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






317




								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






318




									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






319




320




321




322




323




324




									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);
									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());
									
									AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);
									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






325




326




								}
							}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






327




						}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






328




329




330




331




332




333




					}
			}
		}
		//line 17-19 of Naeem/Lhotak/Rodriguez		
		//process intra-procedural flows along call-to-return flow functions
		for (N returnSiteN : returnSiteNs) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






334




			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






335




			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






336




				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






337




338




339




		}
	}










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






340




	private void resumeEdges(M method, D factAtMethodStartPoint) {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






341




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






342




343




		if(edges != null) {
			for(PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






344




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






345




346




					if(edges.remove(edge))  {
						logger.trace("RESUME-EDGE: {}", edge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






347




						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






348




349




350




351




352




					}
				}
			}
		}
	}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






353




354




355




356




	
	private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {
		Set<PathEdge<N, D>> edges = pausedEdges.get(method);
		if(edges != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






357




358




359




			if(edges.size() > 100)
				System.out.println("Paused edges for method "+method+": "+edges.size());
			









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






360




			for(final PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






361




				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






362




363




					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);
					









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






364




					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






365




366




367




					
					if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 
							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






368




369




370




						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();
							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






371




								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






372




								incomingEdge.getCallSite(), 









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






373




								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






374




								method,









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






375




								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






376




377




378




379




380




381




382




383




384




						}
						else {
							propagateConstrained(new CallConcretizationPathEdge<>(
									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 
									incomingEdge.getCallSite(), 
									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),
									method,
									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));
						}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






385




					}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






386




387




388




389




				}
			}
		}
	}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






390














FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






391




392




393




394




395




396




397




	/**
	 * Computes the call flow function for the given call-site abstraction
	 * @param callFlowFunction The call flow function to compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the callee's start node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






398




	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






399




			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






400




401




402




403




404




405




406




407




408




409




410




411




		return callFlowFunction.computeTargets(d2);
	}

	/**
	 * Computes the call-to-return flow function for the given call-site
	 * abstraction
	 * @param callToReturnFlowFunction The call-to-return flow function to
	 * compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






412




	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






413




			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






414




415




416




417




418




419




420




421




422




423




424




425




426




427




428




429




430




431




432




433




434




435




436




		return callToReturnFlowFunction.computeTargets(d2);
	}
	
	/**
	 * Lines 21-32 of the algorithm.
	 * 
	 * Stores callee-side summaries.
	 * Also, at the side of the caller, propagates intra-procedural flows to return sites
	 * using those newly computed summaries.
	 * 
	 * @param edge an edge whose target node resembles a method exits
	 */
	protected void processExit(PathEdge<N,D> edge) {
		final N n = edge.getTarget(); // an exit node; line 21...
		M methodThatNeedsSummary = icfg.getMethodOf(n);
		
		final D d1 = edge.factAtSource();
		final D d2 = edge.factAtTarget();
		
		//for each of the method's start points, determine incoming calls
		
		//line 21.1 of Naeem/Lhotak/Rodriguez
		//register end-summary









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






437




438




		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);
		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






439




			return; //FIXME: should never be reached?! -> assert ?









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






440




441




442




		
		//for each incoming call edge already processed
		//(see processCall(..))









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






443




444




445




446




447




448




		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {
			// line 22
			N callSite = incomingEdge.getCallSite();
			// for each return site
			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {
				// compute return-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






449




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






450




				









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






451




				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






452




453




454




					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);
					if(delta.isPresent()) {
						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






455




456




	
						// for each incoming-call value









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






457




						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






458




							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






459




460




461




462




							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());
							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






463




						}









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






464




					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






465




466




				}
			}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






467




468




		}
		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






469




470




471




472




		
		//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow
		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only
		//be propagated into callers that have an incoming edge for this condition









bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015






473




		if(followReturnsPastSeeds && d1 == zeroValue) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






474




475




476




			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
			for(N c: callers) {
				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






477




					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






478




					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






479




480




481




482




483




484




485




					for(ConstrainedFact<FieldRef, D> d5: targets) {
						
						Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());
						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);
					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






486




487




488




489




490




491




				}
			}
			//in cases where there are no callers, the return statement would normally not be processed at all;
			//this might be undesirable if the flow function has a side effect such as registering a taint;
			//instead we thus call the return flow function will a null caller
			if(callers.isEmpty()) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






492




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






493




494




495




496




497




				retFunction.computeTargets(d2);
			}
		}
	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






498




499




500




501




502




503




504




505




506




507




508




509




510




511




512




513




514




515




516




517




518




519




520




521




522




523




524




525




526




527




528




529




530




531




532




533




534




535




536




537




538




539




540




541




542




543




544




545




546




547




548




549




550




551




552




553




554




555




556




557




558




559




560




561




562




563




564




565




566




567




568




569




570




571




572




573




574




575




576




577




578




579




580




581




582




583




584




585




586




587




588




589




590




591




592




593




594




595




596




597




598




599




600




601




602




603




604




605




606




607




608




609




610




611




612




613




614




615




616




617




618




619




620




621




622




623




624




625




626




627




628




629




630




631




632




633




634




635




636




637




638




639




640




641




642




643




644




645




646




647




648




649




650




651




652




653




654




655




656




657




658




659




660




661




662




663




664




665




666




667




668




669




670




671




672




673




674




675




676




677




678




679




680




681




682




683




684




685




686




687




688




689




690




691




692




693




694




695




696




697




698




699




700




701




702




703




704




705




706




707




708




709




710




711




712




713




714




715




716




717




718




719




720




721




722




723




724




725




726




727




728




729




730




731




732




733




734




735




736




737




738




739




740




741




742




743




744




745




746




747




748




749




750




751




752




753




754




755




756




757




758




759




760




761




762




763




764




765




766




767




768




769




770




771




772




773




774




775




776




777




778




779




780




781




782




783




784




785




786




787




788




789




790




791




	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();
	
	private Resolver getResolver(D sourceFact, D targetFact, N stmt) {
		HashKey key = new HashKey(sourceFact, targetFact, stmt);
		if(!returnSiteIncomingEdges.containsKey(key))
			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));
		return returnSiteIncomingEdges.get(key);
	}
	
	private class PausedReturnSiteEdge {

		private Constraint<FieldRef> constraint;
		private PathEdge<N, D> pathEdge;
		private AccessPath<FieldRef> alreadyResolvedAccPath;
		private D concretizedStmtFact;

		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {
			this.constraint = constraint;
			this.pathEdge = pathEdge;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
			this.concretizedStmtFact = concretizedStmtFact;
		}
	}
	
	class Resolver {

		private D sourceFact;
		private N stmt;
		private Set<IncomingFact> incomingFacts = Sets.newHashSet();
		private D targetFact;
		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();

		public Resolver(D sourceFact, D targetFact, N stmt) {
			this.sourceFact = sourceFact;
			this.targetFact = targetFact;
			this.stmt = stmt;
		}

		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {
				if(!fact.getAccessPath().hasResolver())
					throw new AssertionError();
				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))
					throw new AssertionError();
			}
			
			logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);
			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);
			incomingFacts.add(incFact);
			
			for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {
				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {
					propagate(edge.pathEdge, null, false);
					paused.remove(edge);
				}
			}
		}

		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {
			if(!visited.resolver.add(this))
				return false;
			
			alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);
			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);
			
			logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());
			
			boolean resolved = false;
			for(final IncomingFact incFact : incomingFacts) {
				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);
				if(resolved)
					break;
			}
			if(resolved) {
				propagate(pathEdge, null, false);
			} else {
				logger.trace("Pause {} at {}", pathEdge, stmt);
				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));
			}
			return resolved;
		}

		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,
				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {
			
			
			logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);
			
			if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {
				logger.trace("Resolved by incoming fact {}", incFact.fact);
				return true;
			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
				if(incFact.fact.getAccessPath().hasResolver()) {
					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();
					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);
					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(
								incFact.summaryEdge.getSourceFact(), 
								incFact.summaryEdge.getTargetStmt(), 
								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {

									@Override
									public void _propagate(D dSource, N target, D dTarget) {
										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);
									}
						}, decoratingResolver.alreadyResolvedAccPath, visited);
						if(resolved) {
							propagate(pathEdge, null, false);
							return true;
						}
					}
				}
				else {
					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));
					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {
						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);
						return true;
					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
						if(factWithDelta.getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();
							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
							
							final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);
							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);
								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));
								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {
									@Override
									protected void _propagate(D dSource, N target, D dTarget) {
										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);
									}
								};
								
								boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);
								if(resolved) {
									return true;
								}
							}
						}
						else {
							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));
							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);
							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(
									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 
									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {
										@Override
										protected void _propagate(D dSource, N target, D dTarget) {
											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);
										}
									}, visited);
							if(resolved)
								return true;
						}
					}
				}
			}
			return false;
		}
		
		@Override
		public String toString() {
			return stmt.toString();
		}
	}

	private class Visited {
		Set<Resolver> resolver = Sets.newHashSet();
		Map<N, Boolean> visitedCallSites = Maps.newHashMap();
	}
	
	class DecoratingResolver implements SubPathResolver<FieldRef> {
		
		private Resolver resolver;
		private AccessPath<FieldRef> alreadyResolvedAccPath;

		public DecoratingResolver(Resolver resolver) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();
		}
		
		public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
		}
		
		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {
			return resolve(constraint, pathEdge, new Visited());
		}

		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {
			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());
			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			DecoratingResolver other = (DecoratingResolver) obj;
			if (alreadyResolvedAccPath == null) {
				if (other.alreadyResolvedAccPath != null)
					return false;
			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))
				return false;
			if (resolver == null) {
				if (other.resolver != null)
					return false;
			} else if (!resolver.equals(other.resolver))
				return false;
			return true;
		}
		
		@Override
		public String toString() {
			return alreadyResolvedAccPath+ ":"+resolver.toString();
		}

		@Override
		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {
			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));
		}
	}
	
	private class IncomingFact {

		private D fact;
		private Delta<FieldRef> delta;
		private SummaryEdge<D, N> summaryEdge;

		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			this.summaryEdge = summaryEdge;
			this.fact = fact;
			this.delta = delta;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((delta == null) ? 0 : delta.hashCode());
			result = prime * result + ((fact == null) ? 0 : fact.hashCode());
			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			IncomingFact other = (IncomingFact) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (delta == null) {
				if (other.delta != null)
					return false;
			} else if (!delta.equals(other.delta))
				return false;
			if (fact == null) {
				if (other.fact != null)
					return false;
			} else if (!fact.equals(other.fact))
				return false;
			if (summaryEdge == null) {
				if (other.summaryEdge != null)
					return false;
			} else if (!summaryEdge.equals(other.summaryEdge))
				return false;
			return true;
		}

		private FieldSensitiveIFDSSolver getOuterType() {
			return FieldSensitiveIFDSSolver.this;
		}
		
	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






792




793




794




795




796




797




798




799




	/**
	 * Computes the return flow function for the given set of caller-side
	 * abstractions.
	 * @param retFunction The return flow function to compute
	 * @param d2 The abstraction at the exit node in the callee
	 * @param callSite The call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






800




	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






801




			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






802




803




804




805




806




807




808




809




		return retFunction.computeTargets(d2);
	}

	/**
	 * Lines 33-37 of the algorithm.
	 * Simply propagate normal, intra-procedural flows.
	 * @param edge
	 */









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






810




	@SuppressWarnings("unchecked")









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






811




812




813




814




815




816




	private void processNormalFlow(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); 
		final D d2 = edge.factAtTarget();
		
		for (N m : icfg.getSuccsOf(n)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






817




			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






818




819




			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);
			for (ConstrainedFact<FieldRef, D> d3 : res) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






820




				if(d3.getConstraint() != null) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






821




822




823




824




825




					if(d3.getFact().getAccessPath().hasResolver()) {
						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());
						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));
					} else
						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






826




				}









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






827




				else









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






828




					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






829




830




831




832




			}
		}
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






833




	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






834




835




836




		if(fact.equals(zeroValue))
			return zeroValue;
		else









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






837




			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






838




	}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






839




	









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






840




	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






841




		return propagateConstrained(pathEdge, new Visited());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






842




843




	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






844




	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






845




		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






846




		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






847














cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






848




849




850




		boolean propagate = false;
		if(pathEdge.factAtSource().equals(zeroValue))
			propagate = true;









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






851




852




		else if(hasPausedEdges(calleeMethod, pathEdge))
			propagate = false;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






853




854




		else {
			Set<N> callSitesWithInterest = Sets.newHashSet();









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






855




			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






856




				callSitesWithInterest.add(incEdge.getCallSite());









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






857




			}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






858




859




			propagate = !callSitesWithInterest.isEmpty();
			









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






860




861




862




863




864




865




866




			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());
			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);
			
			for(IncomingEdge<D, N> incEdge : candidates) { //potential
				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {
					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)
						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






867




868




				}
				else {









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






869




					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






870




871




872




873




874




875




876




877




878




879




880




881




882




883




884




885




886




887




888




889




890




891




892




893




894




895




896




897




898




899




900




901




902




903




						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();
								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);
								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(
										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));
								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 
										calleeMethod,
										calleeSourceFact), visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}
						}
						else {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
					
								PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),
										calleeMethod,
										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));
								visited.visitedCallSites.put(incEdge.getCallSite(), null);
								boolean result = propagateConstrained(callerEdge, visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






904




						}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






905




					}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






906




				}









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






907




			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






908




		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






909




		









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






910




		if(propagate) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






911




			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






912




913




914




915




916




917




			return true;
		} else {
			pauseEdge(pathEdge);
			return false;
		}
	}









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






918














abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






919




920




921




922




923




924




925




926




927




928




929




930




931




932




933




	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {
		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();
		for(IncomingEdge<D, N> incEdge : candidates) {
			if(result.containsKey(incEdge.getCallSite())) {
				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());
				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {
					result.put(incEdge.getCallSite(), incEdge);
				}
			}
			else
				result.put(incEdge.getCallSite(), incEdge);
		}
		return result.values();
	}










Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






934




935




936




937




	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {
		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);
		if(pe != null) {
			for(PathEdge<N, D> edge : pe) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






938




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






939




940




941




942




943




944




					return true;
			}
		}
		return false;
	}










cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






945




946




	private void pauseEdge(PathEdge<N,D> edge) {
		M method = icfg.getMethodOf(edge.getTarget());









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






947




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






948




949




950




		if(edges.add(edge)) {
			logger.trace("PAUSED: {}: {}", method, edge);
		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






951




952




	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






953




954




955




956




957




958




959




960




	/**
	 * Computes the normal flow function for the given set of start and end
	 * abstractions.
	 * @param flowFunction The normal flow function to compute
	 * @param d1 The abstraction at the method's start node
	 * @param d1 The abstraction at the current node
	 * @return The set of abstractions at the successor node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






961




	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






962




			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






963




964




965




966




967




968




969




970




971




972




973




974




975




976




977




978




979




980




981




982




		return flowFunction.computeTargets(d2);
	}
	
	/**
	 * This method will be called for each incoming edge and can be used to
	 * transfer knowledge from the calling edge to the returning edge, without
	 * affecting the summary edges at the callee.
	 * 
	 * @param d4
	 *            Fact stored with the incoming edge, i.e., present at the
	 *            caller side
	 * @param d5
	 *            Fact that originally should be propagated to the caller.
	 * @return Fact that will be propagated to the caller.
	 */
	protected D restoreContextOnReturnedFact(D d4, D d5) {
		d5.setCallingContext(d4);
		return d5;
	}
	









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






983




984




985




986




	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,
			/* deliberately exposed to clients */ N relatedCallSite) {
		propagate(edge, relatedCallSite, true);
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






987




	









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






988




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






989




990




991




992




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();
	private int cacheHits = 0;
	private int cacheMerges = 0;
	private int cacheOppositePrefix = 0;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






993




994




995




	private int cacheSourceBaseValue = 0;
	private int concretizationEdges = 0;
	private int cacheEquals = 0;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






996




997




	/**
	 * Propagates the flow further down the exploded super graph. 









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






998




	 * @param edge the PathEdge that should be propagated









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






999




1000




	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 






For faster browsing, not all history is shown.

View entire blame







FieldSensitiveIFDSSolver.java



50.9 KB










FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older
NewerOlder







FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1




/*******************************************************************************









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






2




 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






3




4




5




6




7




8




 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






9




 *     Johannes Lerch, Johannes Späth - initial API and implementation









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






10




11




12




 ******************************************************************************/
package heros.alias;










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






13




14




15




16




import heros.DontSynchronize;
import heros.FlowFunctionCache;
import heros.InterproceduralCFG;
import heros.SynchronizedBy;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






17




import heros.alias.AccessPath.Delta;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






18




import heros.alias.AccessPath.PrefixTestResult;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






19




import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






20




import heros.alias.FlowFunction.ConstrainedFact;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






21




import heros.alias.FlowFunction.Constraint;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






22




23




import heros.solver.CountingThreadPoolExecutor;
import heros.solver.IFDSSolver;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






24




import heros.solver.Pair;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






25




26




import heros.solver.PathEdge;










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






27




28




29




30




31




32




import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






33




34




import java.util.Collection;
import java.util.Collections;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






35




36




import java.util.Comparator;
import java.util.Enumeration;









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






37




import java.util.HashMap;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






38




import java.util.Iterator;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






39




import java.util.LinkedList;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






40




import java.util.List;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






41




42




import java.util.Map;
import java.util.Map.Entry;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






43




import java.util.PriorityQueue;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






44




import java.util.Set;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






45




46




47




48




49




50




import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;










handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






51




import com.google.common.base.Optional;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






52




import com.google.common.base.Predicate;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






53




import com.google.common.cache.CacheBuilder;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






54




import com.google.common.collect.HashMultimap;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






55




import com.google.common.collect.Iterators;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






56




import com.google.common.collect.Lists;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






57




import com.google.common.collect.Maps;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






58




import com.google.common.collect.Sets;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






59




import com.sun.org.apache.xpath.internal.axes.IteratorPool;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






60














merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






61




public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85






	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel
			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
	
    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);

    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
    public static final boolean DEBUG = logger.isDebugEnabled();

	protected CountingThreadPoolExecutor executor;
	
	@DontSynchronize("only used by single thread")
	protected int numThreads;
	
	@SynchronizedBy("thread safe data structure, consistent locking when used")
	protected final JumpFunctions<N,D> jumpFn;
	
	@SynchronizedBy("thread safe data structure, only modified internally")
	protected final I icfg;
	
	//stores summaries that were queried before they were computed
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on 'incoming'")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






86




87




	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =
			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






88




89




90




91




	
	//edges going along calls
	//see CC 2010 paper by Naeem, Lhotak and Rodriguez
	@SynchronizedBy("consistent lock on field")









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






92




93




	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =
			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






94




	









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






95




	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






96




	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






97




	@DontSynchronize("stateless")









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






98




	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




	
	@DontSynchronize("only used by single thread")
	protected final Map<N,Set<D>> initialSeeds;
	
	@DontSynchronize("benign races")
	public long propagationCount;
	
	@DontSynchronize("stateless")
	protected final D zeroValue;
	
	@DontSynchronize("readOnly")
	protected final FlowFunctionCache<N,D,M> ffCache = null; 
	
	@DontSynchronize("readOnly")
	protected final boolean followReturnsPastSeeds;









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






114














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






115




	private LinkedList<PathEdgeProcessingTask> worklist;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






116




117




118




119




120




121




	
	
	/**
	 * Creates a solver for the given problem, which caches flow functions and edge functions.
	 * The solver must then be started by calling {@link #solve()}.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






122




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






123




124




125




126




127




128




129




130




131




		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
	}

	/**
	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling
	 * {@link #solve()}.
	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.
	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.
	 */









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






132




	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






133




134




135




136




137




138




		if(logger.isDebugEnabled())
			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
		this.zeroValue = tabulationProblem.zeroValue();
		this.icfg = tabulationProblem.interproceduralCFG();		
	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?
				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






139




		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






140




141




142




143




144




145




146




147




148




149




		/*if(flowFunctionCacheBuilder!=null) {
			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);
			flowFunctions = ffCache;
		} else {
			ffCache = null;
		}*/
		this.flowFunctions = flowFunctions;
		this.initialSeeds = tabulationProblem.initialSeeds();
		this.jumpFn = new JumpFunctions<N,D>();
		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






150




		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






151




		this.executor = getExecutor();









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






152




		this.worklist = Lists.newLinkedList();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






153




154




155




156




157




158




159




160




	}

	/**
	 * Runs the solver on the configured problem. This can take some time.
	 */
	public void solve() {		
		submitInitialSeeds();
		awaitCompletionComputeValuesAndShutdown();









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






161




		writeDebugFile();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






162




163




164




165




166




167




168




169




170




171




172




	}

	/**
	 * Schedules the processing of initial seeds, initiating the analysis.
	 * Clients should only call this methods if performing synchronization on
	 * their own. Normally, {@link #solve()} should be called instead.
	 */
	protected void submitInitialSeeds() {
		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {
			N startPoint = seed.getKey();
			for(D val: seed.getValue())









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






173




				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






174




175




176




177




178




179




180




181




182




			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
		}
	}

	/**
	 * Awaits the completion of the exploded super graph. When complete, computes result values,
	 * shuts down the executor and returns.
	 */
	protected void awaitCompletionComputeValuesAndShutdown() {









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






183




184




185




186




//		{
//			//run executor and await termination of tasks
//			runExecutorAndAwaitCompletion();
//		}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






187




188




189




190




191




192




		if(logger.isDebugEnabled())
			printStats();

		//ask executor to shut down;
		//this will cause new submissions to the executor to be rejected,
		//but at this point all tasks should have completed anyway









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






193




//		executor.shutdown();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






194




195




196




197




198




		//similarly here: we await termination, but this should happen instantaneously,
		//as all tasks should have completed
		runExecutorAndAwaitCompletion();
	}










field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






199




200




201




202




	protected boolean hasWork() {
		return !worklist.isEmpty();
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






203




204




	private int jobCounter = 0;
	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






205




206




207




208




	/**
	 * Runs execution, re-throwing exceptions that might be thrown during its execution.
	 */
	private void runExecutorAndAwaitCompletion() {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






209




210




211




212




213




214




215




216




217




218




//		try {
//			executor.awaitCompletion();
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//		Throwable exception = executor.getException();
//		if(exception!=null) {
//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);
//		}
		while(!worklist.isEmpty()) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






219




220




//			if(jobCounter % 100_000 == 0)
			









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






221




			PathEdgeProcessingTask current = worklist.removeLast();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






222




223




224




225




226




227




228




229




230




231




232




			int size = worklist.size();
			current.run();
			jobCounter++;
			M method = icfg.getMethodOf(current.edge.getTarget());
//			edgesPerMethod.put(method, current.edge);
//			if(edgesPerMethod.get(method).size() > 10_000) {
//				System.out.println(method);
//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {
//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));
//				}
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






233




			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






234




235




236




				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));
			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






237




238




//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +
//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






239




240




241




242




243




244




245




246




247




248




		}
	}

    /**
     * Dispatch the processing of a given edge. It may be executed in a different thread.
     * @param edge the edge to process
     */
    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){
    	// If the executor has been killed, there is little point
    	// in submitting new tasks









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






249




250




251




252




//    	if (executor.isTerminating())
//    		return;
//    	executor.execute(new PathEdgeProcessingTask(edge));
    	worklist.add(new PathEdgeProcessingTask(edge));









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






253




254




255




256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




    	propagationCount++;
    }
	
	/**
	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
	 * 
	 * For each possible callee, registers incoming call edges.
	 * Also propagates call-to-return flows and summarized callee flows within the caller. 
	 * 
	 * @param edge an edge whose target node resembles a method call
	 */
	private void processCall(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); // a call node; line 14...

        logger.trace("Processing call to {}", n);

		final D d2 = edge.factAtTarget();
		assert d2 != null;
		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
		
		//for each possible callee
		Collection<M> callees = icfg.getCalleesOfCallAt(n);
		for(M sCalledProcN: callees) { //still line 14
			//compute the call-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






278




			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






279




			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






280




281




282




			
			Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
			//for each result node of the call-flow function









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






283




			for(ConstrainedFact<FieldRef, D> d3: res) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






284




285




286




				//for each callee's start point(s)
				for(N sP: startPointsOf) {
					//create initial self-loop









avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015






287




					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






288




					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






289




290




291




292




				}
				
				//register the fact that <sp,d3> has an incoming edge from <n,d2>
				//line 15.1 of Naeem/Lhotak/Rodriguez









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






293




294




				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);
				if (!addIncoming(sCalledProcN, incomingEdge))









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






295




296




					continue;
				









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






297




				resumeEdges(sCalledProcN, d3.getFact());









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






298




299




				registerInterestedCaller(sCalledProcN, incomingEdge);
				









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






300




301




				
				//line 15.2









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






302




				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






303




304




305




306




307




308




					
				//still line 15.2 of Naeem/Lhotak/Rodriguez
				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,
				//create new caller-side jump functions to the return sites
				//because we have observed a potentially new incoming edge into <sP,d3>
				if (endSumm != null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






309




					for(SummaryEdge<D, N> summary: endSumm) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






310




311




						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);
						if(delta.isPresent()) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






312




313




314




315




316




							//for each return site
							for(N retSiteN: returnSiteNs) {
								//compute return-flow function
								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);
								//for each target value of the function









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






317




								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






318




									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






319




320




321




322




323




324




									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);
									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());
									
									AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);
									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);









handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014






325




326




								}
							}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






327




						}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






328




329




330




331




332




333




					}
			}
		}
		//line 17-19 of Naeem/Lhotak/Rodriguez		
		//process intra-procedural flows along call-to-return flow functions
		for (N returnSiteN : returnSiteNs) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






334




			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






335




			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






336




				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






337




338




339




		}
	}










edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






340




	private void resumeEdges(M method, D factAtMethodStartPoint) {









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






341




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






342




343




		if(edges != null) {
			for(PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






344




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






345




346




					if(edges.remove(edge))  {
						logger.trace("RESUME-EDGE: {}", edge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






347




						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






348




349




350




351




352




					}
				}
			}
		}
	}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






353




354




355




356




	
	private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {
		Set<PathEdge<N, D>> edges = pausedEdges.get(method);
		if(edges != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






357




358




359




			if(edges.size() > 100)
				System.out.println("Paused edges for method "+method+": "+edges.size());
			









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






360




			for(final PathEdge<N, D> edge : edges) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






361




				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






362




363




					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);
					









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






364




					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






365




366




367




					
					if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 
							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






368




369




370




						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();
							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






371




								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






372




								incomingEdge.getCallSite(), 









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






373




								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






374




								method,









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






375




								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






376




377




378




379




380




381




382




383




384




						}
						else {
							propagateConstrained(new CallConcretizationPathEdge<>(
									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 
									incomingEdge.getCallSite(), 
									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),
									method,
									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));
						}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






385




					}









Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014






386




387




388




389




				}
			}
		}
	}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






390














FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






391




392




393




394




395




396




397




	/**
	 * Computes the call flow function for the given call-site abstraction
	 * @param callFlowFunction The call flow function to compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the callee's start node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






398




	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






399




			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






400




401




402




403




404




405




406




407




408




409




410




411




		return callFlowFunction.computeTargets(d2);
	}

	/**
	 * Computes the call-to-return flow function for the given call-site
	 * abstraction
	 * @param callToReturnFlowFunction The call-to-return flow function to
	 * compute
	 * @param d1 The abstraction at the current method's start node.
	 * @param d2 The abstraction at the call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






412




	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






413




			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






414




415




416




417




418




419




420




421




422




423




424




425




426




427




428




429




430




431




432




433




434




435




436




		return callToReturnFlowFunction.computeTargets(d2);
	}
	
	/**
	 * Lines 21-32 of the algorithm.
	 * 
	 * Stores callee-side summaries.
	 * Also, at the side of the caller, propagates intra-procedural flows to return sites
	 * using those newly computed summaries.
	 * 
	 * @param edge an edge whose target node resembles a method exits
	 */
	protected void processExit(PathEdge<N,D> edge) {
		final N n = edge.getTarget(); // an exit node; line 21...
		M methodThatNeedsSummary = icfg.getMethodOf(n);
		
		final D d1 = edge.factAtSource();
		final D d2 = edge.factAtTarget();
		
		//for each of the method's start points, determine incoming calls
		
		//line 21.1 of Naeem/Lhotak/Rodriguez
		//register end-summary









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






437




438




		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);
		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






439




			return; //FIXME: should never be reached?! -> assert ?









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






440




441




442




		
		//for each incoming call edge already processed
		//(see processCall(..))









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






443




444




445




446




447




448




		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {
			// line 22
			N callSite = incomingEdge.getCallSite();
			// for each return site
			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {
				// compute return-flow function









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






449




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






450




				









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






451




				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






452




453




454




					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);
					if(delta.isPresent()) {
						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






455




456




	
						// for each incoming-call value









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






457




						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






458




							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






459




460




461




462




							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());
							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






463




						}









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






464




					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






465




466




				}
			}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






467




468




		}
		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






469




470




471




472




		
		//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow
		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only
		//be propagated into callers that have an incoming edge for this condition









bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015






473




		if(followReturnsPastSeeds && d1 == zeroValue) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






474




475




476




			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
			for(N c: callers) {
				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






477




					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






478




					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






479




480




481




482




483




484




485




					for(ConstrainedFact<FieldRef, D> d5: targets) {
						
						Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);
						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());
						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));
						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);
					}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






486




487




488




489




490




491




				}
			}
			//in cases where there are no callers, the return statement would normally not be processed at all;
			//this might be undesirable if the flow function has a side effect such as registering a taint;
			//instead we thus call the return flow function will a null caller
			if(callers.isEmpty()) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






492




				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






493




494




495




496




497




				retFunction.computeTargets(d2);
			}
		}
	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






498




499




500




501




502




503




504




505




506




507




508




509




510




511




512




513




514




515




516




517




518




519




520




521




522




523




524




525




526




527




528




529




530




531




532




533




534




535




536




537




538




539




540




541




542




543




544




545




546




547




548




549




550




551




552




553




554




555




556




557




558




559




560




561




562




563




564




565




566




567




568




569




570




571




572




573




574




575




576




577




578




579




580




581




582




583




584




585




586




587




588




589




590




591




592




593




594




595




596




597




598




599




600




601




602




603




604




605




606




607




608




609




610




611




612




613




614




615




616




617




618




619




620




621




622




623




624




625




626




627




628




629




630




631




632




633




634




635




636




637




638




639




640




641




642




643




644




645




646




647




648




649




650




651




652




653




654




655




656




657




658




659




660




661




662




663




664




665




666




667




668




669




670




671




672




673




674




675




676




677




678




679




680




681




682




683




684




685




686




687




688




689




690




691




692




693




694




695




696




697




698




699




700




701




702




703




704




705




706




707




708




709




710




711




712




713




714




715




716




717




718




719




720




721




722




723




724




725




726




727




728




729




730




731




732




733




734




735




736




737




738




739




740




741




742




743




744




745




746




747




748




749




750




751




752




753




754




755




756




757




758




759




760




761




762




763




764




765




766




767




768




769




770




771




772




773




774




775




776




777




778




779




780




781




782




783




784




785




786




787




788




789




790




791




	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();
	
	private Resolver getResolver(D sourceFact, D targetFact, N stmt) {
		HashKey key = new HashKey(sourceFact, targetFact, stmt);
		if(!returnSiteIncomingEdges.containsKey(key))
			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));
		return returnSiteIncomingEdges.get(key);
	}
	
	private class PausedReturnSiteEdge {

		private Constraint<FieldRef> constraint;
		private PathEdge<N, D> pathEdge;
		private AccessPath<FieldRef> alreadyResolvedAccPath;
		private D concretizedStmtFact;

		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {
			this.constraint = constraint;
			this.pathEdge = pathEdge;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
			this.concretizedStmtFact = concretizedStmtFact;
		}
	}
	
	class Resolver {

		private D sourceFact;
		private N stmt;
		private Set<IncomingFact> incomingFacts = Sets.newHashSet();
		private D targetFact;
		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();

		public Resolver(D sourceFact, D targetFact, N stmt) {
			this.sourceFact = sourceFact;
			this.targetFact = targetFact;
			this.stmt = stmt;
		}

		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {
				if(!fact.getAccessPath().hasResolver())
					throw new AssertionError();
				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))
					throw new AssertionError();
			}
			
			logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);
			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);
			incomingFacts.add(incFact);
			
			for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {
				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {
					propagate(edge.pathEdge, null, false);
					paused.remove(edge);
				}
			}
		}

		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {
			if(!visited.resolver.add(this))
				return false;
			
			alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);
			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);
			
			logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());
			
			boolean resolved = false;
			for(final IncomingFact incFact : incomingFacts) {
				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);
				if(resolved)
					break;
			}
			if(resolved) {
				propagate(pathEdge, null, false);
			} else {
				logger.trace("Pause {} at {}", pathEdge, stmt);
				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));
			}
			return resolved;
		}

		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,
				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {
			
			
			logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);
			
			if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {
				logger.trace("Resolved by incoming fact {}", incFact.fact);
				return true;
			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
				if(incFact.fact.getAccessPath().hasResolver()) {
					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();
					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);
					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(
								incFact.summaryEdge.getSourceFact(), 
								incFact.summaryEdge.getTargetStmt(), 
								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {

									@Override
									public void _propagate(D dSource, N target, D dTarget) {
										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);
									}
						}, decoratingResolver.alreadyResolvedAccPath, visited);
						if(resolved) {
							propagate(pathEdge, null, false);
							return true;
						}
					}
				}
				else {
					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));
					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {
						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);
						return true;
					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {
						if(factWithDelta.getAccessPath().hasResolver()) {
							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();
							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);
							
							final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);
							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {
								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);
								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));
								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {
									@Override
									protected void _propagate(D dSource, N target, D dTarget) {
										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);
									}
								};
								
								boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);
								if(resolved) {
									return true;
								}
							}
						}
						else {
							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));
							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);
							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(
									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 
									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {
										@Override
										protected void _propagate(D dSource, N target, D dTarget) {
											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);
										}
									}, visited);
							if(resolved)
								return true;
						}
					}
				}
			}
			return false;
		}
		
		@Override
		public String toString() {
			return stmt.toString();
		}
	}

	private class Visited {
		Set<Resolver> resolver = Sets.newHashSet();
		Map<N, Boolean> visitedCallSites = Maps.newHashMap();
	}
	
	class DecoratingResolver implements SubPathResolver<FieldRef> {
		
		private Resolver resolver;
		private AccessPath<FieldRef> alreadyResolvedAccPath;

		public DecoratingResolver(Resolver resolver) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();
		}
		
		public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {
			this.resolver = resolver;
			this.alreadyResolvedAccPath = alreadyResolvedAccPath;
		}
		
		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {
			return resolve(constraint, pathEdge, new Visited());
		}

		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {
			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());
			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			DecoratingResolver other = (DecoratingResolver) obj;
			if (alreadyResolvedAccPath == null) {
				if (other.alreadyResolvedAccPath != null)
					return false;
			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))
				return false;
			if (resolver == null) {
				if (other.resolver != null)
					return false;
			} else if (!resolver.equals(other.resolver))
				return false;
			return true;
		}
		
		@Override
		public String toString() {
			return alreadyResolvedAccPath+ ":"+resolver.toString();
		}

		@Override
		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {
			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));
		}
	}
	
	private class IncomingFact {

		private D fact;
		private Delta<FieldRef> delta;
		private SummaryEdge<D, N> summaryEdge;

		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {
			this.summaryEdge = summaryEdge;
			this.fact = fact;
			this.delta = delta;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((delta == null) ? 0 : delta.hashCode());
			result = prime * result + ((fact == null) ? 0 : fact.hashCode());
			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			IncomingFact other = (IncomingFact) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (delta == null) {
				if (other.delta != null)
					return false;
			} else if (!delta.equals(other.delta))
				return false;
			if (fact == null) {
				if (other.fact != null)
					return false;
			} else if (!fact.equals(other.fact))
				return false;
			if (summaryEdge == null) {
				if (other.summaryEdge != null)
					return false;
			} else if (!summaryEdge.equals(other.summaryEdge))
				return false;
			return true;
		}

		private FieldSensitiveIFDSSolver getOuterType() {
			return FieldSensitiveIFDSSolver.this;
		}
		
	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






792




793




794




795




796




797




798




799




	/**
	 * Computes the return flow function for the given set of caller-side
	 * abstractions.
	 * @param retFunction The return flow function to compute
	 * @param d2 The abstraction at the exit node in the callee
	 * @param callSite The call site
	 * @return The set of caller-side abstractions at the return site
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






800




	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






801




			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






802




803




804




805




806




807




808




809




		return retFunction.computeTargets(d2);
	}

	/**
	 * Lines 33-37 of the algorithm.
	 * Simply propagate normal, intra-procedural flows.
	 * @param edge
	 */









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






810




	@SuppressWarnings("unchecked")









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






811




812




813




814




815




816




	private void processNormalFlow(PathEdge<N,D> edge) {
		final D d1 = edge.factAtSource();
		final N n = edge.getTarget(); 
		final D d2 = edge.factAtTarget();
		
		for (N m : icfg.getSuccsOf(n)) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






817




			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






818




819




			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);
			for (ConstrainedFact<FieldRef, D> d3 : res) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






820




				if(d3.getConstraint() != null) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






821




822




823




824




825




					if(d3.getFact().getAccessPath().hasResolver()) {
						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());
						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));
					} else
						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






826




				}









handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015






827




				else









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






828




					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






829




830




831




832




			}
		}
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






833




	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






834




835




836




		if(fact.equals(zeroValue))
			return zeroValue;
		else









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






837




			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






838




	}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






839




	









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






840




	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






841




		return propagateConstrained(pathEdge, new Visited());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






842




843




	}
	









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






844




	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






845




		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






846




		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






847














cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






848




849




850




		boolean propagate = false;
		if(pathEdge.factAtSource().equals(zeroValue))
			propagate = true;









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






851




852




		else if(hasPausedEdges(calleeMethod, pathEdge))
			propagate = false;









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






853




854




		else {
			Set<N> callSitesWithInterest = Sets.newHashSet();









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






855




			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






856




				callSitesWithInterest.add(incEdge.getCallSite());









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






857




			}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






858




859




			propagate = !callSitesWithInterest.isEmpty();
			









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






860




861




862




863




864




865




866




			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());
			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);
			
			for(IncomingEdge<D, N> incEdge : candidates) { //potential
				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {
					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)
						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






867




868




				}
				else {









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






869




					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






870




871




872




873




874




875




876




877




878




879




880




881




882




883




884




885




886




887




888




889




890




891




892




893




894




895




896




897




898




899




900




901




902




903




						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();
								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);
								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(
										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));
								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 
										calleeMethod,
										calleeSourceFact), visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}
						}
						else {
							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());
							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 
									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {
					
								PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(
										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 
										incEdge.getCallSite(), 
										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),
										calleeMethod,
										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));
								visited.visitedCallSites.put(incEdge.getCallSite(), null);
								boolean result = propagateConstrained(callerEdge, visited);
								visited.visitedCallSites.put(incEdge.getCallSite(), result);
								propagate |= result;
							}









Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015






904




						}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






905




					}









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






906




				}









annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014






907




			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






908




		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






909




		









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






910




		if(propagate) {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






911




			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






912




913




914




915




916




917




			return true;
		} else {
			pauseEdge(pathEdge);
			return false;
		}
	}









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






918














abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






919




920




921




922




923




924




925




926




927




928




929




930




931




932




933




	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {
		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();
		for(IncomingEdge<D, N> incEdge : candidates) {
			if(result.containsKey(incEdge.getCallSite())) {
				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());
				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {
					result.put(incEdge.getCallSite(), incEdge);
				}
			}
			else
				result.put(incEdge.getCallSite(), incEdge);
		}
		return result.values();
	}










Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






934




935




936




937




	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {
		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);
		if(pe != null) {
			for(PathEdge<N, D> edge : pe) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






938




				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)









Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015






939




940




941




942




943




944




					return true;
			}
		}
		return false;
	}










cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






945




946




	private void pauseEdge(PathEdge<N,D> edge) {
		M method = icfg.getMethodOf(edge.getTarget());









changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015






947




		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






948




949




950




		if(edges.add(edge)) {
			logger.trace("PAUSED: {}: {}", method, edge);
		}









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






951




952




	}
	









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






953




954




955




956




957




958




959




960




	/**
	 * Computes the normal flow function for the given set of start and end
	 * abstractions.
	 * @param flowFunction The normal flow function to compute
	 * @param d1 The abstraction at the method's start node
	 * @param d1 The abstraction at the current node
	 * @return The set of abstractions at the successor node
	 */









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






961




	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction









cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015






962




			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






963




964




965




966




967




968




969




970




971




972




973




974




975




976




977




978




979




980




981




982




		return flowFunction.computeTargets(d2);
	}
	
	/**
	 * This method will be called for each incoming edge and can be used to
	 * transfer knowledge from the calling edge to the returning edge, without
	 * affecting the summary edges at the callee.
	 * 
	 * @param d4
	 *            Fact stored with the incoming edge, i.e., present at the
	 *            caller side
	 * @param d5
	 *            Fact that originally should be propagated to the caller.
	 * @return Fact that will be propagated to the caller.
	 */
	protected D restoreContextOnReturnedFact(D d4, D d5) {
		d5.setCallingContext(d4);
		return d5;
	}
	









field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015






983




984




985




986




	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,
			/* deliberately exposed to clients */ N relatedCallSite) {
		propagate(edge, relatedCallSite, true);
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






987




	









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






988




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






989




990




991




992




	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();
	private int cacheHits = 0;
	private int cacheMerges = 0;
	private int cacheOppositePrefix = 0;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






993




994




995




	private int cacheSourceBaseValue = 0;
	private int concretizationEdges = 0;
	private int cacheEquals = 0;









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






996




997




	/**
	 * Propagates the flow further down the exploded super graph. 









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






998




	 * @param edge the PathEdge that should be propagated









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






999




1000




	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 








FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1
/*******************************************************************************/*******************************************************************************



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

2
 * Copyright (c) 2014 Johannes Lerch, Johannes Späth. * Copyright (c) 2014 Johannes Lerch, Johannes Späth.



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

3

4

5

6

7

8
 * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors:



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

9
 *     Johannes Lerch, Johannes Späth - initial API and implementation *     Johannes Lerch, Johannes Späth - initial API and implementation



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

10

11

12
 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

13

14

15

16
import heros.DontSynchronize;importheros.DontSynchronize;import heros.FlowFunctionCache;importheros.FlowFunctionCache;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SynchronizedBy;importheros.SynchronizedBy;



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

17
import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

18
import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

19
import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;importheros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

20
import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

21
import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

22

23
import heros.solver.CountingThreadPoolExecutor;importheros.solver.CountingThreadPoolExecutor;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

24
import heros.solver.Pair;importheros.solver.Pair;



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

25

26
import heros.solver.PathEdge;importheros.solver.PathEdge;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

27

28

29

30

31

32
import java.io.BufferedOutputStream;importjava.io.BufferedOutputStream;import java.io.FileNotFoundException;importjava.io.FileNotFoundException;import java.io.FileOutputStream;importjava.io.FileOutputStream;import java.io.FileWriter;importjava.io.FileWriter;import java.io.IOException;importjava.io.IOException;import java.util.Arrays;importjava.util.Arrays;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

33

34
import java.util.Collection;importjava.util.Collection;import java.util.Collections;importjava.util.Collections;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

35

36
import java.util.Comparator;importjava.util.Comparator;import java.util.Enumeration;importjava.util.Enumeration;



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

37
import java.util.HashMap;importjava.util.HashMap;



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

38
import java.util.Iterator;importjava.util.Iterator;



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

39
import java.util.LinkedList;importjava.util.LinkedList;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

40
import java.util.List;importjava.util.List;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

41

42
import java.util.Map;importjava.util.Map;import java.util.Map.Entry;importjava.util.Map.Entry;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

43
import java.util.PriorityQueue;importjava.util.PriorityQueue;



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

44
import java.util.Set;importjava.util.Set;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

45

46

47

48

49

50
import java.util.concurrent.LinkedBlockingQueue;importjava.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;importjava.util.concurrent.TimeUnit;import org.slf4j.Logger;importorg.slf4j.Logger;import org.slf4j.LoggerFactory;importorg.slf4j.LoggerFactory;



handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015



handling for writing fields / excluding access paths


 

 

handling for writing fields / excluding access paths

 

Johannes Lerch
committed
Jan 05, 2015

51
import com.google.common.base.Optional;importcom.google.common.base.Optional;



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

52
import com.google.common.base.Predicate;importcom.google.common.base.Predicate;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

53
import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

54
import com.google.common.collect.HashMultimap;importcom.google.common.collect.HashMultimap;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

55
import com.google.common.collect.Iterators;importcom.google.common.collect.Iterators;



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

56
import com.google.common.collect.Lists;importcom.google.common.collect.Lists;



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

57
import com.google.common.collect.Maps;importcom.google.common.collect.Maps;



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

58
import com.google.common.collect.Sets;importcom.google.common.collect.Sets;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

59
import com.sun.org.apache.xpath.internal.axes.IteratorPool;importcom.sun.org.apache.xpath.internal.axes.IteratorPool;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

60




merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015



merge only on equal field types


 

 

merge only on equal field types

 

Johannes Lerch
committed
Feb 05, 2015

61
public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<BaseValue,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>{



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85
	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevelpublicstaticCacheBuilder<Object,Object>DEFAULT_CACHE_BUILDER=CacheBuilder.newBuilder().concurrencyLevel			(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();	    protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);protectedstaticfinalLoggerlogger=LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);    //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace//enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace    public static final boolean DEBUG = logger.isDebugEnabled();publicstaticfinalbooleanDEBUG=logger.isDebugEnabled();	protected CountingThreadPoolExecutor executor;protectedCountingThreadPoolExecutorexecutor;		@DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread")	protected int numThreads;protectedintnumThreads;		@SynchronizedBy("thread safe data structure, consistent locking when used")@SynchronizedBy("thread safe data structure, consistent locking when used")	protected final JumpFunctions<N,D> jumpFn;protectedfinalJumpFunctions<N,D>jumpFn;		@SynchronizedBy("thread safe data structure, only modified internally")@SynchronizedBy("thread safe data structure, only modified internally")	protected final I icfg;protectedfinalIicfg;		//stores summaries that were queried before they were computed//stores summaries that were queried before they were computed	//see CC 2010 paper by Naeem, Lhotak and Rodriguez//see CC 2010 paper by Naeem, Lhotak and Rodriguez	@SynchronizedBy("consistent lock on 'incoming'")@SynchronizedBy("consistent lock on 'incoming'")



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

86

87
	protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =protectedfinalMyConcurrentHashMap<M,Set<SummaryEdge<D,N>>>endSummary=			new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();newMyConcurrentHashMap<M,Set<SummaryEdge<D,N>>>();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

88

89

90

91
		//edges going along calls//edges going along calls	//see CC 2010 paper by Naeem, Lhotak and Rodriguez//see CC 2010 paper by Naeem, Lhotak and Rodriguez	@SynchronizedBy("consistent lock on field")@SynchronizedBy("consistent lock on field")



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

92

93
	protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =protectedfinalMyConcurrentHashMap<M,Set<IncomingEdge<D,N>>>incoming=			new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();newMyConcurrentHashMap<M,Set<IncomingEdge<D,N>>>();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

94
	



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

95
	protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();protectedfinalMyConcurrentHashMap<M,ConcurrentHashSet<PathEdge<N,D>>>pausedEdges=newMyConcurrentHashMap<M,ConcurrentHashSet<PathEdge<N,D>>>();



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

96
	



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

97
	@DontSynchronize("stateless")@DontSynchronize("stateless")



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

98
	protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;protectedfinalFlowFunctions<N,FieldRef,D,M>flowFunctions;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113
		@DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread")	protected final Map<N,Set<D>> initialSeeds;protectedfinalMap<N,Set<D>>initialSeeds;		@DontSynchronize("benign races")@DontSynchronize("benign races")	public long propagationCount;publiclongpropagationCount;		@DontSynchronize("stateless")@DontSynchronize("stateless")	protected final D zeroValue;protectedfinalDzeroValue;		@DontSynchronize("readOnly")@DontSynchronize("readOnly")	protected final FlowFunctionCache<N,D,M> ffCache = null; protectedfinalFlowFunctionCache<N,D,M>ffCache=null;		@DontSynchronize("readOnly")@DontSynchronize("readOnly")	protected final boolean followReturnsPastSeeds;protectedfinalbooleanfollowReturnsPastSeeds;



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

114




subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

115
	private LinkedList<PathEdgeProcessingTask> worklist;privateLinkedList<PathEdgeProcessingTask>worklist;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

116

117

118

119

120

121
			/**/**	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * The solver must then be started by calling {@link #solve()}.	 * The solver must then be started by calling {@link #solve()}.	 */	 */



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

122
	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I>tabulationProblem){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

123

124

125

126

127

128

129

130

131
		this(tabulationProblem, DEFAULT_CACHE_BUILDER);this(tabulationProblem,DEFAULT_CACHE_BUILDER);	}}	/**/**	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling	 * {@link #solve()}.	 * {@link #solve()}.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 */	 */



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

132
	public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I>tabulationProblem,@SuppressWarnings("rawtypes")CacheBuilderflowFunctionCacheBuilder){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

133

134

135

136

137

138
		if(logger.isDebugEnabled())if(logger.isDebugEnabled())			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();flowFunctionCacheBuilder=flowFunctionCacheBuilder.recordStats();		this.zeroValue = tabulationProblem.zeroValue();this.zeroValue=tabulationProblem.zeroValue();		this.icfg = tabulationProblem.interproceduralCFG();		this.icfg=tabulationProblem.interproceduralCFG();	/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

139
		FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); FlowFunctions<N,FieldRef,D,M>flowFunctions=tabulationProblem.flowFunctions();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

140

141

142

143

144

145

146

147

148

149
		/*if(flowFunctionCacheBuilder!=null) {/*if(flowFunctionCacheBuilder!=null) {			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);			flowFunctions = ffCache;			flowFunctions = ffCache;		} else {		} else {			ffCache = null;			ffCache = null;		}*/		}*/		this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions;		this.initialSeeds = tabulationProblem.initialSeeds();this.initialSeeds=tabulationProblem.initialSeeds();		this.jumpFn = new JumpFunctions<N,D>();this.jumpFn=newJumpFunctions<N,D>();		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();this.followReturnsPastSeeds=tabulationProblem.followReturnsPastSeeds();



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

150
		this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safethis.numThreads=1;//Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

151
		this.executor = getExecutor();this.executor=getExecutor();



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

152
		this.worklist = Lists.newLinkedList();this.worklist=Lists.newLinkedList();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

153

154

155

156

157

158

159

160
	}}	/**/**	 * Runs the solver on the configured problem. This can take some time.	 * Runs the solver on the configured problem. This can take some time.	 */	 */	public void solve() {		publicvoidsolve(){		submitInitialSeeds();submitInitialSeeds();		awaitCompletionComputeValuesAndShutdown();awaitCompletionComputeValuesAndShutdown();



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

161
		writeDebugFile();writeDebugFile();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

162

163

164

165

166

167

168

169

170

171

172
	}}	/**/**	 * Schedules the processing of initial seeds, initiating the analysis.	 * Schedules the processing of initial seeds, initiating the analysis.	 * Clients should only call this methods if performing synchronization on	 * Clients should only call this methods if performing synchronization on	 * their own. Normally, {@link #solve()} should be called instead.	 * their own. Normally, {@link #solve()} should be called instead.	 */	 */	protected void submitInitialSeeds() {protectedvoidsubmitInitialSeeds(){		for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {for(Entry<N,Set<D>>seed:initialSeeds.entrySet()){			N startPoint = seed.getKey();NstartPoint=seed.getKey();			for(D val: seed.getValue())for(Dval:seed.getValue())



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

173
				propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);propagate(newPathEdge<>(zeroValue,startPoint,val),null,false);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

174

175

176

177

178

179

180

181

182
			jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));jumpFn.addFunction(newPathEdge<N,D>(zeroValue,startPoint,zeroValue));		}}	}}	/**/**	 * Awaits the completion of the exploded super graph. When complete, computes result values,	 * Awaits the completion of the exploded super graph. When complete, computes result values,	 * shuts down the executor and returns.	 * shuts down the executor and returns.	 */	 */	protected void awaitCompletionComputeValuesAndShutdown() {protectedvoidawaitCompletionComputeValuesAndShutdown(){



field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015



field-sensitive version of the BiDi solver 


 

 

field-sensitive version of the BiDi solver 

 

Johannes Lerch
committed
Jan 29, 2015

183

184

185

186
//		{//		{//			//run executor and await termination of tasks//			//run executor and await termination of tasks//			runExecutorAndAwaitCompletion();//			runExecutorAndAwaitCompletion();//		}//		}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

187

188

189

190

191

192
		if(logger.isDebugEnabled())if(logger.isDebugEnabled())			printStats();printStats();		//ask executor to shut down;//ask executor to shut down;		//this will cause new submissions to the executor to be rejected,//this will cause new submissions to the executor to be rejected,		//but at this point all tasks should have completed anyway//but at this point all tasks should have completed anyway



field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015



field-sensitive version of the BiDi solver 


 

 

field-sensitive version of the BiDi solver 

 

Johannes Lerch
committed
Jan 29, 2015

193
//		executor.shutdown();//		executor.shutdown();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

194

195

196

197

198
		//similarly here: we await termination, but this should happen instantaneously,//similarly here: we await termination, but this should happen instantaneously,		//as all tasks should have completed//as all tasks should have completed		runExecutorAndAwaitCompletion();runExecutorAndAwaitCompletion();	}}



field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015



field-sensitive version of the BiDi solver 


 

 

field-sensitive version of the BiDi solver 

 

Johannes Lerch
committed
Jan 29, 2015

199

200

201

202
	protected boolean hasWork() {protectedbooleanhasWork(){		return !worklist.isEmpty();return!worklist.isEmpty();	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

203

204
	private int jobCounter = 0;privateintjobCounter=0;	private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();privateHashMultimap<M,PathEdge<N,D>>edgesPerMethod=HashMultimap.create();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

205

206

207

208
	/**/**	 * Runs execution, re-throwing exceptions that might be thrown during its execution.	 * Runs execution, re-throwing exceptions that might be thrown during its execution.	 */	 */	private void runExecutorAndAwaitCompletion() {privatevoidrunExecutorAndAwaitCompletion(){



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

209

210

211

212

213

214

215

216

217

218
//		try {//		try {//			executor.awaitCompletion();//			executor.awaitCompletion();//		} catch (InterruptedException e) {//		} catch (InterruptedException e) {//			e.printStackTrace();//			e.printStackTrace();//		}//		}//		Throwable exception = executor.getException();//		Throwable exception = executor.getException();//		if(exception!=null) {//		if(exception!=null) {//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);//		}//		}		while(!worklist.isEmpty()) {while(!worklist.isEmpty()){



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

219

220
//			if(jobCounter % 100_000 == 0)//			if(jobCounter % 100_000 == 0)			



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

221
			PathEdgeProcessingTask current = worklist.removeLast();PathEdgeProcessingTaskcurrent=worklist.removeLast();



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

222

223

224

225

226

227

228

229

230

231

232
			int size = worklist.size();intsize=worklist.size();			current.run();current.run();			jobCounter++;jobCounter++;			M method = icfg.getMethodOf(current.edge.getTarget());Mmethod=icfg.getMethodOf(current.edge.getTarget());//			edgesPerMethod.put(method, current.edge);//			edgesPerMethod.put(method, current.edge);//			if(edgesPerMethod.get(method).size() > 10_000) {//			if(edgesPerMethod.get(method).size() > 10_000) {//				System.out.println(method);//				System.out.println(method);//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));//				}//				}//			}//			}



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

233
			if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {if(worklist.size()>size+100||jobCounter%10_000==0){



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

234

235

236
				System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ",size,worklist.size(),jobCounter)+						String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s",method,current.edge.factAtSource(),current.edge.factAtTarget(),current.edge.getTarget()));			}}



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

237

238
//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

239

240

241

242

243

244

245

246

247

248
		}}	}}    /**/**     * Dispatch the processing of a given edge. It may be executed in a different thread.     * Dispatch the processing of a given edge. It may be executed in a different thread.     * @param edge the edge to process     * @param edge the edge to process     */     */    protected void scheduleEdgeProcessing(PathEdge<N,D> edge){protectedvoidscheduleEdgeProcessing(PathEdge<N,D>edge){    	// If the executor has been killed, there is little point// If the executor has been killed, there is little point    	// in submitting new tasks// in submitting new tasks



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

249

250

251

252
//    	if (executor.isTerminating())//    	if (executor.isTerminating())//    		return;//    		return;//    	executor.execute(new PathEdgeProcessingTask(edge));//    	executor.execute(new PathEdgeProcessingTask(edge));    	worklist.add(new PathEdgeProcessingTask(edge));worklist.add(newPathEdgeProcessingTask(edge));



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277
    	propagationCount++;propagationCount++;    }}		/**/**	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.	 * 	 * 	 * For each possible callee, registers incoming call edges.	 * For each possible callee, registers incoming call edges.	 * Also propagates call-to-return flows and summarized callee flows within the caller. 	 * Also propagates call-to-return flows and summarized callee flows within the caller. 	 * 	 * 	 * @param edge an edge whose target node resembles a method call	 * @param edge an edge whose target node resembles a method call	 */	 */	private void processCall(PathEdge<N,D> edge) {privatevoidprocessCall(PathEdge<N,D>edge){		final D d1 = edge.factAtSource();finalDd1=edge.factAtSource();		final N n = edge.getTarget(); // a call node; line 14...finalNn=edge.getTarget();// a call node; line 14...        logger.trace("Processing call to {}", n);logger.trace("Processing call to {}",n);		final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();		assert d2 != null;assertd2!=null;		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);Collection<N>returnSiteNs=icfg.getReturnSitesOfCallAt(n);				//for each possible callee//for each possible callee		Collection<M> callees = icfg.getCalleesOfCallAt(n);Collection<M>callees=icfg.getCalleesOfCallAt(n);		for(M sCalledProcN: callees) { //still line 14for(MsCalledProcN:callees){//still line 14			//compute the call-flow function//compute the call-flow function



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

278
			FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);FlowFunction<FieldRef,D>function=flowFunctions.getCallFlowFunction(n,sCalledProcN);



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

279
			Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);Set<ConstrainedFact<FieldRef,D>>res=computeCallFlowFunction(function,d1,d2);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

280

281

282
						Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);Collection<N>startPointsOf=icfg.getStartPointsOf(sCalledProcN);			//for each result node of the call-flow function//for each result node of the call-flow function



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

283
			for(ConstrainedFact<FieldRef, D> d3: res) {for(ConstrainedFact<FieldRef,D>d3:res){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

284

285

286
				//for each callee's start point(s)//for each callee's start point(s)				for(N sP: startPointsOf) {for(NsP:startPointsOf){					//create initial self-loop//create initial self-loop



avoiding unnecessary calls to clone a fact


 

 


Johannes Lerch
committed
Jan 08, 2015



avoiding unnecessary calls to clone a fact


 

 

avoiding unnecessary calls to clone a fact

 

Johannes Lerch
committed
Jan 08, 2015

287
					D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());DabstractStartPointFact=AccessPathUtil.cloneWithAccessPath(d3.getFact(),newAccessPath<FieldRef>());



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

288
					propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15propagate(newPathEdge<>(abstractStartPointFact,sP,abstractStartPointFact),n,false);//line 15



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

289

290

291

292
				}}								//register the fact that <sp,d3> has an incoming edge from <n,d2>//register the fact that <sp,d3> has an incoming edge from <n,d2>				//line 15.1 of Naeem/Lhotak/Rodriguez//line 15.1 of Naeem/Lhotak/Rodriguez



handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014



handling the case that incoming edge is prefix of existing summary


 

 

handling the case that incoming edge is prefix of existing summary

 

Johannes Lerch
committed
Nov 27, 2014

293

294
				IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);IncomingEdge<D,N>incomingEdge=newIncomingEdge<D,N>(d3.getFact(),n,d1,d2);				if (!addIncoming(sCalledProcN, incomingEdge))if(!addIncoming(sCalledProcN,incomingEdge))



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

295

296
					continue;continue;				



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

297
				resumeEdges(sCalledProcN, d3.getFact());resumeEdges(sCalledProcN,d3.getFact());



Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014



Bug/test fixes


 

 

Bug/test fixes

 

Johannes Lerch
committed
Dec 10, 2014

298

299
				registerInterestedCaller(sCalledProcN, incomingEdge);registerInterestedCaller(sCalledProcN,incomingEdge);				



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

300

301
								//line 15.2//line 15.2



annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014



annotated facts (WIP)


 

 

annotated facts (WIP)

 

Johannes Lerch
committed
Nov 13, 2014

302
				Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());Set<SummaryEdge<D,N>>endSumm=endSummary(sCalledProcN,d3.getFact());



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

303

304

305

306

307

308
									//still line 15.2 of Naeem/Lhotak/Rodriguez//still line 15.2 of Naeem/Lhotak/Rodriguez				//for each already-queried exit value <eP,d4> reachable from <sP,d3>,//for each already-queried exit value <eP,d4> reachable from <sP,d3>,				//create new caller-side jump functions to the return sites//create new caller-side jump functions to the return sites				//because we have observed a potentially new incoming edge into <sP,d3>//because we have observed a potentially new incoming edge into <sP,d3>				if (endSumm != null)if(endSumm!=null)



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

309
					for(SummaryEdge<D, N> summary: endSumm) {for(SummaryEdge<D,N>summary:endSumm){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

310

311
						Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);Optional<Delta<FieldRef>>delta=AccessPathUtil.getDelta(d3.getFact(),summary);						if(delta.isPresent()) {if(delta.isPresent()){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

312

313

314

315

316
							//for each return site//for each return site							for(N retSiteN: returnSiteNs) {for(NretSiteN:returnSiteNs){								//compute return-flow function//compute return-flow function								FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN);								//for each target value of the function//for each target value of the function



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

317
								for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {for(ConstrainedFact<FieldRef,D>d5:computeReturnFlowFunction(retFunction,summary.getTargetFact(),n)){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

318
									D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());Dd5p_restoredCtx=restoreContextOnReturnedFact(d2,d5.getFact());



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

319

320

321

322

323

324
									Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);Resolverresolver=getResolver(d1,d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()),retSiteN);									resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());resolver.addIncomingFact(summary,d5p_restoredCtx,delta.get());																		AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));AccessPath<FieldRef>abstractedAccPath=newAccessPath<FieldRef>().setResolver(newDecoratingResolver(resolver));									D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);DabstractedTargetFact=d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);									propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);propagate(newPathEdge<>(d1,retSiteN,abstractedTargetFact),n,false);



handling the case that incoming edge is prefix of existing summary


 

 


Johannes Lerch
committed
Nov 27, 2014



handling the case that incoming edge is prefix of existing summary


 

 

handling the case that incoming edge is prefix of existing summary

 

Johannes Lerch
committed
Nov 27, 2014

325

326
								}}							}}



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

327
						}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

328

329

330

331

332

333
					}}			}}		}}		//line 17-19 of Naeem/Lhotak/Rodriguez		//line 17-19 of Naeem/Lhotak/Rodriguez				//process intra-procedural flows along call-to-return flow functions//process intra-procedural flows along call-to-return flow functions		for (N returnSiteN : returnSiteNs) {for(NreturnSiteN:returnSiteNs){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

334
			FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);FlowFunction<FieldRef,D>callToReturnFlowFunction=flowFunctions.getCallToReturnFlowFunction(n,returnSiteN);



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

335
			for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))for(ConstrainedFact<FieldRef,D>d3:computeCallToReturnFlowFunction(callToReturnFlowFunction,d1,d2))



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

336
				propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);propagate(newPathEdge<>(d1,returnSiteN,d3.getFact()),n,false);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

337

338

339
		}}	}}



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

340
	private void resumeEdges(M method, D factAtMethodStartPoint) {privatevoidresumeEdges(Mmethod,DfactAtMethodStartPoint){



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

341
		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);ConcurrentHashSet<PathEdge<N,D>>edges=pausedEdges.get(method);



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

342

343
		if(edges != null) {if(edges!=null){			for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

344
				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(edge.factAtSource(),factAtMethodStartPoint)==PrefixTestResult.GUARANTEED_PREFIX){



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

345

346
					if(edges.remove(edge))  {if(edges.remove(edge)){						logger.trace("RESUME-EDGE: {}", edge);logger.trace("RESUME-EDGE: {}",edge);



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

347
						propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);propagate(edge,edgeinstanceofCallConcretizationPathEdge?edge.getTarget():null,false);



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

348

349

350

351

352
					}}				}}			}}		}}	}}



Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014



Bug/test fixes


 

 

Bug/test fixes

 

Johannes Lerch
committed
Dec 10, 2014

353

354

355

356
		private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {privatevoidregisterInterestedCaller(Mmethod,IncomingEdge<D,N>incomingEdge){		Set<PathEdge<N, D>> edges = pausedEdges.get(method);Set<PathEdge<N,D>>edges=pausedEdges.get(method);		if(edges != null) {if(edges!=null){



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

357

358

359
			if(edges.size() > 100)if(edges.size()>100)				System.out.println("Paused edges for method "+method+": "+edges.size());System.out.println("Paused edges for method "+method+": "+edges.size());			



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

360
			for(final PathEdge<N, D> edge : edges) {for(finalPathEdge<N,D>edge:edges){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

361
				if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(),edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){



Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014



Bug/test fixes


 

 

Bug/test fixes

 

Johannes Lerch
committed
Dec 10, 2014

362

363
					logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}",edge,incomingEdge);					



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

364
					Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());Constraint<FieldRef>constraint=newDeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(),edge.factAtSource().getAccessPath());



Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015



Bug fix: check for possibility before applying DeltaConstraint


 

 

Bug fix: check for possibility before applying DeltaConstraint

 

Johannes Lerch
committed
Jan 30, 2015

365

366

367
										if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath())&&							constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

368

369

370
						if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()){							DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();							decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(decoratingResolver.resolve(constraint,newCallConcretizationPathEdge<>(



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

371
								applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), applyConstraint(constraint,incomingEdge.getCallerSourceFact(),true),



Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015



Bug fix: check for possibility before applying DeltaConstraint


 

 

Bug fix: check for possibility before applying DeltaConstraint

 

Johannes Lerch
committed
Jan 30, 2015

372
								incomingEdge.getCallSite(), incomingEdge.getCallSite(),



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

373
								applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),applyConstraint(constraint,incomingEdge.getCallerCallSiteFact(),false),



Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015



Bug fix: check for possibility before applying DeltaConstraint


 

 

Bug fix: check for possibility before applying DeltaConstraint

 

Johannes Lerch
committed
Jan 30, 2015

374
								method,method,



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

375
								applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));applyConstraint(constraint,incomingEdge.getCalleeSourceFact(),true)));



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

376

377

378

379

380

381

382

383

384
						}}						else {else{							propagateConstrained(new CallConcretizationPathEdge<>(propagateConstrained(newCallConcretizationPathEdge<>(									applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), applyConstraint(constraint,incomingEdge.getCallerSourceFact(),true),									incomingEdge.getCallSite(), incomingEdge.getCallSite(),									applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),applyConstraint(constraint,incomingEdge.getCallerCallSiteFact(),false),									method,method,									applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));applyConstraint(constraint,incomingEdge.getCalleeSourceFact(),true)));						}}



Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015



Bug fix: check for possibility before applying DeltaConstraint


 

 

Bug fix: check for possibility before applying DeltaConstraint

 

Johannes Lerch
committed
Jan 30, 2015

385
					}}



Bug/test fixes


 

 


Johannes Lerch
committed
Dec 10, 2014



Bug/test fixes


 

 

Bug/test fixes

 

Johannes Lerch
committed
Dec 10, 2014

386

387

388

389
				}}			}}		}}	}}



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

390




FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

391

392

393

394

395

396

397
	/**/**	 * Computes the call flow function for the given call-site abstraction	 * Computes the call flow function for the given call-site abstraction	 * @param callFlowFunction The call flow function to compute	 * @param callFlowFunction The call flow function to compute	 * @param d1 The abstraction at the current method's start node.	 * @param d1 The abstraction at the current method's start node.	 * @param d2 The abstraction at the call site	 * @param d2 The abstraction at the call site	 * @return The set of caller-side abstractions at the callee's start node	 * @return The set of caller-side abstractions at the callee's start node	 */	 */



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

398
	protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeCallFlowFunction



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

399
			(FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {(FlowFunction<FieldRef,D>callFlowFunction,Dd1,Dd2){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

400

401

402

403

404

405

406

407

408

409

410

411
		return callFlowFunction.computeTargets(d2);returncallFlowFunction.computeTargets(d2);	}}	/**/**	 * Computes the call-to-return flow function for the given call-site	 * Computes the call-to-return flow function for the given call-site	 * abstraction	 * abstraction	 * @param callToReturnFlowFunction The call-to-return flow function to	 * @param callToReturnFlowFunction The call-to-return flow function to	 * compute	 * compute	 * @param d1 The abstraction at the current method's start node.	 * @param d1 The abstraction at the current method's start node.	 * @param d2 The abstraction at the call site	 * @param d2 The abstraction at the call site	 * @return The set of caller-side abstractions at the return site	 * @return The set of caller-side abstractions at the return site	 */	 */



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

412
	protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeCallToReturnFlowFunction



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

413
			(FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {(FlowFunction<FieldRef,D>callToReturnFlowFunction,Dd1,Dd2){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

414

415

416

417

418

419

420

421

422

423

424

425

426

427

428

429

430

431

432

433

434

435

436
		return callToReturnFlowFunction.computeTargets(d2);returncallToReturnFlowFunction.computeTargets(d2);	}}		/**/**	 * Lines 21-32 of the algorithm.	 * Lines 21-32 of the algorithm.	 * 	 * 	 * Stores callee-side summaries.	 * Stores callee-side summaries.	 * Also, at the side of the caller, propagates intra-procedural flows to return sites	 * Also, at the side of the caller, propagates intra-procedural flows to return sites	 * using those newly computed summaries.	 * using those newly computed summaries.	 * 	 * 	 * @param edge an edge whose target node resembles a method exits	 * @param edge an edge whose target node resembles a method exits	 */	 */	protected void processExit(PathEdge<N,D> edge) {protectedvoidprocessExit(PathEdge<N,D>edge){		final N n = edge.getTarget(); // an exit node; line 21...finalNn=edge.getTarget();// an exit node; line 21...		M methodThatNeedsSummary = icfg.getMethodOf(n);MmethodThatNeedsSummary=icfg.getMethodOf(n);				final D d1 = edge.factAtSource();finalDd1=edge.factAtSource();		final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();				//for each of the method's start points, determine incoming calls//for each of the method's start points, determine incoming calls				//line 21.1 of Naeem/Lhotak/Rodriguez//line 21.1 of Naeem/Lhotak/Rodriguez		//register end-summary//register end-summary



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

437

438
		SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);SummaryEdge<D,N>summaryEdge=newSummaryEdge<D,N>(d1,n,d2);		if (!addEndSummary(methodThatNeedsSummary, summaryEdge))if(!addEndSummary(methodThatNeedsSummary,summaryEdge))



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

439
			return; //FIXME: should never be reached?! -> assert ?return;//FIXME: should never be reached?! -> assert ?



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

440

441

442
				//for each incoming call edge already processed//for each incoming call edge already processed		//(see processCall(..))//(see processCall(..))



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

443

444

445

446

447

448
		for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {for(IncomingEdge<D,N>incomingEdge:incoming(methodThatNeedsSummary)){			// line 22// line 22			N callSite = incomingEdge.getCallSite();NcallSite=incomingEdge.getCallSite();			// for each return site// for each return site			for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(callSite)){				// compute return-flow function// compute return-flow function



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

449
				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC);



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

450
				



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

451
				if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(d1,incomingEdge.getCalleeSourceFact())==PrefixTestResult.GUARANTEED_PREFIX){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

452

453

454
					Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);Optional<Delta<FieldRef>>delta=AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(),summaryEdge);					if(delta.isPresent()) {if(delta.isPresent()){						Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);Set<ConstrainedFact<FieldRef,D>>callerTargetFacts=computeReturnFlowFunction(retFunction,d2,callSite);



handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015



handling for writing fields / excluding access paths


 

 

handling for writing fields / excluding access paths

 

Johannes Lerch
committed
Jan 05, 2015

455

456
							// for each incoming-call value// for each incoming-call value



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

457
						for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {for(ConstrainedFact<FieldRef,D>callerTargetAnnotatedFact:callerTargetFacts){



handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015



handling for writing fields / excluding access paths


 

 

handling for writing fields / excluding access paths

 

Johannes Lerch
committed
Jan 05, 2015

458
							D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact());



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

459

460

461

462
							Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);Resolverresolver=getResolver(incomingEdge.getCallerSourceFact(),callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()),retSiteC);							resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());resolver.addIncomingFact(summaryEdge,callerTargetFact,delta.get());							AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));AccessPath<FieldRef>abstractedAccPath=newAccessPath<FieldRef>().setResolver(newDecoratingResolver(resolver));							propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);propagate(newPathEdge<>(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact.cloneWithAccessPath(abstractedAccPath)),callSite,false);



handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015



handling for writing fields / excluding access paths


 

 

handling for writing fields / excluding access paths

 

Johannes Lerch
committed
Jan 05, 2015

463
						}}



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

464
					}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

465

466
				}}			}}



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

467

468
		}}		



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

469

470

471

472
				//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow		//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only		//be propagated into callers that have an incoming edge for this condition//be propagated into callers that have an incoming edge for this condition



bug fix in unbalanced return handling


 

 


Johannes Lerch
committed
Jan 29, 2015



bug fix in unbalanced return handling


 

 

bug fix in unbalanced return handling

 

Johannes Lerch
committed
Jan 29, 2015

473
		if(followReturnsPastSeeds && d1 == zeroValue) {if(followReturnsPastSeeds&&d1==zeroValue){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

474

475

476
			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);Collection<N>callers=icfg.getCallersOf(methodThatNeedsSummary);			for(N c: callers) {for(Nc:callers){				for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(c)){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

477
					FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(c,methodThatNeedsSummary,n,retSiteC);



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

478
					Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);Set<ConstrainedFact<FieldRef,D>>targets=computeReturnFlowFunction(retFunction,d2,c);



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

479

480

481

482

483

484

485
					for(ConstrainedFact<FieldRef, D> d5: targets) {for(ConstrainedFact<FieldRef,D>d5:targets){												Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);Resolverresolver=getResolver(zeroValue,d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()),retSiteC);						resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());resolver.addIncomingFact(summaryEdge,d5.getFact(),AccessPath.Delta.<FieldRef>empty());						AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));AccessPath<FieldRef>abstractedAccPath=newAccessPath<FieldRef>().setResolver(newDecoratingResolver(resolver));						propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);propagateUnbalancedReturnFlow(newPathEdge<>(zeroValue,retSiteC,d5.getFact().cloneWithAccessPath(abstractedAccPath)),c);					}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

486

487

488

489

490

491
				}}			}}			//in cases where there are no callers, the return statement would normally not be processed at all;//in cases where there are no callers, the return statement would normally not be processed at all;			//this might be undesirable if the flow function has a side effect such as registering a taint;//this might be undesirable if the flow function has a side effect such as registering a taint;			//instead we thus call the return flow function will a null caller//instead we thus call the return flow function will a null caller			if(callers.isEmpty()) {if(callers.isEmpty()){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

492
				FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(null,methodThatNeedsSummary,n,null);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

493

494

495

496

497
				retFunction.computeTargets(d2);retFunction.computeTargets(d2);			}}		}}	}}	



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

498

499

500

501

502

503

504

505

506

507

508

509

510

511

512

513

514

515

516

517

518

519

520

521

522

523

524

525

526

527

528

529

530

531

532

533

534

535

536

537

538

539

540

541

542

543

544

545

546

547

548

549

550

551

552

553

554

555

556

557

558

559

560

561

562

563

564

565

566

567

568

569

570

571

572

573

574

575

576

577

578

579

580

581

582

583

584

585

586

587

588

589

590

591

592

593

594

595

596

597

598

599

600

601

602

603

604

605

606

607

608

609

610

611

612

613

614

615

616

617

618

619

620

621

622

623

624

625

626

627

628

629

630

631

632

633

634

635

636

637

638

639

640

641

642

643

644

645

646

647

648

649

650

651

652

653

654

655

656

657

658

659

660

661

662

663

664

665

666

667

668

669

670

671

672

673

674

675

676

677

678

679

680

681

682

683

684

685

686

687

688

689

690

691

692

693

694

695

696

697

698

699

700

701

702

703

704

705

706

707

708

709

710

711

712

713

714

715

716

717

718

719

720

721

722

723

724

725

726

727

728

729

730

731

732

733

734

735

736

737

738

739

740

741

742

743

744

745

746

747

748

749

750

751

752

753

754

755

756

757

758

759

760

761

762

763

764

765

766

767

768

769

770

771

772

773

774

775

776

777

778

779

780

781

782

783

784

785

786

787

788

789

790

791
	private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();privateMap<HashKey,Resolver>returnSiteIncomingEdges=Maps.newHashMap();		private Resolver getResolver(D sourceFact, D targetFact, N stmt) {privateResolvergetResolver(DsourceFact,DtargetFact,Nstmt){		HashKey key = new HashKey(sourceFact, targetFact, stmt);HashKeykey=newHashKey(sourceFact,targetFact,stmt);		if(!returnSiteIncomingEdges.containsKey(key))if(!returnSiteIncomingEdges.containsKey(key))			returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));returnSiteIncomingEdges.put(key,newResolver(sourceFact,targetFact,stmt));		return returnSiteIncomingEdges.get(key);returnreturnSiteIncomingEdges.get(key);	}}		private class PausedReturnSiteEdge {privateclassPausedReturnSiteEdge{		private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint;		private PathEdge<N, D> pathEdge;privatePathEdge<N,D>pathEdge;		private AccessPath<FieldRef> alreadyResolvedAccPath;privateAccessPath<FieldRef>alreadyResolvedAccPath;		private D concretizedStmtFact;privateDconcretizedStmtFact;		public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {publicPausedReturnSiteEdge(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge,AccessPath<FieldRef>alreadyResolvedAccPath,DconcretizedStmtFact){			this.constraint = constraint;this.constraint=constraint;			this.pathEdge = pathEdge;this.pathEdge=pathEdge;			this.alreadyResolvedAccPath = alreadyResolvedAccPath;this.alreadyResolvedAccPath=alreadyResolvedAccPath;			this.concretizedStmtFact = concretizedStmtFact;this.concretizedStmtFact=concretizedStmtFact;		}}	}}		class Resolver {classResolver{		private D sourceFact;privateDsourceFact;		private N stmt;privateNstmt;		private Set<IncomingFact> incomingFacts = Sets.newHashSet();privateSet<IncomingFact>incomingFacts=Sets.newHashSet();		private D targetFact;privateDtargetFact;		private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();privateList<PausedReturnSiteEdge>paused=Lists.newLinkedList();		public Resolver(D sourceFact, D targetFact, N stmt) {publicResolver(DsourceFact,DtargetFact,Nstmt){			this.sourceFact = sourceFact;this.sourceFact=sourceFact;			this.targetFact = targetFact;this.targetFact=targetFact;			this.stmt = stmt;this.stmt=stmt;		}}		public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {publicvoidaddIncomingFact(SummaryEdge<D,N>summaryEdge,Dfact,Delta<FieldRef>delta){			if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {if(summaryEdge.getTargetFact().getAccessPath().hasResolver()){				if(!fact.getAccessPath().hasResolver())if(!fact.getAccessPath().hasResolver())					throw new AssertionError();thrownewAssertionError();				if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))					throw new AssertionError();thrownewAssertionError();			}}						logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}",stmt,fact,delta,summaryEdge);			IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);IncomingFactincFact=newIncomingFact(summaryEdge,fact,delta);			incomingFacts.add(incFact);incomingFacts.add(incFact);						for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {for(PausedReturnSiteEdgeedge:Lists.newLinkedList(paused)){				if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {if(resolve(edge.constraint,edge.pathEdge,edge.alreadyResolvedAccPath,edge.concretizedStmtFact,incFact,newVisited())){					propagate(edge.pathEdge, null, false);propagate(edge.pathEdge,null,false);					paused.remove(edge);paused.remove(edge);				}}			}}		}}		private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {privatebooleanresolve(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge,AccessPath<FieldRef>alreadyResolvedAccPath,Visitedvisited){			if(!visited.resolver.add(this))if(!visited.resolver.add(this))				return false;returnfalse;						alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);alreadyResolvedAccPath=constraint.applyToAccessPath(alreadyResolvedAccPath,false);			D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);DconcretizedStmtFact=targetFact.cloneWithAccessPath(alreadyResolvedAccPath);						logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());logger.trace("Resolving {} through return site {} (inc edges: {})",alreadyResolvedAccPath,stmt,incomingFacts.size());						boolean resolved = false;booleanresolved=false;			for(final IncomingFact incFact : incomingFacts) {for(finalIncomingFactincFact:incomingFacts){				resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);resolved|=resolve(constraint,pathEdge,alreadyResolvedAccPath,concretizedStmtFact,incFact,visited);				if(resolved)if(resolved)					break;break;			}}			if(resolved) {if(resolved){				propagate(pathEdge, null, false);propagate(pathEdge,null,false);			} else {}else{				logger.trace("Pause {} at {}", pathEdge, stmt);logger.trace("Pause {} at {}",pathEdge,stmt);				paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));paused.add(newPausedReturnSiteEdge(constraint,pathEdge,alreadyResolvedAccPath,concretizedStmtFact));			}}			return resolved;returnresolved;		}}		protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,protectedbooleanresolve(Constraint<FieldRef>constraint,finalPathEdge<N,D>pathEdge,AccessPath<FieldRef>alreadyResolvedAccPath,				final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {finalDconcretizedStmtFact,finalIncomingFactincFact,Visitedvisited){									logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}",incFact.fact,incFact.delta,incFact.summaryEdge,stmt,alreadyResolvedAccPath);						if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(concretizedStmtFact,incFact.fact)==PrefixTestResult.GUARANTEED_PREFIX){				logger.trace("Resolved by incoming fact {}", incFact.fact);logger.trace("Resolved by incoming fact {}",incFact.fact);				return true;returntrue;			} else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {}elseif(AccessPathUtil.isPrefixOf(incFact.fact,concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){				if(incFact.fact.getAccessPath().hasResolver()) {if(incFact.fact.getAccessPath().hasResolver()){					DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)incFact.fact.getAccessPath().getResolver();					logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);logger.trace("Asking {} to resolve {}",decoratingResolver,alreadyResolvedAccPath);					final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);finalConstraint<FieldRef>deltaConstraint=newDeltaConstraint<FieldRef>(incFact.fact.getAccessPath(),alreadyResolvedAccPath);					if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath())&&deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)){						boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(booleanresolved=decoratingResolver.resolver.resolve(deltaConstraint,newReturnConcretizationPathEdge<N,D>(								incFact.summaryEdge.getSourceFact(), incFact.summaryEdge.getSourceFact(),								incFact.summaryEdge.getTargetStmt(), incFact.summaryEdge.getTargetStmt(),								applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {applyConstraint(deltaConstraint,incFact.summaryEdge.getTargetFact(),false)){									@Override@Override									public void _propagate(D dSource, N target, D dTarget) {publicvoid_propagate(DdSource,Ntarget,DdTarget){										addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);addIncomingFact(newSummaryEdge<>(dSource,target,dTarget),applyConstraint(deltaConstraint,incFact.fact,false),incFact.delta);									}}						}, decoratingResolver.alreadyResolvedAccPath, visited);},decoratingResolver.alreadyResolvedAccPath,visited);						if(resolved) {if(resolved){							propagate(pathEdge, null, false);propagate(pathEdge,null,false);							return true;returntrue;						}}					}}				}}				else {else{					D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));DfactWithDelta=incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));					if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(concretizedStmtFact,factWithDelta)==PrefixTestResult.GUARANTEED_PREFIX){						logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);logger.trace("Resolved by incoming fact {} with delta {}",incFact.fact,incFact.delta);						return true;returntrue;					} else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {}elseif(AccessPathUtil.isPrefixOf(factWithDelta,concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){						if(factWithDelta.getAccessPath().hasResolver()) {if(factWithDelta.getAccessPath().hasResolver()){							DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)factWithDelta.getAccessPath().getResolver();							logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);logger.trace("Asking {} to resolve {}",decoratingResolver,alreadyResolvedAccPath);														final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);finalConstraint<FieldRef>deltaConstraint=newDeltaConstraint<FieldRef>(factWithDelta.getAccessPath(),alreadyResolvedAccPath);							if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)){								D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);Dtarget=applyConstraint(deltaConstraint,decoratingResolver.resolver.targetFact,false);								target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));target=target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));								PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {PathEdge<N,D>newEdge=newReturnConcretizationPathEdge<N,D>(decoratingResolver.resolver.sourceFact,decoratingResolver.resolver.stmt,target){									@Override@Override									protected void _propagate(D dSource, N target, D dTarget) {protectedvoid_propagate(DdSource,Ntarget,DdTarget){										FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);FieldSensitiveIFDSSolver.this.propagate(pathEdge,null,false);									}}								};};																boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);booleanresolved=decoratingResolver.resolver.resolve(deltaConstraint,newEdge,decoratingResolver.alreadyResolvedAccPath,visited);								if(resolved) {if(resolved){									return true;returntrue;								}}							}}						}}						else {else{							final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));finalDeltaConstraint<FieldRef>deltaConstraint=newDeltaConstraint<>(alreadyResolvedAccPath,constraint.applyToAccessPath(factWithDelta.getAccessPath(),false));							AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);AccessPath<FieldRef>newAccPath=deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null),false);							boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(booleanresolved=propagateConstrained(newReturnConcretizationPathEdge<N,D>(									applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), applyConstraint(constraint,sourceFact,true),pathEdge.getTarget(),									pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)){										@Override@Override										protected void _propagate(D dSource, N target, D dTarget) {protectedvoid_propagate(DdSource,Ntarget,DdTarget){											addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);addIncomingFact(newSummaryEdge<>(dSource,target,dTarget),dTarget,incFact.delta);										}}									}, visited);},visited);							if(resolved)if(resolved)								return true;returntrue;						}}					}}				}}			}}			return false;returnfalse;		}}				@Override@Override		public String toString() {publicStringtoString(){			return stmt.toString();returnstmt.toString();		}}	}}	private class Visited {privateclassVisited{		Set<Resolver> resolver = Sets.newHashSet();Set<Resolver>resolver=Sets.newHashSet();		Map<N, Boolean> visitedCallSites = Maps.newHashMap();Map<N,Boolean>visitedCallSites=Maps.newHashMap();	}}		class DecoratingResolver implements SubPathResolver<FieldRef> {classDecoratingResolverimplementsSubPathResolver<FieldRef>{				private Resolver resolver;privateResolverresolver;		private AccessPath<FieldRef> alreadyResolvedAccPath;privateAccessPath<FieldRef>alreadyResolvedAccPath;		public DecoratingResolver(Resolver resolver) {publicDecoratingResolver(Resolverresolver){			this.resolver = resolver;this.resolver=resolver;			this.alreadyResolvedAccPath = new AccessPath<FieldRef>();this.alreadyResolvedAccPath=newAccessPath<FieldRef>();		}}				public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {publicDecoratingResolver(Resolverresolver,AccessPath<FieldRef>alreadyResolvedAccPath){			this.resolver = resolver;this.resolver=resolver;			this.alreadyResolvedAccPath = alreadyResolvedAccPath;this.alreadyResolvedAccPath=alreadyResolvedAccPath;		}}				public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {publicbooleanresolve(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge){			return resolve(constraint, pathEdge, new Visited());returnresolve(constraint,pathEdge,newVisited());		}}		public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {publicbooleanresolve(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge,Visitedvisited){			return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);returnresolver.resolve(constraint,pathEdge,alreadyResolvedAccPath,visited);		}}		@Override@Override		public int hashCode() {publicinthashCode(){			final int prime = 31;finalintprime=31;			int result = 1;intresult=1;			result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());result=prime*result+((alreadyResolvedAccPath==null)?0:alreadyResolvedAccPath.hashCode());			result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());result=prime*result+((resolver==null)?0:resolver.hashCode());			return result;returnresult;		}}		@Override@Override		public boolean equals(Object obj) {publicbooleanequals(Objectobj){			if (this == obj)if(this==obj)				return true;returntrue;			if (obj == null)if(obj==null)				return false;returnfalse;			if (getClass() != obj.getClass())if(getClass()!=obj.getClass())				return false;returnfalse;			DecoratingResolver other = (DecoratingResolver) obj;DecoratingResolverother=(DecoratingResolver)obj;			if (alreadyResolvedAccPath == null) {if(alreadyResolvedAccPath==null){				if (other.alreadyResolvedAccPath != null)if(other.alreadyResolvedAccPath!=null)					return false;returnfalse;			} else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))}elseif(!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))				return false;returnfalse;			if (resolver == null) {if(resolver==null){				if (other.resolver != null)if(other.resolver!=null)					return false;returnfalse;			} else if (!resolver.equals(other.resolver))}elseif(!resolver.equals(other.resolver))				return false;returnfalse;			return true;returntrue;		}}				@Override@Override		public String toString() {publicStringtoString(){			return alreadyResolvedAccPath+ ":"+resolver.toString();returnalreadyResolvedAccPath+":"+resolver.toString();		}}		@Override@Override		public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {publicSubPathResolver<FieldRef>decorate(Constraint<FieldRef>constraint){			return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));returnnewDecoratingResolver(resolver,constraint.applyToAccessPath(alreadyResolvedAccPath,false));		}}	}}		private class IncomingFact {privateclassIncomingFact{		private D fact;privateDfact;		private Delta<FieldRef> delta;privateDelta<FieldRef>delta;		private SummaryEdge<D, N> summaryEdge;privateSummaryEdge<D,N>summaryEdge;		public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {publicIncomingFact(SummaryEdge<D,N>summaryEdge,Dfact,Delta<FieldRef>delta){			this.summaryEdge = summaryEdge;this.summaryEdge=summaryEdge;			this.fact = fact;this.fact=fact;			this.delta = delta;this.delta=delta;		}}		@Override@Override		public int hashCode() {publicinthashCode(){			final int prime = 31;finalintprime=31;			int result = 1;intresult=1;			result = prime * result + getOuterType().hashCode();result=prime*result+getOuterType().hashCode();			result = prime * result + ((delta == null) ? 0 : delta.hashCode());result=prime*result+((delta==null)?0:delta.hashCode());			result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode());			result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());result=prime*result+((summaryEdge==null)?0:summaryEdge.hashCode());			return result;returnresult;		}}		@Override@Override		public boolean equals(Object obj) {publicbooleanequals(Objectobj){			if (this == obj)if(this==obj)				return true;returntrue;			if (obj == null)if(obj==null)				return false;returnfalse;			if (getClass() != obj.getClass())if(getClass()!=obj.getClass())				return false;returnfalse;			IncomingFact other = (IncomingFact) obj;IncomingFactother=(IncomingFact)obj;			if (!getOuterType().equals(other.getOuterType()))if(!getOuterType().equals(other.getOuterType()))				return false;returnfalse;			if (delta == null) {if(delta==null){				if (other.delta != null)if(other.delta!=null)					return false;returnfalse;			} else if (!delta.equals(other.delta))}elseif(!delta.equals(other.delta))				return false;returnfalse;			if (fact == null) {if(fact==null){				if (other.fact != null)if(other.fact!=null)					return false;returnfalse;			} else if (!fact.equals(other.fact))}elseif(!fact.equals(other.fact))				return false;returnfalse;			if (summaryEdge == null) {if(summaryEdge==null){				if (other.summaryEdge != null)if(other.summaryEdge!=null)					return false;returnfalse;			} else if (!summaryEdge.equals(other.summaryEdge))}elseif(!summaryEdge.equals(other.summaryEdge))				return false;returnfalse;			return true;returntrue;		}}		private FieldSensitiveIFDSSolver getOuterType() {privateFieldSensitiveIFDSSolvergetOuterType(){			return FieldSensitiveIFDSSolver.this;returnFieldSensitiveIFDSSolver.this;		}}			}}	



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

792

793

794

795

796

797

798

799
	/**/**	 * Computes the return flow function for the given set of caller-side	 * Computes the return flow function for the given set of caller-side	 * abstractions.	 * abstractions.	 * @param retFunction The return flow function to compute	 * @param retFunction The return flow function to compute	 * @param d2 The abstraction at the exit node in the callee	 * @param d2 The abstraction at the exit node in the callee	 * @param callSite The call site	 * @param callSite The call site	 * @return The set of caller-side abstractions at the return site	 * @return The set of caller-side abstractions at the return site	 */	 */



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

800
	protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeReturnFlowFunction



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

801
			(FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {(FlowFunction<FieldRef,D>retFunction,Dd2,NcallSite){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

802

803

804

805

806

807

808

809
		return retFunction.computeTargets(d2);returnretFunction.computeTargets(d2);	}}	/**/**	 * Lines 33-37 of the algorithm.	 * Lines 33-37 of the algorithm.	 * Simply propagate normal, intra-procedural flows.	 * Simply propagate normal, intra-procedural flows.	 * @param edge	 * @param edge	 */	 */



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

810
	@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

811

812

813

814

815

816
	private void processNormalFlow(PathEdge<N,D> edge) {privatevoidprocessNormalFlow(PathEdge<N,D>edge){		final D d1 = edge.factAtSource();finalDd1=edge.factAtSource();		final N n = edge.getTarget(); finalNn=edge.getTarget();		final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();				for (N m : icfg.getSuccsOf(n)) {for(Nm:icfg.getSuccsOf(n)){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

817
			FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);FlowFunction<FieldRef,D>flowFunction=flowFunctions.getNormalFlowFunction(n,m);



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

818

819
			Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);Set<ConstrainedFact<FieldRef,D>>res=computeNormalFlowFunction(flowFunction,d1,d2);			for (ConstrainedFact<FieldRef, D> d3 : res) {for(ConstrainedFact<FieldRef,D>d3:res){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

820
				if(d3.getConstraint() != null) {if(d3.getConstraint()!=null){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

821

822

823

824

825
					if(d3.getFact().getAccessPath().hasResolver()) {if(d3.getFact().getAccessPath().hasResolver()){						AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());AccessPath<FieldRef>accPath=d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());						((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));((DecoratingResolver)d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(),newPathEdge<>(d1,m,d3.getFact().cloneWithAccessPath(accPath)));					} else}else						propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));propagateConstrained(newPathEdge<>(applyConstraint(d3.getConstraint(),d1,true),m,d3.getFact()));



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

826
				}}



handling for writing fields / excluding access paths


 

 


Johannes Lerch
committed
Jan 05, 2015



handling for writing fields / excluding access paths


 

 

handling for writing fields / excluding access paths

 

Johannes Lerch
committed
Jan 05, 2015

827
				elseelse



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

828
					propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);propagate(newPathEdge<>(d1,m,d3.getFact()),null,false);



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

829

830

831

832
			}}		}}	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

833
	private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {privateDapplyConstraint(Constraint<FieldRef>constraint,Dfact,booleansourceFact){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

834

835

836
		if(fact.equals(zeroValue))if(fact.equals(zeroValue))			return zeroValue;returnzeroValue;		elseelse



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

837
			return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));returnfact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(),sourceFact));



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

838
	}}



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

839
	



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

840
	private boolean propagateConstrained(PathEdge<N, D> pathEdge) {privatebooleanpropagateConstrained(PathEdge<N,D>pathEdge){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

841
		return propagateConstrained(pathEdge, new Visited());returnpropagateConstrained(pathEdge,newVisited());



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

842

843
	}}	



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

844
	private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {privatebooleanpropagateConstrained(PathEdge<N,D>pathEdge,Visitedvisited){



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

845
		M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());McalleeMethod=icfg.getMethodOf(pathEdge.getTarget());



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

846
		logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);logger.trace("Checking interest at method {} in fact {} for edge {}",calleeMethod,pathEdge.factAtSource(),pathEdge);



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

847




cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

848

849

850
		boolean propagate = false;booleanpropagate=false;		if(pathEdge.factAtSource().equals(zeroValue))if(pathEdge.factAtSource().equals(zeroValue))			propagate = true;propagate=true;



Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015



Do not check interest of callers if paused edge already available.


 

 

Do not check interest of callers if paused edge already available.

 

Johannes Lerch
committed
Jan 16, 2015

851

852
		else if(hasPausedEdges(calleeMethod, pathEdge))elseif(hasPausedEdges(calleeMethod,pathEdge))			propagate = false;propagate=false;



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

853

854
		else {else{			Set<N> callSitesWithInterest = Sets.newHashSet();Set<N>callSitesWithInterest=Sets.newHashSet();



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

855
			for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteedfor(IncomingEdge<D,N>incEdge:incomingEdgesPrefixedWith(calleeMethod,pathEdge.factAtSource())){//guaranteed



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

856
				callSitesWithInterest.add(incEdge.getCallSite());callSitesWithInterest.add(incEdge.getCallSite());



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

857
			}}



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

858

859
			propagate = !callSitesWithInterest.isEmpty();propagate=!callSitesWithInterest.isEmpty();			



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

860

861

862

863

864

865

866
			Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());Set<IncomingEdge<D,N>>incomingEdgesPotentialPrefixesOf=incomingEdgesPotentialPrefixesOf(calleeMethod,pathEdge.factAtSource());			Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);Collection<IncomingEdge<D,N>>candidates=reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);						for(IncomingEdge<D, N> incEdge : candidates) { //potentialfor(IncomingEdge<D,N>incEdge:candidates){//potential				if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {if(visited.visitedCallSites.containsKey(incEdge.getCallSite())){					if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)if(visited.visitedCallSites.get(incEdge.getCallSite())!=null)						propagate |= visited.visitedCallSites.get(incEdge.getCallSite());propagate|=visited.visitedCallSites.get(incEdge.getCallSite());



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

867

868
				}}				else {else{



Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015



Do not check interest of callers if paused edge already available.


 

 

Do not check interest of callers if paused edge already available.

 

Johannes Lerch
committed
Jan 16, 2015

869
					if(!callSitesWithInterest.contains(incEdge.getCallSite())) {if(!callSitesWithInterest.contains(incEdge.getCallSite())){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

870

871

872

873

874

875

876

877

878

879

880

881

882

883

884

885

886

887

888

889

890

891

892

893

894

895

896

897

898

899

900

901

902

903
						if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()){							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());Constraint<FieldRef>callerConstraint=newDeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(),pathEdge.factAtSource().getAccessPath());							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath())&&									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())){								DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)incEdge.getCalleeSourceFact().getAccessPath().getResolver();								D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);DcalleeSourceFact=applyConstraint(callerConstraint,incEdge.getCalleeSourceFact(),true);								calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(calleeSourceFact=calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(										incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));								boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(booleanresult=decoratingResolver.resolve(callerConstraint,newCallConcretizationPathEdge<>(										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), applyConstraint(callerConstraint,incEdge.getCallerSourceFact(),true),										incEdge.getCallSite(), incEdge.getCallSite(),										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), applyConstraint(callerConstraint,incEdge.getCallerCallSiteFact(),false),										calleeMethod,calleeMethod,										calleeSourceFact), visited);calleeSourceFact),visited);								visited.visitedCallSites.put(incEdge.getCallSite(), result);visited.visitedCallSites.put(incEdge.getCallSite(),result);								propagate |= result;propagate|=result;							}}						}}						else {else{							Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());Constraint<FieldRef>callerConstraint=newDeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(),pathEdge.factAtSource().getAccessPath());							if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath())&&									callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())){													PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(PathEdge<N,D>callerEdge=newCallConcretizationPathEdge<>(										applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), applyConstraint(callerConstraint,incEdge.getCallerSourceFact(),true),										incEdge.getCallSite(), incEdge.getCallSite(),										applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),applyConstraint(callerConstraint,incEdge.getCallerCallSiteFact(),false),										calleeMethod,calleeMethod,										applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));applyConstraint(callerConstraint,incEdge.getCalleeSourceFact(),true));								visited.visitedCallSites.put(incEdge.getCallSite(), null);visited.visitedCallSites.put(incEdge.getCallSite(),null);								boolean result = propagateConstrained(callerEdge, visited);booleanresult=propagateConstrained(callerEdge,visited);								visited.visitedCallSites.put(incEdge.getCallSite(), result);visited.visitedCallSites.put(incEdge.getCallSite(),result);								propagate |= result;propagate|=result;							}}



Bug fix: check for possibility before applying DeltaConstraint


 

 


Johannes Lerch
committed
Jan 30, 2015



Bug fix: check for possibility before applying DeltaConstraint


 

 

Bug fix: check for possibility before applying DeltaConstraint

 

Johannes Lerch
committed
Jan 30, 2015

904
						}}



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

905
					}}



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

906
				}}



annotated facts (WIP)


 

 


Johannes Lerch
committed
Nov 13, 2014



annotated facts (WIP)


 

 

annotated facts (WIP)

 

Johannes Lerch
committed
Nov 13, 2014

907
			}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

908
		}}



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

909
		



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

910
		if(propagate) {if(propagate){



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

911
			propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);propagate(pathEdge,pathEdgeinstanceofCallConcretizationPathEdge?pathEdge.getTarget():null,false);



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

912

913

914

915

916

917
			return true;returntrue;		} else {}else{			pauseEdge(pathEdge);pauseEdge(pathEdge);			return false;returnfalse;		}}	}}



Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015



Do not check interest of callers if paused edge already available.


 

 

Do not check interest of callers if paused edge already available.

 

Johannes Lerch
committed
Jan 16, 2015

918




abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

919

920

921

922

923

924

925

926

927

928

929

930

931

932

933
	private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {privateCollection<IncomingEdge<D,N>>reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D,N>>candidates){		Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();Map<N,IncomingEdge<D,N>>result=Maps.newHashMap();		for(IncomingEdge<D, N> incEdge : candidates) {for(IncomingEdge<D,N>incEdge:candidates){			if(result.containsKey(incEdge.getCallSite())) {if(result.containsKey(incEdge.getCallSite())){				IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());IncomingEdge<D,N>currentIncEdge=result.get(incEdge.getCallSite());				if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(),currentIncEdge.getCalleeSourceFact())==PrefixTestResult.GUARANTEED_PREFIX){					result.put(incEdge.getCallSite(), incEdge);result.put(incEdge.getCallSite(),incEdge);				}}			}}			elseelse				result.put(incEdge.getCallSite(), incEdge);result.put(incEdge.getCallSite(),incEdge);		}}		return result.values();returnresult.values();	}}



Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015



Do not check interest of callers if paused edge already available.


 

 

Do not check interest of callers if paused edge already available.

 

Johannes Lerch
committed
Jan 16, 2015

934

935

936

937
	private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {privatebooleanhasPausedEdges(McalleeMethod,PathEdge<N,D>pathEdge){		ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);ConcurrentHashSet<PathEdge<N,D>>pe=pausedEdges.get(calleeMethod);		if(pe != null) {if(pe!=null){			for(PathEdge<N, D> edge : pe) {for(PathEdge<N,D>edge:pe){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

938
				if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)if(AccessPathUtil.isPrefixOf(edge.factAtSource(),pathEdge.factAtSource())==PrefixTestResult.GUARANTEED_PREFIX)



Do not check interest of callers if paused edge already available.


 

 


Johannes Lerch
committed
Jan 16, 2015



Do not check interest of callers if paused edge already available.


 

 

Do not check interest of callers if paused edge already available.

 

Johannes Lerch
committed
Jan 16, 2015

939

940

941

942

943

944
					return true;returntrue;			}}		}}		return false;returnfalse;	}}



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

945

946
	private void pauseEdge(PathEdge<N,D> edge) {privatevoidpauseEdge(PathEdge<N,D>edge){		M method = icfg.getMethodOf(edge.getTarget());Mmethod=icfg.getMethodOf(edge.getTarget());



changed to single threaded; bugfix


 

 


Johannes Lerch
committed
Jan 15, 2015



changed to single threaded; bugfix


 

 

changed to single threaded; bugfix

 

Johannes Lerch
committed
Jan 15, 2015

947
		ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());ConcurrentHashSet<PathEdge<N,D>>edges=pausedEdges.putIfAbsentElseGet(method,newConcurrentHashSet<PathEdge<N,D>>());



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

948

949

950
		if(edges.add(edge)) {if(edges.add(edge)){			logger.trace("PAUSED: {}: {}", method, edge);logger.trace("PAUSED: {}: {}",method,edge);		}}



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

951

952
	}}	



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

953

954

955

956

957

958

959

960
	/**/**	 * Computes the normal flow function for the given set of start and end	 * Computes the normal flow function for the given set of start and end	 * abstractions.	 * abstractions.	 * @param flowFunction The normal flow function to compute	 * @param flowFunction The normal flow function to compute	 * @param d1 The abstraction at the method's start node	 * @param d1 The abstraction at the method's start node	 * @param d1 The abstraction at the current node	 * @param d1 The abstraction at the current node	 * @return The set of abstractions at the successor node	 * @return The set of abstractions at the successor node	 */	 */



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

961
	protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeNormalFlowFunction



cleaning code


 

 


Johannes Lerch
committed
Jan 07, 2015



cleaning code


 

 

cleaning code

 

Johannes Lerch
committed
Jan 07, 2015

962
			(FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {(FlowFunction<FieldRef,D>flowFunction,Dd1,Dd2){



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

963

964

965

966

967

968

969

970

971

972

973

974

975

976

977

978

979

980

981

982
		return flowFunction.computeTargets(d2);returnflowFunction.computeTargets(d2);	}}		/**/**	 * This method will be called for each incoming edge and can be used to	 * This method will be called for each incoming edge and can be used to	 * transfer knowledge from the calling edge to the returning edge, without	 * transfer knowledge from the calling edge to the returning edge, without	 * affecting the summary edges at the callee.	 * affecting the summary edges at the callee.	 * 	 * 	 * @param d4	 * @param d4	 *            Fact stored with the incoming edge, i.e., present at the	 *            Fact stored with the incoming edge, i.e., present at the	 *            caller side	 *            caller side	 * @param d5	 * @param d5	 *            Fact that originally should be propagated to the caller.	 *            Fact that originally should be propagated to the caller.	 * @return Fact that will be propagated to the caller.	 * @return Fact that will be propagated to the caller.	 */	 */	protected D restoreContextOnReturnedFact(D d4, D d5) {protectedDrestoreContextOnReturnedFact(Dd4,Dd5){		d5.setCallingContext(d4);d5.setCallingContext(d4);		return d5;returnd5;	}}	



field-sensitive version of the BiDi solver 


 

 


Johannes Lerch
committed
Jan 29, 2015



field-sensitive version of the BiDi solver 


 

 

field-sensitive version of the BiDi solver 

 

Johannes Lerch
committed
Jan 29, 2015

983

984

985

986
	protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,protectedvoidpropagateUnbalancedReturnFlow(PathEdge<N,D>edge,			/* deliberately exposed to clients */ N relatedCallSite) {/* deliberately exposed to clients */NrelatedCallSite){		propagate(edge, relatedCallSite, true);propagate(edge,relatedCallSite,true);	}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

987
	



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

988
	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();privateHashMultimap<CacheKey<N,D,BaseValue>,PathEdge<N,D>>sourceBaseValueCache=HashMultimap.create();



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

989

990

991

992
	private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();privateHashMultimap<CacheKey<N,D,BaseValue>,PathEdge<N,D>>cache=HashMultimap.create();	private int cacheHits = 0;privateintcacheHits=0;	private int cacheMerges = 0;privateintcacheMerges=0;	private int cacheOppositePrefix = 0;privateintcacheOppositePrefix=0;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

993

994

995
	private int cacheSourceBaseValue = 0;privateintcacheSourceBaseValue=0;	private int concretizationEdges = 0;privateintconcretizationEdges=0;	private int cacheEquals = 0;privateintcacheEquals=0;



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

996

997
	/**/**	 * Propagates the flow further down the exploded super graph. 	 * Propagates the flow further down the exploded super graph. 



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

998
	 * @param edge the PathEdge that should be propagated	 * @param edge the PathEdge that should be propagated



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

999

1000
	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 
For faster browsing, not all history is shown.

View entire blame



View entire blame





Prev


1


2


Next





Prev

1

2

Next







