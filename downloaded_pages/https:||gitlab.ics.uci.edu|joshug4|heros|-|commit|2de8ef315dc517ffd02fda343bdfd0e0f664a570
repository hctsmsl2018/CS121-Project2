



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

2de8ef31















Commit
2de8ef31


authored
Mar 26, 2015
by


Johannes Lerch



Browse files




restructuring







parent
e60e669d













Changes
21




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/JsonArray.java








View file @ 2de8ef31






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java








View file @ 2de8ef31






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file














test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......














test/heros/IFDSSolverTest.java








View file @ 2de8ef31






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......














test/heros/alias/AccessPathTest.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}














test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file














test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......














test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file














test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31





This diff is collapsed.
Click to expand it.













test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}














src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......














test/heros/utilities/TestHelper.java








View file @ 2de8ef31






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

2de8ef31















Commit
2de8ef31


authored
Mar 26, 2015
by


Johannes Lerch



Browse files




restructuring







parent
e60e669d













Changes
21




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/JsonArray.java








View file @ 2de8ef31






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java








View file @ 2de8ef31






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file














test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......














test/heros/IFDSSolverTest.java








View file @ 2de8ef31






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......














test/heros/alias/AccessPathTest.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}














test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file














test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......














test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file














test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31





This diff is collapsed.
Click to expand it.













test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}














src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......














test/heros/utilities/TestHelper.java








View file @ 2de8ef31






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

2de8ef31







Open sidebar



Joshua Garcia heros
Commits

2de8ef31




Open sidebar

Joshua Garcia heros
Commits

2de8ef31


Joshua GarciaherosherosCommits
2de8ef31








Commit
2de8ef31


authored
Mar 26, 2015
by


Johannes Lerch



Browse files




restructuring







parent
e60e669d













Changes
21




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/JsonArray.java








View file @ 2de8ef31






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java








View file @ 2de8ef31






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file














test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......














test/heros/IFDSSolverTest.java








View file @ 2de8ef31






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......














test/heros/alias/AccessPathTest.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}














test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file














test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......














test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file














test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31





This diff is collapsed.
Click to expand it.













test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}














src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......














test/heros/utilities/TestHelper.java








View file @ 2de8ef31






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
2de8ef31


authored
Mar 26, 2015
by


Johannes Lerch



Browse files




restructuring







parent
e60e669d













Changes
21




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/JsonArray.java








View file @ 2de8ef31






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java








View file @ 2de8ef31






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file














test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......














test/heros/IFDSSolverTest.java








View file @ 2de8ef31






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......














test/heros/alias/AccessPathTest.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}














test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file














test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......














test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file














test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31





This diff is collapsed.
Click to expand it.













test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}














src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......














test/heros/utilities/TestHelper.java








View file @ 2de8ef31






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
2de8ef31


authored
Mar 26, 2015
by


Johannes Lerch



Browse files



Commit
2de8ef31


authored
Mar 26, 2015
by


Johannes Lerch

2de8ef31authoredbyJohannes Lerch

restructuring






parent
e60e669d
















parent
e60e669d





parent












Changes
21
21


Expand all
Hide whitespace changes

Inline
Side-by-side






Expand all
Hide whitespace changes

Inline
Side-by-side




Expand all
Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/JsonArray.java








View file @ 2de8ef31






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java








View file @ 2de8ef31






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file














test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......














test/heros/IFDSSolverTest.java








View file @ 2de8ef31






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......














test/heros/alias/AccessPathTest.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}














test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......














test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}














test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file














test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......














test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file














test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31





This diff is collapsed.
Click to expand it.













test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}














src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......














test/heros/utilities/TestHelper.java








View file @ 2de8ef31






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......









Prev


1


2


Next













src/heros/alias/JsonArray.java








View file @ 2de8ef31






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file












src/heros/alias/JsonArray.java








View file @ 2de8ef31








src/heros/alias/JsonArray.java










View file @ 2de8ef31


2de8ef31



......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file






......@@ -14,7 +14,7 @@ import java.util.List;




















import com.google.common.collect.Lists;





















class JsonArray {










public class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 



......@@ -25,8 +25,8 @@ class JsonArray {









 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 JsonDocument.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file


import com.google.common.collect.Lists;importcom.google.common.collect.Lists;class JsonArray {classJsonArray{public class JsonArray {publicpublic classJsonArray{  private List<String> items = Lists.newLinkedList();privateList<String>items=Lists.newLinkedList();  public void write(StringBuilder builder, int tabs) {publicvoidwrite(StringBuilderbuilder,inttabs){ builder.append("[\n");builder.append("[\n"); for(String item: items) {for(Stringitem:items){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");TestDebuggerTestDebugger.tabs(tabs+1,builder);builder.append("\""+item+"\",\n"); JsonDocument.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");JsonDocumentJsonDocument.tabs(tabs+1,builder);builder.append("\""+item+"\",\n"); }} TestDebugger.tabs(tabs, builder); builder.append("]");TestDebuggerTestDebugger.tabs(tabs,builder);builder.append("]"); JsonDocument.tabs(tabs, builder); builder.append("]");JsonDocumentJsonDocument.tabs(tabs,builder);builder.append("]"); }}}}








src/heros/alias/JsonDocument.java








View file @ 2de8ef31






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file












src/heros/alias/JsonDocument.java








View file @ 2de8ef31








src/heros/alias/JsonDocument.java










View file @ 2de8ef31


2de8ef31



......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file






......@@ -15,7 +15,7 @@ import java.util.Map.Entry;




















import com.google.common.collect.Maps;





















class JsonDocument {










public class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override



......@@ -47,23 +47,27 @@ class JsonDocument {









 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 tabs(tabs, builder); builder.append("}");










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }










}




\ No newline at end of file


import com.google.common.collect.Maps;importcom.google.common.collect.Maps;class JsonDocument {classJsonDocument{public class JsonDocument {publicpublic classJsonDocument{  private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {privateCacheMap<String,JsonDocument>documents=newCacheMap<String,JsonDocument>(){ @Override@Override builder.append("{\n");builder.append("{\n");  for(Entry<String, String> entry : keyValuePairs.entrySet()) {for(Entry<String,String>entry:keyValuePairs.entrySet()){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");TestDebuggerTestDebugger..tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n"); tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n"); }}  for(Entry<String, JsonArray> entry : arrays.entrySet()) {for(Entry<String,JsonArray>entry:arrays.entrySet()){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");TestDebuggerTestDebugger..tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": "); tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": "); entry.getValue().write(builder, tabs+1);entry.getValue().write(builder,tabs+1); builder.append(",\n");builder.append(",\n"); }}  for(Entry<String, JsonDocument> entry : documents.entrySet()) {for(Entry<String,JsonDocument>entry:documents.entrySet()){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");TestDebuggerTestDebugger..tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": "); tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": "); entry.getValue().write(builder, tabs+1);entry.getValue().write(builder,tabs+1); builder.append(",\n");builder.append(",\n"); }}  TestDebugger.tabs(tabs, builder); builder.append("}");TestDebuggerTestDebugger..tabs(tabs,builder);builder.append("}"); tabs(tabs, builder); builder.append("}");tabs(tabs,builder);builder.append("}"); }} static void tabs(int tabs, StringBuilder builder) {staticvoidtabs(inttabs,StringBuilderbuilder){ for(int i=0; i<tabs; i++)for(inti=0;i<tabs;i++) builder.append("\t");builder.append("\t"); }}}}








test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......












test/heros/BiDiIFDSSolverTest.java








View file @ 2de8ef31








test/heros/BiDiIFDSSolverTest.java










View file @ 2de8ef31


2de8ef31



......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......






......@@ -50,13 +50,13 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");



......@@ -67,7 +67,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -77,7 +77,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -92,7 +92,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -102,7 +102,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", flow("0", "2")),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",



......@@ -117,7 +117,7 @@ public class BiDiIFDSSolverTest {









 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b").succ("c", flow("0", "1")),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",



......@@ -127,7 +127,7 @@ public class BiDiIFDSSolverTest {









 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b").succ("a", kill("0")),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",



......@@ -141,14 +141,14 @@ public class BiDiIFDSSolverTest {









 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 



......@@ -163,15 +163,15 @@ public class BiDiIFDSSolverTest {









 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1").succ("b", flow("0", "1")),










 normalStmt("a2").succ("b", flow("0", "1")),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x").succ("y", flow("2", "2")),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 



......@@ -187,7 +187,7 @@ public class BiDiIFDSSolverTest {









 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",



......@@ -196,7 +196,7 @@ public class BiDiIFDSSolverTest {









 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a").succ("c", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",



......


 forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b").succ("c", flow("0", "1")),normalStmt("b").).succsucc(("c""c",flow("0","1")), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1"))..succsucc(("c""c"),) exitStmt("c").expectArtificalFlow(flow("1")));exitStmt("c").expectArtificalFlow(flow("1")));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b").succ("a", flow("0", "2")),normalStmt("b").).succsucc(("a""a",flow("0","2")), normalStmt("b", flow("0", "2")).succ("a"),normalStmt("b",flow("0","2"))..succsucc(("a""a"),) exitStmt("a").expectArtificalFlow(flow("2")));exitStmt("a").expectArtificalFlow(flow("2")));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");forwardHelper.runBiDiSolver(backwardHelper,exchange,"b"); forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b").succ("c", flow("0", "1")),normalStmt("b").).succsucc(("c""c",flow("0","1")), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1"))..succsucc(("c""c"),) exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));exitStmt("c").returns(over("y"),to("z"),flow("1","2")));  forwardHelper.method("bar",forwardHelper.method("bar", backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b").succ("a", flow("0", "2")),normalStmt("b").).succsucc(("a""a",flow("0","2")), normalStmt("b", flow("0", "2")).succ("a"),normalStmt("b",flow("0","2"))..succsucc(("a""a"),) exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));exitStmt("a").returns(over("y"),to("x"),flow("2","3")));  backwardHelper.method("bar",backwardHelper.method("bar", forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b").succ("c", flow("0", "1")),normalStmt("b").).succsucc(("c""c",flow("0","1")), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1"))..succsucc(("c""c"),) exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));exitStmt("c").returns(over("y1"),to("z"),flow("1","2")));  forwardHelper.method("bar",forwardHelper.method("bar", backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b").succ("a", flow("0", "2")),normalStmt("b").).succsucc(("a""a",flow("0","2")), normalStmt("b", flow("0", "2")).succ("a"),normalStmt("b",flow("0","2"))..succsucc(("a""a"),) exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));exitStmt("a").returns(over("y2"),to("x"),flow("2","3")));  backwardHelper.method("bar",backwardHelper.method("bar", forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b").succ("c", flow("0", "1")),normalStmt("b").).succsucc(("c""c",flow("0","1")), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1"))..succsucc(("c""c"),) exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));exitStmt("c").returns(over("y"),to("z"),flow("1","2")));  forwardHelper.method("bar",forwardHelper.method("bar", backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b").succ("a", kill("0")),normalStmt("b").).succsucc(("a""a",kill("0")), normalStmt("b", kill("0")).succ("a"),normalStmt("b",kill("0"))..succsucc(("a""a"),) exitStmt("a").returns(over("y"), to("x") /*none*/));exitStmt("a").returns(over("y"),to("x")/*none*/));  backwardHelper.method("bar",backwardHelper.method("bar", public void reuseSummary() {publicvoidreuseSummary(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints(),startPoints(), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").).succsucc(("b""b",flow("0","1")), normalStmt("a", flow("0", "1")).succ("b"),normalStmt("a",flow("0","1"))..succsucc(("b""b"),) callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("c",kill("1")), callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),callSite("c").calls("bar",flow("1","2")).retSite("d",kill("1")), exitStmt("d").expectArtificalFlow(kill("1")));exitStmt("d").expectArtificalFlow(kill("1")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints("x"),startPoints("x"), normalStmt("x").succ("y", flow("2", "2")),normalStmt("x").).succsucc(("y""y",flow("2","2")), normalStmt("x", flow("2", "2")).succ("y"),normalStmt("x",flow("2","2"))..succsucc(("y""y"),) exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))exitStmt("y").returns(over("b"),to("c"),flow("2","1")) .returns(over("c"), to("d"), flow("2", "1")));.returns(over("c"),to("d"),flow("2","1")));  public void multipleSeedsPreventReusingSummary() {publicvoidmultipleSeedsPreventReusingSummary(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints(),startPoints(), normalStmt("a1").succ("b", flow("0", "1")),normalStmt("a1").).succsucc(("b""b",flow("0","1")), normalStmt("a2").succ("b", flow("0", "1")),normalStmt("a2").).succsucc(("b""b",flow("0","1")), normalStmt("a1", flow("0", "1")).succ("b"),normalStmt("a1",flow("0","1"))..succsucc(("b""b"),) normalStmt("a2", flow("0", "1")).succ("b"),normalStmt("a2",flow("0","1"))..succsucc(("b""b"),) callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),callSite("b").calls("bar",flow(times(2),"1","2")).retSite("c",kill(times(2),"1")), callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),callSite("c").calls("bar",flow(times(2),"1","2")).retSite("d",kill(times(2),"1")), exitStmt("d").expectArtificalFlow(kill(times(2), "1")));exitStmt("d").expectArtificalFlow(kill(times(2),"1")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints("x"),startPoints("x"), normalStmt("x").succ("y", flow("2", "2")),normalStmt("x").).succsucc(("y""y",flow("2","2")), normalStmt("x", flow("2", "2")).succ("y"),normalStmt("x",flow("2","2"))..succsucc(("y""y"),) exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))exitStmt("y").returns(over("b"),to("c"),flow(times(2),"2","1")) .returns(over("c"), to("d"), flow(times(2), "2", "1")));.returns(over("c"),to("d"),flow(times(2),"2","1")));  public void dontResumeIfReturnFlowIsKilled() {publicvoiddontResumeIfReturnFlowIsKilled(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints(), startPoints(), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").).succsucc(("b""b",flow("0","1")), normalStmt("a", flow("0", "1")).succ("b"),normalStmt("a",flow("0","1"))..succsucc(("b""b"),) exitStmt("b").returns(over("cs"), to("y"), kill("1")));exitStmt("b").returns(over("cs"),to("y"),kill("1")));  forwardHelper.method("bar",forwardHelper.method("bar",  backwardHelper.method("foo",backwardHelper.method("foo", startPoints(),startPoints(), normalStmt("a").succ("c", flow("0", "1")),normalStmt("a").).succsucc(("c""c",flow("0","1")), normalStmt("a", flow("0", "1")).succ("c"),normalStmt("a",flow("0","1"))..succsucc(("c""c"),) exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));exitStmt("c").returns(over("cs"),to("x"),flow("1","2")));  backwardHelper.method("bar",backwardHelper.method("bar",








test/heros/IFDSSolverTest.java








View file @ 2de8ef31






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......












test/heros/IFDSSolverTest.java








View file @ 2de8ef31








test/heros/IFDSSolverTest.java










View file @ 2de8ef31


2de8ef31



......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......






......@@ -30,13 +30,13 @@ public class IFDSSolverTest {









 public void happyPath() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "x")),










 normalStmt("b").succ("c", flow("x", "x")),










 normalStmt("a", flow("0", "x")).succ("b"),










 normalStmt("b", flow("x", "x")).succ("c"),










 callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));










 










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("y", "y", "z")),










 normalStmt("d", flow("y", "y", "z")).succ("e"),










 exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));










 










 helper.runSolver(false, "a");



......@@ -48,11 +48,11 @@ public class IFDSSolverTest {









 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 normalStmt("c", flow("w", "0")).succ("c0"));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 normalStmt("d", flow("x", "z")).succ("e"),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 



......@@ -64,11 +64,11 @@ public class IFDSSolverTest {









 helper.method("foo",










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),










 normalStmt("b").succ("c", flow("2", "3")));










 normalStmt("b", flow("2", "3")).succ("c"));










 










 helper.method("bar",










 startPoints("g"),










 normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),










 normalStmt("g", flow("1", "1")).succ("i").succ("h"),










 callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),










 exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))










 .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));



......@@ -80,11 +80,11 @@ public class IFDSSolverTest {









 public void branch() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),










 normalStmt("b1").succ("c", flow("x", "x", "y")),










 normalStmt("b2").succ("c", flow("x", "x")),










 normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),










 normalStmt("d").succ("e", flow("z"), flow("w")));










 normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),










 normalStmt("b1", flow("x", "x", "y")).succ("c"),










 normalStmt("b2", flow("x", "x")).succ("c"),










 normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),










 normalStmt("d", flow("z"), flow("w")).succ("e"));










 










 helper.runSolver(false, "a");










 }



......@@ -93,12 +93,12 @@ public class IFDSSolverTest {









 public void unbalancedReturn() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));










 










 helper.method("bar", 










 startPoints("unused"),










 normalStmt("y").succ("z", flow("1", "2")));










 normalStmt("y", flow("1", "2")).succ("z"));










 










 helper.runSolver(true, "a");










 }



......@@ -107,7 +107,7 @@ public class IFDSSolverTest {









 public void artificalReturnEdgeForNoCallersCase() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(null, null, flow("1", "1")));










 










 helper.runSolver(true, "a");



......


 public void happyPath() {publicvoidhappyPath(){ helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "x")),normalStmt("a").).succsucc(("b""b",flow("0","x")), normalStmt("b").succ("c", flow("x", "x")),normalStmt("b").).succsucc(("c""c",flow("x","x")), normalStmt("a", flow("0", "x")).succ("b"),normalStmt("a",flow("0","x"))..succsucc(("b""b"),) normalStmt("b", flow("x", "x")).succ("c"),normalStmt("b",flow("x","x"))..succsucc(("c""c"),) callSite("c").calls("foo", flow("x", "y")).retSite("f", flow("x", "x")));callSite("c").calls("foo",flow("x","y")).retSite("f",flow("x","x")));  helper.method("foo",helper.method("foo", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("y", "y", "z")),normalStmt("d").).succsucc(("e""e",flow("y","y","z")), normalStmt("d", flow("y", "y", "z")).succ("e"),normalStmt("d",flow("y","y","z"))..succsucc(("e""e"),) exitStmt("e").returns(over("c"), to("f"), flow("z", "u"), flow("y")));exitStmt("e").returns(over("c"),to("f"),flow("z","u"),flow("y")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); startPoints("a"),startPoints("a"), callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),callSite("a").calls("bar",flow("0","x")).retSite("b",flow("0","y")), callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),callSite("b").calls("bar",flow("y","x")).retSite("c",flow("y")), normalStmt("c").succ("c0", flow("w", "0")));normalStmt("c").).succsucc(("c0""c0",flow("w","0"))); normalStmt("c", flow("w", "0")).succ("c0"));normalStmt("c",flow("w","0"))..succsucc(("c0""c0"));)  helper.method("bar",helper.method("bar", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("x", "z")),normalStmt("d").).succsucc(("e""e",flow("x","z")), normalStmt("d", flow("x", "z")).succ("e"),normalStmt("d",flow("x","z"))..succsucc(("e""e"),) exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))exitStmt("e").returns(over("a"),to("b"),flow("z","y")) .returns(over("b"), to("c"), flow("z", "w")));.returns(over("b"),to("c"),flow("z","w")));  helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), callSite("a").calls("bar", flow("0", "1")).retSite("b", flow("0")),callSite("a").calls("bar",flow("0","1")).retSite("b",flow("0")), normalStmt("b").succ("c", flow("2", "3")));normalStmt("b").).succsucc(("c""c",flow("2","3"))); normalStmt("b", flow("2", "3")).succ("c"));normalStmt("b",flow("2","3"))..succsucc(("c""c"));)  helper.method("bar",helper.method("bar", startPoints("g"),startPoints("g"), normalStmt("g").succ("h", flow("1", "1")).succ("i", flow("1", "1")),normalStmt("g").).succsucc(("h""h",flow("1","1")).succ("i",, flowflow(("1""1",, "1""1")),) normalStmt("g", flow("1", "1")).succ("i").succ("h"),normalStmt("g",flow("1","1")).succ("i").).succsucc(("h""h"), callSite("i").calls("bar", flow("1", "1")).retSite("h", flow("1")),callSite("i").calls("bar",flow("1","1")).retSite("h",flow("1")), exitStmt("h").returns(over("a"), to("b"), flow("1"), flow("2" ,"2"))exitStmt("h").returns(over("a"),to("b"),flow("1"),flow("2","2")) .returns(over("i"), to("h"), flow("1","2"), flow("2", "2")));.returns(over("i"),to("h"),flow("1","2"),flow("2","2"))); public void branch() {publicvoidbranch(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b1", flow("0", "x")).succ("b2", flow("0", "x")),normalStmt("a").).succsucc(("b1""b1",flow("0","x")).succ("b2",, flowflow(("0""0",, "x""x")),) normalStmt("b1").succ("c", flow("x", "x", "y")),normalStmt("b1").).succsucc(("c""c",flow("x","x","y")), normalStmt("b2").succ("c", flow("x", "x")),normalStmt("b2").).succsucc(("c""c",flow("x","x")), normalStmt("c").succ("d", flow("x", "z"), flow("y", "w")),normalStmt("c").).succsucc(("d""d",flow("x","z"),flow("y","w")), normalStmt("d").succ("e", flow("z"), flow("w")));normalStmt("d").).succsucc(("e""e",flow("z"),flow("w"))); normalStmt("a", flow("0", "x")).succ("b2").succ("b1"),normalStmt("a",flow("0","x")).succ("b2").).succsucc(("b1""b1"), normalStmt("b1", flow("x", "x", "y")).succ("c"),normalStmt("b1",flow("x","x","y"))..succsucc(("c""c"),) normalStmt("b2", flow("x", "x")).succ("c"),normalStmt("b2",flow("x","x"))..succsucc(("c""c"),) normalStmt("c", flow("x", "z"), flow("y", "w")).succ("d"),normalStmt("c",flow("x","z"),flow("y","w"))..succsucc(("d""d"),) normalStmt("d", flow("z"), flow("w")).succ("e"));normalStmt("d",flow("z"),flow("w"))..succsucc(("e""e"));)  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} public void unbalancedReturn() {publicvoidunbalancedReturn(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").).succsucc(("b""b",flow("0","1")), normalStmt("a", flow("0", "1")).succ("b"),normalStmt("a",flow("0","1"))..succsucc(("b""b"),) exitStmt("b").returns(over("x"), to("y"), flow("1", "1")));exitStmt("b").returns(over("x"),to("y"),flow("1","1")));  helper.method("bar", helper.method("bar", startPoints("unused"),startPoints("unused"), normalStmt("y").succ("z", flow("1", "2")));normalStmt("y").).succsucc(("z""z",flow("1","2"))); normalStmt("y", flow("1", "2")).succ("z"));normalStmt("y",flow("1","2"))..succsucc(("z""z"));)  helper.runSolver(true, "a");helper.runSolver(true,"a"); }} public void artificalReturnEdgeForNoCallersCase() {publicvoidartificalReturnEdgeForNoCallersCase(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").).succsucc(("b""b",flow("0","1")), normalStmt("a", flow("0", "1")).succ("b"),normalStmt("a",flow("0","1"))..succsucc(("b""b"),) exitStmt("b").returns(null, null, flow("1", "1")));exitStmt("b").returns(null,null,flow("1","1")));  helper.runSolver(true, "a");helper.runSolver(true,"a");








test/heros/alias/AccessPathTest.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}












test/heros/alias/AccessPathTest.java








View file @ 2de8ef31








test/heros/alias/AccessPathTest.java










View file @ 2de8ef31


2de8ef31










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;










import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertArrayEquals;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 assertEquals(ap("a.b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<String> sut = ap("^a");










 sut.append("a"); 










 }










 










 @Test










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 assertEquals(ap("b"), ap("a.b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);










 }










 










 @Test










 public void deltaDepth2() {










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 AccessPath<String> actual = ap("^f");










 Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;










 assertEquals(0, accesses.length);










 assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch.5 Johannes Lerch * Copyright (c) 2014 Eric Bodden. * Copyright (c) 2014 Eric Bodden.4 Eric Bodden * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementationJohannes Lerch *     Eric Bodden - initial API and implementation *     Eric Bodden - initial API and implementationEric Bodden ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static org.junit.Assert.*;importstaticorg.junit.Assert.*;import static heros.alias.AccessPath.PrefixTestResult.*;importstaticheros.alias.AccessPath.PrefixTestResult.*;import static org.junit.Assert.assertArrayEquals;importstaticorg.junit.Assert.assertArrayEquals;import static org.junit.Assert.assertEquals;importstaticorg.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;importstaticorg.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import java.util.regex.Matcher;importjava.util.regex.Matcher;import java.util.regex.Pattern;importjava.util.regex.Pattern;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import org.junit.Test;importorg.junit.Test;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPathTest {publicclassAccessPathTest{  private static AccessPath<String> ap(String... path) {privatestaticAccessPath<String>ap(String...path){ return new AccessPath<String>(path, Sets.<String> newHashSet());returnnewAccessPath<String>(path,Sets.<String>newHashSet()); public static AccessPath<String> ap(String ap) {publicstaticAccessPath<String>ap(Stringap){ Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)?([^\\.\\^]+)"); Matcher matcher = pattern.matcher(ap);Matchermatcher=pattern.matcher(ap); AccessPath<String> accessPath = new AccessPath<>();AccessPath<String>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  while(matcher.find()) {while(matcher.find()){ String separator = matcher.group(1);Stringseparator=matcher.group(1); String identifier = matcher.group(2);Stringidentifier=matcher.group(2);  if(".".equals(separator) || separator == null) {if(".".equals(separator)||separator==null){ if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.append(identifier);accessPath=accessPath.append(identifier); } else {}else{ addedExclusions=true;addedExclusions=true; String[] excl = identifier.split(",");String[]excl=identifier.split(","); accessPath = accessPath.appendExcludedFieldReference(excl);accessPath=accessPath.appendExcludedFieldReference(excl); }} }} return accessPath;returnaccessPath; }}  @Test@Test public void append() {publicvoidappend(){ AccessPath<String> sut = ap("a");AccessPath<String>sut=ap("a"); assertEquals(ap("a", "b"), sut.append("b"));assertEquals(ap("a"",, "b""),sut.append("b")); assertEquals(ap("a.b"), sut.append("b"));assertEquals(ap("a.b".),sut.append("b")); }}  @Test@Test public void addOnExclusion() {publicvoidaddOnExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<String>sut=ap().).appendExcludedFieldReferenceappendExcludedFieldReference(("a"); AccessPath<String> sut = ap("^a");AccessPath<String>sut=ap("^a"^); assertEquals(ap("b"), sut.append("b"));assertEquals(ap("b"),sut.append("b")); }}  @Test(expected=IllegalArgumentException.class)@Test(expected=IllegalArgumentException.class) public void addMergedFieldsOnSingleExclusion() {publicvoidaddMergedFieldsOnSingleExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<String>sut=ap().).appendExcludedFieldReferenceappendExcludedFieldReference(("a"); AccessPath<String> sut = ap("^a");AccessPath<String>sut=ap("^a"^); sut.append("a"); sut.append("a"); }}  @Test@Test public void prepend() {publicvoidprepend(){ assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));assertEquals(ap("c"",, "a""a",, "b""),ap("a"",, "b"").prepend("c")); assertEquals(ap("c.a.b"), ap("a.b").prepend("c"));assertEquals(ap("c.a.b".a.),ap("a.b".).prepend("c")); }}  @Test@Test public void remove() {publicvoidremove(){ assertEquals(ap("b"), ap("a", "b").removeFirst());assertEquals(ap("b"),ap("a"",, "b"").removeFirst()); assertEquals(ap("b"), ap("a.b").removeFirst());assertEquals(ap("b"),ap("a.b".).removeFirst()); }}  @Test@Test public void deltaDepth1() {publicvoiddeltaDepth1(){ String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;String[]actual=ap("a").getDeltaTo(ap("a","b")).accesses; assertArrayEquals(new String[] { "b" }, actual);assertArrayEquals(newString[]{"b"},actual); assertArrayEquals(new String[] { "b" }, ap("a").getDeltaTo(ap("a.b")).accesses);assertArrayEquals(newString[]{"b"},ap("a").getDeltaTo(ap("a.b")).accesses); }}  @Test@Test public void deltaDepth2() {publicvoiddeltaDepth2(){ String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;String[]actual=ap("a").getDeltaTo(ap("a","b","c")).accesses; assertArrayEquals(new String[] { "b", "c" }, actual);assertArrayEquals(newString[]{"b","c"},actual); assertArrayEquals(new String[] { "b", "c" }, ap("a").getDeltaTo(ap("a.b.c")).accesses);assertArrayEquals(newString[]{"b","c"},ap("a").getDeltaTo(ap("a.b.c")).accesses); }}  @Test@Test public void emptyDeltaOnEqualExclusions() {publicvoidemptyDeltaOnEqualExclusions(){ AccessPath<String> actual = ap().appendExcludedFieldReference("f");AccessPath<String>actual=ap().appendExcludedFieldReference("f"); assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);assertEquals(0,actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length); assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f"))); AccessPath<String> actual = ap("^f");AccessPath<String>actual=ap("^f"); Object[] accesses = actual.getDeltaTo(ap("^f")).accesses;Object[]accesses=actual.getDeltaTo(ap("^f")).accesses; assertEquals(0, accesses.length);assertEquals(0,accesses.length); assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f")));assertTrue(actual.getDeltaTo(ap("^f")).exclusions.equals(Sets.newHashSet("f"))); }}  @Test@Test public void multipleExclPrefixOfMultipleExcl() {publicvoidmultipleExclPrefixOfMultipleExcl(){ AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");AccessPath<String>sut=ap().appendExcludedFieldReference("f","g"); assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));assertEquals(PrefixTestResult.POTENTIAL_PREFIX,sut.isPrefixOf(ap().appendExcludedFieldReference("f","h"))); assertEquals(PrefixTestResult.POTENTIAL_PREFIX, ap("^f,g").isPrefixOf(ap("^f,h")));assertEquals(PrefixTestResult.POTENTIAL_PREFIX,ap("^f,g").isPrefixOf(ap("^f,h"))); }}  @Test@Test public void testBaseValuePrefixOfFieldAccess() {publicvoidtestBaseValuePrefixOfFieldAccess(){ assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("f"))); assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,ap("f").isPrefixOf(ap(""))); }}  @Test@Test public void testBaseValueIdentity() {publicvoidtestBaseValueIdentity(){ assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap(""))); }}  @Test@Test public void testFieldAccessPrefixOfFieldAccess() {publicvoidtestFieldAccessPrefixOfFieldAccess(){ assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));assertEquals(GUARANTEED_PREFIX,ap("b").isPrefixOf(ap("b.c"))); assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));assertEquals(NO_PREFIX,ap("b.c").isPrefixOf(ap("b"))); }}  @Test@Test public void testPrefixOfFieldAccessWithExclusion() {publicvoidtestPrefixOfFieldAccessWithExclusion(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g"))); assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f"))); }}  @Test@Test public void testIdentityWithExclusion() {publicvoidtestIdentityWithExclusion(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f"))); assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g"))); }}  @Test@Test public void testDifferentExclusions() {publicvoidtestDifferentExclusions(){ assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g"))); }}  @Test@Test public void testMixedFieldAccess() {publicvoidtestMixedFieldAccess(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g"))); assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h"))); assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g"))); }}  @Test@Test public void testMultipleExclusions() {publicvoidtestMultipleExclusions(){ assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f"))); assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g"))); assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g"))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g"))); }} @Test@Test public void testDifferentAccessPathLength() {publicvoidtestDifferentAccessPathLength(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h"))); }}  @Test@Test public void testExclusionRequiresFieldAccess() {publicvoidtestExclusionRequiresFieldAccess(){ assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f"))); assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));  assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g"))); assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));  assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h"))); assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f"))); }} }}








test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}












test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0







View file @ e60e669d








test/heros/alias/AccessPathUtilTest.java

deleted


100644 → 0









View file @ e60e669d


e60e669d










/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}













/*******************************************************************************










 * Copyright (c) 2014 Eric Bodden.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Eric Bodden - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Eric Bodden. * Copyright (c) 2014 Eric Bodden. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Eric Bodden - initial API and implementation *     Eric Bodden - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static heros.alias.AccessPath.PrefixTestResult.*;importstaticheros.alias.AccessPath.PrefixTestResult.*;import static org.junit.Assert.assertEquals;importstaticorg.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;importstaticorg.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import java.util.regex.Matcher;importjava.util.regex.Matcher;import java.util.regex.Pattern;importjava.util.regex.Pattern;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import org.junit.Test;importorg.junit.Test;public class AccessPathUtilTest {publicclassAccessPathUtilTest{ public static AccessPath<String> ap(String ap) {publicstaticAccessPath<String>ap(Stringap){ Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)?([^\\.\\^]+)"); Matcher matcher = pattern.matcher(ap);Matchermatcher=pattern.matcher(ap); AccessPath<String> accessPath = new AccessPath<>();AccessPath<String>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  while(matcher.find()) {while(matcher.find()){ String separator = matcher.group(1);Stringseparator=matcher.group(1); String identifier = matcher.group(2);Stringidentifier=matcher.group(2);  if(".".equals(separator) || separator == null) {if(".".equals(separator)||separator==null){ if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.append(identifier);accessPath=accessPath.append(identifier); } else {}else{ addedExclusions=true;addedExclusions=true; String[] excl = identifier.split(",");String[]excl=identifier.split(","); accessPath = accessPath.appendExcludedFieldReference(excl);accessPath=accessPath.appendExcludedFieldReference(excl); }} }} return accessPath;returnaccessPath; }}  @Test@Test public void testBaseValuePrefixOfFieldAccess() {publicvoidtestBaseValuePrefixOfFieldAccess(){ assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("f"))); assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,ap("f").isPrefixOf(ap(""))); }}  @Test@Test public void testBaseValueIdentity() {publicvoidtestBaseValueIdentity(){ assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap(""))); }}  @Test@Test public void testFieldAccessPrefixOfFieldAccess() {publicvoidtestFieldAccessPrefixOfFieldAccess(){ assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));assertEquals(GUARANTEED_PREFIX,ap("b").isPrefixOf(ap("b.c"))); assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));assertEquals(NO_PREFIX,ap("b.c").isPrefixOf(ap("b"))); }}  @Test@Test public void testPrefixOfFieldAccessWithExclusion() {publicvoidtestPrefixOfFieldAccessWithExclusion(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g"))); assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f"))); }}  @Test@Test public void testIdentityWithExclusion() {publicvoidtestIdentityWithExclusion(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f"))); assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g"))); }}  @Test@Test public void testDifferentExclusions() {publicvoidtestDifferentExclusions(){ assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g"))); }}  @Test@Test public void testMixedFieldAccess() {publicvoidtestMixedFieldAccess(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g"))); assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h"))); assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g"))); }}  @Test@Test public void testMultipleExclusions() {publicvoidtestMultipleExclusions(){ assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f"))); assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g"))); assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g"))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g"))); }} @Test@Test public void testDifferentAccessPathLength() {publicvoidtestDifferentAccessPathLength(){ assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h"))); }}  @Test@Test public void testExclusionRequiresFieldAccess() {publicvoidtestExclusionRequiresFieldAccess(){ assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f"))); assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));  assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g"))); assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));  assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h"))); assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f"))); }} }}








test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}












test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644







View file @ 2de8ef31








test/heros/alias/BiDiFieldSensitiveIFDSSolverTest.java



0 → 100644









View file @ 2de8ef31


2de8ef31










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;










import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;





















import java.util.Collection;










import java.util.LinkedList;





















import org.junit.Test;










import org.junit.runner.RunWith;










import org.junit.runners.Parameterized;










import org.junit.runners.Parameterized.Parameters;





















import com.google.common.collect.Lists;





















import static heros.utilities.FieldSensitiveTestHelper.*;
































@RunWith(Parameterized.class)










public class BiDiFieldSensitiveIFDSSolverTest {





















 private FieldSensitiveTestHelper forwardHelper;










 private FieldSensitiveTestHelper backwardHelper;










 private TabulationProblemExchange exchange;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;










 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }





















 @Parameters(name="{0}")










 public static Collection<Object[]> parameters() {










 LinkedList<Object[]> result = Lists.newLinkedList();










 result.add(new Object[] {TabulationProblemExchange.AsSpecified});










 result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});










 return result;










 }










 










 @Test










 public void happyPath() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").expectArtificalFlow(flow("1")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").expectArtificalFlow(flow("2")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsInBothDirections() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(kill("2")));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints("y"),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(kill("3")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void unbalancedReturnsNonMatchingCallSites() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y1").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", flow("0", "2")).succ("a"),










 exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y2").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void returnsOnlyOneDirectionAndStops() {










 forwardHelper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b"),










 normalStmt("b", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z"),










 exitStmt("z").expectArtificalFlow(/*none*/));










 










 backwardHelper.method("foo",










 startPoints("c"),










 normalStmt("c").succ("b"),










 normalStmt("b", kill("0")).succ("a"),










 exitStmt("a").returns(over("y"), to("x") /*none*/));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("x"),










 exitStmt("x").expectArtificalFlow(/*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");










 }










 










 @Test










 public void reuseSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),










 exitStmt("d").expectArtificalFlow(kill("1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))










 .returns(over("c"), to("d"), flow("2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










 










 @Test










 public void multipleSeedsPreventReusingSummary() {










 forwardHelper.method("foo",










 startPoints(),










 normalStmt("a1", flow("0", "1")).succ("b"),










 normalStmt("a2", flow("0", "1")).succ("b"),










 callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),










 callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),










 exitStmt("d").expectArtificalFlow(kill(times(2), "1")));










 










 forwardHelper.method("bar",










 startPoints("x"),










 normalStmt("x", flow("2", "2")).succ("y"),










 exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))










 .returns(over("c"), to("d"), flow(times(2), "2", "1")));










 










 backwardHelper.method("foo",










 startPoints(),










 exitStmt("a1").expectArtificalFlow(kill("0")),










 exitStmt("a2").expectArtificalFlow(kill("0")));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");










 }





















 @Test










 public void dontResumeIfReturnFlowIsKilled() {










 forwardHelper.method("foo",










 startPoints(), 










 normalStmt("a", flow("0", "1")).succ("b"),










 exitStmt("b").returns(over("cs"), to("y"), kill("1")));










 










 forwardHelper.method("bar",










 startPoints(),










 normalStmt("y").succ("z" /* none */));










 










 backwardHelper.method("foo",










 startPoints(),










 normalStmt("a", flow("0", "1")).succ("c"),










 exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));










 










 backwardHelper.method("bar",










 startPoints(),










 normalStmt("cs").succ("x"),










 normalStmt("x").succ("z" /*none*/));










 










 forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.utilities.FieldSensitiveTestHelper;importheros.utilities.FieldSensitiveTestHelper;import heros.utilities.Statement;importheros.utilities.Statement;import heros.utilities.TestDebugger;importheros.utilities.TestDebugger;import heros.utilities.TestFact;importheros.utilities.TestFact;import heros.utilities.TestMethod;importheros.utilities.TestMethod;import heros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;importheros.utilities.FieldSensitiveTestHelper.TabulationProblemExchange;import java.util.Collection;importjava.util.Collection;import java.util.LinkedList;importjava.util.LinkedList;import org.junit.Test;importorg.junit.Test;import org.junit.runner.RunWith;importorg.junit.runner.RunWith;import org.junit.runners.Parameterized;importorg.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;importorg.junit.runners.Parameterized.Parameters;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import static heros.utilities.FieldSensitiveTestHelper.*;importstaticheros.utilities.FieldSensitiveTestHelper.*;@RunWith(Parameterized.class)@RunWith(Parameterized.class)public class BiDiFieldSensitiveIFDSSolverTest {publicclassBiDiFieldSensitiveIFDSSolverTest{ private FieldSensitiveTestHelper forwardHelper;privateFieldSensitiveTestHelperforwardHelper; private FieldSensitiveTestHelper backwardHelper;privateFieldSensitiveTestHelperbackwardHelper; private TabulationProblemExchange exchange;privateTabulationProblemExchangeexchange; private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;privateTestDebugger<String,TestFact,Statement,TestMethod,InterproceduralCFG<Statement,TestMethod>>debugger;  public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {publicBiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchangeexchange){ this.exchange = exchange;this.exchange=exchange; debugger = new TestDebugger<>();debugger=newTestDebugger<>(); forwardHelper = new FieldSensitiveTestHelper(debugger);forwardHelper=newFieldSensitiveTestHelper(debugger); backwardHelper = new FieldSensitiveTestHelper(debugger);backwardHelper=newFieldSensitiveTestHelper(debugger); }} @Parameters(name="{0}")@Parameters(name="{0}") public static Collection<Object[]> parameters() {publicstaticCollection<Object[]>parameters(){ LinkedList<Object[]> result = Lists.newLinkedList();LinkedList<Object[]>result=Lists.newLinkedList(); result.add(new Object[] {TabulationProblemExchange.AsSpecified});result.add(newObject[]{TabulationProblemExchange.AsSpecified}); result.add(new Object[] {TabulationProblemExchange.ExchangeForwardAndBackward});result.add(newObject[]{TabulationProblemExchange.ExchangeForwardAndBackward}); return result;returnresult; }}  @Test@Test public void happyPath() {publicvoidhappyPath(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1")).succ("c"), exitStmt("c").expectArtificalFlow(flow("1")));exitStmt("c").expectArtificalFlow(flow("1")));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b", flow("0", "2")).succ("a"),normalStmt("b",flow("0","2")).succ("a"), exitStmt("a").expectArtificalFlow(flow("2")));exitStmt("a").expectArtificalFlow(flow("2")));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");forwardHelper.runBiDiSolver(backwardHelper,exchange,"b"); }}  @Test@Test public void unbalancedReturnsInBothDirections() {publicvoidunbalancedReturnsInBothDirections(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1")).succ("c"), exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));exitStmt("c").returns(over("y"),to("z"),flow("1","2")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints("y"),startPoints("y"), normalStmt("y").succ("z"),normalStmt("y").succ("z"), exitStmt("z").expectArtificalFlow(kill("2")));exitStmt("z").expectArtificalFlow(kill("2")));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b", flow("0", "2")).succ("a"),normalStmt("b",flow("0","2")).succ("a"), exitStmt("a").returns(over("y"), to("x"), flow("2", "3")));exitStmt("a").returns(over("y"),to("x"),flow("2","3")));  backwardHelper.method("bar",backwardHelper.method("bar", startPoints("y"),startPoints("y"), normalStmt("y").succ("x"),normalStmt("y").succ("x"), exitStmt("x").expectArtificalFlow(kill("3")));exitStmt("x").expectArtificalFlow(kill("3")));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");forwardHelper.runBiDiSolver(backwardHelper,exchange,"b"); }}  @Test@Test public void unbalancedReturnsNonMatchingCallSites() {publicvoidunbalancedReturnsNonMatchingCallSites(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1")).succ("c"), exitStmt("c").returns(over("y1"), to("z"), flow("1", "2")));exitStmt("c").returns(over("y1"),to("z"),flow("1","2")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints(),startPoints(), normalStmt("y1").succ("z"),normalStmt("y1").succ("z"), exitStmt("z").expectArtificalFlow(/*none*/));exitStmt("z").expectArtificalFlow(/*none*/));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b", flow("0", "2")).succ("a"),normalStmt("b",flow("0","2")).succ("a"), exitStmt("a").returns(over("y2"), to("x"), flow("2", "3")));exitStmt("a").returns(over("y2"),to("x"),flow("2","3")));  backwardHelper.method("bar",backwardHelper.method("bar", startPoints(),startPoints(), normalStmt("y2").succ("x"),normalStmt("y2").succ("x"), exitStmt("x").expectArtificalFlow(/*none*/));exitStmt("x").expectArtificalFlow(/*none*/));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");forwardHelper.runBiDiSolver(backwardHelper,exchange,"b"); }}  @Test@Test public void returnsOnlyOneDirectionAndStops() {publicvoidreturnsOnlyOneDirectionAndStops(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b"),normalStmt("a").succ("b"), normalStmt("b", flow("0", "1")).succ("c"),normalStmt("b",flow("0","1")).succ("c"), exitStmt("c").returns(over("y"), to("z"), flow("1", "2")));exitStmt("c").returns(over("y"),to("z"),flow("1","2")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints(),startPoints(), normalStmt("y").succ("z"),normalStmt("y").succ("z"), exitStmt("z").expectArtificalFlow(/*none*/));exitStmt("z").expectArtificalFlow(/*none*/));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints("c"),startPoints("c"), normalStmt("c").succ("b"),normalStmt("c").succ("b"), normalStmt("b", kill("0")).succ("a"),normalStmt("b",kill("0")).succ("a"), exitStmt("a").returns(over("y"), to("x") /*none*/));exitStmt("a").returns(over("y"),to("x")/*none*/));  backwardHelper.method("bar",backwardHelper.method("bar", startPoints(),startPoints(), normalStmt("y").succ("x"),normalStmt("y").succ("x"), exitStmt("x").expectArtificalFlow(/*none*/));exitStmt("x").expectArtificalFlow(/*none*/));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "b");forwardHelper.runBiDiSolver(backwardHelper,exchange,"b"); }}  @Test@Test public void reuseSummary() {publicvoidreuseSummary(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints(),startPoints(), normalStmt("a", flow("0", "1")).succ("b"),normalStmt("a",flow("0","1")).succ("b"), callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("c",kill("1")), callSite("c").calls("bar", flow("1", "2")).retSite("d", kill("1")),callSite("c").calls("bar",flow("1","2")).retSite("d",kill("1")), exitStmt("d").expectArtificalFlow(kill("1")));exitStmt("d").expectArtificalFlow(kill("1")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints("x"),startPoints("x"), normalStmt("x", flow("2", "2")).succ("y"),normalStmt("x",flow("2","2")).succ("y"), exitStmt("y").returns(over("b"), to("c"), flow("2", "1"))exitStmt("y").returns(over("b"),to("c"),flow("2","1")) .returns(over("c"), to("d"), flow("2", "1")));.returns(over("c"),to("d"),flow("2","1")));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints(),startPoints(), exitStmt("a").expectArtificalFlow(kill("0")));exitStmt("a").expectArtificalFlow(kill("0")));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");forwardHelper.runBiDiSolver(backwardHelper,exchange,"a"); }}  @Test@Test public void multipleSeedsPreventReusingSummary() {publicvoidmultipleSeedsPreventReusingSummary(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints(),startPoints(), normalStmt("a1", flow("0", "1")).succ("b"),normalStmt("a1",flow("0","1")).succ("b"), normalStmt("a2", flow("0", "1")).succ("b"),normalStmt("a2",flow("0","1")).succ("b"), callSite("b").calls("bar", flow(times(2), "1", "2")).retSite("c", kill(times(2), "1")),callSite("b").calls("bar",flow(times(2),"1","2")).retSite("c",kill(times(2),"1")), callSite("c").calls("bar", flow(times(2), "1", "2")).retSite("d", kill(times(2), "1")),callSite("c").calls("bar",flow(times(2),"1","2")).retSite("d",kill(times(2),"1")), exitStmt("d").expectArtificalFlow(kill(times(2), "1")));exitStmt("d").expectArtificalFlow(kill(times(2),"1")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints("x"),startPoints("x"), normalStmt("x", flow("2", "2")).succ("y"),normalStmt("x",flow("2","2")).succ("y"), exitStmt("y").returns(over("b"), to("c"), flow(times(2), "2", "1"))exitStmt("y").returns(over("b"),to("c"),flow(times(2),"2","1")) .returns(over("c"), to("d"), flow(times(2), "2", "1")));.returns(over("c"),to("d"),flow(times(2),"2","1")));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints(),startPoints(), exitStmt("a1").expectArtificalFlow(kill("0")),exitStmt("a1").expectArtificalFlow(kill("0")), exitStmt("a2").expectArtificalFlow(kill("0")));exitStmt("a2").expectArtificalFlow(kill("0")));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "a1", "a2");forwardHelper.runBiDiSolver(backwardHelper,exchange,"a1","a2"); }} @Test@Test public void dontResumeIfReturnFlowIsKilled() {publicvoiddontResumeIfReturnFlowIsKilled(){ forwardHelper.method("foo",forwardHelper.method("foo", startPoints(), startPoints(), normalStmt("a", flow("0", "1")).succ("b"),normalStmt("a",flow("0","1")).succ("b"), exitStmt("b").returns(over("cs"), to("y"), kill("1")));exitStmt("b").returns(over("cs"),to("y"),kill("1")));  forwardHelper.method("bar",forwardHelper.method("bar", startPoints(),startPoints(), normalStmt("y").succ("z" /* none */));normalStmt("y").succ("z"/* none */));  backwardHelper.method("foo",backwardHelper.method("foo", startPoints(),startPoints(), normalStmt("a", flow("0", "1")).succ("c"),normalStmt("a",flow("0","1")).succ("c"), exitStmt("c").returns(over("cs"), to("x"), flow("1", "2")));exitStmt("c").returns(over("cs"),to("x"),flow("1","2")));  backwardHelper.method("bar",backwardHelper.method("bar", startPoints(),startPoints(), normalStmt("cs").succ("x"),normalStmt("cs").succ("x"), normalStmt("x").succ("z" /*none*/));normalStmt("x").succ("z"/*none*/));  forwardHelper.runBiDiSolver(backwardHelper, exchange, "a");forwardHelper.runBiDiSolver(backwardHelper,exchange,"a"); }}}}








test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......












test/heros/alias/ControlFlowJoinResolverTest.java








View file @ 2de8ef31








test/heros/alias/ControlFlowJoinResolverTest.java










View file @ 2de8ef31


2de8ef31



......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ControlFlowJoinResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement joinStmt;










 private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,7 +105,7 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......


import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import static org.mockito.Mockito.*;importstaticorg.mockito.Mockito.*;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.utilities.Statement;importheros.utilities.Statement;import heros.utilities.TestFact;importheros.utilities.TestFact;import heros.utilities.TestMethod;importheros.utilities.TestMethod;import org.junit.Before;importorg.junit.Before;import org.junit.Test;importorg.junit.Test; return accPath;returnaccPath; }} private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<String,TestFact,TestStatementTest,TestMethod>analyzer; private TestStatement joinStmt;privateTestStatementTestjoinStmt; private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;privateControlFlowJoinResolver<String,TestFact,TestStatementTest,TestMethod>sut; private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<String,TestFact,Statement,TestMethod>analyzer; private Statement joinStmt;privateStatementjoinStmt; private ControlFlowJoinResolver<String, TestFact, Statement, TestMethod> sut;privateControlFlowJoinResolver<String,TestFact,Statement,TestMethod>sut; private TestFact fact;privateTestFactfact; private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<String,TestFact,TestStatementTest,TestMethod>callback; private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<String,TestFact,TestStatementTest,TestMethod>callEdgeResolver; private InterestCallback<String, TestFact, Statement, TestMethod> callback;privateInterestCallback<String,TestFact,Statement,TestMethod>callback; private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;privateResolver<String,TestFact,Statement,TestMethod>callEdgeResolver; @Before@Before public void before() {publicvoidbefore(){ analyzer = mock(PerAccessPathMethodAnalyzer.class);analyzer=mock(PerAccessPathMethodAnalyzer.class); joinStmt = new TestStatement("joinStmt");joinStmt=newTestStatementTest("joinStmt"); joinStmt = new Statement("joinStmt");joinStmt=newStatement("joinStmt"); sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);sut=newControlFlowJoinResolver<>(analyzer,joinStmt); fact = new TestFact("value");fact=newTestFact("value"); callback = mock(InterestCallback.class);callback=mock(InterestCallback.class); @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver)); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  @Test@Test public void resolveViaIncomingResolver() {publicvoidresolveViaIncomingResolver(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<String,TestFact,TestStatementTest,TestMethod>nestedResolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<String,TestFact,Statement,TestMethod>nestedResolver=mock(Resolver.class); Mockito.doAnswer(new Answer(){Mockito.doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<String,TestFact,TestStatementTest,TestMethod>argCallback= (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<String,TestFact,TestStatementTest,TestMethod>)invocation.getArguments()[1]; InterestCallback<String, TestFact, Statement, TestMethod> argCallback = InterestCallback<String,TestFact,Statement,TestMethod>argCallback= (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];(InterestCallback<String,TestFact,Statement,TestMethod>)invocation.getArguments()[1]; argCallback.interest(null, nestedResolver);argCallback.interest(null,nestedResolver); return null;returnnull; }}   private class ResolverArgumentMatcher extendsprivateclassResolverArgumentMatcherextends ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>>{ ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<String,TestFact,Statement,TestMethod>>{ private AccessPath<String> accPath;privateAccessPath<String>accPath;








test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}












test/heros/alias/EdgeBuilder.java

deleted


100644 → 0







View file @ e60e669d








test/heros/alias/EdgeBuilder.java

deleted


100644 → 0









View file @ e60e669d


e60e669d










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.TestHelper.Edge;










import heros.alias.TestHelper.ExpectedFlowFunction;





















import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;
































public abstract class EdgeBuilder {










 










 protected List<Edge> edges = Lists.newLinkedList();










 public Collection<Edge> edges() {










 if(edges.isEmpty()) {










 throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());










 }










 










 return edges;










 }





















 public static class CallSiteBuilder extends EdgeBuilder {





















 private TestStatement callSite;





















 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private TestStatement exitStmt;





















 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.TestHelper.Edge;importheros.alias.TestHelper.Edge;import heros.alias.TestHelper.ExpectedFlowFunction;importheros.alias.TestHelper.ExpectedFlowFunction;import java.util.Collection;importjava.util.Collection;import java.util.List;importjava.util.List;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;public abstract class EdgeBuilder {publicabstractclassEdgeBuilder{  protected List<Edge> edges = Lists.newLinkedList();protectedList<Edge>edges=Lists.newLinkedList(); public Collection<Edge> edges() {publicCollection<Edge>edges(){ if(edges.isEmpty()) {if(edges.isEmpty()){ throw new IllegalStateException("Not a single edge created on EdgeBuilder: "+toString());thrownewIllegalStateException("Not a single edge created on EdgeBuilder: "+toString()); }}  return edges;returnedges; }} public static class CallSiteBuilder extends EdgeBuilder {publicstaticclassCallSiteBuilderextendsEdgeBuilder{ private TestStatement callSite;privateTestStatementcallSite; public CallSiteBuilder(TestStatement callSite) {publicCallSiteBuilder(TestStatementcallSite){ this.callSite = callSite;this.callSite=callSite; }} public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {publicCallSiteBuildercalls(Stringmethod,ExpectedFlowFunction...flows){ edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));edges.add(newTestHelper.CallEdge(callSite,newTestMethod(method),flows)); return this;returnthis; }}  public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {publicCallSiteBuilderretSite(StringreturnSite,ExpectedFlowFunction...flows){ edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));edges.add(newTestHelper.Call2ReturnEdge(callSite,newTestStatement(returnSite),flows)); return this;returnthis; }} }}  public static class NormalStmtBuilder extends EdgeBuilder {publicstaticclassNormalStmtBuilderextendsEdgeBuilder{ private TestStatement stmt;privateTestStatementstmt; private ExpectedFlowFunction[] flowFunctions;privateExpectedFlowFunction[]flowFunctions; public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {publicNormalStmtBuilder(TestStatementstmt,ExpectedFlowFunction[]flowFunctions){ this.stmt = stmt;this.stmt=stmt; this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; }} public NormalStmtBuilder succ(String succ) {publicNormalStmtBuildersucc(Stringsucc){ edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));edges.add(newTestHelper.NormalEdge(stmt,newTestStatement(succ),flowFunctions)); return this;returnthis; }} }}  public static class ExitStmtBuilder extends EdgeBuilder {publicstaticclassExitStmtBuilderextendsEdgeBuilder{ private TestStatement exitStmt;privateTestStatementexitStmt; public ExitStmtBuilder(TestStatement exitStmt) {publicExitStmtBuilder(TestStatementexitStmt){ this.exitStmt = exitStmt;this.exitStmt=exitStmt; }}  public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {publicExitStmtBuilderexpectArtificalFlow(ExpectedFlowFunction...flows){ edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));edges.add(newTestHelper.ReturnEdge(null,exitStmt,null,flows)); return this;returnthis; }} public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {publicExitStmtBuilderreturns(TestStatementcallSite,TestStatementreturnSite,ExpectedFlowFunction...flows){ edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));edges.add(newTestHelper.ReturnEdge(callSite,exitStmt,returnSite,flows)); return this;returnthis; }}  }}}}








test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......












test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 2de8ef31








test/heros/alias/FieldSensitiveIFDSSolverTest.java










View file @ 2de8ef31


2de8ef31



......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......






......@@ -13,6 +13,11 @@ package heros.alias;































import heros.InterproceduralCFG;










import heros.utilities.FieldSensitiveTestHelper;










import heros.utilities.Statement;










import heros.utilities.TestDebugger;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Ignore;



......@@ -20,18 +25,18 @@ import org.junit.Rule;









import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;










import static heros.utilities.FieldSensitiveTestHelper.*;





















public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private FieldSensitiveTestHelper helper;










 private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;





















 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 helper = new TestHelper(debugger);










 helper = new FieldSensitiveTestHelper(debugger);










 }










 










 @Rule



......


import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.utilities.FieldSensitiveTestHelper;importheros.utilities.FieldSensitiveTestHelper;import heros.utilities.Statement;importheros.utilities.Statement;import heros.utilities.TestDebugger;importheros.utilities.TestDebugger;import heros.utilities.TestFact;importheros.utilities.TestFact;import heros.utilities.TestMethod;importheros.utilities.TestMethod;import org.junit.Before;importorg.junit.Before;import org.junit.Ignore;importorg.junit.Ignore;import org.junit.Test;importorg.junit.Test;import org.junit.rules.TestWatcher;importorg.junit.rules.TestWatcher;import static heros.alias.TestHelper.*;importstaticheros.aliasalias..TestHelper.*;import static heros.utilities.FieldSensitiveTestHelper.*;importstaticheros.utilitiesutilities..FieldSensitiveTestHelperFieldSensitive.*;public class FieldSensitiveIFDSSolverTest {publicclassFieldSensitiveIFDSSolverTest{ private TestHelper helper;privateTestHelperhelper; private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;privateTestDebugger<String,TestFact,TestStatementTest,TestMethod,InterproceduralCFG<TestStatementTest,TestMethod>>debugger; private FieldSensitiveTestHelper helper;privateFieldSensitiveTestHelperFieldSensitivehelper; private TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> debugger;privateTestDebugger<String,TestFact,Statement,TestMethod,InterproceduralCFG<Statement,TestMethod>>debugger; @Before@Before public void before() {publicvoidbefore(){ System.err.println("-----");System.err.println("-----"); debugger = new TestDebugger<>();debugger=newTestDebugger<>(); helper = new TestHelper(debugger);helper=newTestHelper(debugger); helper = new FieldSensitiveTestHelper(debugger);helper=newFieldSensitiveTestHelperFieldSensitive(debugger); }}  @Rule@Rule








test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......












test/heros/alias/ReturnSiteResolverTest.java








View file @ 2de8ef31








test/heros/alias/ReturnSiteResolverTest.java










View file @ 2de8ef31


2de8ef31



......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......






......@@ -13,6 +13,9 @@ package heros.alias;









import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;










import heros.utilities.Statement;










import heros.utilities.TestFact;










import heros.utilities.TestMethod;





















import org.junit.Before;










import org.junit.Test;



......@@ -41,17 +44,17 @@ public class ReturnSiteResolverTest {









 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;










 private Statement returnSite;










 private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, Statement, TestMethod> callback;










 private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);



......@@ -74,7 +77,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +85,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, Statement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +112,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +130,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +154,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +162,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +181,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,7 +200,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {



......@@ -218,7 +221,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,7 +230,7 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {





















 private AccessPath<String> accPath;














......


import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import static org.mockito.Mockito.*;importstaticorg.mockito.Mockito.*;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.utilities.Statement;importheros.utilities.Statement;import heros.utilities.TestFact;importheros.utilities.TestFact;import heros.utilities.TestMethod;importheros.utilities.TestMethod;import org.junit.Before;importorg.junit.Before;import org.junit.Test;importorg.junit.Test; return accPath;returnaccPath; }} private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<String,TestFact,TestStatementTest,TestMethod>analyzer; private TestStatement returnSite;privateTestStatementTestreturnSite; private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;privateReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>sut; private PerAccessPathMethodAnalyzer<String, TestFact, Statement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<String,TestFact,Statement,TestMethod>analyzer; private Statement returnSite;privateStatementreturnSite; private ReturnSiteResolver<String, TestFact, Statement, TestMethod> sut;privateReturnSiteResolver<String,TestFact,Statement,TestMethod>sut; private TestFact fact;privateTestFactfact; private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<String,TestFact,TestStatementTest,TestMethod>callback; private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<String,TestFact,TestStatementTest,TestMethod>callEdgeResolver; private InterestCallback<String, TestFact, Statement, TestMethod> callback;privateInterestCallback<String,TestFact,Statement,TestMethod>callback; private Resolver<String, TestFact, Statement, TestMethod> callEdgeResolver;privateResolver<String,TestFact,Statement,TestMethod>callEdgeResolver; @Before@Before public void before() {publicvoidbefore(){ analyzer = mock(PerAccessPathMethodAnalyzer.class);analyzer=mock(PerAccessPathMethodAnalyzer.class); returnSite = new TestStatement("returnSite");returnSite=newTestStatementTest("returnSite"); returnSite = new Statement("returnSite");returnSite=newStatement("returnSite"); sut = new ReturnSiteResolver<>(analyzer, returnSite);sut=newReturnSiteResolver<>(analyzer,returnSite); fact = new TestFact("value");fact=newTestFact("value"); callback = mock(InterestCallback.class);callback=mock(InterestCallback.class); @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  @Test@Test public void resolveViaIncomingResolver() {publicvoidresolveViaIncomingResolver(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<String,TestFact,TestStatementTest,TestMethod>nestedResolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<String,TestFact,Statement,TestMethod>nestedResolver=mock(Resolver.class); Mockito.doAnswer(new Answer(){Mockito.doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<String,TestFact,TestStatementTest,TestMethod>argCallback= (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<String,TestFact,TestStatementTest,TestMethod>)invocation.getArguments()[1]; InterestCallback<String, TestFact, Statement, TestMethod> argCallback = InterestCallback<String,TestFact,Statement,TestMethod>argCallback= (InterestCallback<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];(InterestCallback<String,TestFact,Statement,TestMethod>)invocation.getArguments()[1]; argCallback.interest(null, nestedResolver);argCallback.interest(null,nestedResolver); return null;returnnull; }}  @Test@Test public void resolveViaDeltaTwice() {publicvoidresolveViaDeltaTwice(){ final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<String,TestFact,TestStatementTest,TestMethod>innerCallback=mock(InterestCallback.class); final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<String,TestFact,Statement,TestMethod>innerCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>resolver=(ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>)invocation.getArguments()[1]; ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<String,TestFact,Statement,TestMethod>resolver=(ReturnSiteResolver<String,TestFact,Statement,TestMethod>)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), innerCallback);resolver.resolve(getDeltaConstraint("b"),innerCallback); return null;returnnull; }}  @Test@Test public void resolveViaDeltaAndThenViaCallSite() {publicvoidresolveViaDeltaAndThenViaCallSite(){ final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<String,TestFact,TestStatementTest,TestMethod>innerCallback=mock(InterestCallback.class); final InterestCallback<String, TestFact, Statement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<String,TestFact,Statement,TestMethod>innerCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>resolver=(ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>)invocation.getArguments()[1]; ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, Statement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<String,TestFact,Statement,TestMethod>resolver=(ReturnSiteResolver<String,TestFact,Statement,TestMethod>)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), innerCallback);resolver.resolve(getDeltaConstraint("b"),innerCallback); return null;returnnull; }}  @Test@Test public void resolveViaResolverAtCallSite() {publicvoidresolveViaResolverAtCallSite(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  @Test@Test public void resolveViaResolverAtCallSiteTwice() {publicvoidresolveViaResolverAtCallSiteTwice(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<String,TestFact,TestStatementTest,TestMethod>nestedResolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, Statement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<String,TestFact,Statement,TestMethod>nestedResolver=mock(Resolver.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ }} }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));}).when(nestedResolver).resolve(eq(getDeltaConstraint("b")),any(InterestCallback.class));  final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);finalInterestCallback<String,TestFact,TestStatementTest,TestMethod>secondCallback=mock(InterestCallback.class); final InterestCallback<String, TestFact, Statement, TestMethod> secondCallback = mock(InterestCallback.class);finalInterestCallback<String,TestFact,Statement,TestMethod>secondCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>resolver=(ReturnSiteResolver)invocation.getArguments()[1]; ReturnSiteResolver<String, TestFact, Statement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];ReturnSiteResolver<String,TestFact,Statement,TestMethod>resolver=(ReturnSiteResolver)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), secondCallback);resolver.resolve(getDeltaConstraint("b"),secondCallback); return null;returnnull; }}  @Test@Test public void resolveAsEmptyViaIncomingResolver() {publicvoidresolveAsEmptyViaIncomingResolver(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));Delta<String>delta=newAccessPath<String>().getDeltaTo(newAccessPath<String>().appendExcludedFieldReference(newString("a")));  doAnswer(new Answer() {doAnswer(newAnswer(){  @Test@Test public void resolveViaCallSiteResolver() {publicvoidresolveViaCallSiteResolver(){ Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,TestStatementTest,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class);  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); }}  private class ReturnSiteResolverArgumentMatcher extendsprivateclassReturnSiteResolverArgumentMatcherextends ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<String,TestFact,TestStatementTest,TestMethod>>{ ArgumentMatcher<ReturnSiteResolver<String, TestFact, Statement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<String,TestFact,Statement,TestMethod>>{ private AccessPath<String> accPath;privateAccessPath<String>accPath;








test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}












test/heros/alias/TestStatement.java

deleted


100644 → 0







View file @ e60e669d








test/heros/alias/TestStatement.java

deleted


100644 → 0









View file @ e60e669d


e60e669d










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestStatement {





















 public final String identifier;










 










 public TestStatement(String identifier) {










 this.identifier = identifier;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestStatement))










 return false;










 TestStatement other = (TestStatement) obj;










 if (identifier == null) {










 if (other.identifier != null)










 return false;










 } else if (!identifier.equals(other.identifier))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return "[Statement "+identifier+"]";










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class TestStatement {publicclassTestStatement{ public final String identifier;publicfinalStringidentifier;  public TestStatement(String identifier) {publicTestStatement(Stringidentifier){ this.identifier = identifier;this.identifier=identifier; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((identifier == null) ? 0 : identifier.hashCode());result=prime*result+((identifier==null)?0:identifier.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof TestStatement))if(!(objinstanceofTestStatement)) return false;returnfalse; TestStatement other = (TestStatement) obj;TestStatementother=(TestStatement)obj; if (identifier == null) {if(identifier==null){ if (other.identifier != null)if(other.identifier!=null) return false;returnfalse; } else if (!identifier.equals(other.identifier))}elseif(!identifier.equals(other.identifier)) return false;returnfalse; return true;returntrue; }}  @Override@Override public String toString() {publicStringtoString(){ return "[Statement "+identifier+"]";return"[Statement "+identifier+"]"; }}}}








test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file












test/heros/utilities/Edge.java



0 → 100644







View file @ 2de8ef31








test/heros/utilities/Edge.java



0 → 100644









View file @ 2de8ef31


2de8ef31










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.utilities;
































public abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 










 










 public static class NormalEdge extends Edge {





















 public final Statement unit;










 public final Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 public final Statement callSite;










 public final TestMethod destinationMethod;





















 public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 public final Statement callSite;










 public final Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 public final Statement exitStmt;










 public final Statement returnSite;










 public final Statement callSite;










 public TestMethod calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 










 public static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.utilities;packageheros.utilities;public abstract class Edge {publicabstractclassEdge{ public final ExpectedFlowFunction[] flowFunctions;publicfinalExpectedFlowFunction[]flowFunctions; public boolean includeInCfg = true;publicbooleanincludeInCfg=true; public Edge(ExpectedFlowFunction...flowFunctions) {publicEdge(ExpectedFlowFunction...flowFunctions){ this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; for(ExpectedFlowFunction ff : flowFunctions) {for(ExpectedFlowFunctionff:flowFunctions){ ff.edge = this;ff.edge=this; }} }}  public abstract void accept(EdgeVisitor visitor);publicabstractvoidaccept(EdgeVisitorvisitor);   public static class NormalEdge extends Edge {publicstaticclassNormalEdgeextendsEdge{ public final Statement unit;publicfinalStatementunit; public final Statement succUnit;publicfinalStatementsuccUnit; public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {publicNormalEdge(Statementunit,StatementsuccUnit,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.unit = unit;this.unit=unit; this.succUnit = succUnit;this.succUnit=succUnit; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -normal-> %s", unit, succUnit);returnString.format("%s -normal-> %s",unit,succUnit); }} @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }} public static class CallEdge extends Edge {publicstaticclassCallEdgeextendsEdge{ public final Statement callSite;publicfinalStatementcallSite; public final TestMethod destinationMethod;publicfinalTestMethoddestinationMethod; public CallEdge(Statement callSite, TestMethod destinationMethod, ExpectedFlowFunction...flowFunctions) {publicCallEdge(StatementcallSite,TestMethoddestinationMethod,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.callSite = callSite;this.callSite=callSite; this.destinationMethod = destinationMethod;this.destinationMethod=destinationMethod; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -call-> %s", callSite, destinationMethod);returnString.format("%s -call-> %s",callSite,destinationMethod); }}  @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }} public static class Call2ReturnEdge extends Edge {publicstaticclassCall2ReturnEdgeextendsEdge{ public final Statement callSite;publicfinalStatementcallSite; public final Statement returnSite;publicfinalStatementreturnSite; public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {publicCall2ReturnEdge(StatementcallSite,StatementreturnSite,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.callSite = callSite;this.callSite=callSite; this.returnSite = returnSite;this.returnSite=returnSite; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -call2ret-> %s", callSite, returnSite);returnString.format("%s -call2ret-> %s",callSite,returnSite); }}  @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }} public static class ReturnEdge extends Edge {publicstaticclassReturnEdgeextendsEdge{ public final Statement exitStmt;publicfinalStatementexitStmt; public final Statement returnSite;publicfinalStatementreturnSite; public final Statement callSite;publicfinalStatementcallSite; public TestMethod calleeMethod;publicTestMethodcalleeMethod; public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {publicReturnEdge(StatementcallSite,StatementexitStmt,StatementreturnSite,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.callSite = callSite;this.callSite=callSite; this.exitStmt = exitStmt;this.exitStmt=exitStmt; this.returnSite = returnSite;this.returnSite=returnSite; if(callSite == null || returnSite == null)if(callSite==null||returnSite==null) includeInCfg = false;includeInCfg=false; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -return-> %s", exitStmt, returnSite);returnString.format("%s -return-> %s",exitStmt,returnSite); }}  @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }}   public static interface EdgeVisitor {publicstaticinterfaceEdgeVisitor{ void visit(NormalEdge edge);voidvisit(NormalEdgeedge); void visit(CallEdge edge);voidvisit(CallEdgeedge); void visit(Call2ReturnEdge edge);voidvisit(Call2ReturnEdgeedge); void visit(ReturnEdge edge);voidvisit(ReturnEdgeedge); }}}}








test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......












test/heros/utilities/EdgeBuilder.java








View file @ 2de8ef31








test/heros/utilities/EdgeBuilder.java










View file @ 2de8ef31


2de8ef31



......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......






......@@ -10,13 +10,12 @@









 ******************************************************************************/










package heros.utilities;
































import java.util.Collection;










import java.util.List;





















import com.google.common.collect.Lists;





















import heros.utilities.TestHelper.Edge;










import heros.utilities.TestHelper.ExpectedFlowFunction;





















public abstract class EdgeBuilder {










 



......@@ -38,12 +37,12 @@ public abstract class EdgeBuilder {









 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 return this;










 }










 }



......@@ -51,16 +50,17 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {



......@@ -72,12 +72,12 @@ public abstract class EdgeBuilder {









 }










 










 public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));










 edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));










 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }










 



......


 ******************************************************************************/ ******************************************************************************/package heros.utilities;packageheros.utilities;import java.util.Collection;importjava.util.Collection;import java.util.List;importjava.util.List;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import heros.utilities.TestHelper.Edge;importheros.utilities.TestHelper.Edge;import heros.utilities.TestHelper.ExpectedFlowFunction;importheros.utilities.TestHelper.ExpectedFlowFunction;public abstract class EdgeBuilder {publicabstractclassEdgeBuilder{  }} public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {publicCallSiteBuildercalls(Stringmethod,ExpectedFlowFunction...flows){ edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));edges.add(newTestHelperTestHelper.CallEdge(callSite,newMethod(method),flows)); edges.add(new Edge.CallEdge(callSite, new TestMethod(method), flows));edges.add(newEdgeEdge.CallEdge(callSite,newTestMethodTest(method),flows)); return this;returnthis; }}  public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {publicCallSiteBuilderretSite(StringreturnSite,ExpectedFlowFunction...flows){ edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));edges.add(newTestHelperTestHelper.Call2ReturnEdge(callSite,newStatement(returnSite),flows)); edges.add(new Edge.Call2ReturnEdge(callSite, new Statement(returnSite), flows));edges.add(newEdgeEdge.Call2ReturnEdge(callSite,newStatement(returnSite),flows)); return this;returnthis; }} }} public static class NormalStmtBuilder extends EdgeBuilder {publicstaticclassNormalStmtBuilderextendsEdgeBuilder{ private Statement stmt;privateStatementstmt; private ExpectedFlowFunction[] flowFunctions;privateExpectedFlowFunction[]flowFunctions; public NormalStmtBuilder(Statement stmt) {publicNormalStmtBuilder(Statementstmt){ public NormalStmtBuilder(Statement stmt, ExpectedFlowFunction[] flowFunctions) {publicNormalStmtBuilder(Statementstmt,, ExpectedFlowFunctionExpectedFlowFunction[][] flowFunctionsflowFunctions){ this.stmt = stmt;this.stmt=stmt; this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; }} public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {publicNormalStmtBuildersucc(Stringsucc,, ExpectedFlowFunctionExpectedFlowFunction...... flowsflows){ edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));edges.add(newTestHelperTestHelper.NormalEdge(stmt,newStatement(succ),flows)); public NormalStmtBuilder succ(String succ) {publicNormalStmtBuildersucc(Stringsucc){ edges.add(new Edge.NormalEdge(stmt, new Statement(succ), flowFunctions));edges.add(newEdgeEdge.NormalEdge(stmt,newStatement(succ),flowFunctionsFunction)); return this;returnthis; }}  }}  public static class ExitStmtBuilder extends EdgeBuilder {publicstaticclassExitStmtBuilderextendsEdgeBuilder{ }}  public ExitStmtBuilder expectArtificalFlow(ExpectedFlowFunction...flows) {publicExitStmtBuilderexpectArtificalFlow(ExpectedFlowFunction...flows){ edges.add(new TestHelper.ReturnEdge(null, exitStmt, null, flows));edges.add(newTestHelperTestHelper.ReturnEdge(null,exitStmt,null,flows)); edges.add(new Edge.ReturnEdge(null, exitStmt, null, flows));edges.add(newEdgeEdge.ReturnEdge(null,exitStmt,null,flows)); return this;returnthis; }} public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {publicExitStmtBuilderreturns(StatementcallSite,StatementreturnSite,ExpectedFlowFunction...flows){ edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));edges.add(newTestHelperTestHelper.ReturnEdge(callSite,exitStmt,returnSite,flows)); edges.add(new Edge.ReturnEdge(callSite, exitStmt, returnSite, flows));edges.add(newEdgeEdge.ReturnEdge(callSite,exitStmt,returnSite,flows)); return this;returnthis; }} 








test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file












test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java








View file @ 2de8ef31








test/heros/utilities/Method.java

→

test/heros/utilities/ExpectedFlowFunction.java





MethodExpectedFlowFunction




View file @ 2de8ef31


2de8ef31










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,41 +10,30 @@









 ******************************************************************************/










package heros.utilities;





















public class Method {










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction;





















 public final String name;










 










 public Method(String name) {










 this.name = name;










 }










import com.google.common.base.Joiner;





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((name == null) ? 0 : name.hashCode());










 return result;










 }










public abstract class ExpectedFlowFunction<Fact> {





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Method))










 return false;










 Method other = (Method) obj;










 if (name == null) {










 if (other.name != null)










 return false;










 } else if (!name.equals(other.name))










 return false;










 return true;










 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }










 





















 @Override










 public String toString() {










 return "[Method "+name+"]";










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










}









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch.4 * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch.5 * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at ******************************************************************************/ ******************************************************************************/package heros.utilities;packageheros.utilities;public class Method {publicclassMethod{import heros.alias.AccessPathHandler;importheros.alias.AccessPathHandler;import heros.alias.FlowFunction;importheros.alias.FlowFunction; public final String name;publicfinalStringname;  public Method(String name) {publicMethod(Stringname){ this.name = name;this.name=name; }}import com.google.common.base.Joiner;importcom.google.common.base.Joiner; @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((name == null) ? 0 : name.hashCode());result=prime*result+((name==null)?0:name.hashCode()); return result;returnresult; }}public abstract class ExpectedFlowFunction<Fact> {publicabstractclassExpectedFlowFunction<Fact>{ @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof Method))if(!(objinstanceofMethod)) return false;returnfalse; Method other = (Method) obj;Methodother=(Method)obj; if (name == null) {if(name==null){ if (other.name != null)if(other.name!=null) return false;returnfalse; } else if (!name.equals(other.name))}elseif(!name.equals(other.name)) return false;returnfalse; return true;returntrue; public final Fact source;publicfinalFactsource; public final Fact[] targets;publicfinalFact[]targets; public Edge edge;publicEdgeedge; int times;inttimes; public ExpectedFlowFunction(int times, Fact source, Fact... targets) {publicExpectedFlowFunction(inttimes,Factsource,Fact...targets){ this.times = times;this.times=times; this.source = source;this.source=source; this.targets = targets;this.targets=targets; }}   @Override@Override public String toString() {publicStringtoString(){ return "[Method "+name+"]";return"[Method ""[Method "++namename++"]""]"; return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));returnStringString..formatformat(("%s: %s -> {%s}""%s: %s -> {%s}",, edgeedge,, sourcesource,, JoinerJoiner..onon((","",").).joinjoin((targetstargets));)) }}}}  public abstract String transformerString();publicabstractStringtransformerString(); public abstract FlowFunction.ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler);publicabstractFlowFunction.ConstrainedFact<String,TestFact,Statement,TestMethod>apply(TestFacttarget,AccessPathHandler<String,TestFact,Statement,TestMethod>accPathHandler);}}








test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31





This diff is collapsed.
Click to expand it.











test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2de8ef31








test/heros/alias/TestHelper.java

→

test/heros/utilities/FieldSensitiveTestHelper.java





alias/utilities/FieldSensitive




View file @ 2de8ef31


2de8ef31


This diff is collapsed.
Click to expand it.




This diff is collapsed.
Click to expand it.


This diff is collapsed.
Click to expand it.









test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}












test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java








View file @ 2de8ef31








test/heros/utilities/Fact.java

→

test/heros/utilities/JoinableFact.java





Joinable




View file @ 2de8ef31


2de8ef31



......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}






......@@ -14,11 +14,11 @@ import heros.solver.JoinHandlingNode;









import heros.solver.LinkedNode;










import heros.solver.JoinHandlingNode.JoinKey;





















public class Fact implements JoinHandlingNode<Fact> {










public class JoinableFact implements JoinHandlingNode<JoinableFact> {





















 public final String name;










 










 public Fact(String name) {










 public JoinableFact(String name) {










 this.name = name;










 }














......@@ -36,9 +36,9 @@ public class Fact implements JoinHandlingNode<Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (!(obj instanceof JoinableFact))










 return false;










 Fact other = (Fact) obj;










 JoinableFact other = (JoinableFact) obj;










 if (name == null) {










 if (other.name != null)










 return false;



......@@ -53,7 +53,7 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public void setCallingContext(Fact callingContext) {










 public void setCallingContext(JoinableFact callingContext) {










 










 }














......@@ -63,14 +63,14 @@ public class Fact implements JoinHandlingNode<Fact> {









 }





















 @Override










 public boolean handleJoin(Fact joiningNode) {










 public boolean handleJoin(JoinableFact joiningNode) {










 return true;










 }





















 private class TestJoinKey extends JoinKey {





















 private Fact getFact() {










 return Fact.this;










 private JoinableFact getFact() {










 return JoinableFact.this;










 }





















 @Override



......@@ -83,7 +83,7 @@ public class Fact implements JoinHandlingNode<Fact> {




















 @Override










 public int hashCode() {










 return Fact.this.hashCode();










 return JoinableFact.this.hashCode();










 }










 }










}


import heros.solver.LinkedNode;importheros.solver.LinkedNode;import heros.solver.JoinHandlingNode.JoinKey;importheros.solver.JoinHandlingNode.JoinKey;public class Fact implements JoinHandlingNode<Fact> {publicclassFactimplementsJoinHandlingNode<Fact>{public class JoinableFact implements JoinHandlingNode<JoinableFact> {publicclassJoinableFactJoinableimplementsJoinHandlingNode<JoinableFactJoinable>{ public final String name;publicfinalStringname;  public Fact(String name) {publicFact(Stringname){ public JoinableFact(String name) {publicJoinableFactJoinable(Stringname){ this.name = name;this.name=name; }} return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof Fact))if(!(objinstanceofFact)) if (!(obj instanceof JoinableFact))if(!(objinstanceofJoinableFactJoinable)) return false;returnfalse; Fact other = (Fact) obj;Factother=(Fact)obj; JoinableFact other = (JoinableFact) obj;JoinableFactJoinableother=(JoinableFactJoinable)obj; if (name == null) {if(name==null){ if (other.name != null)if(other.name!=null) return false;returnfalse; }} @Override@Override public void setCallingContext(Fact callingContext) {publicvoidsetCallingContext(FactcallingContext){ public void setCallingContext(JoinableFact callingContext) {publicvoidsetCallingContext(JoinableFactJoinablecallingContext){  }} }} @Override@Override public boolean handleJoin(Fact joiningNode) {publicbooleanhandleJoin(FactjoiningNode){ public boolean handleJoin(JoinableFact joiningNode) {publicbooleanhandleJoin(JoinableFactJoinablejoiningNode){ return true;returntrue; }} private class TestJoinKey extends JoinKey {privateclassTestJoinKeyextendsJoinKey{ private Fact getFact() {privateFactgetFact(){ return Fact.this;returnFact.this; private JoinableFact getFact() {privateJoinableFactJoinablegetFact(){ return JoinableFact.this;returnJoinableFactJoinable.this; }} @Override@Override @Override@Override public int hashCode() {publicinthashCode(){ return Fact.this.hashCode();returnFact.this.hashCode(); return JoinableFact.this.hashCode();returnJoinableFactJoinable.this.hashCode(); }} }}}}








src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}












src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java








View file @ 2de8ef31








src/heros/alias/TestDebugger.java

→

test/heros/utilities/TestDebugger.java





srcaliatestutilitie




View file @ 2de8ef31


2de8ef31



......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















import java.io.FileWriter;










import java.io.IOException;



......@@ -17,7 +17,8 @@ import java.util.Set;









import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;










import heros.alias.Debugger;










import heros.alias.JsonDocument;





















public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {














......@@ -108,9 +109,4 @@ public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCF









 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}


 * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.aliasalia;package heros.utilities;packageheros.utilitiesutilitie;import java.io.FileWriter;importjava.io.FileWriter;import java.io.IOException;importjava.io.IOException;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.alias.TestHelper.Edge;importheros.alias.TestHelper.Edge;import heros.alias.Debugger;importheros.alias.Debugger;import heros.alias.JsonDocument;importheros.alias.JsonDocument;public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicclassTestDebugger<Field,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow",expectedFlowFunctionsToString); }} static void tabs(int tabs, StringBuilder builder) {staticvoidtabs(inttabs,StringBuilderbuilder){ for(int i=0; i<tabs; i++)for(inti=0;i<tabs;i++) builder.append("\t");builder.append("\t"); }}}}








test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......












test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java








View file @ 2de8ef31








test/heros/alias/TestFact.java

→

test/heros/utilities/TestFact.java





aliautilitie




View file @ 2de8ef31


2de8ef31



......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......






......@@ -8,7 +8,7 @@









 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;










package heros.utilities;





















public class TestFact {














......


 * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.aliasalia;package heros.utilities;packageheros.utilitiesutilitie;public class TestFact {publicclassTestFact{








test/heros/utilities/TestHelper.java








View file @ 2de8ef31






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......












test/heros/utilities/TestHelper.java








View file @ 2de8ef31








test/heros/utilities/TestHelper.java










View file @ 2de8ef31


2de8ef31



......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......






......@@ -15,10 +15,16 @@ import heros.FlowFunction;









import heros.FlowFunctions;










import heros.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.alias.TestStatement;










import heros.alias.TestHelper.NormalEdge;










import heros.alias.AccessPathHandler;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.solver.BiDiIFDSSolver;










import heros.solver.IFDSSolver;










import heros.utilities.Edge.Call2ReturnEdge;










import heros.utilities.Edge.CallEdge;










import heros.utilities.Edge.EdgeVisitor;










import heros.utilities.Edge.NormalEdge;










import heros.utilities.Edge.ReturnEdge;










import heros.utilities.EdgeBuilder.NormalStmtBuilder;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -39,16 +45,16 @@ import com.google.common.collect.Sets;




















public class TestHelper {





















 private Multimap<Method, Statement> method2startPoint = HashMultimap.create();










 private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();










 private List<NormalEdge> normalEdges = Lists.newLinkedList();










 private List<CallEdge> callEdges = Lists.newLinkedList();










 private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();










 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<Statement, Method> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();





















 public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {










 MethodHelper methodHelper = new MethodHelper(new Method(methodName));










 MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));










 methodHelper.startPoints(startingPoints);










 for(EdgeBuilder edgeBuilder : edgeBuilders){










 methodHelper.edges(edgeBuilder.edges());



......@@ -64,8 +70,9 @@ public class TestHelper {









 return result;










 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 @SafeVarargs










 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {










 return new NormalStmtBuilder(new Statement(stmt), flowFunctions);










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -84,32 +91,55 @@ public class TestHelper {









 return new Statement(returnSite);










 }










 










 public static ExpectedFlowFunction kill(String source) {










 public static ExpectedFlowFunction<JoinableFact> kill(String source) {










 return kill(1, source);










 }










 










 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new Fact(source));










 public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {





















 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {










 JoinableFact[] targetFacts = new JoinableFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new JoinableFact(targets[i]);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {










 @Override










 public String transformerString() {










 throw new IllegalStateException();










 }





















 @Override










 public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,










 AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 };










 }










 










 public static int times(int times) {










 return times;










 }





















 public InterproceduralCFG<Statement, Method> buildIcfg() {










 return new InterproceduralCFG<Statement, Method>() {










 public InterproceduralCFG<Statement, TestMethod> buildIcfg() {










 return new InterproceduralCFG<Statement, TestMethod>() {





















 @Override










 public boolean isStartPoint(Statement stmt) {



......@@ -166,7 +196,7 @@ public class TestHelper {









 }





















 @Override










 public Collection<Statement> getStartPointsOf(Method m) {










 public Collection<Statement> getStartPointsOf(TestMethod m) {










 return method2startPoint.get(m);










 }














......@@ -184,18 +214,19 @@ public class TestHelper {









 return result;










 }





















 










 @Override










 public Method getMethodOf(Statement n) {










 public TestMethod getMethodOf(Statement n) {










 return stmt2method.get(n);










 }





















 @Override










 public Set<Statement> getCallsFromWithin(Method m) {










 public Set<Statement> getCallsFromWithin(TestMethod m) {










 throw new IllegalStateException();










 }





















 @Override










 public Collection<Statement> getCallersOf(Method m) {










 public Collection<Statement> getCallersOf(TestMethod m) {










 Set<Statement> result = Sets.newHashSet();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.destinationMethod.equals(m)) {



......@@ -211,8 +242,8 @@ public class TestHelper {









 }





















 @Override










 public Collection<Method> getCalleesOfCallAt(Statement n) {










 List<Method> result = Lists.newLinkedList();










 public Collection<TestMethod> getCalleesOfCallAt(Statement n) {










 List<TestMethod> result = Lists.newLinkedList();










 for (CallEdge edge : callEdges) {










 if (edge.includeInCfg && edge.callSite.equals(n)) {










 result.add(edge.destinationMethod);



......@@ -233,55 +264,55 @@ public class TestHelper {









 remainingFlowFunctions.isEmpty());










 }





















 private void addOrVerifyStmt2Method(Statement stmt, Method m) {










 private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {










 if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));










 throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));










 }










 stmt2method.put(stmt, m);










 }





















 public MethodHelper method(Method method) {










 public MethodHelper method(TestMethod method) {










 MethodHelper h = new MethodHelper(method);










 return h;










 }





















 public class MethodHelper {





















 private Method method;










 private TestMethod method;





















 public MethodHelper(Method method) {










 public MethodHelper(TestMethod method) {










 this.method = method;










 }





















 public void edges(Collection<Edge> edges) {










 for(Edge edge : edges) {










 for(ExpectedFlowFunction ff : edge.flowFunctions) {










 for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 remainingFlowFunctions.add(ff, ff.times);










 }










 










 edge.accept(new EdgeVisitor() {










 @Override










 public void visit(heros.utilities.TestHelper.ReturnEdge edge) {










 public void visit(ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.exitStmt, method);










 edge.calleeMethod = method;










 returnEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {










 public void visit(Call2ReturnEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 addOrVerifyStmt2Method(edge.returnSite, method);










 call2retEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.CallEdge edge) {










 public void visit(CallEdge edge) {










 addOrVerifyStmt2Method(edge.callSite, method);










 callEdges.add(edge);










 }










 










 @Override










 public void visit(heros.utilities.TestHelper.NormalEdge edge) {










 public void visit(NormalEdge edge) {










 addOrVerifyStmt2Method(edge.unit, method);










 addOrVerifyStmt2Method(edge.succUnit, method);










 normalEdges.add(edge);



......@@ -295,138 +326,6 @@ public class TestHelper {









 }










 }










 










 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;










 }





















 @Override










 public String toString() {










 return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));










 }










 }










 










 private static interface EdgeVisitor {










 void visit(NormalEdge edge);










 void visit(CallEdge edge);










 void visit(Call2ReturnEdge edge);










 void visit(ReturnEdge edge);










 }





















 public static abstract class Edge {










 public final ExpectedFlowFunction[] flowFunctions;










 public boolean includeInCfg = true;





















 public Edge(ExpectedFlowFunction...flowFunctions) {










 this.flowFunctions = flowFunctions;










 for(ExpectedFlowFunction ff : flowFunctions) {










 ff.edge = this;










 }










 }










 










 public abstract void accept(EdgeVisitor visitor);










 }





















 public static class NormalEdge extends Edge {





















 private Statement unit;










 private Statement succUnit;





















 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.succUnit = succUnit;










 }





















 @Override










 public String toString() {










 return String.format("%s -normal-> %s", unit, succUnit);










 }





















 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class CallEdge extends Edge {





















 private Statement callSite;










 private Method destinationMethod;





















 public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.destinationMethod = destinationMethod;










 }





















 @Override










 public String toString() {










 return String.format("%s -call-> %s", callSite, destinationMethod);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class Call2ReturnEdge extends Edge {










 private Statement callSite;










 private Statement returnSite;





















 public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.returnSite = returnSite;










 }





















 @Override










 public String toString() {










 return String.format("%s -call2ret-> %s", callSite, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }





















 public static class ReturnEdge extends Edge {





















 private Statement exitStmt;










 private Statement returnSite;










 private Statement callSite;










 private Method calleeMethod;





















 public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.callSite = callSite;










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 if(callSite == null || returnSite == null)










 includeInCfg = false;










 }





















 @Override










 public String toString() {










 return String.format("%s -return-> %s", exitStmt, returnSite);










 }










 










 @Override










 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }










 }










 










 private static boolean nullAwareEquals(Object a, Object b) {










 if(a == null)










 return b==null;



......@@ -434,11 +333,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return new FlowFunctions<Statement, JoinableFact, TestMethod>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -450,7 +349,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -460,7 +359,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -470,7 +369,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -479,11 +378,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {










 return new FlowFunction<JoinableFact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 public Set<JoinableFact> computeTargets(JoinableFact source) {










 for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);



......@@ -500,8 +399,8 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(










 IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds));





















 solver.solve();



......@@ -511,11 +410,11 @@ public class TestHelper {









 










 public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};










 public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {










 BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =










 BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds)) :










 new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds));










 










 solver.solve();



......@@ -523,11 +422,11 @@ public class TestHelper {









 backwardHelper.assertAllFlowFunctionsUsed();










 }










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -550,27 +449,27 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }





















 @Override










 public InterproceduralCFG<Statement, Method> interproceduralCFG() {










 public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {










 return icfg;










 }





















 @Override










 public Map<Statement, Set<Fact>> initialSeeds() {










 Map<Statement, Set<Fact>> result = Maps.newHashMap();










 public Map<Statement, Set<JoinableFact>> initialSeeds() {










 Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();










 for (String stmt : initialSeeds) {










 result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));










 result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));










 }










 return result;










 }





















 @Override










 public Fact zeroValue() {










 return new Fact("0");










 public JoinableFact zeroValue() {










 return new JoinableFact("0");










 }










 };










 }



......


import heros.FlowFunctions;importheros.FlowFunctions;import heros.IFDSTabulationProblem;importheros.IFDSTabulationProblem;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.alias.TestStatement;importheros.alias.TestStatementTestStatement;import heros.alias.TestHelper.NormalEdge;importheros.alias.TestHelper.NormalEdgeTestHelper.NormalEdge;import heros.alias.AccessPathHandler;importheros.alias.AccessPathHandlerAccessPathHandler;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFactFlowFunction.ConstrainedFact;import heros.solver.BiDiIFDSSolver;importheros.solver.BiDiIFDSSolver;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.utilities.Edge.Call2ReturnEdge;importheros.utilities.Edge.Call2ReturnEdge;import heros.utilities.Edge.CallEdge;importheros.utilities.Edge.CallEdge;import heros.utilities.Edge.EdgeVisitor;importheros.utilities.Edge.EdgeVisitor;import heros.utilities.Edge.NormalEdge;importheros.utilities.Edge.NormalEdge;import heros.utilities.Edge.ReturnEdge;importheros.utilities.Edge.ReturnEdge;import heros.utilities.EdgeBuilder.NormalStmtBuilder;importheros.utilities.EdgeBuilder.NormalStmtBuilder;import java.util.Collection;importjava.util.Collection;import java.util.LinkedList;importjava.util.LinkedList;public class TestHelper {publicclassTestHelper{ private Multimap<Method, Statement> method2startPoint = HashMultimap.create();privateMultimap<Method,Statement>method2startPoint=HashMultimap.create(); private Multimap<TestMethod, Statement> method2startPoint = HashMultimap.create();privateMultimap<TestMethodTest,Statement>method2startPoint=HashMultimap.create(); private List<NormalEdge> normalEdges = Lists.newLinkedList();privateList<NormalEdge>normalEdges=Lists.newLinkedList(); private List<CallEdge> callEdges = Lists.newLinkedList();privateList<CallEdge>callEdges=Lists.newLinkedList(); private List<Call2ReturnEdge> call2retEdges = Lists.newLinkedList();privateList<Call2ReturnEdge>call2retEdges=Lists.newLinkedList(); private List<ReturnEdge> returnEdges = Lists.newLinkedList();privateList<ReturnEdge>returnEdges=Lists.newLinkedList(); private Map<Statement, Method> stmt2method = Maps.newHashMap();privateMap<Statement,Method>stmt2method=Maps.newHashMap(); private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();privateMultiset<ExpectedFlowFunction>remainingFlowFunctions=HashMultiset.create(); private Map<Statement, TestMethod> stmt2method = Maps.newHashMap();privateMap<Statement,TestMethodTest>stmt2method=Maps.newHashMap(); private Multiset<ExpectedFlowFunction<JoinableFact>> remainingFlowFunctions = HashMultiset.create();privateMultiset<ExpectedFlowFunction<<JoinableFactJoinableFact>>>remainingFlowFunctions=HashMultiset.create(); public MethodHelper method(String methodName, Statement[] startingPoints, EdgeBuilder... edgeBuilders) {publicMethodHelpermethod(StringmethodName,Statement[]startingPoints,EdgeBuilder...edgeBuilders){ MethodHelper methodHelper = new MethodHelper(new Method(methodName));MethodHelpermethodHelper=newMethodHelper(newMethod(methodName)); MethodHelper methodHelper = new MethodHelper(new TestMethod(methodName));MethodHelpermethodHelper=newMethodHelper(newTestMethodTest(methodName)); methodHelper.startPoints(startingPoints);methodHelper.startPoints(startingPoints); for(EdgeBuilder edgeBuilder : edgeBuilders){for(EdgeBuilderedgeBuilder:edgeBuilders){ methodHelper.edges(edgeBuilder.edges());methodHelper.edges(edgeBuilder.edges()); return result;returnresult; }} public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {publicstaticEdgeBuilder.NormalStmtBuildernormalStmt(Stringstmt){ return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));returnnewEdgeBuilder.NormalStmtBuilder(newStatement(stmt)); @SafeVarargs@SafeVarargs public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt, ExpectedFlowFunction<JoinableFact>...flowFunctions) {publicstaticEdgeBuilder.NormalStmtBuildernormalStmt(Stringstmt,ExpectedFlowFunction<JoinableFact>...flowFunctions){ return new NormalStmtBuilder(new Statement(stmt), flowFunctions);returnnewNormalStmtBuilder(newStatement(stmt),flowFunctions); }}  public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {publicstaticEdgeBuilder.CallSiteBuildercallSite(StringcallSite){ return new Statement(returnSite);returnnewStatement(returnSite); }}  public static ExpectedFlowFunction kill(String source) {publicstaticExpectedFlowFunctionkill(Stringsource){ public static ExpectedFlowFunction<JoinableFact> kill(String source) {publicstaticExpectedFlowFunction<<JoinableFactJoinableFact>>kill(Stringsource){ return kill(1, source);returnkill(1,source); }}  public static ExpectedFlowFunction kill(int times, String source) {publicstaticExpectedFlowFunctionkill(inttimes,Stringsource){ return new ExpectedFlowFunction(times, new Fact(source));returnnewExpectedFlowFunction(times,newFact(source)); public static ExpectedFlowFunction<JoinableFact> kill(int times, String source) {publicstaticExpectedFlowFunction<JoinableFact>kill(inttimes,Stringsource){ return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source)) {returnnewExpectedFlowFunction<JoinableFact>(times,newJoinableFact(source)){ @Override@Override public String transformerString() {publicStringtransformerString(){ throw new IllegalStateException();thrownewIllegalStateException(); }} @Override@Override public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,publicConstrainedFact<String,TestFact,Statement,TestMethod>apply(TestFacttarget, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {AccessPathHandler<String,TestFact,Statement,TestMethod>accPathHandler){ throw new IllegalStateException();thrownewIllegalStateException(); }} };}; }} public static ExpectedFlowFunction flow(String source, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,String...targets){ public static ExpectedFlowFunction<JoinableFact> flow(String source, String... targets) {publicstaticExpectedFlowFunction<<JoinableFactJoinableFact>>flow(Stringsource,String...targets){ return flow(1, source, targets);returnflow(1,source,targets); }}  public static ExpectedFlowFunction flow(int times, String source, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,String...targets){ Fact[] targetFacts = new Fact[targets.length];Fact[]targetFacts=newFact[targets.length]; public static ExpectedFlowFunction<JoinableFact> flow(int times, String source, String... targets) {publicstaticExpectedFlowFunction<<JoinableFactJoinableFact>>flow(inttimes,Stringsource,String...targets){ JoinableFact[] targetFacts = new JoinableFact[targets.length];JoinableFactJoinable[]targetFacts=newJoinableFactJoinable[targets.length]; for(int i=0; i<targets.length; i++) {for(inti=0;i<targets.length;i++){ targetFacts[i] = new Fact(targets[i]);targetFacts[i]=newFact(targets[i]); targetFacts[i] = new JoinableFact(targets[i]);targetFacts[i]=newJoinableFactJoinable(targets[i]); }} return new ExpectedFlowFunction(times, new Fact(source), targetFacts);returnnewExpectedFlowFunction(times,newFact(source),targetFacts); return new ExpectedFlowFunction<JoinableFact>(times, new JoinableFact(source), targetFacts) {returnnewExpectedFlowFunction<JoinableFact>(times,newJoinableFact(source),targetFacts){ @Override@Override public String transformerString() {publicStringtransformerString(){ throw new IllegalStateException();thrownewIllegalStateException(); }} @Override@Override public ConstrainedFact<String, TestFact, Statement, TestMethod> apply(TestFact target,publicConstrainedFact<String,TestFact,Statement,TestMethod>apply(TestFacttarget, AccessPathHandler<String, TestFact, Statement, TestMethod> accPathHandler) {AccessPathHandler<String,TestFact,Statement,TestMethod>accPathHandler){ throw new IllegalStateException();thrownewIllegalStateException(); }} };}; }}  public static int times(int times) {publicstaticinttimes(inttimes){ return times;returntimes; }} public InterproceduralCFG<Statement, Method> buildIcfg() {publicInterproceduralCFG<Statement,Method>buildIcfg(){ return new InterproceduralCFG<Statement, Method>() {returnnewInterproceduralCFG<Statement,Method>(){ public InterproceduralCFG<Statement, TestMethod> buildIcfg() {publicInterproceduralCFG<Statement,TestMethodTest>buildIcfg(){ return new InterproceduralCFG<Statement, TestMethod>() {returnnewInterproceduralCFG<Statement,TestMethodTest>(){ @Override@Override public boolean isStartPoint(Statement stmt) {publicbooleanisStartPoint(Statementstmt){ }} @Override@Override public Collection<Statement> getStartPointsOf(Method m) {publicCollection<Statement>getStartPointsOf(Methodm){ public Collection<Statement> getStartPointsOf(TestMethod m) {publicCollection<Statement>getStartPointsOf(TestMethodTestm){ return method2startPoint.get(m);returnmethod2startPoint.get(m); }} return result;returnresult; }}  @Override@Override public Method getMethodOf(Statement n) {publicMethodgetMethodOf(Statementn){ public TestMethod getMethodOf(Statement n) {publicTestMethodTestgetMethodOf(Statementn){ return stmt2method.get(n);returnstmt2method.get(n); }} @Override@Override public Set<Statement> getCallsFromWithin(Method m) {publicSet<Statement>getCallsFromWithin(Methodm){ public Set<Statement> getCallsFromWithin(TestMethod m) {publicSet<Statement>getCallsFromWithin(TestMethodTestm){ throw new IllegalStateException();thrownewIllegalStateException(); }} @Override@Override public Collection<Statement> getCallersOf(Method m) {publicCollection<Statement>getCallersOf(Methodm){ public Collection<Statement> getCallersOf(TestMethod m) {publicCollection<Statement>getCallersOf(TestMethodTestm){ Set<Statement> result = Sets.newHashSet();Set<Statement>result=Sets.newHashSet(); for (CallEdge edge : callEdges) {for(CallEdgeedge:callEdges){ if (edge.includeInCfg && edge.destinationMethod.equals(m)) {if(edge.includeInCfg&&edge.destinationMethod.equals(m)){ }} @Override@Override public Collection<Method> getCalleesOfCallAt(Statement n) {publicCollection<Method>getCalleesOfCallAt(Statementn){ List<Method> result = Lists.newLinkedList();List<Method>result=Lists.newLinkedList(); public Collection<TestMethod> getCalleesOfCallAt(Statement n) {publicCollection<TestMethodTest>getCalleesOfCallAt(Statementn){ List<TestMethod> result = Lists.newLinkedList();List<TestMethodTest>result=Lists.newLinkedList(); for (CallEdge edge : callEdges) {for(CallEdgeedge:callEdges){ if (edge.includeInCfg && edge.callSite.equals(n)) {if(edge.includeInCfg&&edge.callSite.equals(n)){ result.add(edge.destinationMethod);result.add(edge.destinationMethod); remainingFlowFunctions.isEmpty());remainingFlowFunctions.isEmpty()); }} private void addOrVerifyStmt2Method(Statement stmt, Method m) {privatevoidaddOrVerifyStmt2Method(Statementstmt,Methodm){ private void addOrVerifyStmt2Method(Statement stmt, TestMethod m) {privatevoidaddOrVerifyStmt2Method(Statementstmt,TestMethodTestm){ if (stmt2method.containsKey(stmt) && !stmt2method.get(stmt).equals(m)) {if(stmt2method.containsKey(stmt)&&!stmt2method.get(stmt).equals(m)){ throw new IllegalArgumentException("Statement " + stmt + " is used in multiple methods: " + m + " and " + stmt2method.get(stmt));thrownewIllegalArgumentException("Statement "+stmt+" is used in multiple methods: "m+m+" and "+stmt2method.get(stmt)); throw new IllegalArgumentException("Statement " + stmt + " is used in multiple TestMethods: " + m + " and " + stmt2method.get(stmt));thrownewIllegalArgumentException("Statement "+stmt+" is used in multiple TestMethods: "TestM+m+" and "+stmt2method.get(stmt)); }} stmt2method.put(stmt, m);stmt2method.put(stmt,m); }} public MethodHelper method(Method method) {publicMethodHelpermethod(Methodmethod){ public MethodHelper method(TestMethod method) {publicMethodHelpermethod(TestMethodTestmethod){ MethodHelper h = new MethodHelper(method);MethodHelperh=newMethodHelper(method); return h;returnh; }} public class MethodHelper {publicclassMethodHelper{ private Method method;privateMethodmethod; private TestMethod method;privateTestMethodTestmethod; public MethodHelper(Method method) {publicMethodHelper(Methodmethod){ public MethodHelper(TestMethod method) {publicMethodHelper(TestMethodTestmethod){ this.method = method;this.method=method; }} public void edges(Collection<Edge> edges) {publicvoidedges(Collection<Edge>edges){ for(Edge edge : edges) {for(Edgeedge:edges){ for(ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ for(ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {for(ExpectedFlowFunction<<JoinableFactJoinableFact>>ff:edge.flowFunctions){ remainingFlowFunctions.add(ff, ff.times);remainingFlowFunctions.add(ff,ff.times); }}  edge.accept(new EdgeVisitor() {edge.accept(newEdgeVisitor(){ @Override@Override public void visit(heros.utilities.TestHelper.ReturnEdge edge) {publicvoidvisit(herosheros..utilitiesutilities..TestHelperTestHelper..ReturnEdgeedge){ public void visit(ReturnEdge edge) {publicvoidvisit(ReturnEdgeedge){ addOrVerifyStmt2Method(edge.exitStmt, method);addOrVerifyStmt2Method(edge.exitStmt,method); edge.calleeMethod = method;edge.calleeMethod=method; returnEdges.add(edge);returnEdges.add(edge); }}  @Override@Override public void visit(heros.utilities.TestHelper.Call2ReturnEdge edge) {publicvoidvisit(herosheros..utilitiesutilities..TestHelperTestHelper..Call2ReturnEdgeedge){ public void visit(Call2ReturnEdge edge) {publicvoidvisit(Call2ReturnEdgeedge){ addOrVerifyStmt2Method(edge.callSite, method);addOrVerifyStmt2Method(edge.callSite,method); addOrVerifyStmt2Method(edge.returnSite, method);addOrVerifyStmt2Method(edge.returnSite,method); call2retEdges.add(edge);call2retEdges.add(edge); }}  @Override@Override public void visit(heros.utilities.TestHelper.CallEdge edge) {publicvoidvisit(herosheros..utilitiesutilities..TestHelperTestHelper..CallEdgeedge){ public void visit(CallEdge edge) {publicvoidvisit(CallEdgeedge){ addOrVerifyStmt2Method(edge.callSite, method);addOrVerifyStmt2Method(edge.callSite,method); callEdges.add(edge);callEdges.add(edge); }}  @Override@Override public void visit(heros.utilities.TestHelper.NormalEdge edge) {publicvoidvisit(herosheros..utilitiesutilities..TestHelperTestHelper..NormalEdgeedge){ public void visit(NormalEdge edge) {publicvoidvisit(NormalEdgeedge){ addOrVerifyStmt2Method(edge.unit, method);addOrVerifyStmt2Method(edge.unit,method); addOrVerifyStmt2Method(edge.succUnit, method);addOrVerifyStmt2Method(edge.succUnit,method); normalEdges.add(edge);normalEdges.add(edge); }} }}  public static class ExpectedFlowFunction {publicstaticclassExpectedFlowFunction{ public final Fact source;publicfinalFactsource; public final Fact[] targets;publicfinalFact[]targets; public Edge edge;publicEdgeedge; private int times;privateinttimes; public ExpectedFlowFunction(int times, Fact source, Fact... targets) {publicExpectedFlowFunction(inttimes,Factsource,Fact...targets){ this.times = times;this.times=times; this.source = source;this.source=source; this.targets = targets;this.targets=targets; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s: %s -> {%s}", edge, source, Joiner.on(",").join(targets));returnString.format("%s: %s -> {%s}",edge,source,Joiner.on(",").join(targets)); }} }}  private static interface EdgeVisitor {privatestaticinterfaceEdgeVisitor{ void visit(NormalEdge edge);voidvisit(NormalEdgeedge); void visit(CallEdge edge);voidvisit(CallEdgeedge); void visit(Call2ReturnEdge edge);voidvisit(Call2ReturnEdgeedge); void visit(ReturnEdge edge);voidvisit(ReturnEdgeedge); }} public static abstract class Edge {publicstaticabstractclassEdge{ public final ExpectedFlowFunction[] flowFunctions;publicfinalExpectedFlowFunction[]flowFunctions; public boolean includeInCfg = true;publicbooleanincludeInCfg=true; public Edge(ExpectedFlowFunction...flowFunctions) {publicEdge(ExpectedFlowFunction...flowFunctions){ this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; for(ExpectedFlowFunction ff : flowFunctions) {for(ExpectedFlowFunctionff:flowFunctions){ ff.edge = this;ff.edge=this; }} }}  public abstract void accept(EdgeVisitor visitor);publicabstractvoidaccept(EdgeVisitorvisitor); }} public static class NormalEdge extends Edge {publicstaticclassNormalEdgeextendsEdge{ private Statement unit;privateStatementunit; private Statement succUnit;privateStatementsuccUnit; public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {publicNormalEdge(Statementunit,StatementsuccUnit,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.unit = unit;this.unit=unit; this.succUnit = succUnit;this.succUnit=succUnit; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -normal-> %s", unit, succUnit);returnString.format("%s -normal-> %s",unit,succUnit); }} @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }} public static class CallEdge extends Edge {publicstaticclassCallEdgeextendsEdge{ private Statement callSite;privateStatementcallSite; private Method destinationMethod;privateMethoddestinationMethod; public CallEdge(Statement callSite, Method destinationMethod, ExpectedFlowFunction...flowFunctions) {publicCallEdge(StatementcallSite,MethoddestinationMethod,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.callSite = callSite;this.callSite=callSite; this.destinationMethod = destinationMethod;this.destinationMethod=destinationMethod; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -call-> %s", callSite, destinationMethod);returnString.format("%s -call-> %s",callSite,destinationMethod); }}  @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }} public static class Call2ReturnEdge extends Edge {publicstaticclassCall2ReturnEdgeextendsEdge{ private Statement callSite;privateStatementcallSite; private Statement returnSite;privateStatementreturnSite; public Call2ReturnEdge(Statement callSite, Statement returnSite, ExpectedFlowFunction...flowFunctions) {publicCall2ReturnEdge(StatementcallSite,StatementreturnSite,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.callSite = callSite;this.callSite=callSite; this.returnSite = returnSite;this.returnSite=returnSite; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -call2ret-> %s", callSite, returnSite);returnString.format("%s -call2ret-> %s",callSite,returnSite); }}  @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }} public static class ReturnEdge extends Edge {publicstaticclassReturnEdgeextendsEdge{ private Statement exitStmt;privateStatementexitStmt; private Statement returnSite;privateStatementreturnSite; private Statement callSite;privateStatementcallSite; private Method calleeMethod;privateMethodcalleeMethod; public ReturnEdge(Statement callSite, Statement exitStmt, Statement returnSite, ExpectedFlowFunction...flowFunctions) {publicReturnEdge(StatementcallSite,StatementexitStmt,StatementreturnSite,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.callSite = callSite;this.callSite=callSite; this.exitStmt = exitStmt;this.exitStmt=exitStmt; this.returnSite = returnSite;this.returnSite=returnSite; if(callSite == null || returnSite == null)if(callSite==null||returnSite==null) includeInCfg = false;includeInCfg=false; }} @Override@Override public String toString() {publicStringtoString(){ return String.format("%s -return-> %s", exitStmt, returnSite);returnString.format("%s -return-> %s",exitStmt,returnSite); }}  @Override@Override public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} }}  private static boolean nullAwareEquals(Object a, Object b) {privatestaticbooleannullAwareEquals(Objecta,Objectb){ if(a == null)if(a==null) return b==null;returnb==null; return a.equals(b);returna.equals(b); }} public FlowFunctions<Statement, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,Fact,Method>flowFunctions(){ return new FlowFunctions<Statement, Fact, Method>() {returnnewFlowFunctions<Statement,Fact,Method>(){ public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {publicFlowFunctions<Statement,JoinableFactJoinable,TestMethodTest>flowFunctions(){ return new FlowFunctions<Statement, JoinableFact, TestMethod>() {returnnewFlowFunctions<Statement,JoinableFactJoinable,TestMethodTest>(){ @Override@Override public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {publicFlowFunction<Fact>getReturnFlowFunction(StatementcallSite,MethodcalleeMethod,StatementexitStmt,StatementreturnSite){ public FlowFunction<JoinableFact> getReturnFlowFunction(Statement callSite, TestMethod calleeMethod, Statement exitStmt, Statement returnSite) {publicFlowFunction<JoinableFactJoinable>getReturnFlowFunction(StatementcallSite,TestMethodTestcalleeMethod,StatementexitStmt,StatementreturnSite){ for (final ReturnEdge edge : returnEdges) {for(finalReturnEdgeedge:returnEdges){ if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)if(nullAwareEquals(callSite,edge.callSite)&&edge.calleeMethod.equals(calleeMethod) && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {&&edge.exitStmt.equals(exitStmt)&&nullAwareEquals(edge.returnSite,returnSite)){ }} @Override@Override public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {publicFlowFunction<Fact>getNormalFlowFunction(finalStatementcurr,finalStatementsucc){ public FlowFunction<JoinableFact> getNormalFlowFunction(final Statement curr, final Statement succ) {publicFlowFunction<JoinableFactJoinable>getNormalFlowFunction(finalStatementcurr,finalStatementsucc){ for (final NormalEdge edge : normalEdges) {for(finalNormalEdgeedge:normalEdges){ if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {if(edge.unit.equals(curr)&&edge.succUnit.equals(succ)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<Fact>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ public FlowFunction<JoinableFact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<JoinableFactJoinable>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ for (final Call2ReturnEdge edge : call2retEdges) {for(finalCall2ReturnEdgeedge:call2retEdges){ if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {if(edge.callSite.equals(callSite)&&edge.returnSite.equals(returnSite)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {publicFlowFunction<Fact>getCallFlowFunction(StatementcallStmt,MethoddestinationMethod){ public FlowFunction<JoinableFact> getCallFlowFunction(Statement callStmt, TestMethod destinationMethod) {publicFlowFunction<JoinableFactJoinable>getCallFlowFunction(StatementcallStmt,TestMethodTestdestinationMethod){ for (final CallEdge edge : callEdges) {for(finalCallEdgeedge:callEdges){ if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {if(edge.callSite.equals(callStmt)&&edge.destinationMethod.equals(destinationMethod)){ return createFlowFunction(edge);returncreateFlowFunction(edge); throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));thrownewAssertionError(String.format("No Flow Function expected for call %s -> %s",callStmt,destinationMethod)); }} private FlowFunction<Fact> createFlowFunction(final Edge edge) {privateFlowFunction<Fact>createFlowFunction(finalEdgeedge){ return new FlowFunction<Fact>() {returnnewFlowFunction<Fact>(){ private FlowFunction<JoinableFact> createFlowFunction(final Edge edge) {privateFlowFunction<JoinableFactJoinable>createFlowFunction(finalEdgeedge){ return new FlowFunction<JoinableFact>() {returnnewFlowFunction<JoinableFactJoinable>(){ @Override@Override public Set<Fact> computeTargets(Fact source) {publicSet<Fact>computeTargets(Factsource){ for (ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ public Set<JoinableFact> computeTargets(JoinableFact source) {publicSet<JoinableFactJoinable>computeTargets(JoinableFactJoinablesource){ for (ExpectedFlowFunction<JoinableFact> ff : edge.flowFunctions) {for(ExpectedFlowFunction<<JoinableFactJoinableFact>>ff:edge.flowFunctions){ if (ff.source.equals(source)) {if(ff.source.equals(source)){ if (remainingFlowFunctions.remove(ff)) {if(remainingFlowFunctions.remove(ff)){ return Sets.newHashSet(ff.targets);returnSets.newHashSet(ff.targets); }} public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {publicvoidrunSolver(finalbooleanfollowReturnsPastSeeds,finalString...initialSeeds){ IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =IFDSSolver<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>solver= new IFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(newIFDSSolver<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>( IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =IFDSSolver<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>solver= new IFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(newIFDSSolver<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>( createTabulationProblem(followReturnsPastSeeds, initialSeeds));createTabulationProblem(followReturnsPastSeeds,initialSeeds)); solver.solve();solver.solve();  public static enum TabulationProblemExchange {AsSpecified, ExchangeForwardAndBackward};publicstaticenumTabulationProblemExchange{AsSpecified,ExchangeForwardAndBackward}; public void runBiDiSolver(TestHelper backwardHelper, TabulationProblemExchange direction, final String...initialSeeds) {publicvoidrunBiDiSolver(TestHelperbackwardHelper,TabulationProblemExchangedirection,finalString...initialSeeds){ BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> solver =BiDiIFDSSolver<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>solver= BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =BiDiIFDSSolver<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>solver= direction == TabulationProblemExchange.AsSpecified ? direction==TabulationProblemExchange.AsSpecified? new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(createTabulationProblem(true, initialSeeds), newBiDiIFDSSolver<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>(createTabulationProblem(true,initialSeeds), new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(createTabulationProblem(true, initialSeeds), newBiDiIFDSSolver<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>(createTabulationProblem(true,initialSeeds), backwardHelper.createTabulationProblem(true, initialSeeds)) :backwardHelper.createTabulationProblem(true,initialSeeds)): new BiDiIFDSSolver<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>(backwardHelper.createTabulationProblem(true, initialSeeds), newBiDiIFDSSolver<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>(backwardHelper.createTabulationProblem(true,initialSeeds), new BiDiIFDSSolver<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>(backwardHelper.createTabulationProblem(true, initialSeeds), newBiDiIFDSSolver<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>(backwardHelper.createTabulationProblem(true,initialSeeds), createTabulationProblem(true, initialSeeds));createTabulationProblem(true,initialSeeds));  solver.solve();solver.solve(); backwardHelper.assertAllFlowFunctionsUsed();backwardHelper.assertAllFlowFunctionsUsed(); }}  private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ final InterproceduralCFG<Statement, Method> icfg = buildIcfg();finalInterproceduralCFG<Statement,Method>icfg=buildIcfg(); final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();finalFlowFunctions<Statement,Fact,Method>flowFunctions=flowFunctions(); private IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ final InterproceduralCFG<Statement, TestMethod> icfg = buildIcfg();finalInterproceduralCFG<Statement,TestMethodTest>icfg=buildIcfg(); final FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions = flowFunctions();finalFlowFunctions<Statement,JoinableFactJoinable,TestMethodTest>flowFunctions=flowFunctions();  return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {returnnewIFDSTabulationProblem<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>(){ return new IFDSTabulationProblem<Statement, JoinableFact, TestMethod, InterproceduralCFG<Statement, TestMethod>>() {returnnewIFDSTabulationProblem<Statement,JoinableFactJoinable,TestMethodTest,InterproceduralCFG<Statement,TestMethodTest>>(){ @Override@Override public boolean followReturnsPastSeeds() {publicbooleanfollowReturnsPastSeeds(){ }} @Override@Override public FlowFunctions<Statement, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,Fact,Method>flowFunctions(){ public FlowFunctions<Statement, JoinableFact, TestMethod> flowFunctions() {publicFlowFunctions<Statement,JoinableFactJoinable,TestMethodTest>flowFunctions(){ return flowFunctions;returnflowFunctions; }} @Override@Override public InterproceduralCFG<Statement, Method> interproceduralCFG() {publicInterproceduralCFG<Statement,Method>interproceduralCFG(){ public InterproceduralCFG<Statement, TestMethod> interproceduralCFG() {publicInterproceduralCFG<Statement,TestMethodTest>interproceduralCFG(){ return icfg;returnicfg; }} @Override@Override public Map<Statement, Set<Fact>> initialSeeds() {publicMap<Statement,Set<Fact>>initialSeeds(){ Map<Statement, Set<Fact>> result = Maps.newHashMap();Map<Statement,Set<Fact>>result=Maps.newHashMap(); public Map<Statement, Set<JoinableFact>> initialSeeds() {publicMap<Statement,Set<JoinableFactJoinable>>initialSeeds(){ Map<Statement, Set<JoinableFact>> result = Maps.newHashMap();Map<Statement,Set<JoinableFactJoinable>>result=Maps.newHashMap(); for (String stmt : initialSeeds) {for(Stringstmt:initialSeeds){ result.put(new Statement(stmt), Sets.newHashSet(new Fact("0")));result.put(newStatement(stmt),Sets.newHashSet(newFact("0"))); result.put(new Statement(stmt), Sets.newHashSet(new JoinableFact("0")));result.put(newStatement(stmt),Sets.newHashSet(newJoinableFactJoinable("0"))); }} return result;returnresult; }} @Override@Override public Fact zeroValue() {publicFactzeroValue(){ return new Fact("0");returnnewFact("0"); public JoinableFact zeroValue() {publicJoinableFactJoinablezeroValue(){ return new JoinableFact("0");returnnewJoinableFactJoinable("0"); }} };}; }}



Prev


1


2


Next





Prev

1

2

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






