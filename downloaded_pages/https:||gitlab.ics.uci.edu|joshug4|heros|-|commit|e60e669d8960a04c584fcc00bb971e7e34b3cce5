



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

e60e669d















Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ e60e669d






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathHandler.java








View file @ e60e669d






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......














src/heros/alias/CallEdgeResolver.java








View file @ e60e669d






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......














src/heros/alias/Context.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......














src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......














src/heros/alias/Debugger.java








View file @ e60e669d






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......














src/heros/alias/DeltaConstraint.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......














src/heros/alias/FlowFunction.java








View file @ e60e669d






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}














src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......














src/heros/alias/FlowFunctions.java








View file @ e60e669d






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/IncomingEdge.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......














src/heros/alias/InterestCallback.java








View file @ e60e669d






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/MethodAnalyzer.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......














src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......














src/heros/alias/Resolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

e60e669d















Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ e60e669d






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathHandler.java








View file @ e60e669d






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......














src/heros/alias/CallEdgeResolver.java








View file @ e60e669d






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......














src/heros/alias/Context.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......














src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......














src/heros/alias/Debugger.java








View file @ e60e669d






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......














src/heros/alias/DeltaConstraint.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......














src/heros/alias/FlowFunction.java








View file @ e60e669d






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}














src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......














src/heros/alias/FlowFunctions.java








View file @ e60e669d






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/IncomingEdge.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......














src/heros/alias/InterestCallback.java








View file @ e60e669d






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/MethodAnalyzer.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......














src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......














src/heros/alias/Resolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

e60e669d







Open sidebar



Joshua Garcia heros
Commits

e60e669d




Open sidebar

Joshua Garcia heros
Commits

e60e669d


Joshua GarciaherosherosCommits
e60e669d








Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ e60e669d






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathHandler.java








View file @ e60e669d






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......














src/heros/alias/CallEdgeResolver.java








View file @ e60e669d






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......














src/heros/alias/Context.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......














src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......














src/heros/alias/Debugger.java








View file @ e60e669d






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......














src/heros/alias/DeltaConstraint.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......














src/heros/alias/FlowFunction.java








View file @ e60e669d






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}














src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......














src/heros/alias/FlowFunctions.java








View file @ e60e669d






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/IncomingEdge.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......














src/heros/alias/InterestCallback.java








View file @ e60e669d






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/MethodAnalyzer.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......














src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......














src/heros/alias/Resolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ e60e669d






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathHandler.java








View file @ e60e669d






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......














src/heros/alias/CallEdgeResolver.java








View file @ e60e669d






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......














src/heros/alias/Context.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......














src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......














src/heros/alias/Debugger.java








View file @ e60e669d






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......














src/heros/alias/DeltaConstraint.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......














src/heros/alias/FlowFunction.java








View file @ e60e669d






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}














src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......














src/heros/alias/FlowFunctions.java








View file @ e60e669d






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/IncomingEdge.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......














src/heros/alias/InterestCallback.java








View file @ e60e669d






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/MethodAnalyzer.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......














src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......














src/heros/alias/Resolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files



Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch

e60e669dauthoredbyJohannes Lerch

removed unnecessary merge code in access path






parent
1f74a4f2
















parent
1f74a4f2





parent












Changes
36
36


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPath.java








View file @ e60e669d






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathHandler.java








View file @ e60e669d






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......














src/heros/alias/CallEdgeResolver.java








View file @ e60e669d






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......














src/heros/alias/Context.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......














src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......














src/heros/alias/Debugger.java








View file @ e60e669d






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......














src/heros/alias/DeltaConstraint.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......














src/heros/alias/FlowFunction.java








View file @ e60e669d






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}














src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......














src/heros/alias/FlowFunctions.java








View file @ e60e669d






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/IncomingEdge.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......














src/heros/alias/InterestCallback.java








View file @ e60e669d






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/MethodAnalyzer.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......














src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......














src/heros/alias/Resolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......









Prev


1


2


Next













src/heros/alias/AccessPath.java








View file @ e60e669d






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}












src/heros/alias/AccessPath.java








View file @ e60e669d








src/heros/alias/AccessPath.java










View file @ e60e669d


e60e669d



......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}






......@@ -11,9 +11,6 @@









package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;



......@@ -27,192 +24,73 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










public class AccessPath<T> {










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<T>[] accesses;










 private final T[] accesses;










 private final Set<T> exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 accesses = (T[]) new Object[0];










 exclusions = Sets.newHashSet();










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 public boolean isAccessInExclusions(T fieldReference) {










 return exclusions.contains(fieldReference);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {










 if(!exclusions.contains(field))










 return false;










 }










 return true;










 }










 return false;










 }










 










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 if(fieldReferences.length>0)










 builder.removeExclusions();










 return builder.build();










 }










 










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<T> newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {










 newExclusions = Sets.newHashSet();










 }





















 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 removeExclusions();










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 public AccessPath<T> append(T... fieldReferences) {










 if(fieldReferences.length == 0)










 return this;










 }





















 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 if(isAccessInExclusions(fieldReferences[0]))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










//				










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 assert accesses.length != 0 || !exclusions.contains(fieldRef);










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 










 private int value;














......@@ -225,102 +103,54 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(!exclusions.isEmpty())










 return accesses.length + 1;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 if(accesses.length < accessPath.accesses.length) {










 if(exclusions.contains(accessPath.accesses[accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 else










 return PrefixTestResult.GUARANTEED_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 










 if(exclusions.isEmpty())










 return PrefixTestResult.GUARANTEED_PREFIX;










 if(accessPath.exclusions.isEmpty())










 return PrefixTestResult.NO_PREFIX;










 










 boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();










 boolean containsAll = exclusions.containsAll(accessPath.exclusions);










 boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 if(potentialMatch) {










 if(oppositeContainsAll)










 return PrefixTestResult.GUARANTEED_PREFIX;










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));










 return PrefixTestResult.POTENTIAL_PREFIX;










 }










 return result;










 return PrefixTestResult.NO_PREFIX;










 }










 





















 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 break;










 }










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));










 return delta;










 }










 










 //FIXME this is an unsound dirty hack










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 for(T sub : accesses) {










 if(sub.equals(accPath.accesses[0])) {










 return true;










 }










 }



......@@ -331,21 +161,24 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 public static class Delta<T> {










 final T[] accesses;










 final Set<T> exclusions;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 protected Delta(T[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 if(accesses.length > 0)










 return !accPath.isAccessInExclusions(accesses[0]);










 else










 return true;










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return accPath.append(accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -384,8 +217,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 public static <T> Delta<T> empty() {










 return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());










 }










 }










 



......@@ -395,21 +228,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 return accesses.length > 0 && accesses[0].equals(field);










 }










 










 public boolean isEmpty() {



......@@ -452,20 +272,9 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {










 SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = accesses[i].map(function);










 }










 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>((T[]) new Object[0], exclusions);










 else










 return this;










 }



......@@ -474,123 +283,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return accesses.length == 0;










 }





















 public boolean subsumes(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) 










 && otherIndex>=accPath.accesses.length-1) {










 if(transitions.isEmpty())










 return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(!match.hasMatched())










 return false;










 } 










 }










 return hasAtLeastTheSameExclusionsAs(accPath);










 }





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 }










 return false;










 }










 }










 










 private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {










 return accPath.exclusions.containsAll(exclusions);










 }





















 public Collection<String> tokenize() {










 List<String> result = Lists.newLinkedList();










 for(SubAccessPath<T> s : accesses) {










 result.add(s.toString());










 }










 if(!exclusions.isEmpty())










 result.add("^"+Joiner.on(",").join(exclusions));










 return result;










 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {










 public T getFirstAccess() {










 return accesses[0];










 }





















 public AccessPath<T> removeRepeatableFirstAccess(T field) {










 Collection<? extends T> elements = accesses[0].elements();










 if(!elements.contains(field))










 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}


package heros.alias;packageheros.alias;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;importheros.alias.SubAccessPath.SetOfPossibleFieldAccesses;import heros.alias.SubAccessPath.SpecificFieldAccess;importheros.alias.SubAccessPath.SpecificFieldAccess;import heros.alias.Transition.MatchResult;importheros.alias.Transition.MatchResult;import java.util.Arrays;importjava.util.Arrays;import java.util.Collection;importjava.util.Collection;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPath<T extends AccessPath.FieldRef<T>> {publicclassAccessPath<TextendsAccessPath.FieldRef<T>>{ public static interface FieldRef<F> {publicstaticinterfaceFieldRef<F>{ boolean shouldBeMergedWith(F fieldRef);booleanshouldBeMergedWith(FfieldRef); }}public class AccessPath<T> {publicclassAccessPath<T>{  public static <T extends FieldRef<T>> AccessPath<T> empty() {publicstatic<T extendsextends FieldRefFieldRef<<TT>>>AccessPath<T>empty(){ public static <T> AccessPath<T> empty() {publicstatic<T>AccessPath<T>empty(){ return new AccessPath<T>();returnnewAccessPath<T>(); }}  private final SubAccessPath<T>[] accesses;privatefinalSubAccessPathSubAccessPath<<TT>[]>accesses; private final T[] accesses;privatefinalTT[]accesses; private final Set<T> exclusions;privatefinalSet<T>exclusions;  public AccessPath() {publicAccessPath(){ accesses = new SubAccessPath[0];accesses=newnew SubAccessPathSubAccessPath[0]; accesses = (T[]) new Object[0];accesses=((TT[])[]) newnew ObjectObject[0]; exclusions = Sets.newHashSet();exclusions=Sets.newHashSet(); }}  AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {AccessPath(SubAccessPathSubAccessPath<<TT>[]>accesses,Set<T>exclusions){ AccessPath(T[] accesses, Set<T> exclusions) {AccessPath(TT[]accesses,Set<T>exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; }} public boolean isAccessInExclusions(T fieldReferences) {publicbooleanisAccessInExclusions(TfieldReferencess){ return exclusions.contains(fieldReferences);returnexclusions.contains(fieldReferencess); public boolean isAccessInExclusions(T fieldReference) {publicbooleanisAccessInExclusions(TfieldReference){ return exclusions.contains(fieldReference);returnexclusions.contains(fieldReference); }}  public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<T>...fieldReferences){ if(fieldReferences.length > 0) {if(fieldReferences.length>0){ for(T field : fieldReferences[0].elements()) {for(Tfield:fieldReferences[0].elements()){ if(!exclusions.contains(field))if(!exclusions.contains(field)) return false;returnfalse; }} return true;returntrue; }} return false;returnfalse; }}  public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {publicAccessPath<T>addFieldReference(SubAccessPath<T>...fieldReferences){ return addFieldReference(true, fieldReferences);returnaddFieldReference(true,fieldReferences); }} public boolean hasAllExclusionsOf(AccessPath<T> accPath) {publicbooleanhasAllExclusionsOf(AccessPath<T>accPath){ return exclusions.containsAll(accPath.exclusions);returnexclusions.containsAll(accPath.exclusions); }}  AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {AccessPath<T>addFieldReference(booleanmerge,SubAccessPath<T>...fieldReferences){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString()); //FIXME do we need to not merge sometimes?//FIXME do we need to not merge sometimes?//		if(merge) {//		if(merge) {//			for(int i=fieldReferences.length-1; i>=0; i--) {//			for(int i=fieldReferences.length-1; i>=0; i--) {//				for(int j=0; j<accesses.length; j++) {//				for(int j=0; j<accesses.length; j++) {//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {//						// [..., {j-i}, ...]//						// [..., {j-i}, ...]//						//						//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);//						builder.keep(0, j);//						builder.keep(0, j);//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);//						builder.append(fieldReferences, i+1, fieldReferences.length);//						builder.append(fieldReferences, i+1, fieldReferences.length);//						builder.removeExclusions();//						builder.removeExclusions();//						return builder.build();//						return builder.build();//					}//					}//				}//				}//			}//			}//		}//		}  AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+fieldReferences.length); builder.keep(0, accesses.length);builder.keep(0,accesses.length); builder.append(fieldReferences, 0, fieldReferences.length);builder.append(fieldReferences,0,fieldReferences.length); if(fieldReferences.length>0)if(fieldReferences.length>0) builder.removeExclusions();builder.removeExclusions(); return builder.build();returnbuilder.build(); }}  public AccessPath<T> addFieldReference(T... fieldReferences) {publicAccessPath<T>addFieldReference(T...fieldReferences){ SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];SubAccessPath<T>[]subPath=newSubAccessPath[fieldReferences.length]; for(int i=0; i<fieldReferences.length; i++) {for(inti=0;i<fieldReferences.length;i++){ subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);subPath[i]=newSpecificFieldAccess<>(fieldReferences[i]); }} return addFieldReference(subPath);returnaddFieldReference(subPath); }}  private class AccessPathBuilder {privateclassAccessPathBuilder{  private Set<T> newExclusions;privateSet<T>newExclusions; private SubAccessPath<T>[] newAccesses;privateSubAccessPath<T>[]newAccesses; private int currentIndex = 0;privateintcurrentIndex=0; public AccessPathBuilder(int capacity) {publicAccessPathBuilder(intcapacity){ newAccesses = new SubAccessPath[capacity];newAccesses=newSubAccessPath[capacity]; newExclusions = exclusions;newExclusions=exclusions; }}  public AccessPath<T> build() {publicAccessPath<T>build(){ return new AccessPath<>(newAccesses, newExclusions);returnnewAccessPath<>(newAccesses,newExclusions); }} public void removeExclusions() {publicvoidremoveExclusions(){ newExclusions = Sets.newHashSet();newExclusions=Sets.newHashSet(); }} public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {publicvoidappend(SubAccessPath<T>[]fieldReferences,intstart,intendExcl){ for(int i=start; i<endExcl; i++) {for(inti=start;i<endExcl;i++){ newAccesses[currentIndex] = fieldReferences[i];newAccesses[currentIndex]=fieldReferences[i]; currentIndex++;currentIndex++; if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)if(fieldReferences[i]instanceofSetOfPossibleFieldAccesses) removeExclusions();removeExclusions(); }} currentIndex+=endExcl-start;currentIndex+=endExcl-start; }} public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<T>[]fieldReferences,intstart,intendExcl){ newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccesses[currentIndex-1]=newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); }} public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {publicAccessPathBuildermerge(intsrcIndex,intdestIndexExcl){ Set<T> set = Sets.newHashSet();Set<T>set=Sets.newHashSet(); for(int i=srcIndex; i<destIndexExcl; i++) {for(inti=srcIndex;i<destIndexExcl;i++){ set.addAll(accesses[i].elements());set.addAll(accesses[i].elements()); }} newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);newAccesses[currentIndex]=newSubAccessPath.SetOfPossibleFieldAccesses<>(set); currentIndex++;currentIndex++; return this;returnthis; }} public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {publicAccessPathBuilderkeep(intsrcIndex,intdestIndexExcl){ System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);System.arraycopy(accesses,srcIndex,newAccesses,currentIndex,destIndexExcl-srcIndex); currentIndex += destIndexExcl-srcIndex;currentIndex+=destIndexExcl-srcIndex; public AccessPath<T> append(T... fieldReferences) {publicAccessPath<T>append(T...fieldReferences){ if(fieldReferences.length == 0)if(fieldReferences.length==0) return this;returnthis; }} public void append(T fieldRef) {publicvoidappend(TfieldRef){ newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);newAccesses[currentIndex]=newSubAccessPath.SpecificFieldAccess<>(fieldRef); currentIndex++;currentIndex++; }}  if(isAccessInExclusions(fieldReferences[0]))if(isAccessInExclusions(fieldReferences[0])) throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString()); T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);T[]newAccesses=Arrays.copyOf(accesses,accesses.length+fieldReferences.length); System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);System.arraycopy(fieldReferences,0,newAccesses,accesses.length,fieldReferences.length); return new AccessPath<>(newAccesses, Sets.<T>newHashSet());returnnewAccessPath<>(newAccesses,Sets.<T>newHashSet()); }} public AccessPath<T> prepend(T fieldRef) {publicAccessPath<T>prepend(TfieldRef){//		for(int j=0; j<accesses.length; j++) {//		for(int j=0; j<accesses.length; j++) {//			if(accesses[j].contains(fieldRef)) {//			if(accesses[j].contains(fieldRef)) {//				// [{0-j}, ...]//				// [{0-j}, ...]//				//				//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);//				builder.merge(0, j+1);//				builder.merge(0, j+1);//				builder.keep(j+1, accesses.length);//				builder.keep(j+1, accesses.length);//				return builder.build();//				return builder.build();//			}//			}//		}//		} AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+1); builder.append(fieldRef);builder.append(fieldRef); builder.keep(0, accesses.length);builder.keep(0,accesses.length); return builder.build();returnbuilder.build(); assert accesses.length != 0 || !exclusions.contains(fieldRef);assertaccesses.length!=0||!exclusions.contains(fieldRef); T[] newAccesses = (T[]) new Object[accesses.length+1];T[]newAccesses=(T[])newObject[accesses.length+1]; newAccesses[0] = fieldRef;newAccesses[0]=fieldRef; System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);System.arraycopy(accesses,0,newAccesses,1,accesses.length); return new AccessPath<>(newAccesses, Sets.<T>newHashSet());returnnewAccessPath<>(newAccesses,Sets.<T>newHashSet()); }} public AccessPath<T> removeFirst(T field) {publicAccessPath<T>removeFirst(Tfield){ for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i].contains(field)) {if(accesses[i].contains(field)){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); elseelse return this;returnthis; }} else if(accesses[i] instanceof SpecificFieldAccess)elseif(accesses[i]instanceofSpecificFieldAccess) throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this); }}  throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this); public AccessPath<T> removeFirst() {publicAccessPath<T>removeFirst(){ T[] newAccesses = (T[]) new Object[accesses.length-1];T[]newAccesses=(T[])newObject[accesses.length-1]; System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);System.arraycopy(accesses,1,newAccesses,0,accesses.length-1); return new AccessPath<>(newAccesses, exclusions);returnnewAccessPath<>(newAccesses,exclusions); }}  public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(TT......fieldReferences){ public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(CollectionCollection<<TT>>fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }} public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(CollectionCollection<<TT>>fieldReferences){  public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(TT......fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }} public static enum PrefixTestResult {publicstaticenumPrefixTestResult{ GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);GUARANTEED_PREFIX(33),POTENTIAL_PREFIX(22),), NEEDS_RESOLVNGNEEDS_RESOLVNG((1),NO_PREFIX(0); GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);GUARANTEED_PREFIX(22),POTENTIAL_PREFIX(1),NO_PREFIX(0);  private int value;privateintvalue; }} }}  public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {publicPrefixTestResultisPrefixOf(AccessPath<T>accPath){ int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0; PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;PrefixTestResultresult=PrefixTestResult.GUARANTEED_PREFIX;  int finalIndex = finalIndex();intfinalIndex=finalIndex(); outer: while(currIndex < finalIndex) {outer:while(currIndex<finalIndex){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);Collection<Transition<T>>transitions=possibleTransitions(currIndex,true); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);Collection<Transition<T>>otherTransitions=accPath.possibleTransitions(otherIndex,true); for(Transition<T> transition : transitions) {for(Transition<T>transition:transitions){ for(Transition<T> otherTransition : otherTransitions) {for(Transition<T>otherTransition:otherTransitions){ MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<T>>match=transition.isPrefixMatchOf(otherTransition); if(match.hasMatched()) {if(match.hasMatched()){ if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())if(currIndex==transition.transitionToIndex()&&otherIndex==otherTransition.transitionToIndex()) continue;continue;  currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex(); otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex(); if(!match.isGuaranteedMatch())if(!match.isGuaranteedMatch()) result = PrefixTestResult.POTENTIAL_PREFIX;result=PrefixTestResult.POTENTIAL_PREFIX;  continue outer;continueouter; }} }} }} public PrefixTestResult isPrefixOf(AccessPath<T> accessPath) {publicPrefixTestResultisPrefixOf(AccessPath<T>accessPath){ if(accesses.length > accessPath.accesses.length)if(accesses.length>accessPath.accesses.length) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX;  for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(!accesses[i].equals(accessPath.accesses[i]))if(!accesses[i].equals(accessPath.accesses[i])) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; }}  return result;returnresult; }}  private int finalIndex() {privateintfinalIndex(){ if(!exclusions.isEmpty())if(!exclusions.isEmpty()) return accesses.length + 1;returnaccesses.length+1;  int finalIndex = 0;intfinalIndex=0; for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) finalIndex = i+1;finalIndex=i+1; if(accesses.length < accessPath.accesses.length) {if(accesses.length<accessPath.accesses.length){ if(exclusions.contains(accessPath.accesses[accesses.length]))if(exclusions.contains(accessPath.accesses[accesses.length])) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; elseelse return PrefixTestResult.GUARANTEED_PREFIX;returnPrefixTestResult.GUARANTEED_PREFIX; }} return finalIndex;returnfinalIndex; }} private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {privateCollection<Transition<T>>possibleTransitions(intindex,booleanaddExclusionTransitions){ Collection<Transition<T>> result = Lists.newLinkedList();Collection<Transition<T>>result=Lists.newLinkedList(); if(index < accesses.length) {if(index<accesses.length){ if(accesses[index] instanceof SetOfPossibleFieldAccesses) {if(accesses[index]instanceofSetOfPossibleFieldAccesses){ result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index,accesses[index])); result.addAll(possibleTransitions(index+1, addExclusionTransitions));result.addAll(possibleTransitions(index+1,addExclusionTransitions)); }}  if(exclusions.isEmpty())if(exclusions.isEmpty()) return PrefixTestResult.GUARANTEED_PREFIX;returnPrefixTestResult.GUARANTEED_PREFIX; if(accessPath.exclusions.isEmpty())if(accessPath.exclusions.isEmpty()) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX;  boolean intersection = !Sets.intersection(exclusions, accessPath.exclusions).isEmpty();booleanintersection=!Sets.intersection(exclusions,accessPath.exclusions).isEmpty(); boolean containsAll = exclusions.containsAll(accessPath.exclusions);booleancontainsAll=exclusions.containsAll(accessPath.exclusions); boolean oppositeContainsAll = accessPath.exclusions.containsAll(exclusions);booleanoppositeContainsAll=accessPath.exclusions.containsAll(exclusions); boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);booleanpotentialMatch=oppositeContainsAll||!intersection||(!containsAll&&!oppositeContainsAll); if(potentialMatch) {if(potentialMatch){ if(oppositeContainsAll)if(oppositeContainsAll) return PrefixTestResult.GUARANTEED_PREFIX;returnPrefixTestResult.GUARANTEED_PREFIX; elseelse result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index+1,accesses[index])); } else if(addExclusionTransitions && index - accesses.length == 0 && !exclusions.isEmpty()) {}elseif(addExclusionTransitions&&index-accesses.length==0&&!exclusions.isEmpty()){ result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions));result.add(newTransition.ExclusionPathTransition<T>(index+1,exclusions)); return PrefixTestResult.POTENTIAL_PREFIX;returnPrefixTestResult.POTENTIAL_PREFIX; }} return result;returnresultresult; return PrefixTestResult.NO_PREFIX;returnPrefixTestResultPrefixTestResult..NO_PREFIXNO_PREFIX; }}   public Delta<T> getDeltaTo(AccessPath<T> accPath) {publicDelta<T>getDeltaTo(AccessPath<T>accPath){ assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);assertisPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX); int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  outer: while(true) {outer:while(true){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);Collection<Transition<T>>transitions=possibleTransitions(currIndex,false); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);Collection<Transition<T>>otherTransitions=accPath.possibleTransitions(otherIndex,false); for(Transition<T> transition : transitions) {for(Transition<T>transition:transitions){ for(Transition<T> otherTransition : otherTransitions) {for(Transition<T>otherTransition:otherTransitions){ MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<T>>match=transition.isPrefixMatchOf(otherTransition); if(match.hasMatched()) {if(match.hasMatched()){ if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())if(currIndex==transition.transitionToIndex()&&otherIndex==otherTransition.transitionToIndex()) continue;continue;  currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex(); otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex(); continue outer;continueouter; }} }} }} break;break; }}//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);//		exclusions.removeAll(this.exclusions);//		exclusions.removeAll(this.exclusions); Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);Delta<T>delta=newDelta<T>(Arrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length),accPath.exclusions); assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) assert(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)&&accPath.isPrefixOf(delta.applyTo(this,true))==PrefixTestResult.GUARANTEED_PREFIX) || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));||(isPrefixOf(accPath)==PrefixTestResult.GUARANTEED_PREFIX&&accPath.equals(delta.applyTo(this,true))); Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length), accPath.exclusions);Delta<T>delta=newDelta<T>(Arrays.copyOfRange(accPath.accesses,accesses.length,accPath.accesses.length),accPath.exclusions); assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this)) == PrefixTestResult.GUARANTEED_PREFIX) assert(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)&&accPath.isPrefixOf(delta.applyTo(this))==PrefixTestResult.GUARANTEED_PREFIX) || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this)));||(isPrefixOf(accPath)==PrefixTestResult.GUARANTEED_PREFIX&&accPath.equals(delta.applyTo(this))); return delta;returndelta; }}  //FIXME this is an unsound dirty hack//FIXME this is an unsound dirty hack public boolean contains(AccessPath<T> accPath) {publicbooleancontains(AccessPath<T>accPath){ assert accPath.accesses.length <= 1;assertaccPath.accesses.length<=1; if(accPath.accesses.length == 1) {if(accPath.accesses.length==1){ for(SubAccessPath<T> sub : accesses) {for(SubAccessPathSubAccessPath<<TT>>sub:accesses){ if(sub.elements().equals(accPath.accesses[0].elements())) {if(sub.elementselements().().equals(accPath.accesses[0]..elementselements()))(){ for(T sub : accesses) {for(TTsub:accesses){ if(sub.equals(accPath.accesses[0])) {if(sub.equals(accPath.accesses[0])){ return true;returntrue; }} }} }}   public static class Delta<T extends FieldRef<T>> {publicstaticclassDelta<T extendsextends FieldRefFieldRef<<TT>>>{ final SubAccessPath<T>[] accesses;finalSubAccessPathSubAccessPath<<TT>[]>accesses; public static class Delta<T> {publicstaticclassDelta<T>{ final T[] accesses;finalTT[]accesses; final Set<T> exclusions;finalSet<T>exclusions; protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {protectedDelta(SubAccessPathSubAccessPath<<TT>[]>accesses,Set<T>exclusions){ protected Delta(T[] accesses, Set<T> exclusions) {protectedDelta(TT[]accesses,Set<T>exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; }}  public boolean canBeAppliedTo(AccessPath<T> accPath) {publicbooleancanBeAppliedTo(AccessPath<T>accPath){ return !accPath.isAccessInExclusions(accesses);return!accPath.isAccessInExclusions(accesses); if(accesses.length > 0)if(accesses.length>0) return !accPath.isAccessInExclusions(accesses[0]);return!accPath.isAccessInExclusions(accesses[0]); elseelse return true;returntrue; }}  public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {publicAccessPath<T>applyTo(AccessPath<T>accPath,, booleanboolean mergemerge){ return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);returnaccPath.addFieldReferenceddFieldReference((mergemerge,, accesses).appendExcludedFieldReference(exclusions); public AccessPath<T> applyTo(AccessPath<T> accPath) {publicAccessPath<T>applyTo(AccessPath<T>accPath){ return accPath.append(accesses).appendExcludedFieldReference(exclusions);returnaccPath.appendppend((accesses).appendExcludedFieldReference(exclusions); }}  @Override@Override return true;returntrue; }} public static <T extends FieldRef<T>> Delta<T> empty() {publicstatic<T extendsextends FieldRefFieldRef<<TT>>>Delta<T>empty(){ return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());returnnewDelta<T>(newnew SubAccessPathSubAccessPath[0],Sets.<T>newHashSet()); public static <T> Delta<T> empty() {publicstatic<T>Delta<T>empty(){ return new Delta<T>((T[]) new Object[0], Sets.<T>newHashSet());returnnewDelta<T>(((TT[])[]) newnew ObjectObject[0],Sets.<T>newHashSet()); }} }}  return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }}  public boolean mayHaveEmptyAccessPath() {publicbooleanmayHaveEmptyAccessPath(){ for(SubAccessPath<T> subAcc : accesses)for(SubAccessPath<T>subAcc:accesses) if(subAcc instanceof SpecificFieldAccess)if(subAccinstanceofSpecificFieldAccess) return false;returnfalse; return true;returntrue; }}  public boolean canRead(T field) {publicbooleancanRead(Tfield){ for(SubAccessPath<T> acc : accesses) {for(SubAccessPath<T>acc:accesses){ if(acc.contains(field))if(acc.contains(field)) return true;returntrue; if(acc instanceof SpecificFieldAccess)if(accinstanceofSpecificFieldAccess) return false;returnfalse; }} return false;returnfalse; return accesses.length > 0 && accesses[0].equals(field);returnaccesses.length>0&&accesses[0].equals(field); }}  public boolean isEmpty() {publicbooleanisEmpty(){ return result;returnresult; }}  public <U extends FieldRef<U>> AccessPath<U> map(Function<T, U> function) {public<UextendsFieldRef<U>>AccessPath<U>map(Function<T,U>function){ SubAccessPath<U>[] newAccesses = new SubAccessPath[accesses.length];SubAccessPath<U>[]newAccesses=newSubAccessPath[accesses.length]; for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ newAccesses[i] = accesses[i].map(function);newAccesses[i]=accesses[i].map(function); }} Set<U> newExclusions = Sets.newHashSet();Set<U>newExclusions=Sets.newHashSet(); for(T f : exclusions)for(Tf:exclusions) newExclusions.add(function.apply(f));newExclusions.add(function.apply(f)); return new AccessPath<U>(newAccesses, newExclusions);returnnewAccessPath<U>(newAccesses,newExclusions); }}  public AccessPath<T> removeAnyAccess() {publicAccessPath<T>removeAnyAccess(){ if(accesses.length > 0)if(accesses.length>0) return new AccessPath<T>(new SubAccessPath[0], exclusions);returnnewAccessPath<T>(newnew SubAccessPathSubAccessPath[0],exclusions); return new AccessPath<T>((T[]) new Object[0], exclusions);returnnewAccessPath<T>(((TT[])[]) newnew ObjectObject[0],exclusions); elseelse return this;returnthis; }} return accesses.length == 0;returnaccesses.length==0; }} public boolean subsumes(AccessPath<T> accPath) {publicbooleansubsumes(AccessPath<T>accPath){ int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  outer: while(true) {outer:while(true){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);Collection<Transition<T>>transitions=possibleTransitions(currIndex,false); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);Collection<Transition<T>>otherTransitions=accPath.possibleTransitions(otherIndex,false); if((currIndex >= accesses.length || (currIndex == accesses.length-1 && accesses[currIndex] instanceof SetOfPossibleFieldAccesses)) if((currIndex>=accesses.length||(currIndex==accesses.length-1&&accesses[currIndex]instanceofSetOfPossibleFieldAccesses)) && otherIndex>=accPath.accesses.length-1) {&&otherIndex>=accPath.accesses.length-1){ if(transitions.isEmpty())if(transitions.isEmpty()) return otherTransitions.isEmpty() && hasAtLeastTheSameExclusionsAs(accPath);returnotherTransitions.isEmpty()&&hasAtLeastTheSameExclusionsAs(accPath); for(Transition<T> transition : transitions) {for(Transition<T>transition:transitions){ for(Transition<T> otherTransition : otherTransitions) {for(Transition<T>otherTransition:otherTransitions){ MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<T>>match=transition.isPrefixMatchOf(otherTransition); if(!match.hasMatched())if(!match.hasMatched()) return false;returnfalse; } } }} return hasAtLeastTheSameExclusionsAs(accPath);returnhasAtLeastTheSameExclusionsAs(accPath); }} for(Transition<T> transition : transitions) {for(Transition<T>transition:transitions){ for(Transition<T> otherTransition : otherTransitions) {for(Transition<T>otherTransition:otherTransitions){ MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<T>>match=transition.isPrefixMatchOf(otherTransition); if(match.hasMatched()) {if(match.hasMatched()){ if(otherIndex == otherTransition.transitionToIndex())if(otherIndex==otherTransition.transitionToIndex()) continue;continue;  currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex(); otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex(); continue outer;continueouter; }} }} }} return false;returnfalse; }} }}  private boolean hasAtLeastTheSameExclusionsAs(AccessPath<T> accPath) {privatebooleanhasAtLeastTheSameExclusionsAs(AccessPath<T>accPath){ return accPath.exclusions.containsAll(exclusions);returnaccPath.exclusions.containsAll(exclusions); }} public Collection<String> tokenize() {publicCollection<String>tokenize(){ List<String> result = Lists.newLinkedList();List<String>result=Lists.newLinkedList(); for(SubAccessPath<T> s : accesses) {for(SubAccessPath<T>s:accesses){ result.add(s.toString());result.add(s.toString()); }} if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result.add("^"+Joiner.on(",").join(exclusions));result.add("^"+Joiner.on(",").join(exclusions)); return result;returnresult; }} public AccessPath<T> removeExclusions() {publicAccessPath<T>removeExclusions(){ return new AccessPath<T>(accesses, Sets.<T>newHashSet());returnnewAccessPath<T>(accesses,Sets.<T>newHashSet()); }} public SubAccessPath<T> getFirstAccess() {publicSubAccessPath<T>getFirstAccess(){ public T getFirstAccess() {publicTgetFirstAccess(){ return accesses[0];returnaccesses[0]; }} public AccessPath<T> removeRepeatableFirstAccess(T field) {publicAccessPath<T>removeRepeatableFirstAccess(Tfield){ Collection<? extends T> elements = accesses[0].elements();Collection<?extendsT>elements=accesses[0].elements(); if(!elements.contains(field))if(!elements.contains(field)) throw new IllegalArgumentException();thrownewIllegalArgumentException();  if(elements.size() == 1) {if(elements.size()==1){ return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions); }}  HashSet<T> newSet = Sets.newHashSet(elements);HashSet<T>newSet=Sets.newHashSet(elements); newSet.remove(field);newSet.remove(field); SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);SubAccessPath<T>[]newAccesses=Arrays.copyOf(accesses,accesses.length); newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);newAccesses[0]=newSetOfPossibleFieldAccesses<>(newSet); return new AccessPath<T>(newAccesses, exclusions);returnnewAccessPath<T>(newAccesses,exclusions); }} public class Iterator {publicclassIterator{ private int currentIndex = 0;privateintcurrentIndex=0;  public boolean hasNext(T field) {publicbooleanhasNext(Tfield){ for(int i=0; i+currentIndex < accesses.length; i++) {for(inti=0;i+currentIndex<accesses.length;i++){ if(accesses[currentIndex+i].contains(field))if(accesses[currentIndex+i].contains(field)) return true;returntrue; if(accesses[currentIndex+i] instanceof SpecificFieldAccess)if(accesses[currentIndex+i]instanceofSpecificFieldAccess) return false;returnfalse; }} return false;returnfalse; }}  public void next(T field) {publicvoidnext(Tfield){ for(int i=0; i+currentIndex < accesses.length; i++) {for(inti=0;i+currentIndex<accesses.length;i++){ if(accesses[currentIndex+i].contains(field)) {if(accesses[currentIndex+i].contains(field)){ currentIndex+=i;currentIndex+=i; return;return; }} if(accesses[currentIndex+i] instanceof SpecificFieldAccess)if(accesses[currentIndex+i]instanceofSpecificFieldAccess) throw new IllegalStateException();thrownewIllegalStateException(); }} throw new IllegalStateException();thrownewIllegalStateException(); }}  public boolean maybeAtEnd() {publicbooleanmaybeAtEnd(){ for(int i=0; i+currentIndex < accesses.length; i++) {for(inti=0;i+currentIndex<accesses.length;i++){ if(accesses[currentIndex+i] instanceof SpecificFieldAccess)if(accesses[currentIndex+i]instanceofSpecificFieldAccess) return false;returnfalse; }} return true;returntrue; }}  public boolean isExcluded(T field) {publicbooleanisExcluded(Tfield){ return exclusions.contains(field);returnexclusions.contains(field); }}  }} public AccessPath<T>.Iterator iterator() {publicAccessPath<T>.Iteratoriterator(){ return new Iterator();returnnewIterator(); }}}}








src/heros/alias/AccessPathHandler.java








View file @ e60e669d






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......












src/heros/alias/AccessPathHandler.java








View file @ e60e669d








src/heros/alias/AccessPathHandler.java










View file @ e60e669d


e60e669d



......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......






......@@ -13,9 +13,8 @@ package heros.alias;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class AccessPathHandler<Field, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;



......@@ -30,18 +29,18 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 return accessPath.hasEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 if(accessPath.getFirstAccess().equals(fieldRef))










 return true;










 return false;










 }










 



......@@ -68,7 +67,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }



......@@ -84,7 +83,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else



......@@ -99,7 +98,7 @@ public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, S









 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }














......


import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import heros.alias.FlowFunction.ReadFieldConstraint;importheros.alias.FlowFunction.ReadFieldConstraint;import heros.alias.FlowFunction.WriteFieldConstraint;importheros.alias.FlowFunction.WriteFieldConstraint;import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;importheros.alias.SubAccessPath.SetOfPossibleFieldAccesses;public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassAccessPathHandler<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public class AccessPathHandler<Field, Fact, Stmt, Method> {publicclassAccessPathHandler<Field,Fact,Stmt,Method>{ private AccessPath<Field> accessPath;privateAccessPath<Field>accessPath; private Resolver<Field, Fact, Stmt, Method> resolver;privateResolver<Field,Fact,Stmt,Method>resolver; }}  public boolean mayCanRead(Field field) {publicbooleanmayCanRead(Fieldfield){ return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));returnaccessPath.canRead(field)||(accessPath.mayHaveEmptyAccessPathmayHave()&&!accessPath.isAccessInExclusions(field)); return accessPath.canRead(field) || (accessPath.hasEmptyAccessPath() && !accessPath.isAccessInExclusions(field));returnaccessPath.canRead(field)||(accessPath.hasEmptyAccessPathhas()&&!accessPath.isAccessInExclusions(field)); }}  public boolean mayBeEmpty() {publicbooleanmayBeEmpty(){ return accessPath.mayHaveEmptyAccessPath();returnaccessPath.mayHaveEmptyAccessPathmayHave(); return accessPath.hasEmptyAccessPath();returnaccessPath.hasEmptyAccessPathhas(); }} public boolean canOverwrite(Field fieldRef) {publicbooleancanOverwrite(FieldfieldRef){ if(accessPath.hasEmptyAccessPath())if(accessPath.hasEmptyAccessPath()) return true;returntrue; if(accessPath.getFirstAccess().contains(fieldRef))if(accessPath.getFirstAccess().containscontain(fieldRef)) return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;returnaccessPathaccessPath..getFirstAccessgetFirstAccess()() instanceofinstanceof SetOfPossibleFieldAccessesSetOfPossibleFieldAccesses; if(accessPath.getFirstAccess().equals(fieldRef))if(accessPath.getFirstAccess().equalsequal(fieldRef)) return true;returntruetrue; return false;returnfalse; }}  @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(canRead(field))if(canRead(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.removeFirst(fieldfield),resolver)); return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.removeFirst(),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));returnnewConstrainedFact<>(newWrappedFact<>(fact,newAccessPath<Field>(),resolver),newReadFieldConstraint<>(field)); }} @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(accessPath.canRead(field)) {if(accessPath.canRead(field)){ AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);AccessPath<Field>tempAccPath=accessPath.removeRepeatableFirstAccessRepeatableFirstAccess((fieldfield); AccessPath<Field> tempAccPath = accessPath.removeFirst();AccessPath<Field>tempAccPath=accessPath.removeFirstFirst();( if(tempAccPath.hasEmptyAccessPath())if(tempAccPath.hasEmptyAccessPath()) return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,tempAccPath.appendExcludedFieldReference(field),resolver)); elseelse throw new IllegalArgumentException("Cannot write field "+field);thrownewIllegalArgumentException("Cannot write field "+field); }}  public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {publicstaticinterfaceResultBuilder<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>FactAbstraction,Stmt,Method>{ public static interface ResultBuilder<FieldRef, FactAbstraction, Stmt, Method> {publicstaticinterfaceResultBuilder<FieldRef,FactAbstraction,Stmt,Method>{ public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);publicConstrainedFact<FieldRef,FactAbstraction,Stmt,Method>generate(FactAbstractionfact); }}








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......












src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ e60e669d








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java










View file @ e60e669d


e60e669d



......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......






......@@ -19,7 +19,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Sets;
































public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;










 private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;



......


import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class BiDiFieldSensitiveIFDSSolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {publicclassBiDiFieldSensitiveIFDSSolver<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>{public class BiDiFieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {publicclassBiDiFieldSensitiveIFDSSolver<Field,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>{ private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> forwardSolver;privateFieldSensitiveIFDSSolver<Field,Fact,Stmt,Method,I>forwardSolver; private FieldSensitiveIFDSSolver<Field, Fact, Stmt, Method, I> backwardSolver;privateFieldSensitiveIFDSSolver<Field,Fact,Stmt,Method,I>backwardSolver;








src/heros/alias/CallEdgeResolver.java








View file @ e60e669d






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......












src/heros/alias/CallEdgeResolver.java








View file @ e60e669d








src/heros/alias/CallEdgeResolver.java










View file @ e60e669d


e60e669d



......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......






......@@ -10,11 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);



......@@ -24,7 +23,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }



......@@ -32,7 +31,7 @@ class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Met









 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());










 return analyzer.getAccessPath().contains(accPath);










 }














......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {classCallEdgeResolver<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{class CallEdgeResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {classCallEdgeResolver<Field,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {publicCallEdgeResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer){ super(analyzer);super(analyzer); public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { publicvoidresolve(Constraint<Field>constraint,InterestCallback<Field,Fact,Stmt,Method>callback){ log("Resolve: "+constraint);log("Resolve: "+constraint); if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {if(constraint.canBeAppliedTo(analyzer.getAccessPath())&&!analyzer.isLocked()&&!doesContain(constraint)){ AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);AccessPath<Field>newAccPath=constraint.applyToAccessPath(analyzer.getAccessPath(),, truetrue); AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath());AccessPath<Field>newAccPath=constraint.applyToAccessPath(analyzer.getAccessPath()); PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>nestedAnalyzer=analyzer.getOrCreateNestedAnalyzer(newAccPath); nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);nestedAnalyzer.getCallEdgeResolver().registerCallback(callback); }}  //FIXME: this is a dirty hack (and unsound?!)//FIXME: this is a dirty hack (and unsound?!) private boolean doesContain(Constraint<Field> constraint) {privatebooleandoesContain(Constraint<Field>constraint){ AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);AccessPath<Field>accPath=constraint.applyToAccessPath(newAccessPath<Field>(),, truetrue); AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>());AccessPath<Field>accPath=constraint.applyToAccessPath(newAccessPath<Field>()); return analyzer.getAccessPath().contains(accPath);returnanalyzer.getAccessPath().contains(accPath); }}








src/heros/alias/Context.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......












src/heros/alias/Context.java








View file @ e60e669d








src/heros/alias/Context.java










View file @ e60e669d


e60e669d



......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {










public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;



......


import heros.InterproceduralCFG;importheros.InterproceduralCFG;public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {publicabstractclassContext<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>FactAbstraction,Statement,Method>{public abstract class Context<FieldRef, FactAbstraction, Statement, Method> {publicabstractclassContext<FieldRef,FactAbstraction,Statement,Method>{ public final InterproceduralCFG<Statement, Method> icfg;publicfinalInterproceduralCFG<Statement,Method>icfg; public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;publicfinalFlowFunctionProcessor<FactAbstraction,Statement,Method,FieldRef>flowProcessor;








src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......












src/heros/alias/ControlFlowJoinResolver.java








View file @ e60e669d








src/heros/alias/ControlFlowJoinResolver.java










View file @ e60e669d


e60e669d



......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......






......@@ -20,7 +20,7 @@ import heros.alias.AccessPath.Delta;









import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;



......@@ -88,10 +88,10 @@ public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, F









 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......


import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassControlFlowJoinResolver<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassControlFlowJoinResolver<Field,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ private boolean recursiveLock = false;privatebooleanrecursiveLock=false; private Stmt joinStmt;privateStmtjoinStmt; if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())if(!constraint.canBeAppliedTo(resolvedAccPath)||isLocked()) return;return;  AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath,, falsefalse); AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath); recursiveLock = true;recursiveLock=true; ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);ControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver=getOrCreateNestedResolver(candidateAccPath); if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath,, falsefalse))) if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath))) throw new AssertionError();thrownewAssertionError();  nestedResolver.registerCallback(callback);nestedResolver.registerCallback(callback);








src/heros/alias/Debugger.java








View file @ e60e669d






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......












src/heros/alias/Debugger.java








View file @ e60e669d








src/heros/alias/Debugger.java










View file @ e60e669d


e60e669d



......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......






......@@ -12,14 +12,14 @@ package heros.alias;




















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {










public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










 public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {



......


import heros.InterproceduralCFG;importheros.InterproceduralCFG;public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {publicinterfaceDebugger<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>{public interface Debugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {publicinterfaceDebugger<Field,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>{ public abstract void setICFG(I icfg);publicabstractvoidsetICFG(Iicfg); public abstract void initialSeed(Stmt stmt);publicabstractvoidinitialSeed(Stmtstmt);  public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicstaticclassNullDebugger<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ public static class NullDebugger <Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicstaticclassNullDebugger<Field,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ @Override@Override public void setICFG(I icfg) {publicvoidsetICFG(Iicfg){








src/heros/alias/DeltaConstraint.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......












src/heros/alias/DeltaConstraint.java








View file @ e60e669d








src/heros/alias/DeltaConstraint.java










View file @ e60e669d


e60e669d



......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private Delta<FieldRef> delta;














......@@ -26,8 +26,8 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return delta.applyTo(accPath, !sourceFact);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return delta.applyTo(accPath);










 }





















 @Override



......


import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassDeltaConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsConstraint<FieldRef>{public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {publicclassDeltaConstraint<FieldRef>implementsConstraint<FieldRef>{ private Delta<FieldRef> delta;privateDelta<FieldRef>delta; }}  @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact){ return delta.applyTo(accPath, !sourceFact);returndelta.applyTo(accPath,, !!sourceFactsourceFact); public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return delta.applyTo(accPath);returndelta.applyTo(accPath); }} @Override@Override








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ e60e669d








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ e60e669d


e60e669d



......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......






......@@ -18,7 +18,7 @@ import java.util.Set;









import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {





















 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;



......


import org.slf4j.Logger;importorg.slf4j.Logger;import org.slf4j.LoggerFactory;importorg.slf4j.LoggerFactory;public class FieldSensitiveIFDSSolver<FieldRef extends AccessPath.FieldRef<FieldRef>, D, N, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>D,N,M,IextendsInterproceduralCFG<N,M>>{public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<FieldRef,D,N,M,IextendsInterproceduralCFG<N,M>>{ protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);protectedstaticfinalLoggerlogger=LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class); private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;privateFlowFunctionProcessor<D,N,M,FieldRef>flowProcessor;








src/heros/alias/FlowFunction.java








View file @ e60e669d






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}












src/heros/alias/FlowFunction.java








View file @ e60e669d








src/heros/alias/FlowFunction.java










View file @ e60e669d


e60e669d



......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}






......@@ -31,7 +31,7 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










public interface FlowFunction<FieldRef, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.



......@@ -39,7 +39,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 public static class ConstrainedFact<FieldRef, D, Stmt, Method> {










 










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;



......@@ -99,13 +99,13 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -113,7 +113,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 



......@@ -153,7 +153,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 }










 










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......@@ -162,8 +162,8 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.append(fieldRef);










 }










 










 @Override



......@@ -198,7 +198,7 @@ public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D,




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 return !accPath.isAccessInExclusions(fieldRef);










 }










 }










}


 *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {publicinterfaceFlowFunction<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>D,Stmt,Method>{public interface FlowFunction<FieldRef, D, Stmt, Method> {publicinterfaceFlowFunction<FieldRef,D,Stmt,Method>{ /**/**	 * Returns the target values reachable from the source.	 * Returns the target values reachable from the source. Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);Set<ConstrainedFact<FieldRef,D,Stmt,Method>>computeTargets(Dsource,AccessPathHandler<FieldRef,D,Stmt,Method>accPathHandler);   public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {publicstaticclassConstrainedFact<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>D,Stmt,Method>{ public static class ConstrainedFact<FieldRef, D, Stmt, Method> {publicstaticclassConstrainedFact<FieldRef,D,Stmt,Method>{  private WrappedFact<FieldRef, D, Stmt, Method> fact;privateWrappedFact<FieldRef,D,Stmt,Method>fact; private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint; }} }}  public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {publicinterfaceConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>{ AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);AccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact); public interface Constraint<FieldRef> {publicinterfaceConstraint<FieldRef>{ AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);AccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath);  boolean canBeAppliedTo(AccessPath<FieldRef> accPath);booleancanBeAppliedTo(AccessPath<FieldRef>accPath); }}  public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassWriteFieldConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsConstraint<FieldRef>{ public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {publicclassWriteFieldConstraint<FieldRef>implementsConstraint<FieldRef>{ private FieldRef fieldRef;privateFieldReffieldRef; public WriteFieldConstraint(FieldRef fieldRef) {publicWriteFieldConstraint(FieldReffieldRef){ }} @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact){ public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return accPath.appendExcludedFieldReference(fieldRef);returnaccPath.appendExcludedFieldReference(fieldRef); }}  }} }}  public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassReadFieldConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsConstraint<FieldRef>{ public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {publicclassReadFieldConstraint<FieldRef>implementsConstraint<FieldRef>{ private FieldRef fieldRef;privateFieldReffieldRef; }}  @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact){ return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));returnaccPath.addFieldReferenceddFieldReference(!(!sourceFactsourceFact,, newnew SubAccessPathSubAccessPath..SpecificFieldAccessSpecificFieldAccess<<FieldRefFieldRef>(>fieldRef));) public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return accPath.append(fieldRef);returnaccPath.appendppend(fieldRef); }}  @Override@Override @Override@Override public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {publicbooleancanBeAppliedTo(AccessPath<FieldRef>accPath){ return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));return!accPath.isAccessInExclusions(newnew SubAccessPathSubAccessPath..SpecificFieldAccessSpecificFieldAccess<<FieldRefFieldRef>(>(fieldRef));) return !accPath.isAccessInExclusions(fieldRef);return!accPath.isAccessInExclusions(fieldRef); }} }}}}








src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......












src/heros/alias/FlowFunctionProcessor.java








View file @ e60e669d








src/heros/alias/FlowFunctionProcessor.java










View file @ e60e669d


e60e669d



......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......






......@@ -16,7 +16,7 @@ import java.util.Set;




















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {










public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;














......


import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {publicclassFlowFunctionProcessor<Fact,Stmt,Method,Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>>>{public class FlowFunctionProcessor<Fact, Stmt, Method, Field> {publicclassFlowFunctionProcessor<Fact,Stmt,Method,Field>{ private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;privateFlowFunctions<Stmt,Field,Fact,Method>flowFunctions;








src/heros/alias/FlowFunctions.java








View file @ e60e669d






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......












src/heros/alias/FlowFunctions.java








View file @ e60e669d








src/heros/alias/FlowFunctions.java










View file @ e60e669d


e60e669d



......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {










public interface FlowFunctions<Stmt, FieldRef, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......


 *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. */ */public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {publicinterfaceFlowFunctions<Stmt,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>F,Method>{public interface FlowFunctions<Stmt, FieldRef, F, Method> {publicinterfaceFlowFunctions<Stmt,FieldRef,F,Method>{ /**/**	 * Returns the flow function that computes the flow for a normal statement,	 * Returns the flow function that computes the flow for a normal statement,








src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}












src/heros/alias/HashKey.java

deleted


100644 → 0







View file @ 1f74a4f2








src/heros/alias/HashKey.java

deleted


100644 → 0









View file @ 1f74a4f2


1f74a4f2










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Arrays;importjava.util.Arrays;public class HashKey {publicclassHashKey{ private Object[] values;privateObject[]values; public HashKey(Object...values) {publicHashKey(Object...values){ this.values = values;this.values=values; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(values);result=prime*result+Arrays.hashCode(values); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; HashKey other = (HashKey) obj;HashKeyother=(HashKey)obj; if (!Arrays.equals(values, other.values))if(!Arrays.equals(values,other.values)) return false;returnfalse; return true;returntrue; }}  }}








src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......












src/heros/alias/IFDSTabulationProblem.java








View file @ e60e669d








src/heros/alias/IFDSTabulationProblem.java










View file @ e60e669d


e60e669d



......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......






......@@ -29,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......


 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>D,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{public interface IFDSTabulationProblem<N,FieldRef, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRef,D,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{ /**/**	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * Returns a set of flow functions. Those functions are used to compute data-flow facts








src/heros/alias/IncomingEdge.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......












src/heros/alias/IncomingEdge.java








View file @ e60e669d








src/heros/alias/IncomingEdge.java










View file @ e60e669d


e60e669d



......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class IncomingEdge<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;



......@@ -57,12 +57,12 @@ public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt,









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), 










 calleeSourceFactWithDelta));










 }










 



......


import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassIncomingEdge<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public class IncomingEdge<Field, Fact, Stmt, Method> {publicclassIncomingEdge<Field,Fact,Stmt,Method>{ private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;privateWrappedFact<Field,Fact,Stmt,Method>calleeSourceFact; private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;privatePerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>callerAnalyzer;  @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);WrappedFact<Field,Fact,Stmt,Method>calleeSourceFactWithDelta=newWrappedFact<>(calleeSourceFact.getFact(),delta.applyTo(calleeSourceFact.getAccessPath(),, falsefalse),resolver); WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);WrappedFact<Field,Fact,Stmt,Method>calleeSourceFactWithDelta=newWrappedFact<>(calleeSourceFact.getFact(),delta.applyTo(calleeSourceFact.getAccessPath()),resolver); if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath())!=PrefixTestResult.GUARANTEED_PREFIX) throw new AssertionError();thrownewAssertionError(); interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, interestedAnalyzer.addIncomingEdge(newIncomingEdge<>(analyzer, new WrappedFactAtStatement<>(factAtCallSite.getStatement(), newWrappedFactAtStatement<>(factAtCallSite.getStatement(), new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), newWrappedFact<>(factAtCallSite.getFact().getFact(),delta.applyTo(factAtCallSite.getFact().getAccessPath(),, falsefalse),resolver)), new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath()), resolver)), newWrappedFact<>(factAtCallSite.getFact().getFact(),delta.applyTo(factAtCallSite.getFact().getAccessPath()),resolver)), calleeSourceFactWithDelta));calleeSourceFactWithDelta)); }} 








src/heros/alias/InterestCallback.java








View file @ e60e669d






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}












src/heros/alias/InterestCallback.java








View file @ e60e669d








src/heros/alias/InterestCallback.java










View file @ e60e669d


e60e669d



......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}






......@@ -10,14 +10,10 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public interface InterestCallback<Field, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicinterfaceInterestCallback<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public interface InterestCallback<Field, Fact, Stmt, Method> {publicinterfaceInterestCallback<Field,Fact,Stmt,Method>{ void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);voidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver); //	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);  void canBeResolvedEmpty();voidcanBeResolvedEmpty();}}








src/heros/alias/MethodAnalyzer.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......












src/heros/alias/MethodAnalyzer.java








View file @ e60e669d








src/heros/alias/MethodAnalyzer.java










View file @ e60e669d


e60e669d



......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {










public interface MethodAnalyzer<Field,Fact,Stmt,Method> {





















 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);










 



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public interface MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,Fact,Stmt,Method> {publicinterfaceMethodAnalyzer<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public interface MethodAnalyzer<Field,Fact,Stmt,Method> {publicinterfaceMethodAnalyzer<Field,Fact,Stmt,Method>{ public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge);publicvoidaddIncomingEdge(IncomingEdge<Field,Fact,Stmt,Method>incEdge); 








src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......












src/heros/alias/MethodAnalyzerImpl.java








View file @ e60e669d








src/heros/alias/MethodAnalyzerImpl.java










View file @ e60e669d


e60e669d



......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> 










public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> 










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class MethodAnalyzerImpl<Field extends AccessPath.FieldRef<Field>,Fact, Stmt, Method> publicclassMethodAnalyzerImpl<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>public class MethodAnalyzerImpl<Field,Fact, Stmt, Method> publicclassMethodAnalyzerImpl<Field,Fact,Stmt,Method> implements MethodAnalyzer<Field, Fact, Stmt, Method> {implementsMethodAnalyzer<Field,Fact,Stmt,Method>{ private Method method;privateMethodmethod;








src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......












src/heros/alias/PerAccessPathMethodAnalyzer.java








View file @ e60e669d








src/heros/alias/PerAccessPathMethodAnalyzer.java










View file @ e60e669d


e60e669d



......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......






......@@ -28,7 +28,7 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;



......


import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassPerAccessPathMethodAnalyzer<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {publicclassPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>{ protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);protectedstaticfinalLoggerlogger=LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class); private Fact sourceFact;privateFactsourceFact;








src/heros/alias/Resolver.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......












src/heros/alias/Resolver.java








View file @ e60e669d








src/heros/alias/Resolver.java










View file @ e60e669d


e60e669d



......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......






......@@ -19,7 +19,7 @@ import com.google.common.collect.Lists;









import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public abstract class Resolver<Field, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();



......


import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicabstractclassResolver<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public abstract class Resolver<Field, Fact, Stmt, Method> {publicabstractclassResolver<Field,Fact,Stmt,Method>{ private boolean interest = false;privatebooleaninterest=false; private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();privateList<InterestCallback<Field,Fact,Stmt,Method>>interestCallbacks=Lists.newLinkedList();



Prev


1


2


Next





Prev

1

2

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






