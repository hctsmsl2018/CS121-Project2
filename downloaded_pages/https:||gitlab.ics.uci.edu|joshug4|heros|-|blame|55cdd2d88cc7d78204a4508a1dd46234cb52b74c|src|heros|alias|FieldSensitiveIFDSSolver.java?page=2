



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c

















55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1001




1002




1003




	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})
	 */









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1004




	protected void propagate(PathEdge<N,D> edge,









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1005




1006




			/* deliberately exposed to clients */ N relatedCallSite,
			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1007




		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1008




		final D existingVal = jumpFn.addFunction(edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1009




		









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1010




1011




1012




1013




1014




1015




1016




1017




		
		if(!edge.factAtTarget().getAccessPath().hasResolver()) {
			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {
				throw new AssertionError();
			}
		}
		
		if(edge instanceof CallConcretizationPathEdge) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1018




			concretizationEdges++;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1019




			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1020




1021




1022




1023




1024




1025




1026




			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 
					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());
			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))
				return;
			
			resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());
			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1027




1028




		} else if(edge instanceof ReturnConcretizationPathEdge) {
			((ReturnConcretizationPathEdge<N,D>) edge).propagate();









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1029




		} else {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1030




1031




1032




1033




//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {
//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",
//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1034




1035




			
			









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1036




			if (existingVal != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1037




				cacheEquals++;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1038




1039




1040




1041




				if (existingVal != edge.factAtTarget())
					existingVal.addNeighbor(edge.factAtTarget());
			}
			else {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1042




1043




1044




1045




1046




1047




1048




1049




				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());
				
				if(sourceBaseValueCache.containsKey(sourceValueKey)) {
					cacheSourceBaseValue++;
				}
				sourceBaseValueCache.put(sourceValueKey, edge);
				
				









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1050




1051




				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());
				if(cache.containsKey(key)) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1052




1053




1054




1055




1056




//					if(cacheHits % 10_000 == 0) {
//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));
//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));
//						System.out.println(edge);
//						System.out.println(icfg.getMethodOf(edge.getTarget()));









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1057




//						System.out.println("---");









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1058




1059




1060




//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {
//							System.out.println(cachedEdge);
//						}









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1061




//						System.out.println("---");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1062




//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1063




					cacheHits++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1064




1065




1066




1067




1068




1069




1070




1071




1072




					boolean opposite = false;
					for(PathEdge<N,D> cachedEdge : cache.get(key)) {
						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {
							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());
							cacheMerges++;
							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);
							return;
						}
//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1073




//							opposite=true;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1074




1075





					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1076




1077




//					if(opposite)
//						cacheOppositePrefix++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1078




1079




1080




1081




//					else if(cache.get(key).size() > 500) {
//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");
//						System.out.println(edge.factAtTarget());
//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1082




1083




1084




				}	
				
				cache.put(key, edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1085




1086




1087




1088




				scheduleEdgeProcessing(edge);
				if(edge.factAtTarget()!=zeroValue)
					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);
			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1089




1090




		}
	}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1091




1092




1093




	
	private static class CacheKey<N, D, BaseValue> {










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1094




		private Object[] values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1095














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1096




1097




		public CacheKey(Object...values) {
			this.values = values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1098




1099




1100




1101




1102




1103




		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1104




			result = prime * result + Arrays.hashCode(values);









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1105




1106




1107




1108




1109




1110




1111




1112




1113




1114




1115




1116




			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof CacheKey))
				return false;
			CacheKey other = (CacheKey) obj;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1117




			if (!Arrays.equals(values, other.values))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1118




1119




1120




1121




1122




				return false;
			return true;
		}
		
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1123














use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1124




1125




1126




1127




1128




1129




1130




1131




	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {
		Set<SummaryEdge<D, N>> map = endSummary.get(m);
		if(map == null)
			return null;
		
		return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {
			@Override
			public boolean apply(SummaryEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1132




				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1133




1134




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1135




1136




	}










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1137




1138




1139




1140




	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {
		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet
				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());
		return summaries.add(summaryEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1141




1142




	}	










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1143




1144




	protected Set<IncomingEdge<D, N>> incoming(M m) {
		Set<IncomingEdge<D, N>> result = incoming.get(m);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1145




		if(result == null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1146




			return Collections.emptySet();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1147




1148




1149




1150




		else
			return result;
	}
	









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1151




1152




1153




1154




1155




	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {
		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1156




				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1157




1158




1159




1160




			}
		});
	}
	









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1161




	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1162




1163




1164




1165




		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1166




				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1167




1168




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1169




1170




	}
	









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1171




	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1172




		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1173




1174




		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());
		return set.add(incomingEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1175




1176




1177




1178




1179




1180




1181




1182




1183




1184




1185




1186




1187




1188




1189




1190




1191




1192




1193




1194




1195




1196




1197




1198




1199




1200




1201




1202




1203




1204




1205




1206




1207




1208




1209




1210




1211




1212




1213




1214




1215




1216




1217




1218




1219




1220




1221




1222




1223




1224




	}
	
	/**
	 * Factory method for this solver's thread-pool executor.
	 */
	protected CountingThreadPoolExecutor getExecutor() {
		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
	}
	
	/**
	 * Returns a String used to identify the output of this solver in debug mode.
	 * Subclasses can overwrite this string to distinguish the output from different solvers.
	 */
	protected String getDebugName() {
		return "FAST IFDS SOLVER";
	}

	public void printStats() {
		if(logger.isDebugEnabled()) {
			if(ffCache!=null)
				ffCache.printStats();
		} else {
			logger.info("No statistics were collected, as DEBUG is disabled.");
		}
	}
	
	private class PathEdgeProcessingTask implements Runnable {
		private final PathEdge<N,D> edge;

		public PathEdgeProcessingTask(PathEdge<N,D> edge) {
			this.edge = edge;
		}

		public void run() {
			if(icfg.isCallStmt(edge.getTarget())) {
				processCall(edge);
			} else {
				//note that some statements, such as "throw" may be
				//both an exit statement and a "normal" statement
				if(icfg.isExitStmt(edge.getTarget())) {
					processExit(edge);
				}
				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {
					processNormalFlow(edge);
				}
			}
		}
	}
	










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1225




1226




1227




1228




1229




1230




1231




1232




1233




1234




1235




1236




1237




1238




1239




1240




1241




1242




1243




1244




1245




1246




1247




1248




1249




1250




1251




1252




1253




1254




1255




1256




1257




1258




1259




1260




1261




1262




1263




1264




1265




1266




1267




	public void writeDebugFile() {
		try {
			FileWriter writer = new FileWriter("debug-solver-dump.json");
			writer.write("var methods= {\n\t");
			Enumeration<M> summaryEnumerable = endSummary.keys();
			
			while(summaryEnumerable.hasMoreElements()) {
				M m = summaryEnumerable.nextElement();
				writer.write("\""+m.toString()+"\"");
				writer.write(": { \n\t\tsummaries: [\n");
				for(SummaryEdge<D,N> summary : endSummary.get(m)) {
					writer.write("\t\t\t{ \n\t\t\t\tsource: ");
					writeFact(writer, summary.getSourceFact());
					writer.write(",\n\t\t\t\ttarget: ");
					writeFact(writer, summary.getTargetFact());
					writer.write("\n\t\t\t},");
				}
				writer.write("\n\t\t],");
				writer.write("\n\t\tincoming: [\n");
				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);
				if(incEdges!=null)
					for(IncomingEdge<D,N> incEdge : incEdges) {
						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");
						writeFact(writer, incEdge.getCalleeSourceFact());
						writer.write(",\n\t\t\t\tcalling_method: ");
						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");
						writer.write("\n\t\t\t},");
					}
				
				writer.write("\n\t\t]");
				writer.write("\n\t},\n");
			}
			
			writer.write("}");
			writer.flush();
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeFact(FileWriter writer, D sourceFact) throws IOException {
		writer.write("{");









remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015






1268




//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1269




1270




1271




1272




1273




1274




1275




		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");
		writer.write("accPath: [");
		for(String s :sourceFact.getAccessPath().tokenize()) {
			writer.write("\""+s+"\",");
		}
		writer.write("]}");
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1276




}





For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next











H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c

















55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1001




1002




1003




	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})
	 */









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1004




	protected void propagate(PathEdge<N,D> edge,









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1005




1006




			/* deliberately exposed to clients */ N relatedCallSite,
			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1007




		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1008




		final D existingVal = jumpFn.addFunction(edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1009




		









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1010




1011




1012




1013




1014




1015




1016




1017




		
		if(!edge.factAtTarget().getAccessPath().hasResolver()) {
			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {
				throw new AssertionError();
			}
		}
		
		if(edge instanceof CallConcretizationPathEdge) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1018




			concretizationEdges++;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1019




			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1020




1021




1022




1023




1024




1025




1026




			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 
					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());
			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))
				return;
			
			resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());
			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1027




1028




		} else if(edge instanceof ReturnConcretizationPathEdge) {
			((ReturnConcretizationPathEdge<N,D>) edge).propagate();









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1029




		} else {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1030




1031




1032




1033




//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {
//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",
//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1034




1035




			
			









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1036




			if (existingVal != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1037




				cacheEquals++;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1038




1039




1040




1041




				if (existingVal != edge.factAtTarget())
					existingVal.addNeighbor(edge.factAtTarget());
			}
			else {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1042




1043




1044




1045




1046




1047




1048




1049




				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());
				
				if(sourceBaseValueCache.containsKey(sourceValueKey)) {
					cacheSourceBaseValue++;
				}
				sourceBaseValueCache.put(sourceValueKey, edge);
				
				









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1050




1051




				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());
				if(cache.containsKey(key)) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1052




1053




1054




1055




1056




//					if(cacheHits % 10_000 == 0) {
//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));
//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));
//						System.out.println(edge);
//						System.out.println(icfg.getMethodOf(edge.getTarget()));









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1057




//						System.out.println("---");









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1058




1059




1060




//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {
//							System.out.println(cachedEdge);
//						}









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1061




//						System.out.println("---");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1062




//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1063




					cacheHits++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1064




1065




1066




1067




1068




1069




1070




1071




1072




					boolean opposite = false;
					for(PathEdge<N,D> cachedEdge : cache.get(key)) {
						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {
							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());
							cacheMerges++;
							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);
							return;
						}
//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1073




//							opposite=true;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1074




1075





					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1076




1077




//					if(opposite)
//						cacheOppositePrefix++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1078




1079




1080




1081




//					else if(cache.get(key).size() > 500) {
//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");
//						System.out.println(edge.factAtTarget());
//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1082




1083




1084




				}	
				
				cache.put(key, edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1085




1086




1087




1088




				scheduleEdgeProcessing(edge);
				if(edge.factAtTarget()!=zeroValue)
					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);
			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1089




1090




		}
	}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1091




1092




1093




	
	private static class CacheKey<N, D, BaseValue> {










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1094




		private Object[] values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1095














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1096




1097




		public CacheKey(Object...values) {
			this.values = values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1098




1099




1100




1101




1102




1103




		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1104




			result = prime * result + Arrays.hashCode(values);









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1105




1106




1107




1108




1109




1110




1111




1112




1113




1114




1115




1116




			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof CacheKey))
				return false;
			CacheKey other = (CacheKey) obj;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1117




			if (!Arrays.equals(values, other.values))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1118




1119




1120




1121




1122




				return false;
			return true;
		}
		
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1123














use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1124




1125




1126




1127




1128




1129




1130




1131




	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {
		Set<SummaryEdge<D, N>> map = endSummary.get(m);
		if(map == null)
			return null;
		
		return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {
			@Override
			public boolean apply(SummaryEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1132




				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1133




1134




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1135




1136




	}










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1137




1138




1139




1140




	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {
		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet
				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());
		return summaries.add(summaryEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1141




1142




	}	










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1143




1144




	protected Set<IncomingEdge<D, N>> incoming(M m) {
		Set<IncomingEdge<D, N>> result = incoming.get(m);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1145




		if(result == null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1146




			return Collections.emptySet();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1147




1148




1149




1150




		else
			return result;
	}
	









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1151




1152




1153




1154




1155




	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {
		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1156




				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1157




1158




1159




1160




			}
		});
	}
	









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1161




	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1162




1163




1164




1165




		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1166




				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1167




1168




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1169




1170




	}
	









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1171




	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1172




		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1173




1174




		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());
		return set.add(incomingEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1175




1176




1177




1178




1179




1180




1181




1182




1183




1184




1185




1186




1187




1188




1189




1190




1191




1192




1193




1194




1195




1196




1197




1198




1199




1200




1201




1202




1203




1204




1205




1206




1207




1208




1209




1210




1211




1212




1213




1214




1215




1216




1217




1218




1219




1220




1221




1222




1223




1224




	}
	
	/**
	 * Factory method for this solver's thread-pool executor.
	 */
	protected CountingThreadPoolExecutor getExecutor() {
		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
	}
	
	/**
	 * Returns a String used to identify the output of this solver in debug mode.
	 * Subclasses can overwrite this string to distinguish the output from different solvers.
	 */
	protected String getDebugName() {
		return "FAST IFDS SOLVER";
	}

	public void printStats() {
		if(logger.isDebugEnabled()) {
			if(ffCache!=null)
				ffCache.printStats();
		} else {
			logger.info("No statistics were collected, as DEBUG is disabled.");
		}
	}
	
	private class PathEdgeProcessingTask implements Runnable {
		private final PathEdge<N,D> edge;

		public PathEdgeProcessingTask(PathEdge<N,D> edge) {
			this.edge = edge;
		}

		public void run() {
			if(icfg.isCallStmt(edge.getTarget())) {
				processCall(edge);
			} else {
				//note that some statements, such as "throw" may be
				//both an exit statement and a "normal" statement
				if(icfg.isExitStmt(edge.getTarget())) {
					processExit(edge);
				}
				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {
					processNormalFlow(edge);
				}
			}
		}
	}
	










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1225




1226




1227




1228




1229




1230




1231




1232




1233




1234




1235




1236




1237




1238




1239




1240




1241




1242




1243




1244




1245




1246




1247




1248




1249




1250




1251




1252




1253




1254




1255




1256




1257




1258




1259




1260




1261




1262




1263




1264




1265




1266




1267




	public void writeDebugFile() {
		try {
			FileWriter writer = new FileWriter("debug-solver-dump.json");
			writer.write("var methods= {\n\t");
			Enumeration<M> summaryEnumerable = endSummary.keys();
			
			while(summaryEnumerable.hasMoreElements()) {
				M m = summaryEnumerable.nextElement();
				writer.write("\""+m.toString()+"\"");
				writer.write(": { \n\t\tsummaries: [\n");
				for(SummaryEdge<D,N> summary : endSummary.get(m)) {
					writer.write("\t\t\t{ \n\t\t\t\tsource: ");
					writeFact(writer, summary.getSourceFact());
					writer.write(",\n\t\t\t\ttarget: ");
					writeFact(writer, summary.getTargetFact());
					writer.write("\n\t\t\t},");
				}
				writer.write("\n\t\t],");
				writer.write("\n\t\tincoming: [\n");
				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);
				if(incEdges!=null)
					for(IncomingEdge<D,N> incEdge : incEdges) {
						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");
						writeFact(writer, incEdge.getCalleeSourceFact());
						writer.write(",\n\t\t\t\tcalling_method: ");
						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");
						writer.write("\n\t\t\t},");
					}
				
				writer.write("\n\t\t]");
				writer.write("\n\t},\n");
			}
			
			writer.write("}");
			writer.flush();
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeFact(FileWriter writer, D sourceFact) throws IOException {
		writer.write("{");









remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015






1268




//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1269




1270




1271




1272




1273




1274




1275




		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");
		writer.write("accPath: [");
		for(String s :sourceFact.getAccessPath().tokenize()) {
			writer.write("\""+s+"\",");
		}
		writer.write("]}");
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1276




}





For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next










Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c







Open sidebar



Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c




Open sidebar

Joshua Garcia heros

55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Joshua Garciaherosheros
55cdd2d88cc7d78204a4508a1dd46234cb52b74c










55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1001




1002




1003




	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})
	 */









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1004




	protected void propagate(PathEdge<N,D> edge,









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1005




1006




			/* deliberately exposed to clients */ N relatedCallSite,
			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1007




		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1008




		final D existingVal = jumpFn.addFunction(edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1009




		









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1010




1011




1012




1013




1014




1015




1016




1017




		
		if(!edge.factAtTarget().getAccessPath().hasResolver()) {
			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {
				throw new AssertionError();
			}
		}
		
		if(edge instanceof CallConcretizationPathEdge) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1018




			concretizationEdges++;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1019




			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1020




1021




1022




1023




1024




1025




1026




			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 
					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());
			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))
				return;
			
			resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());
			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1027




1028




		} else if(edge instanceof ReturnConcretizationPathEdge) {
			((ReturnConcretizationPathEdge<N,D>) edge).propagate();









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1029




		} else {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1030




1031




1032




1033




//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {
//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",
//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1034




1035




			
			









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1036




			if (existingVal != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1037




				cacheEquals++;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1038




1039




1040




1041




				if (existingVal != edge.factAtTarget())
					existingVal.addNeighbor(edge.factAtTarget());
			}
			else {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1042




1043




1044




1045




1046




1047




1048




1049




				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());
				
				if(sourceBaseValueCache.containsKey(sourceValueKey)) {
					cacheSourceBaseValue++;
				}
				sourceBaseValueCache.put(sourceValueKey, edge);
				
				









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1050




1051




				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());
				if(cache.containsKey(key)) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1052




1053




1054




1055




1056




//					if(cacheHits % 10_000 == 0) {
//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));
//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));
//						System.out.println(edge);
//						System.out.println(icfg.getMethodOf(edge.getTarget()));









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1057




//						System.out.println("---");









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1058




1059




1060




//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {
//							System.out.println(cachedEdge);
//						}









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1061




//						System.out.println("---");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1062




//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1063




					cacheHits++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1064




1065




1066




1067




1068




1069




1070




1071




1072




					boolean opposite = false;
					for(PathEdge<N,D> cachedEdge : cache.get(key)) {
						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {
							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());
							cacheMerges++;
							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);
							return;
						}
//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1073




//							opposite=true;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1074




1075





					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1076




1077




//					if(opposite)
//						cacheOppositePrefix++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1078




1079




1080




1081




//					else if(cache.get(key).size() > 500) {
//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");
//						System.out.println(edge.factAtTarget());
//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1082




1083




1084




				}	
				
				cache.put(key, edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1085




1086




1087




1088




				scheduleEdgeProcessing(edge);
				if(edge.factAtTarget()!=zeroValue)
					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);
			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1089




1090




		}
	}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1091




1092




1093




	
	private static class CacheKey<N, D, BaseValue> {










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1094




		private Object[] values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1095














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1096




1097




		public CacheKey(Object...values) {
			this.values = values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1098




1099




1100




1101




1102




1103




		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1104




			result = prime * result + Arrays.hashCode(values);









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1105




1106




1107




1108




1109




1110




1111




1112




1113




1114




1115




1116




			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof CacheKey))
				return false;
			CacheKey other = (CacheKey) obj;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1117




			if (!Arrays.equals(values, other.values))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1118




1119




1120




1121




1122




				return false;
			return true;
		}
		
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1123














use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1124




1125




1126




1127




1128




1129




1130




1131




	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {
		Set<SummaryEdge<D, N>> map = endSummary.get(m);
		if(map == null)
			return null;
		
		return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {
			@Override
			public boolean apply(SummaryEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1132




				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1133




1134




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1135




1136




	}










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1137




1138




1139




1140




	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {
		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet
				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());
		return summaries.add(summaryEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1141




1142




	}	










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1143




1144




	protected Set<IncomingEdge<D, N>> incoming(M m) {
		Set<IncomingEdge<D, N>> result = incoming.get(m);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1145




		if(result == null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1146




			return Collections.emptySet();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1147




1148




1149




1150




		else
			return result;
	}
	









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1151




1152




1153




1154




1155




	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {
		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1156




				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1157




1158




1159




1160




			}
		});
	}
	









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1161




	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1162




1163




1164




1165




		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1166




				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1167




1168




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1169




1170




	}
	









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1171




	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1172




		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1173




1174




		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());
		return set.add(incomingEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1175




1176




1177




1178




1179




1180




1181




1182




1183




1184




1185




1186




1187




1188




1189




1190




1191




1192




1193




1194




1195




1196




1197




1198




1199




1200




1201




1202




1203




1204




1205




1206




1207




1208




1209




1210




1211




1212




1213




1214




1215




1216




1217




1218




1219




1220




1221




1222




1223




1224




	}
	
	/**
	 * Factory method for this solver's thread-pool executor.
	 */
	protected CountingThreadPoolExecutor getExecutor() {
		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
	}
	
	/**
	 * Returns a String used to identify the output of this solver in debug mode.
	 * Subclasses can overwrite this string to distinguish the output from different solvers.
	 */
	protected String getDebugName() {
		return "FAST IFDS SOLVER";
	}

	public void printStats() {
		if(logger.isDebugEnabled()) {
			if(ffCache!=null)
				ffCache.printStats();
		} else {
			logger.info("No statistics were collected, as DEBUG is disabled.");
		}
	}
	
	private class PathEdgeProcessingTask implements Runnable {
		private final PathEdge<N,D> edge;

		public PathEdgeProcessingTask(PathEdge<N,D> edge) {
			this.edge = edge;
		}

		public void run() {
			if(icfg.isCallStmt(edge.getTarget())) {
				processCall(edge);
			} else {
				//note that some statements, such as "throw" may be
				//both an exit statement and a "normal" statement
				if(icfg.isExitStmt(edge.getTarget())) {
					processExit(edge);
				}
				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {
					processNormalFlow(edge);
				}
			}
		}
	}
	










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1225




1226




1227




1228




1229




1230




1231




1232




1233




1234




1235




1236




1237




1238




1239




1240




1241




1242




1243




1244




1245




1246




1247




1248




1249




1250




1251




1252




1253




1254




1255




1256




1257




1258




1259




1260




1261




1262




1263




1264




1265




1266




1267




	public void writeDebugFile() {
		try {
			FileWriter writer = new FileWriter("debug-solver-dump.json");
			writer.write("var methods= {\n\t");
			Enumeration<M> summaryEnumerable = endSummary.keys();
			
			while(summaryEnumerable.hasMoreElements()) {
				M m = summaryEnumerable.nextElement();
				writer.write("\""+m.toString()+"\"");
				writer.write(": { \n\t\tsummaries: [\n");
				for(SummaryEdge<D,N> summary : endSummary.get(m)) {
					writer.write("\t\t\t{ \n\t\t\t\tsource: ");
					writeFact(writer, summary.getSourceFact());
					writer.write(",\n\t\t\t\ttarget: ");
					writeFact(writer, summary.getTargetFact());
					writer.write("\n\t\t\t},");
				}
				writer.write("\n\t\t],");
				writer.write("\n\t\tincoming: [\n");
				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);
				if(incEdges!=null)
					for(IncomingEdge<D,N> incEdge : incEdges) {
						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");
						writeFact(writer, incEdge.getCalleeSourceFact());
						writer.write(",\n\t\t\t\tcalling_method: ");
						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");
						writer.write("\n\t\t\t},");
					}
				
				writer.write("\n\t\t]");
				writer.write("\n\t},\n");
			}
			
			writer.write("}");
			writer.flush();
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeFact(FileWriter writer, D sourceFact) throws IOException {
		writer.write("{");









remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015






1268




//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1269




1270




1271




1272




1273




1274




1275




		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");
		writer.write("accPath: [");
		for(String s :sourceFact.getAccessPath().tokenize()) {
			writer.write("\""+s+"\",");
		}
		writer.write("]}");
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1276




}





For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next













55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink






FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1001




1002




1003




	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})
	 */









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1004




	protected void propagate(PathEdge<N,D> edge,









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1005




1006




			/* deliberately exposed to clients */ N relatedCallSite,
			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1007




		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1008




		final D existingVal = jumpFn.addFunction(edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1009




		









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1010




1011




1012




1013




1014




1015




1016




1017




		
		if(!edge.factAtTarget().getAccessPath().hasResolver()) {
			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {
				throw new AssertionError();
			}
		}
		
		if(edge instanceof CallConcretizationPathEdge) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1018




			concretizationEdges++;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1019




			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1020




1021




1022




1023




1024




1025




1026




			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 
					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());
			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))
				return;
			
			resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());
			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1027




1028




		} else if(edge instanceof ReturnConcretizationPathEdge) {
			((ReturnConcretizationPathEdge<N,D>) edge).propagate();









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1029




		} else {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1030




1031




1032




1033




//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {
//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",
//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1034




1035




			
			









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1036




			if (existingVal != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1037




				cacheEquals++;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1038




1039




1040




1041




				if (existingVal != edge.factAtTarget())
					existingVal.addNeighbor(edge.factAtTarget());
			}
			else {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1042




1043




1044




1045




1046




1047




1048




1049




				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());
				
				if(sourceBaseValueCache.containsKey(sourceValueKey)) {
					cacheSourceBaseValue++;
				}
				sourceBaseValueCache.put(sourceValueKey, edge);
				
				









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1050




1051




				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());
				if(cache.containsKey(key)) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1052




1053




1054




1055




1056




//					if(cacheHits % 10_000 == 0) {
//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));
//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));
//						System.out.println(edge);
//						System.out.println(icfg.getMethodOf(edge.getTarget()));









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1057




//						System.out.println("---");









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1058




1059




1060




//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {
//							System.out.println(cachedEdge);
//						}









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1061




//						System.out.println("---");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1062




//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1063




					cacheHits++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1064




1065




1066




1067




1068




1069




1070




1071




1072




					boolean opposite = false;
					for(PathEdge<N,D> cachedEdge : cache.get(key)) {
						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {
							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());
							cacheMerges++;
							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);
							return;
						}
//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1073




//							opposite=true;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1074




1075





					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1076




1077




//					if(opposite)
//						cacheOppositePrefix++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1078




1079




1080




1081




//					else if(cache.get(key).size() > 500) {
//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");
//						System.out.println(edge.factAtTarget());
//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1082




1083




1084




				}	
				
				cache.put(key, edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1085




1086




1087




1088




				scheduleEdgeProcessing(edge);
				if(edge.factAtTarget()!=zeroValue)
					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);
			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1089




1090




		}
	}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1091




1092




1093




	
	private static class CacheKey<N, D, BaseValue> {










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1094




		private Object[] values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1095














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1096




1097




		public CacheKey(Object...values) {
			this.values = values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1098




1099




1100




1101




1102




1103




		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1104




			result = prime * result + Arrays.hashCode(values);









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1105




1106




1107




1108




1109




1110




1111




1112




1113




1114




1115




1116




			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof CacheKey))
				return false;
			CacheKey other = (CacheKey) obj;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1117




			if (!Arrays.equals(values, other.values))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1118




1119




1120




1121




1122




				return false;
			return true;
		}
		
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1123














use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1124




1125




1126




1127




1128




1129




1130




1131




	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {
		Set<SummaryEdge<D, N>> map = endSummary.get(m);
		if(map == null)
			return null;
		
		return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {
			@Override
			public boolean apply(SummaryEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1132




				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1133




1134




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1135




1136




	}










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1137




1138




1139




1140




	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {
		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet
				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());
		return summaries.add(summaryEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1141




1142




	}	










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1143




1144




	protected Set<IncomingEdge<D, N>> incoming(M m) {
		Set<IncomingEdge<D, N>> result = incoming.get(m);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1145




		if(result == null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1146




			return Collections.emptySet();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1147




1148




1149




1150




		else
			return result;
	}
	









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1151




1152




1153




1154




1155




	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {
		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1156




				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1157




1158




1159




1160




			}
		});
	}
	









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1161




	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1162




1163




1164




1165




		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1166




				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1167




1168




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1169




1170




	}
	









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1171




	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1172




		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1173




1174




		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());
		return set.add(incomingEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1175




1176




1177




1178




1179




1180




1181




1182




1183




1184




1185




1186




1187




1188




1189




1190




1191




1192




1193




1194




1195




1196




1197




1198




1199




1200




1201




1202




1203




1204




1205




1206




1207




1208




1209




1210




1211




1212




1213




1214




1215




1216




1217




1218




1219




1220




1221




1222




1223




1224




	}
	
	/**
	 * Factory method for this solver's thread-pool executor.
	 */
	protected CountingThreadPoolExecutor getExecutor() {
		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
	}
	
	/**
	 * Returns a String used to identify the output of this solver in debug mode.
	 * Subclasses can overwrite this string to distinguish the output from different solvers.
	 */
	protected String getDebugName() {
		return "FAST IFDS SOLVER";
	}

	public void printStats() {
		if(logger.isDebugEnabled()) {
			if(ffCache!=null)
				ffCache.printStats();
		} else {
			logger.info("No statistics were collected, as DEBUG is disabled.");
		}
	}
	
	private class PathEdgeProcessingTask implements Runnable {
		private final PathEdge<N,D> edge;

		public PathEdgeProcessingTask(PathEdge<N,D> edge) {
			this.edge = edge;
		}

		public void run() {
			if(icfg.isCallStmt(edge.getTarget())) {
				processCall(edge);
			} else {
				//note that some statements, such as "throw" may be
				//both an exit statement and a "normal" statement
				if(icfg.isExitStmt(edge.getTarget())) {
					processExit(edge);
				}
				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {
					processNormalFlow(edge);
				}
			}
		}
	}
	










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1225




1226




1227




1228




1229




1230




1231




1232




1233




1234




1235




1236




1237




1238




1239




1240




1241




1242




1243




1244




1245




1246




1247




1248




1249




1250




1251




1252




1253




1254




1255




1256




1257




1258




1259




1260




1261




1262




1263




1264




1265




1266




1267




	public void writeDebugFile() {
		try {
			FileWriter writer = new FileWriter("debug-solver-dump.json");
			writer.write("var methods= {\n\t");
			Enumeration<M> summaryEnumerable = endSummary.keys();
			
			while(summaryEnumerable.hasMoreElements()) {
				M m = summaryEnumerable.nextElement();
				writer.write("\""+m.toString()+"\"");
				writer.write(": { \n\t\tsummaries: [\n");
				for(SummaryEdge<D,N> summary : endSummary.get(m)) {
					writer.write("\t\t\t{ \n\t\t\t\tsource: ");
					writeFact(writer, summary.getSourceFact());
					writer.write(",\n\t\t\t\ttarget: ");
					writeFact(writer, summary.getTargetFact());
					writer.write("\n\t\t\t},");
				}
				writer.write("\n\t\t],");
				writer.write("\n\t\tincoming: [\n");
				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);
				if(incEdges!=null)
					for(IncomingEdge<D,N> incEdge : incEdges) {
						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");
						writeFact(writer, incEdge.getCalleeSourceFact());
						writer.write(",\n\t\t\t\tcalling_method: ");
						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");
						writer.write("\n\t\t\t},");
					}
				
				writer.write("\n\t\t]");
				writer.write("\n\t},\n");
			}
			
			writer.write("}");
			writer.flush();
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeFact(FileWriter writer, D sourceFact) throws IOException {
		writer.write("{");









remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015






1268




//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1269




1270




1271




1272




1273




1274




1275




		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");
		writer.write("accPath: [");
		for(String s :sourceFact.getAccessPath().tokenize()) {
			writer.write("\""+s+"\",");
		}
		writer.write("]}");
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1276




}





For faster browsing, not all history is shown.

View entire blame








Prev


1


2


Next









55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java



Find file
Normal viewHistoryPermalink




55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag










heros


src


heros


alias


FieldSensitiveIFDSSolver.java





55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag








55cdd2d88cc7d78204a4508a1dd46234cb52b74c


Switch branch/tag





55cdd2d88cc7d78204a4508a1dd46234cb52b74c

Switch branch/tag





Switch branch/tag



Switch branch/tagSwitch branch/tag
heros

src

heros

alias

FieldSensitiveIFDSSolver.java
Find file
Normal viewHistoryPermalink




FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1001




1002




1003




	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})
	 */









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1004




	protected void propagate(PathEdge<N,D> edge,









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1005




1006




			/* deliberately exposed to clients */ N relatedCallSite,
			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1007




		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1008




		final D existingVal = jumpFn.addFunction(edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1009




		









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1010




1011




1012




1013




1014




1015




1016




1017




		
		if(!edge.factAtTarget().getAccessPath().hasResolver()) {
			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {
				throw new AssertionError();
			}
		}
		
		if(edge instanceof CallConcretizationPathEdge) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1018




			concretizationEdges++;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1019




			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1020




1021




1022




1023




1024




1025




1026




			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 
					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());
			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))
				return;
			
			resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());
			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1027




1028




		} else if(edge instanceof ReturnConcretizationPathEdge) {
			((ReturnConcretizationPathEdge<N,D>) edge).propagate();









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1029




		} else {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1030




1031




1032




1033




//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {
//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",
//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1034




1035




			
			









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1036




			if (existingVal != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1037




				cacheEquals++;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1038




1039




1040




1041




				if (existingVal != edge.factAtTarget())
					existingVal.addNeighbor(edge.factAtTarget());
			}
			else {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1042




1043




1044




1045




1046




1047




1048




1049




				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());
				
				if(sourceBaseValueCache.containsKey(sourceValueKey)) {
					cacheSourceBaseValue++;
				}
				sourceBaseValueCache.put(sourceValueKey, edge);
				
				









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1050




1051




				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());
				if(cache.containsKey(key)) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1052




1053




1054




1055




1056




//					if(cacheHits % 10_000 == 0) {
//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));
//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));
//						System.out.println(edge);
//						System.out.println(icfg.getMethodOf(edge.getTarget()));









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1057




//						System.out.println("---");









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1058




1059




1060




//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {
//							System.out.println(cachedEdge);
//						}









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1061




//						System.out.println("---");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1062




//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1063




					cacheHits++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1064




1065




1066




1067




1068




1069




1070




1071




1072




					boolean opposite = false;
					for(PathEdge<N,D> cachedEdge : cache.get(key)) {
						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {
							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());
							cacheMerges++;
							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);
							return;
						}
//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1073




//							opposite=true;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1074




1075





					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1076




1077




//					if(opposite)
//						cacheOppositePrefix++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1078




1079




1080




1081




//					else if(cache.get(key).size() > 500) {
//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");
//						System.out.println(edge.factAtTarget());
//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1082




1083




1084




				}	
				
				cache.put(key, edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1085




1086




1087




1088




				scheduleEdgeProcessing(edge);
				if(edge.factAtTarget()!=zeroValue)
					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);
			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1089




1090




		}
	}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1091




1092




1093




	
	private static class CacheKey<N, D, BaseValue> {










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1094




		private Object[] values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1095














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1096




1097




		public CacheKey(Object...values) {
			this.values = values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1098




1099




1100




1101




1102




1103




		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1104




			result = prime * result + Arrays.hashCode(values);









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1105




1106




1107




1108




1109




1110




1111




1112




1113




1114




1115




1116




			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof CacheKey))
				return false;
			CacheKey other = (CacheKey) obj;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1117




			if (!Arrays.equals(values, other.values))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1118




1119




1120




1121




1122




				return false;
			return true;
		}
		
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1123














use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1124




1125




1126




1127




1128




1129




1130




1131




	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {
		Set<SummaryEdge<D, N>> map = endSummary.get(m);
		if(map == null)
			return null;
		
		return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {
			@Override
			public boolean apply(SummaryEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1132




				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1133




1134




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1135




1136




	}










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1137




1138




1139




1140




	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {
		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet
				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());
		return summaries.add(summaryEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1141




1142




	}	










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1143




1144




	protected Set<IncomingEdge<D, N>> incoming(M m) {
		Set<IncomingEdge<D, N>> result = incoming.get(m);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1145




		if(result == null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1146




			return Collections.emptySet();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1147




1148




1149




1150




		else
			return result;
	}
	









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1151




1152




1153




1154




1155




	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {
		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1156




				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1157




1158




1159




1160




			}
		});
	}
	









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1161




	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1162




1163




1164




1165




		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1166




				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1167




1168




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1169




1170




	}
	









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1171




	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1172




		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1173




1174




		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());
		return set.add(incomingEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1175




1176




1177




1178




1179




1180




1181




1182




1183




1184




1185




1186




1187




1188




1189




1190




1191




1192




1193




1194




1195




1196




1197




1198




1199




1200




1201




1202




1203




1204




1205




1206




1207




1208




1209




1210




1211




1212




1213




1214




1215




1216




1217




1218




1219




1220




1221




1222




1223




1224




	}
	
	/**
	 * Factory method for this solver's thread-pool executor.
	 */
	protected CountingThreadPoolExecutor getExecutor() {
		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
	}
	
	/**
	 * Returns a String used to identify the output of this solver in debug mode.
	 * Subclasses can overwrite this string to distinguish the output from different solvers.
	 */
	protected String getDebugName() {
		return "FAST IFDS SOLVER";
	}

	public void printStats() {
		if(logger.isDebugEnabled()) {
			if(ffCache!=null)
				ffCache.printStats();
		} else {
			logger.info("No statistics were collected, as DEBUG is disabled.");
		}
	}
	
	private class PathEdgeProcessingTask implements Runnable {
		private final PathEdge<N,D> edge;

		public PathEdgeProcessingTask(PathEdge<N,D> edge) {
			this.edge = edge;
		}

		public void run() {
			if(icfg.isCallStmt(edge.getTarget())) {
				processCall(edge);
			} else {
				//note that some statements, such as "throw" may be
				//both an exit statement and a "normal" statement
				if(icfg.isExitStmt(edge.getTarget())) {
					processExit(edge);
				}
				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {
					processNormalFlow(edge);
				}
			}
		}
	}
	










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1225




1226




1227




1228




1229




1230




1231




1232




1233




1234




1235




1236




1237




1238




1239




1240




1241




1242




1243




1244




1245




1246




1247




1248




1249




1250




1251




1252




1253




1254




1255




1256




1257




1258




1259




1260




1261




1262




1263




1264




1265




1266




1267




	public void writeDebugFile() {
		try {
			FileWriter writer = new FileWriter("debug-solver-dump.json");
			writer.write("var methods= {\n\t");
			Enumeration<M> summaryEnumerable = endSummary.keys();
			
			while(summaryEnumerable.hasMoreElements()) {
				M m = summaryEnumerable.nextElement();
				writer.write("\""+m.toString()+"\"");
				writer.write(": { \n\t\tsummaries: [\n");
				for(SummaryEdge<D,N> summary : endSummary.get(m)) {
					writer.write("\t\t\t{ \n\t\t\t\tsource: ");
					writeFact(writer, summary.getSourceFact());
					writer.write(",\n\t\t\t\ttarget: ");
					writeFact(writer, summary.getTargetFact());
					writer.write("\n\t\t\t},");
				}
				writer.write("\n\t\t],");
				writer.write("\n\t\tincoming: [\n");
				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);
				if(incEdges!=null)
					for(IncomingEdge<D,N> incEdge : incEdges) {
						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");
						writeFact(writer, incEdge.getCalleeSourceFact());
						writer.write(",\n\t\t\t\tcalling_method: ");
						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");
						writer.write("\n\t\t\t},");
					}
				
				writer.write("\n\t\t]");
				writer.write("\n\t},\n");
			}
			
			writer.write("}");
			writer.flush();
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeFact(FileWriter writer, D sourceFact) throws IOException {
		writer.write("{");









remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015






1268




//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1269




1270




1271




1272




1273




1274




1275




		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");
		writer.write("accPath: [");
		for(String s :sourceFact.getAccessPath().tokenize()) {
			writer.write("\""+s+"\",");
		}
		writer.write("]}");
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1276




}





For faster browsing, not all history is shown.

View entire blame







FieldSensitiveIFDSSolver.java



50.9 KB










FieldSensitiveIFDSSolver.java



50.9 KB









Newer










Older
NewerOlder







FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1001




1002




1003




	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return
	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})
	 */









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1004




	protected void propagate(PathEdge<N,D> edge,









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1005




1006




			/* deliberately exposed to clients */ N relatedCallSite,
			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1007




		









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1008




		final D existingVal = jumpFn.addFunction(edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1009




		









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1010




1011




1012




1013




1014




1015




1016




1017




		
		if(!edge.factAtTarget().getAccessPath().hasResolver()) {
			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {
				throw new AssertionError();
			}
		}
		
		if(edge instanceof CallConcretizationPathEdge) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1018




			concretizationEdges++;









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1019




			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1020




1021




1022




1023




1024




1025




1026




			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 
					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());
			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))
				return;
			
			resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());
			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1027




1028




		} else if(edge instanceof ReturnConcretizationPathEdge) {
			((ReturnConcretizationPathEdge<N,D>) edge).propagate();









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1029




		} else {









abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015






1030




1031




1032




1033




//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {
//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",
//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));
//			}









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1034




1035




			
			









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1036




			if (existingVal != null) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1037




				cacheEquals++;









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1038




1039




1040




1041




				if (existingVal != edge.factAtTarget())
					existingVal.addNeighbor(edge.factAtTarget());
			}
			else {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1042




1043




1044




1045




1046




1047




1048




1049




				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());
				
				if(sourceBaseValueCache.containsKey(sourceValueKey)) {
					cacheSourceBaseValue++;
				}
				sourceBaseValueCache.put(sourceValueKey, edge);
				
				









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1050




1051




				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());
				if(cache.containsKey(key)) {









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1052




1053




1054




1055




1056




//					if(cacheHits % 10_000 == 0) {
//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));
//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));
//						System.out.println(edge);
//						System.out.println(icfg.getMethodOf(edge.getTarget()));









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1057




//						System.out.println("---");









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1058




1059




1060




//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {
//							System.out.println(cachedEdge);
//						}









merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015






1061




//						System.out.println("---");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1062




//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1063




					cacheHits++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1064




1065




1066




1067




1068




1069




1070




1071




1072




					boolean opposite = false;
					for(PathEdge<N,D> cachedEdge : cache.get(key)) {
						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {
							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());
							cacheMerges++;
							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);
							return;
						}
//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1073




//							opposite=true;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1074




1075





					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1076




1077




//					if(opposite)
//						cacheOppositePrefix++;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1078




1079




1080




1081




//					else if(cache.get(key).size() > 500) {
//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");
//						System.out.println(edge.factAtTarget());
//					}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1082




1083




1084




				}	
				
				cache.put(key, edge);









"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015






1085




1086




1087




1088




				scheduleEdgeProcessing(edge);
				if(edge.factAtTarget()!=zeroValue)
					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);
			}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1089




1090




		}
	}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1091




1092




1093




	
	private static class CacheKey<N, D, BaseValue> {










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1094




		private Object[] values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1095














subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1096




1097




		public CacheKey(Object...values) {
			this.values = values;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1098




1099




1100




1101




1102




1103




		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1104




			result = prime * result + Arrays.hashCode(values);









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1105




1106




1107




1108




1109




1110




1111




1112




1113




1114




1115




1116




			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof CacheKey))
				return false;
			CacheKey other = (CacheKey) obj;









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1117




			if (!Arrays.equals(values, other.values))









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






1118




1119




1120




1121




1122




				return false;
			return true;
		}
		
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1123














use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1124




1125




1126




1127




1128




1129




1130




1131




	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {
		Set<SummaryEdge<D, N>> map = endSummary.get(m);
		if(map == null)
			return null;
		
		return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {
			@Override
			public boolean apply(SummaryEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1132




				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1133




1134




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1135




1136




	}










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1137




1138




1139




1140




	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {
		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet
				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());
		return summaries.add(summaryEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1141




1142




	}	










use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1143




1144




	protected Set<IncomingEdge<D, N>> incoming(M m) {
		Set<IncomingEdge<D, N>> result = incoming.get(m);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1145




		if(result == null)









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1146




			return Collections.emptySet();









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1147




1148




1149




1150




		else
			return result;
	}
	









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1151




1152




1153




1154




1155




	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {
		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1156




				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1157




1158




1159




1160




			}
		});
	}
	









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1161




	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1162




1163




1164




1165




		Set<IncomingEdge<D, N>> result = incoming(m);
		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {
			@Override
			public boolean apply(IncomingEdge<D, N> edge) {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






1166




				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1167




1168




			}
		});









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1169




1170




	}
	









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1171




	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {









edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014






1172




		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);









use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014






1173




1174




		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());
		return set.add(incomingEdge);









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1175




1176




1177




1178




1179




1180




1181




1182




1183




1184




1185




1186




1187




1188




1189




1190




1191




1192




1193




1194




1195




1196




1197




1198




1199




1200




1201




1202




1203




1204




1205




1206




1207




1208




1209




1210




1211




1212




1213




1214




1215




1216




1217




1218




1219




1220




1221




1222




1223




1224




	}
	
	/**
	 * Factory method for this solver's thread-pool executor.
	 */
	protected CountingThreadPoolExecutor getExecutor() {
		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
	}
	
	/**
	 * Returns a String used to identify the output of this solver in debug mode.
	 * Subclasses can overwrite this string to distinguish the output from different solvers.
	 */
	protected String getDebugName() {
		return "FAST IFDS SOLVER";
	}

	public void printStats() {
		if(logger.isDebugEnabled()) {
			if(ffCache!=null)
				ffCache.printStats();
		} else {
			logger.info("No statistics were collected, as DEBUG is disabled.");
		}
	}
	
	private class PathEdgeProcessingTask implements Runnable {
		private final PathEdge<N,D> edge;

		public PathEdgeProcessingTask(PathEdge<N,D> edge) {
			this.edge = edge;
		}

		public void run() {
			if(icfg.isCallStmt(edge.getTarget())) {
				processCall(edge);
			} else {
				//note that some statements, such as "throw" may be
				//both an exit statement and a "normal" statement
				if(icfg.isExitStmt(edge.getTarget())) {
					processExit(edge);
				}
				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {
					processNormalFlow(edge);
				}
			}
		}
	}
	










subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1225




1226




1227




1228




1229




1230




1231




1232




1233




1234




1235




1236




1237




1238




1239




1240




1241




1242




1243




1244




1245




1246




1247




1248




1249




1250




1251




1252




1253




1254




1255




1256




1257




1258




1259




1260




1261




1262




1263




1264




1265




1266




1267




	public void writeDebugFile() {
		try {
			FileWriter writer = new FileWriter("debug-solver-dump.json");
			writer.write("var methods= {\n\t");
			Enumeration<M> summaryEnumerable = endSummary.keys();
			
			while(summaryEnumerable.hasMoreElements()) {
				M m = summaryEnumerable.nextElement();
				writer.write("\""+m.toString()+"\"");
				writer.write(": { \n\t\tsummaries: [\n");
				for(SummaryEdge<D,N> summary : endSummary.get(m)) {
					writer.write("\t\t\t{ \n\t\t\t\tsource: ");
					writeFact(writer, summary.getSourceFact());
					writer.write(",\n\t\t\t\ttarget: ");
					writeFact(writer, summary.getTargetFact());
					writer.write("\n\t\t\t},");
				}
				writer.write("\n\t\t],");
				writer.write("\n\t\tincoming: [\n");
				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);
				if(incEdges!=null)
					for(IncomingEdge<D,N> incEdge : incEdges) {
						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");
						writeFact(writer, incEdge.getCalleeSourceFact());
						writer.write(",\n\t\t\t\tcalling_method: ");
						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");
						writer.write("\n\t\t\t},");
					}
				
				writer.write("\n\t\t]");
				writer.write("\n\t},\n");
			}
			
			writer.write("}");
			writer.flush();
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeFact(FileWriter writer, D sourceFact) throws IOException {
		writer.write("{");









remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015






1268




//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");









subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015






1269




1270




1271




1272




1273




1274




1275




		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");
		writer.write("accPath: [");
		for(String s :sourceFact.getAccessPath().tokenize()) {
			writer.write("\""+s+"\",");
		}
		writer.write("]}");
	}









FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014






1276




}







FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1001

1002

1003
	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})	 */	 */



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1004
	protected void propagate(PathEdge<N,D> edge,protectedvoidpropagate(PathEdge<N,D>edge,



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1005

1006
			/* deliberately exposed to clients */ N relatedCallSite,/* deliberately exposed to clients */NrelatedCallSite,			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {/* deliberately exposed to clients */booleanisUnbalancedReturn){



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1007
		



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1008
		final D existingVal = jumpFn.addFunction(edge);finalDexistingVal=jumpFn.addFunction(edge);



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1009
		



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

1010

1011

1012

1013

1014

1015

1016

1017
				if(!edge.factAtTarget().getAccessPath().hasResolver()) {if(!edge.factAtTarget().getAccessPath().hasResolver()){			if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())){				throw new AssertionError();thrownewAssertionError();			}}		}}				if(edge instanceof CallConcretizationPathEdge) {if(edgeinstanceofCallConcretizationPathEdge){



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1018
			concretizationEdges++;concretizationEdges++;



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

1019
			CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;CallConcretizationPathEdge<M,N,D>concEdge=(CallConcretizationPathEdge<M,N,D>)edge;



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1020

1021

1022

1023

1024

1025

1026
			IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), IncomingEdge<D,N>incomingEdge=newIncomingEdge<D,N>(concEdge.getCalleeSourceFact(),					concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());concEdge.getTarget(),concEdge.factAtSource(),concEdge.factAtTarget());			if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))if(!addIncoming(concEdge.getCalleeMethod(),incomingEdge))				return;return;						resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());resumeEdges(concEdge.getCalleeMethod(),concEdge.getCalleeSourceFact());			registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);registerInterestedCaller(concEdge.getCalleeMethod(),incomingEdge);



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

1027

1028
		} else if(edge instanceof ReturnConcretizationPathEdge) {}elseif(edgeinstanceofReturnConcretizationPathEdge){			((ReturnConcretizationPathEdge<N,D>) edge).propagate();((ReturnConcretizationPathEdge<N,D>)edge).propagate();



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1029
		} else {}else{



abstract at return edges


 

 


Johannes Lerch
committed
Feb 23, 2015



abstract at return edges


 

 

abstract at return edges

 

Johannes Lerch
committed
Feb 23, 2015

1030

1031

1032

1033
//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));//			}//			}



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1034

1035
						



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1036
			if (existingVal != null) {if(existingVal!=null){



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1037
				cacheEquals++;cacheEquals++;



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1038

1039

1040

1041
				if (existingVal != edge.factAtTarget())if(existingVal!=edge.factAtTarget())					existingVal.addNeighbor(edge.factAtTarget());existingVal.addNeighbor(edge.factAtTarget());			}}			else {else{



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1042

1043

1044

1045

1046

1047

1048

1049
				CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());CacheKey<N,D,BaseValue>sourceValueKey=newCacheKey<N,D,BaseValue>(edge.getTarget(),edge.factAtSource().getBaseValue(),edge.factAtTarget().getBaseValue());								if(sourceBaseValueCache.containsKey(sourceValueKey)) {if(sourceBaseValueCache.containsKey(sourceValueKey)){					cacheSourceBaseValue++;cacheSourceBaseValue++;				}}				sourceBaseValueCache.put(sourceValueKey, edge);sourceBaseValueCache.put(sourceValueKey,edge);								



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1050

1051
				CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());CacheKey<N,D,BaseValue>key=newCacheKey<N,D,BaseValue>(edge.getTarget(),edge.factAtSource(),edge.factAtTarget().getBaseValue());				if(cache.containsKey(key)) {if(cache.containsKey(key)){



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1052

1053

1054

1055

1056
//					if(cacheHits % 10_000 == 0) {//					if(cacheHits % 10_000 == 0) {//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));//						System.out.println(edge);//						System.out.println(edge);//						System.out.println(icfg.getMethodOf(edge.getTarget()));//						System.out.println(icfg.getMethodOf(edge.getTarget()));



merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015



merge only on equal field types


 

 

merge only on equal field types

 

Johannes Lerch
committed
Feb 05, 2015

1057
//						System.out.println("---");//						System.out.println("---");



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1058

1059

1060
//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//							System.out.println(cachedEdge);//							System.out.println(cachedEdge);//						}//						}



merge only on equal field types


 

 


Johannes Lerch
committed
Feb 05, 2015



merge only on equal field types


 

 

merge only on equal field types

 

Johannes Lerch
committed
Feb 05, 2015

1061
//						System.out.println("---");//						System.out.println("---");



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1062
//					}//					}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1063
					cacheHits++;cacheHits++;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1064

1065

1066

1067

1068

1069

1070

1071

1072
					boolean opposite = false;booleanopposite=false;					for(PathEdge<N,D> cachedEdge : cache.get(key)) {for(PathEdge<N,D>cachedEdge:cache.get(key)){						if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())){							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());							cacheMerges++;cacheMerges++;							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);logger.trace("MERGE: {} with previous edge {}",edge,cachedEdge);							return;return;						}}//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1073
//							opposite=true;//							opposite=true;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1074

1075
					}}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1076

1077
//					if(opposite)//					if(opposite)//						cacheOppositePrefix++;//						cacheOppositePrefix++;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1078

1079

1080

1081
//					else if(cache.get(key).size() > 500) {//					else if(cache.get(key).size() > 500) {//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");//						System.out.println(edge.factAtTarget());//						System.out.println(edge.factAtTarget());//					}//					}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1082

1083

1084
				}	}								cache.put(key, edge);cache.put(key,edge);



"interest/concrretization" edges in callers are no longer propagated as


 

 


Johannes Lerch
committed
Jan 07, 2015



"interest/concrretization" edges in callers are no longer propagated as


 

 

"interest/concrretization" edges in callers are no longer propagated as

 

Johannes Lerch
committed
Jan 07, 2015

1085

1086

1087

1088
				scheduleEdgeProcessing(edge);scheduleEdgeProcessing(edge);				if(edge.factAtTarget()!=zeroValue)if(edge.factAtTarget()!=zeroValue)					logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);logger.trace("EDGE: {}: {}",icfg.getMethodOf(edge.getTarget()),edge);			}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1089

1090
		}}	}}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1091

1092

1093
		private static class CacheKey<N, D, BaseValue> {privatestaticclassCacheKey<N,D,BaseValue>{



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1094
		private Object[] values;privateObject[]values;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1095




subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1096

1097
		public CacheKey(Object...values) {publicCacheKey(Object...values){			this.values = values;this.values=values;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1098

1099

1100

1101

1102

1103
		}}		@Override@Override		public int hashCode() {publicinthashCode(){			final int prime = 31;finalintprime=31;			int result = 1;intresult=1;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1104
			result = prime * result + Arrays.hashCode(values);result=prime*result+Arrays.hashCode(values);



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1105

1106

1107

1108

1109

1110

1111

1112

1113

1114

1115

1116
			return result;returnresult;		}}		@Override@Override		public boolean equals(Object obj) {publicbooleanequals(Objectobj){			if (this == obj)if(this==obj)				return true;returntrue;			if (obj == null)if(obj==null)				return false;returnfalse;			if (!(obj instanceof CacheKey))if(!(objinstanceofCacheKey))				return false;returnfalse;			CacheKey other = (CacheKey) obj;CacheKeyother=(CacheKey)obj;



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1117
			if (!Arrays.equals(values, other.values))if(!Arrays.equals(values,other.values))



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

1118

1119

1120

1121

1122
				return false;returnfalse;			return true;returntrue;		}}			}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1123




use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1124

1125

1126

1127

1128

1129

1130

1131
	private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {privateSet<SummaryEdge<D,N>>endSummary(Mm,finalDd3){		Set<SummaryEdge<D, N>> map = endSummary.get(m);Set<SummaryEdge<D,N>>map=endSummary.get(m);		if(map == null)if(map==null)			return null;returnnull;				return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {returnSets.filter(map,newPredicate<SummaryEdge<D,N>>(){			@Override@Override			public boolean apply(SummaryEdge<D, N> edge) {publicbooleanapply(SummaryEdge<D,N>edge){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

1132
				return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;returnAccessPathUtil.isPrefixOf(edge.getSourceFact(),d3)==PrefixTestResult.GUARANTEED_PREFIX;



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1133

1134
			}}		});});



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1135

1136
	}}



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1137

1138

1139

1140
	private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {privatebooleanaddEndSummary(Mm,SummaryEdge<D,N>summaryEdge){		Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGetSet<SummaryEdge<D,N>>summaries=endSummary.putIfAbsentElseGet				(m, new ConcurrentHashSet<SummaryEdge<D, N>>());(m,newConcurrentHashSet<SummaryEdge<D,N>>());		return summaries.add(summaryEdge);returnsummaries.add(summaryEdge);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1141

1142
	}	}



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1143

1144
	protected Set<IncomingEdge<D, N>> incoming(M m) {protectedSet<IncomingEdge<D,N>>incoming(Mm){		Set<IncomingEdge<D, N>> result = incoming.get(m);Set<IncomingEdge<D,N>>result=incoming.get(m);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1145
		if(result == null)if(result==null)



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1146
			return Collections.emptySet();returnCollections.emptySet();



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1147

1148

1149

1150
		elseelse			return result;returnresult;	}}	



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

1151

1152

1153

1154

1155
	protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {protectedSet<IncomingEdge<D,N>>incomingEdgesPrefixedWith(Mm,finalDfact){		Set<IncomingEdge<D, N>> result = incoming(m);Set<IncomingEdge<D,N>>result=incoming(m);		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {returnSets.filter(result,newPredicate<IncomingEdge<D,N>>(){			@Override@Override			public boolean apply(IncomingEdge<D, N> edge) {publicbooleanapply(IncomingEdge<D,N>edge){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

1156
				return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;returnAccessPathUtil.isPrefixOf(fact,edge.getCalleeSourceFact())==PrefixTestResult.GUARANTEED_PREFIX;



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

1157

1158

1159

1160
			}}		});});	}}	



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

1161
	protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {protectedSet<IncomingEdge<D,N>>incomingEdgesPotentialPrefixesOf(Mm,finalDfact){



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1162

1163

1164

1165
		Set<IncomingEdge<D, N>> result = incoming(m);Set<IncomingEdge<D,N>>result=incoming(m);		return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {returnSets.filter(result,newPredicate<IncomingEdge<D,N>>(){			@Override@Override			public boolean apply(IncomingEdge<D, N> edge) {publicbooleanapply(IncomingEdge<D,N>edge){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

1166
				return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);returnAccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(),fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1167

1168
			}}		});});



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1169

1170
	}}	



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1171
	protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {protectedbooleanaddIncoming(Mm,IncomingEdge<D,N>incomingEdge){



edges on hold + resume


 

 


Johannes Lerch
committed
Nov 25, 2014



edges on hold + resume


 

 

edges on hold + resume

 

Johannes Lerch
committed
Nov 25, 2014

1172
		logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);logger.trace("Incoming Edge for method {}: {}",m,incomingEdge);



use of abstracted summaries


 

 


Johannes Lerch
committed
Oct 22, 2014



use of abstracted summaries


 

 

use of abstracted summaries

 

Johannes Lerch
committed
Oct 22, 2014

1173

1174
		Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());Set<IncomingEdge<D,N>>set=incoming.putIfAbsentElseGet(m,newConcurrentHashSet<IncomingEdge<D,N>>());		return set.add(incomingEdge);returnset.add(incomingEdge);



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1175

1176

1177

1178

1179

1180

1181

1182

1183

1184

1185

1186

1187

1188

1189

1190

1191

1192

1193

1194

1195

1196

1197

1198

1199

1200

1201

1202

1203

1204

1205

1206

1207

1208

1209

1210

1211

1212

1213

1214

1215

1216

1217

1218

1219

1220

1221

1222

1223

1224
	}}		/**/**	 * Factory method for this solver's thread-pool executor.	 * Factory method for this solver's thread-pool executor.	 */	 */	protected CountingThreadPoolExecutor getExecutor() {protectedCountingThreadPoolExecutorgetExecutor(){		return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());returnnewCountingThreadPoolExecutor(1,this.numThreads,30,TimeUnit.SECONDS,newLinkedBlockingQueue<Runnable>());	}}		/**/**	 * Returns a String used to identify the output of this solver in debug mode.	 * Returns a String used to identify the output of this solver in debug mode.	 * Subclasses can overwrite this string to distinguish the output from different solvers.	 * Subclasses can overwrite this string to distinguish the output from different solvers.	 */	 */	protected String getDebugName() {protectedStringgetDebugName(){		return "FAST IFDS SOLVER";return"FAST IFDS SOLVER";	}}	public void printStats() {publicvoidprintStats(){		if(logger.isDebugEnabled()) {if(logger.isDebugEnabled()){			if(ffCache!=null)if(ffCache!=null)				ffCache.printStats();ffCache.printStats();		} else {}else{			logger.info("No statistics were collected, as DEBUG is disabled.");logger.info("No statistics were collected, as DEBUG is disabled.");		}}	}}		private class PathEdgeProcessingTask implements Runnable {privateclassPathEdgeProcessingTaskimplementsRunnable{		private final PathEdge<N,D> edge;privatefinalPathEdge<N,D>edge;		public PathEdgeProcessingTask(PathEdge<N,D> edge) {publicPathEdgeProcessingTask(PathEdge<N,D>edge){			this.edge = edge;this.edge=edge;		}}		public void run() {publicvoidrun(){			if(icfg.isCallStmt(edge.getTarget())) {if(icfg.isCallStmt(edge.getTarget())){				processCall(edge);processCall(edge);			} else {}else{				//note that some statements, such as "throw" may be//note that some statements, such as "throw" may be				//both an exit statement and a "normal" statement//both an exit statement and a "normal" statement				if(icfg.isExitStmt(edge.getTarget())) {if(icfg.isExitStmt(edge.getTarget())){					processExit(edge);processExit(edge);				}}				if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()){					processNormalFlow(edge);processNormalFlow(edge);				}}			}}		}}	}}	



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1225

1226

1227

1228

1229

1230

1231

1232

1233

1234

1235

1236

1237

1238

1239

1240

1241

1242

1243

1244

1245

1246

1247

1248

1249

1250

1251

1252

1253

1254

1255

1256

1257

1258

1259

1260

1261

1262

1263

1264

1265

1266

1267
	public void writeDebugFile() {publicvoidwriteDebugFile(){		try {try{			FileWriter writer = new FileWriter("debug-solver-dump.json");FileWriterwriter=newFileWriter("debug-solver-dump.json");			writer.write("var methods= {\n\t");writer.write("var methods= {\n\t");			Enumeration<M> summaryEnumerable = endSummary.keys();Enumeration<M>summaryEnumerable=endSummary.keys();						while(summaryEnumerable.hasMoreElements()) {while(summaryEnumerable.hasMoreElements()){				M m = summaryEnumerable.nextElement();Mm=summaryEnumerable.nextElement();				writer.write("\""+m.toString()+"\"");writer.write("\""+m.toString()+"\"");				writer.write(": { \n\t\tsummaries: [\n");writer.write(": { \n\t\tsummaries: [\n");				for(SummaryEdge<D,N> summary : endSummary.get(m)) {for(SummaryEdge<D,N>summary:endSummary.get(m)){					writer.write("\t\t\t{ \n\t\t\t\tsource: ");writer.write("\t\t\t{ \n\t\t\t\tsource: ");					writeFact(writer, summary.getSourceFact());writeFact(writer,summary.getSourceFact());					writer.write(",\n\t\t\t\ttarget: ");writer.write(",\n\t\t\t\ttarget: ");					writeFact(writer, summary.getTargetFact());writeFact(writer,summary.getTargetFact());					writer.write("\n\t\t\t},");writer.write("\n\t\t\t},");				}}				writer.write("\n\t\t],");writer.write("\n\t\t],");				writer.write("\n\t\tincoming: [\n");writer.write("\n\t\tincoming: [\n");				Set<IncomingEdge<D, N>> incEdges = incoming.get(m);Set<IncomingEdge<D,N>>incEdges=incoming.get(m);				if(incEdges!=null)if(incEdges!=null)					for(IncomingEdge<D,N> incEdge : incEdges) {for(IncomingEdge<D,N>incEdge:incEdges){						writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");						writeFact(writer, incEdge.getCalleeSourceFact());writeFact(writer,incEdge.getCalleeSourceFact());						writer.write(",\n\t\t\t\tcalling_method: ");writer.write(",\n\t\t\t\tcalling_method: ");						writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");						writer.write("\n\t\t\t},");writer.write("\n\t\t\t},");					}}								writer.write("\n\t\t]");writer.write("\n\t\t]");				writer.write("\n\t},\n");writer.write("\n\t},\n");			}}						writer.write("}");writer.write("}");			writer.flush();writer.flush();			writer.close();writer.close();		} catch (IOException e) {}catch(IOExceptione){			e.printStackTrace();e.printStackTrace();		}}	}}	private void writeFact(FileWriter writer, D sourceFact) throws IOException {privatevoidwriteFact(FileWriterwriter,DsourceFact)throwsIOException{		writer.write("{");writer.write("{");



remove ability to nest exclusions


 

 


Johannes Lerch
committed
Feb 13, 2015



remove ability to nest exclusions


 

 

remove ability to nest exclusions

 

Johannes Lerch
committed
Feb 13, 2015

1268
//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");



subumption + debugging


 

 


Johannes Lerch
committed
Feb 09, 2015



subumption + debugging


 

 

subumption + debugging

 

Johannes Lerch
committed
Feb 09, 2015

1269

1270

1271

1272

1273

1274

1275
		writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");		writer.write("accPath: [");writer.write("accPath: [");		for(String s :sourceFact.getAccessPath().tokenize()) {for(Strings:sourceFact.getAccessPath().tokenize()){			writer.write("\""+s+"\",");writer.write("\""+s+"\",");		}}		writer.write("]}");writer.write("]}");	}}



FieldSensitiveIFDSSolver - concept outline



 


Johannes Späth
committed
Oct 15, 2014



FieldSensitiveIFDSSolver - concept outline



 

FieldSensitiveIFDSSolver - concept outline


Johannes Späth
committed
Oct 15, 2014

1276
}}
For faster browsing, not all history is shown.

View entire blame



View entire blame





Prev


1


2


Next





Prev

1

2

Next







