



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

3398e46f















Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

3398e46f















Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

3398e46f







Open sidebar



Joshua Garcia heros
Commits

3398e46f




Open sidebar

Joshua Garcia heros
Commits

3398e46f


Joshua GarciaherosherosCommits
3398e46f








Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files



Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch

3398e46fauthoredbyJohannes Lerch

rewrite of ifds solver






parent
55cdd2d8
















parent
55cdd2d8





parent












Changes
45
45


Expand all
Hide whitespace changes

Inline
Side-by-side






Expand all
Hide whitespace changes

Inline
Side-by-side




Expand all
Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next













mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f





File added











mockito-all-1.9.5.jar



0 → 100644




View file @ 3398e46f








mockito-all-1.9.5.jar



0 → 100644






View file @ 3398e46f
3398e46f


File added




File added


File added









src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......












src/heros/InterproceduralCFG.java








View file @ 3398e46f








src/heros/InterproceduralCFG.java










View file @ 3398e46f


3398e46f



......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......


	 */	 */ public M getMethodOf(N n);publicMgetMethodOf(Nn); public List<N> getPredsOf(N u);publicList<N>getPredsOf(Nu);  /**/**	 * Returns the successor nodes.	 * Returns the successor nodes.	 */	 */








src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......












src/heros/alias/AccessPath.java








View file @ 3398e46f








src/heros/alias/AccessPath.java










View file @ 3398e46f


3398e46f



......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......


  private final SubAccessPath<T>[] accesses;privatefinalSubAccessPath<T>[]accesses; private final Set<T> exclusions;privatefinalSet<T>exclusions; private final SubPathResolver<T> resolver;privatefinalSubPathResolver<T>resolver;  public AccessPath() {publicAccessPath(){ accesses = new SubAccessPath[0];accesses=newSubAccessPath[0]; exclusions = Sets.newHashSet();exclusions=Sets.newHashSet(); resolver = null;resolver=null; }}  AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {AccessPath(SubAccessPath<T>[]accesses,Set<T>exclusions,, SubPathResolverSubPathResolver<<TT>> resolverresolver){ AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {AccessPath(SubAccessPath<T>[]accesses,Set<T>exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; this.resolver = resolver;this.resolver=resolver; }} public boolean isAccessInExclusions(T fieldReferences) {publicbooleanisAccessInExclusions(TfieldReferences){ return exclusions.contains(fieldReferences);returnexclusions.contains(fieldReferences); }}  public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<T>...fieldReferences){ if(fieldReferences.length > 0) {if(fieldReferences.length>0){ for(T field : fieldReferences[0].elements()) {for(Tfield:fieldReferences[0].elements()){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString()); if(merge) {if(merge){ for(int i=fieldReferences.length-1; i>=0; i--) {for(inti=fieldReferences.length-1;i>=0;i--){ for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].shouldBeMerged(fieldReferences[i])) {if(accesses[j].shouldBeMerged(fieldReferences[i])){ // [..., {j-i}, ...]// [..., {j-i}, ...]  AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);AccessPathBuilderbuilder=newAccessPathBuilder(j+fieldReferences.length-i); builder.keep(0, j);builder.keep(0,j); builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);builder.merge(j,accesses.length).mergeWithLast(fieldReferences,0,i); builder.append(fieldReferences, i+1, fieldReferences.length);builder.append(fieldReferences,i+1,fieldReferences.length); builder.removeExclusions();builder.removeExclusions(); return builder.build();returnbuilder.build(); }} }} }} }} //FIXME do we need to not merge sometimes?//FIXME do we need to not merge sometimes?//		if(merge) {//		if(merge) {//			for(int i=fieldReferences.length-1; i>=0; i--) {//			for(int i=fieldReferences.length-1; i>=0; i--) {//				for(int j=0; j<accesses.length; j++) {//				for(int j=0; j<accesses.length; j++) {//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {//						// [..., {j-i}, ...]//						// [..., {j-i}, ...]//						//						//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);//						builder.keep(0, j);//						builder.keep(0, j);//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);//						builder.append(fieldReferences, i+1, fieldReferences.length);//						builder.append(fieldReferences, i+1, fieldReferences.length);//						builder.removeExclusions();//						builder.removeExclusions();//						return builder.build();//						return builder.build();//					}//					}//				}//				}//			}//			}//		}//		}  AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+fieldReferences.length); builder.keep(0, accesses.length);builder.keep(0,accesses.length); }}  public AccessPath<T> build() {publicAccessPath<T>build(){ return new AccessPath<>(newAccesses, newExclusions, resolver);returnnewAccessPath<>(newAccesses,newExclusions,, resolverresolver); return new AccessPath<>(newAccesses, newExclusions);returnnewAccessPath<>(newAccesses,newExclusions); }} public void removeExclusions() {publicvoidremoveExclusions(){ }} public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<T>[]fieldReferences,intstart,intendExcl){ newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccessesnewAccesses[[currentIndexcurrentIndex--11]] == newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); }} public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {publicAccessPathBuildermerge(intsrcIndex,intdestIndexExcl){ }} public AccessPath<T> prepend(T fieldRef) {publicAccessPath<T>prepend(TfieldRef){ for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].contains(fieldRef)) {if(accesses[j].contains(fieldRef)){ // [{0-j}, ...]// [{0-j}, ...]  AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length-j); builder.merge(0, j+1);builder.merge(0,j+1); builder.keep(j+1, accesses.length);builder.keep(j+1,accesses.length); return builder.build();returnbuilder.build(); }} }}//		for(int j=0; j<accesses.length; j++) {//		for(int j=0; j<accesses.length; j++) {////			if(accesses[j].contains(fieldRef)) {//			if(accesses[j].contains(fieldRef)) {////				// [{0-j}, ...]//				// [{0-j}, ...]//// // ////				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);////				builder.merge(0, j+1);//				builder.merge(0, j+1);////				builder.keep(j+1, accesses.length);//				builder.keep(j+1, accesses.length);////				return builder.build();//				return builder.build();////			}//			}////		}//		}// AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+1); builder.append(fieldRef);builder.append(fieldRef); builder.keep(0, accesses.length);builder.keep(0,accesses.length); for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i].contains(field)) {if(accesses[i].contains(field)){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions,, resolverresolver); return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); elseelse return this;returnthis; }} public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(T...fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }} public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(Collection<T>fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }} public static enum PrefixTestResult {publicstaticenumPrefixTestResult{ }}  public Delta<T> getDeltaTo(AccessPath<T> accPath) {publicDelta<T>getDeltaTo(AccessPath<T>accPath){ assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);assertisPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX); int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  }} break;break; }}  return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);returnnewDelta<T>(Arrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length),accPath.exclusions,accPath.resolver);//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);//		exclusions.removeAll(this.exclusions);//		exclusions.removeAll(this.exclusions); Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);Delta<T>delta=newDelta<T>(Arrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length),accPath.exclusions); assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) assert(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)&&accPath.isPrefixOf(delta.applyTo(this,true))==PrefixTestResult.GUARANTEED_PREFIX) || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));||(isPrefixOf(accPath)==PrefixTestResult.GUARANTEED_PREFIX&&accPath.equals(delta.applyTo(this,true))); return delta;returndelta; }}  public boolean contains(AccessPath<T> accPath) {publicbooleancontains(AccessPath<T>accPath){ assert accPath.accesses.length <= 1;assertaccPath.accesses.length<=1; if(accPath.accesses.length == 1) {if(accPath.accesses.length==1){ for(SubAccessPath<T> sub : accesses) {for(SubAccessPath<T>sub:accesses){ if(sub.elements().equals(accPath.accesses[0].elements())) {if(sub.elements().equals(accPath.accesses[0].elements())){ return true;returntrue; }} }} return false;returnfalse; }} elseelse return exclusions.containsAll(accPath.exclusions);returnexclusions.containsAll(accPath.exclusions); }}   public static class Delta<T extends FieldRef<T>> {publicstaticclassDelta<TextendsFieldRef<T>>{ final SubAccessPath<T>[] accesses;finalSubAccessPath<T>[]accesses; final Set<T> exclusions;finalSet<T>exclusions; final SubPathResolver<T> resolver;finalSubPathResolver<T>resolver; protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {protectedDelta(SubAccessPath<T>[]accesses,Set<T>exclusions,, SubPathResolverSubPathResolver<<TT>> resolverresolver){ protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {protectedDelta(SubAccessPath<T>[]accesses,Set<T>exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; this.resolver = resolver;this.resolver=resolver; }}  public boolean canBeAppliedTo(AccessPath<T> accPath) {publicbooleancanBeAppliedTo(AccessPath<T>accPath){ return !accPath.isAccessInExclusions(accesses);return!accPath.isAccessInExclusions(accesses); }}  public AccessPath<T> applyTo(AccessPath<T> accPath) {publicAccessPath<T>applyTo(AccessPath<T>accPath){ return applyTo(accPath, true);returnapplyTo(accPath,true); }}  public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {publicAccessPath<T>applyTo(AccessPath<T>accPath,booleanmerge){ AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);AccessPath<T>result=accPath.addFieldReference(merge,accesses).appendExcludedFieldReference(exclusions); if(resolver != null) {if(resolver!=null){ if(result.hasResolver())if(result.hasResolver()) throw new AssertionError();thrownewAssertionError(); result = result.setResolver(resolver);result=result.setResolver(resolver); }} return result;returnresult; }}  public static <T extends FieldRef<T>> Delta<T> empty() {publicstatic<TextendsFieldRef<T>>Delta<T>empty(){ return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);returnnewDelta<T>(newSubAccessPath[0],Sets.<T>newHashSet(),null); return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);returnaccPath.addFieldReference(merge,accesses).appendExcludedFieldReference(exclusions); }}  @Override@Override String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result += "^" + Joiner.on(",").join(exclusions);result+="^"+Joiner.on(",").join(exclusions); if(resolver != null)if(resolver!=null) result+="["+resolver+"]";result+="["+resolver+"]"; return result;returnresult; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses); result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());result=prime*result+((exclusions==null)?0:exclusions.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; Delta other = (Delta) obj;Deltaother=(Delta)obj; if (!Arrays.equals(accesses, other.accesses))if(!Arrays.equals(accesses,other.accesses)) return false;returnfalse; if (exclusions == null) {if(exclusions==null){ if (other.exclusions != null)if(other.exclusions!=null) return false;returnfalse; } else if (!exclusions.equals(other.exclusions))}elseif(!exclusions.equals(other.exclusions)) return false;returnfalse; return true;returntrue; }} public static <T extends FieldRef<T>> Delta<T> empty() {publicstatic<TextendsFieldRef<T>>Delta<T>empty(){ return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());returnnewDelta<T>(newSubAccessPath[0],Sets.<T>newHashSet()); }} }}  public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {publicAccessPath<T>mergeExcludedFieldReferences(AccessPath<T>accPath){ HashSet<T> newExclusions = Sets.newHashSet(exclusions);HashSet<T>newExclusions=Sets.newHashSet(exclusions); newExclusions.addAll(accPath.exclusions);newExclusions.addAll(accPath.exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }}  public boolean mayHaveEmptyAccessPath() {publicbooleanmayHaveEmptyAccessPath(){ return finalIndex() == 0;returnfinalIndex()==0; for(SubAccessPath<T> subAcc : accesses)for(SubAccessPath<T>subAcc:accesses) if(subAcc instanceof SpecificFieldAccess)if(subAccinstanceofSpecificFieldAccess) return false;returnfalse; return true;returntrue; }}  public boolean canRead(T field) {publicbooleancanRead(Tfield){ for(SubAccessPath<T> acc : accesses) {for(SubAccessPath<T>acc:accesses){ if(acc.contains(field))if(acc.contains(field)) return true;returntrue; if(acc instanceof SpecificFieldAccess)if(accinstanceofSpecificFieldAccess) return false;returnfalse; }} return false;returnfalse; }}  public boolean isEmpty() {publicbooleanisEmpty(){ return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();returnexclusions.isEmpty()&&accesses.length==0 &&&& !!hasResolverhasResolver();() return exclusions.isEmpty() && accesses.length == 0;returnexclusions.isEmpty()&&accesses.length==0; }}  @Override@Override int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses); result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());result=prime*result+((exclusions==null)?0:exclusions.hashCode()); result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());result=prime*result+((resolver==null)?0:resolver.hashCode()); return result;returnresult; }} return false;returnfalse; } else if (!exclusions.equals(other.exclusions))}elseif(!exclusions.equals(other.exclusions)) return false;returnfalse; if (resolver == null) {if(resolver==null){ if (other.resolver != null)if(other.resolver!=null) return false;returnfalse; } else if (!resolver.equals(other.resolver))}elseif(!resolver.equals(other.resolver)) return false;returnfalse; return true;returntrue; }} String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result += "^" + Joiner.on(",").join(exclusions);result+="^"+Joiner.on(",").join(exclusions); if(resolver != null)if(resolver!=null) result+="["+resolver+"]";result+="["+resolver+"]"; return result;returnresult; }}  Set<U> newExclusions = Sets.newHashSet();Set<U>newExclusions=Sets.newHashSet(); for(T f : exclusions)for(Tf:exclusions) newExclusions.add(function.apply(f));newExclusions.add(function.apply(f)); return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);returnnewAccessPath<U>(newAccesses,newExclusions,, nullnull /*FIXME*//*FIXME*/); return new AccessPath<U>(newAccesses, newExclusions);returnnewAccessPath<U>(newAccesses,newExclusions); }}  public AccessPath<T> removeAnyAccess() {publicAccessPath<T>removeAnyAccess(){ if(accesses.length > 0)if(accesses.length>0) return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);returnnewAccessPath<T>(newSubAccessPath[0],exclusions,, resolverresolver); return new AccessPath<T>(new SubAccessPath[0], exclusions);returnnewAccessPath<T>(newSubAccessPath[0],exclusions); elseelse return this;returnthis; }} int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  if(resolver != null) {if(resolver!=null){ if(!resolver.equals(accPath.resolver)) {if(!resolver.equals(accPath.resolver)){ return false;returnfalse; }} }} else if(accPath.resolver != null)elseif(accPath.resolver!=null) return false;returnfalse;   outer: while(true) {outer:while(true){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);Collection<Transition<T>>transitions=possibleTransitions(currIndex,false); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);Collection<Transition<T>>otherTransitions=accPath.possibleTransitions(otherIndex,false); }} public AccessPath<T> removeExclusions() {publicAccessPath<T>removeExclusions(){ return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);returnnewAccessPath<T>(accesses,Sets.<T>newHashSet(),, resolverresolver); return new AccessPath<T>(accesses, Sets.<T>newHashSet());returnnewAccessPath<T>(accesses,Sets.<T>newHashSet()); }} public SubAccessPath<T> getFirstAccess() {publicSubAccessPath<T>getFirstAccess(){ throw new IllegalArgumentException();thrownewIllegalArgumentException();  if(elements.size() == 1) {if(elements.size()==1){ return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions,, resolverresolver); return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions); }}  HashSet<T> newSet = Sets.newHashSet(elements);HashSet<T>newSet=Sets.newHashSet(elements); newSet.remove(field);newSet.remove(field); SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);SubAccessPath<T>[]newAccesses=Arrays.copyOf(accesses,accesses.length); newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);newAccesses[0]=newSetOfPossibleFieldAccesses<>(newSet); return new AccessPath<T>(newAccesses, exclusions, resolver);returnnewAccessPath<T>(newAccesses,exclusions,, resolverresolver); return new AccessPath<T>(newAccesses, exclusions);returnnewAccessPath<T>(newAccesses,exclusions); }} public AccessPath<T> setResolver(SubPathResolver<T> resolver) {publicAccessPath<T>setResolver(SubPathResolver<T>resolver){ return new AccessPath<T>(accesses, exclusions, resolver);returnnewAccessPath<T>(accesses,exclusions,resolver); }}  public SubPathResolver<T> getResolver() {publicSubPathResolver<T>getResolver(){ return resolver;returnresolver; }}  public boolean hasResolver() {publicbooleanhasResolver(){ return resolver != null;returnresolver!=null; }}  public AccessPath<T> decorateResolver(Constraint<T> constraint) {publicAccessPath<T>decorateResolver(Constraint<T>constraint){ return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));returnnewAccessPath<T>(accesses,exclusions,resolver.decorate(constraint)); }}  public class Iterator {publicclassIterator{ private int currentIndex = 0;privateintcurrentIndex=0;  return exclusions.contains(field);returnexclusions.contains(field); }}  public boolean hasResolver() {publicbooleanhasResolver(){ return resolver != null;returnresolver!=null; }} public Object getResolver() {publicObjectgetResolver(){ return resolver;returnresolver; }} }} public AccessPath<T>.Iterator iterator() {publicAccessPath<T>.Iteratoriterator(){








src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}












src/heros/alias/AccessPathHandler.java



0 → 100644







View file @ 3398e46f








src/heros/alias/AccessPathHandler.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import heros.alias.FlowFunction.ReadFieldConstraint;importheros.alias.FlowFunction.ReadFieldConstraint;import heros.alias.FlowFunction.WriteFieldConstraint;importheros.alias.FlowFunction.WriteFieldConstraint;import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;importheros.alias.SubAccessPath.SetOfPossibleFieldAccesses;public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassAccessPathHandler<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ private AccessPath<Field> accessPath;privateAccessPath<Field>accessPath; private Resolver<Field, Fact, Stmt, Method> resolver;privateResolver<Field,Fact,Stmt,Method>resolver; public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {publicAccessPathHandler(AccessPath<Field>accessPath,Resolver<Field,Fact,Stmt,Method>resolver){ this.accessPath = accessPath;this.accessPath=accessPath; this.resolver = resolver;this.resolver=resolver; }} public boolean canRead(Field field) {publicbooleancanRead(Fieldfield){ return accessPath.canRead(field);returnaccessPath.canRead(field); }}  public boolean mayCanRead(Field field) {publicbooleanmayCanRead(Fieldfield){ return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));returnaccessPath.canRead(field)||(accessPath.mayHaveEmptyAccessPath()&&!accessPath.isAccessInExclusions(field)); }}  public boolean mayBeEmpty() {publicbooleanmayBeEmpty(){ return accessPath.mayHaveEmptyAccessPath();returnaccessPath.mayHaveEmptyAccessPath(); }} public boolean canOverwrite(Field fieldRef) {publicbooleancanOverwrite(FieldfieldRef){ if(accessPath.hasEmptyAccessPath())if(accessPath.hasEmptyAccessPath()) return true;returntrue; if(accessPath.getFirstAccess().contains(fieldRef))if(accessPath.getFirstAccess().contains(fieldRef)) return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;returnaccessPath.getFirstAccess()instanceofSetOfPossibleFieldAccesses; return false;returnfalse; }}  public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));returnnewConstrainedFact<>(newWrappedFact<Field,Fact,Stmt,Method>(fact,accessPath,resolver)); }}  public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {publicConstrainedFact<Field,Fact,Stmt,Method>generateWithEmptyAccessPath(Factfact,ZeroHandler<Field>zeroHandler){ return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));returnnewConstrainedFact<>(newWrappedFact<>(fact,newAccessPath<Field>(),newZeroCallEdgeResolver<>(resolver.analyzer,zeroHandler))); }}  public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>prepend(finalFieldfield){ return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.prepend(field),resolver)); }} };}; }}  public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>read(finalFieldfield){ if(mayCanRead(field)) {if(mayCanRead(field)){ return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(canRead(field))if(canRead(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.removeFirst(field),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));returnnewConstrainedFact<>(newWrappedFact<>(fact,newAccessPath<Field>(),resolver),newReadFieldConstraint<>(field)); }} };}; }} elseelse throw new IllegalArgumentException("Cannot read field "+field);thrownewIllegalArgumentException("Cannot read field "+field); }}  public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>overwrite(finalFieldfield){ if(canOverwrite(field))if(canOverwrite(field)) return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(accessPath.canRead(field)) {if(accessPath.canRead(field)){ AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);AccessPath<Field>tempAccPath=accessPath.removeRepeatableFirstAccess(field); if(tempAccPath.hasEmptyAccessPath())if(tempAccPath.hasEmptyAccessPath()) return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,tempAccPath.appendExcludedFieldReference(field),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,tempAccPath,resolver)); } else if(accessPath.isAccessInExclusions(field))}elseif(accessPath.isAccessInExclusions(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath,resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.appendExcludedFieldReference(field),resolver),newWriteFieldConstraint<>(field)); }} };}; elseelse throw new IllegalArgumentException("Cannot write field "+field);thrownewIllegalArgumentException("Cannot write field "+field); }}  public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {publicstaticinterfaceResultBuilder<FieldRefextendsAccessPath.FieldRef<FieldRef>,FactAbstraction,Stmt,Method>{ public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);publicConstrainedFact<FieldRef,FactAbstraction,Stmt,Method>generate(FactAbstractionfact); }}}}








src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}












src/heros/alias/AccessPathUtil.java

deleted


100644 → 0







View file @ 55cdd2d8








src/heros/alias/AccessPathUtil.java

deleted


100644 → 0









View file @ 55cdd2d8


55cdd2d8










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Set;importjava.util.Set;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class AccessPathUtil {publicclassAccessPathUtil{ public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>PrefixTestResultisPrefixOf(DprefixCandidate,Dfact){ if(prefixCandidate.getBaseValue() == null) {if(prefixCandidate.getBaseValue()==null){ if(fact.getBaseValue() != null)if(fact.getBaseValue()!=null) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))}elseif(!prefixCandidate.getBaseValue().equals(fact.getBaseValue())) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX;  return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());returnprefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath()); }} public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<Delta<FieldRef>>getDelta(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();AccessPath<FieldRef>concreteAccessPath=sourceFact.getAccessPath(); AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();AccessPath<FieldRef>abstractAccessPath=summary.getSourceFact().getAccessPath(); AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();AccessPath<FieldRef>targetAccessPath=summary.getTargetFact().getAccessPath();  if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(AccessPath.Delta.<FieldRef> empty());returnOptional.of(AccessPath.Delta.<FieldRef>empty()); Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);Delta<FieldRef>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(!delta.canBeAppliedTo(targetAccessPath))if(!delta.canBeAppliedTo(targetAccessPath)) return Optional.absent();returnOptional.absent(); elseelse return Optional.of(delta);returnOptional.of(delta); }}  public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();AccessPath<FieldRef>concreteAccessPath=sourceFact.getAccessPath(); AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();AccessPath<FieldRef>abstractAccessPath=summary.getSourceFact().getAccessPath(); AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();AccessPath<FieldRef>targetAccessPath=summary.getTargetFact().getAccessPath(); if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(summary.getTargetFact());returnOptional.of(summary.getTargetFact());  Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);Delta<FieldRef>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(!delta.canBeAppliedTo(targetAccessPath))if(!delta.canBeAppliedTo(targetAccessPath)) return Optional.absent();returnOptional.absent();  AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);AccessPath<FieldRef>result=delta.applyTo(targetAccessPath); return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result)); }} public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>DcloneWithAccessPath(Dfact,AccessPath<FieldRef>accPath){ if(fact.getAccessPath().equals(accPath))if(fact.getAccessPath().equals(accPath)) return fact;returnfact; elseelse return fact.cloneWithAccessPath(accPath);returnfact.cloneWithAccessPath(accPath); }} }}








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......












src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java










View file @ 3398e46f


3398e46f



......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......


 * @param <M> see {@link IFDSSolver} * @param <M> see {@link IFDSSolver} * @param <I> see {@link IFDSSolver} * @param <I> see {@link IFDSSolver} */ */public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassBiDiFieldSensitiveIFDSSolver<N,BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,D extendsextends FieldSensitiveFactFieldSensitiveFact<<BaseValueBaseValue,, FieldRefFieldRef,, DD>,>M,IextendsInterproceduralCFG<N,M>>{public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {publicclassBiDiFieldSensitiveIFDSSolver<N,BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,D,M,IextendsInterproceduralCFG<N,M>>{ private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;privatefinalIFDSTabulationProblem<N,FieldRef,AbstractionWithSourceStmt,M,I>forwardProblem; private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;privatefinalIFDSTabulationProblem<N,FieldRef,AbstractionWithSourceStmt,M,I>backwardProblem;








src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}












src/heros/alias/CacheMap.java



0 → 100644







View file @ 3398e46f








src/heros/alias/CacheMap.java



0 → 100644









View file @ 3398e46f


3398e46f










package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}


package heros.alias;packageheros.alias;import java.util.Collection;importjava.util.Collection;import java.util.HashMap;importjava.util.HashMap;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;public abstract class CacheMap<K, V> implements Map<K, V> {publicabstractclassCacheMap<K,V>implementsMap<K,V>{ private HashMap<K, V> map;privateHashMap<K,V>map; public CacheMap() {publicCacheMap(){ map = new HashMap<K, V>();map=newHashMap<K,V>(); }} @Override@Override public int size() {publicintsize(){ return map.size();returnmap.size(); }} @Override@Override public boolean isEmpty() {publicbooleanisEmpty(){ return map.isEmpty();returnmap.isEmpty(); }} @Override@Override public boolean containsKey(Object key) {publicbooleancontainsKey(Objectkey){ return map.containsKey(key);returnmap.containsKey(key); }} @Override@Override public boolean containsValue(Object value) {publicbooleancontainsValue(Objectvalue){ return map.containsValue(value);returnmap.containsValue(value); }} protected abstract V createItem(K key);protectedabstractVcreateItem(Kkey); public V getOrCreate(K key) {publicVgetOrCreate(Kkey){ if (!map.containsKey(key)) {if(!map.containsKey(key)){ V value = createItem((K) key);Vvalue=createItem((K)key); map.put((K) key, value);map.put((K)key,value); return value;returnvalue; }} return map.get(key);returnmap.get(key); }} @Override@Override public V get(Object key) {publicVget(Objectkey){ return map.get(key);returnmap.get(key); }} @Override@Override public V put(K key, V value) {publicVput(Kkey,Vvalue){ return map.put(key, value);returnmap.put(key,value); }} @Override@Override public V remove(Object key) {publicVremove(Objectkey){ return map.remove(key);returnmap.remove(key); }} @Override@Override public void putAll(Map<? extends K, ? extends V> m) {publicvoidputAll(Map<?extendsK,?extendsV>m){ map.putAll(m);map.putAll(m); }} @Override@Override public void clear() {publicvoidclear(){ map.clear();map.clear(); }} @Override@Override public Set<K> keySet() {publicSet<K>keySet(){ return map.keySet();returnmap.keySet(); }} @Override@Override public Collection<V> values() {publicCollection<V>values(){ return map.values();returnmap.values(); }} @Override@Override public Set<java.util.Map.Entry<K, V>> entrySet() {publicSet<java.util.Map.Entry<K,V>>entrySet(){ return map.entrySet();returnmap.entrySet(); }}}}








src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file












src/heros/alias/CallEdgeResolver.java



0 → 100644







View file @ 3398e46f








src/heros/alias/CallEdgeResolver.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {classCallEdgeResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {publicCallEdgeResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer){ super(analyzer);super(analyzer); }} @Override@Override public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { publicvoidresolve(Constraint<Field>constraint,InterestCallback<Field,Fact,Stmt,Method>callback){ log("Resolve: "+constraint);log("Resolve: "+constraint); if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {if(constraint.canBeAppliedTo(analyzer.getAccessPath())&&!analyzer.isLocked()&&!doesContain(constraint)){ AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);AccessPath<Field>newAccPath=constraint.applyToAccessPath(analyzer.getAccessPath(),true); PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>nestedAnalyzer=analyzer.getOrCreateNestedAnalyzer(newAccPath); nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);nestedAnalyzer.getCallEdgeResolver().registerCallback(callback); }} }}  //FIXME: this is a dirty hack (and unsound?!)//FIXME: this is a dirty hack (and unsound?!) private boolean doesContain(Constraint<Field> constraint) {privatebooleandoesContain(Constraint<Field>constraint){ AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);AccessPath<Field>accPath=constraint.applyToAccessPath(newAccessPath<Field>(),true); return analyzer.getAccessPath().contains(accPath);returnanalyzer.getAccessPath().contains(accPath); }} @Override@Override public String toString() {publicStringtoString(){ return "";return""; }}  @Override@Override protected void log(String message) {protectedvoidlog(Stringmessage){ analyzer.log(message);analyzer.log(message); }}}}








src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}












src/heros/alias/Context.java



0 → 100644







View file @ 3398e46f








src/heros/alias/Context.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.InterproceduralCFG;importheros.InterproceduralCFG;public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {publicabstractclassContext<FieldRefextendsAccessPath.FieldRef<FieldRef>,FactAbstraction,Statement,Method>{ public final InterproceduralCFG<Statement, Method> icfg;publicfinalInterproceduralCFG<Statement,Method>icfg; public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;publicfinalFlowFunctionProcessor<FactAbstraction,Statement,Method,FieldRef>flowProcessor; public final Scheduler scheduler;publicfinalSchedulerscheduler; public final FactAbstraction zeroValue;publicfinalFactAbstractionzeroValue; public final boolean followReturnsPastSeeds;publicfinalbooleanfollowReturnsPastSeeds; public final FactMergeHandler<FactAbstraction> factHandler;publicfinalFactMergeHandler<FactAbstraction>factHandler; public final ZeroHandler<FieldRef> zeroHandler;publicfinalZeroHandler<FieldRef>zeroHandler;  Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, Context(InterproceduralCFG<Statement,Method>icfg,FlowFunctionProcessor<FactAbstraction,Statement,Method,FieldRef>flowProcessor, Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {Schedulerscheduler,FactAbstractionzeroValue,booleanfollowReturnsPastSeeds,FactMergeHandler<FactAbstraction>factHandler,ZeroHandler<FieldRef>zeroHandler){ this.icfg = icfg;this.icfg=icfg; this.flowProcessor = flowProcessor;this.flowProcessor=flowProcessor; this.scheduler = scheduler;this.scheduler=scheduler; this.zeroValue = zeroValue;this.zeroValue=zeroValue; this.followReturnsPastSeeds = followReturnsPastSeeds;this.followReturnsPastSeeds=followReturnsPastSeeds; this.factHandler = factHandler;this.factHandler=factHandler; this.zeroHandler = zeroHandler;this.zeroHandler=zeroHandler; }}  public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);publicabstractMethodAnalyzer<FieldRef,FactAbstraction,Statement,Method>getAnalyzer(Methodmethod);}}








src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}












src/heros/alias/ControlFlowJoinResolver.java



0 → 100644







View file @ 3398e46f








src/heros/alias/ControlFlowJoinResolver.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassControlFlowJoinResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ private boolean recursiveLock = false;privatebooleanrecursiveLock=false; private Stmt joinStmt;privateStmtjoinStmt; private AccessPath<Field> resolvedAccPath;privateAccessPath<Field>resolvedAccPath; private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();privateSet<WrappedFact<Field,Fact,Stmt,Method>>incomingFacts=Sets.newHashSet(); private boolean propagated = false;privatebooleanpropagated=false; private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();privateMap<AccessPath<Field>,ControlFlowJoinResolver<Field,Fact,Stmt,Method>>nestedResolvers=Maps.newHashMap(); private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;privateControlFlowJoinResolver<Field,Fact,Stmt,Method>parent; public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {publicControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,StmtjoinStmt){ this(analyzer, joinStmt, new AccessPath<Field>(), null);this(analyzer,joinStmt,newAccessPath<Field>(),null); }}  private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {privateControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,StmtjoinStmt,AccessPath<Field>resolvedAccPath,ControlFlowJoinResolver<Field,Fact,Stmt,Method>parent){ super(analyzer);super(analyzer); this.joinStmt = joinStmt;this.joinStmt=joinStmt; this.resolvedAccPath = resolvedAccPath;this.resolvedAccPath=resolvedAccPath; this.parent = parent;this.parent=parent; }} public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {publicvoidaddIncoming(finalWrappedFact<Field,Fact,Stmt,Method>fact){ if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {if(resolvedAccPath.isPrefixOf(fact.getAccessPath())==PrefixTestResult.GUARANTEED_PREFIX){ log("Incoming Fact "+fact);log("Incoming Fact "+fact); if(!incomingFacts.add(fact))if(!incomingFacts.add(fact)) return;return;  interest(analyzer, this);interest(analyzer,this); for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())for(ControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver:nestedResolvers.values()) nestedResolver.addIncoming(fact);nestedResolver.addIncoming(fact);  if(!propagated) {if(!propagated){ propagated=true;propagated=true; analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(analyzer.processFlowFromJoinStmt(newWrappedFactAtStatement<>(joinStmt,newWrappedFact<>( fact.getFact(), new AccessPath<Field>(), this)));fact.getFact(),newAccessPath<Field>(),this))); }} }} else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {elseif(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);Delta<Field>delta=fact.getAccessPath().getDeltaTo(resolvedAccPath); fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {fact.getResolver().resolve(newDeltaConstraint<>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {Resolver<Field,Fact,Stmt,Method>resolver){ ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);ControlFlowJoinResolver.this.interest(analyzer,ControlFlowJoinResolver.this); }} @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ ControlFlowJoinResolver.this.canBeResolvedEmpty();ControlFlowJoinResolver.this.canBeResolvedEmpty(); }} });}); }} }}  private boolean isLocked() {privatebooleanisLocked(){ if(recursiveLock)if(recursiveLock) return true;returntrue; if(parent == null)if(parent==null) return false;returnfalse; return parent.isLocked();returnparent.isLocked(); }}  @Override@Override public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {publicvoidresolve(Constraint<Field>constraint,finalInterestCallback<Field,Fact,Stmt,Method>callback){ log("Resolve: "+constraint);log("Resolve: "+constraint); if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())if(!constraint.canBeAppliedTo(resolvedAccPath)||isLocked()) return;return;  AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath,false); recursiveLock = true;recursiveLock=true; ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);ControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver=getOrCreateNestedResolver(candidateAccPath); if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath,false))) throw new AssertionError();thrownewAssertionError();  nestedResolver.registerCallback(callback);nestedResolver.registerCallback(callback); recursiveLock = false;recursiveLock=false; }}  private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {privateControlFlowJoinResolver<Field,Fact,Stmt,Method>getOrCreateNestedResolver(AccessPath<Field>candidateAccPath){ if(resolvedAccPath.equals(candidateAccPath))if(resolvedAccPath.equals(candidateAccPath)) return this;returnthis;  if(!nestedResolvers.containsKey(candidateAccPath)) {if(!nestedResolvers.containsKey(candidateAccPath)){ assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;assertresolvedAccPath.getDeltaTo(candidateAccPath).accesses.length<=1;  final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);finalControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver=newControlFlowJoinResolver<>(analyzer,joinStmt,candidateAccPath,this); nestedResolver.propagated = true;nestedResolver.propagated=true; nestedResolvers.put(candidateAccPath, nestedResolver);nestedResolvers.put(candidateAccPath,nestedResolver); for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {for(WrappedFact<Field,Fact,Stmt,Method>incFact:incomingFacts){ nestedResolver.addIncoming(incFact);nestedResolver.addIncoming(incFact); } } }} return nestedResolvers.get(candidateAccPath);returnnestedResolvers.get(candidateAccPath); }} @Override@Override protected void log(String message) {protectedvoidlog(Stringmessage){ analyzer.log("Join Stmt "+toString()+": "+message);analyzer.log("Join Stmt "+toString()+": "+message); }} @Override@Override public String toString() {publicStringtoString(){ return "<"+resolvedAccPath+":"+joinStmt+">";return"<"+resolvedAccPath+":"+joinStmt+">"; }} public AccessPath<Field> getResolvedAccessPath() {publicAccessPath<Field>getResolvedAccessPath(){ return resolvedAccPath;returnresolvedAccPath; }} public Stmt getJoinStmt() {publicStmtgetJoinStmt(){ return joinStmt;returnjoinStmt; }}}}








src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file












src/heros/alias/Debugger.java



0 → 100644







View file @ 3398e46f








src/heros/alias/Debugger.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.InterproceduralCFG;importheros.InterproceduralCFG;public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {publicinterfaceDebugger<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>{ public abstract void setICFG(I icfg);publicabstractvoidsetICFG(Iicfg); public abstract void initialSeed(Stmt stmt);publicabstractvoidinitialSeed(Stmtstmt);  public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicstaticclassNullDebugger<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ @Override@Override public void setICFG(I icfg) {publicvoidsetICFG(Iicfg){  }} @Override@Override public void initialSeed(Stmt stmt) {publicvoidinitialSeed(Stmtstmt){  }}  }}}}








src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}












src/heros/alias/DeltaConstraint.java








View file @ 3398e46f








src/heros/alias/DeltaConstraint.java










View file @ 3398e46f


3398e46f



......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}


 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);delta=accPathAtCaller.getDeltaTo(accPathAtCallee); }} public DeltaConstraint(Delta<FieldRef> delta) {publicDeltaConstraint(Delta<FieldRef>delta){ this.delta = delta;this.delta=delta; }}  @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,booleansourceFact){ if(accPath.hasResolver()) {if(accPath.hasResolver()){ return delta.applyTo(accPath, sourceFact).decorateResolver(this);returndelta.applyTo(accPath,sourceFact).decorateResolver(this); }} elseelse return delta.applyTo(accPath, sourceFact);returndelta.applyTo(accPath,sourceFact); return delta.applyTo(accPath, !sourceFact);returndelta.applyTo(accPath,!sourceFact); }} @Override@Override return delta.canBeAppliedTo(accPath);returndelta.canBeAppliedTo(accPath); }} @Override@Override public String toString() {publicStringtoString(){ return delta.toString();returndelta.toString(); }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((delta == null) ? 0 : delta.hashCode());result=prime*result+((delta==null)?0:delta.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; DeltaConstraint other = (DeltaConstraint) obj;DeltaConstraintother=(DeltaConstraint)obj; if (delta == null) {if(delta==null){ if (other.delta != null)if(other.delta!=null) return false;returnfalse; } else if (!delta.equals(other.delta))}elseif(!delta.equals(other.delta)) return false;returnfalse; return true;returntrue; }}  }}








src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}












src/heros/alias/FactAtStatement.java



0 → 100644







View file @ 3398e46f








src/heros/alias/FactAtStatement.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class FactAtStatement<Fact, Stmt> {publicclassFactAtStatement<Fact,Stmt>{ public final Fact fact;publicfinalFactfact; public final Stmt stmt;publicfinalStmtstmt; public FactAtStatement(Fact fact, Stmt stmt) {publicFactAtStatement(Factfact,Stmtstmt){ this.fact = fact;this.fact=fact; this.stmt = stmt;this.stmt=stmt; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode()); result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());result=prime*result+((stmt==null)?0:stmt.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; FactAtStatement other = (FactAtStatement) obj;FactAtStatementother=(FactAtStatement)obj; if (fact == null) {if(fact==null){ if (other.fact != null)if(other.fact!=null) return false;returnfalse; } else if (!fact.equals(other.fact))}elseif(!fact.equals(other.fact)) return false;returnfalse; if (stmt == null) {if(stmt==null){ if (other.stmt != null)if(other.stmt!=null) return false;returnfalse; } else if (!stmt.equals(other.stmt))}elseif(!stmt.equals(other.stmt)) return false;returnfalse; return true;returntrue; }}}}








src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}












src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f








src/heros/alias/SubPathResolver.java

→

src/heros/alias/FactMergeHandler.java





SubPathResolvFactMergeHandl




View file @ 3398e46f


3398e46f



......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.Constraint;importimport heros.alias.FlowFunction.Constraintheros.alias.FlowFunction.Constraint;;public interface FactMergeHandler<Fact> {publicpublic interfaceinterface FactMergeHandlerFactMergeHandler<<FactFact>> {{public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {publicpublic interfaceinterface SubPathResolverSubPathResolver<<TT extendsextends AccessPathAccessPath..FieldRefFieldRef<<TT>>>> {{ SubPathResolver<T> decorate(Constraint<T> constraint);SubPathResolverSubPathResolver<<TT>> decoratedecorate((ConstraintConstraint<<TT>> constraintconstraint); void merge(Fact previousFact, Fact currentFact); voidvoid mergemerge((FactFact previousFactpreviousFact,, FactFact currentFactcurrentFact););  void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);voidvoid restoreCallingContextrestoreCallingContext((FactFact factAtReturnSitefactAtReturnSite,, FactFact factAtCallSitefactAtCallSite);}}








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.











src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ 3398e46f


3398e46f


This diff is collapsed.
Click to expand it.




This diff is collapsed.
Click to expand it.


This diff is collapsed.
Click to expand it.









src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......












src/heros/alias/FlowFunction.java








View file @ 3398e46f








src/heros/alias/FlowFunction.java










View file @ 3398e46f


3398e46f



......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......


 *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {publicinterfaceFlowFunction<FieldRefextendsAccessPath.FieldRef<FieldRef>,D extendsextends FieldSensitiveFactFieldSensitiveFact<?,<?, FieldRefFieldRef,, DD>>>{public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {publicinterfaceFlowFunction<FieldRefextendsAccessPath.FieldRef<FieldRef>,D,, StmtStmt,, MethodMethod>{ /**/**	 * Returns the target values reachable from the source.	 * Returns the target values reachable from the source.	 */	 */ Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);Set<ConstrainedFact<FieldRef,D>>computeTargets(Dsource); Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);Set<ConstrainedFact<FieldRef,D,, StmtStmt,, MethodMethod>>computeTargets(Dsource,, AccessPathHandlerAccessPathHandler<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>> accPathHandleraccPathHandler);  public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {publicstaticclassConstrainedFact<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>{  public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {publicstaticclassConstrainedFact<FieldRefextendsAccessPath.FieldRef<FieldRef>,D,Stmt,Method>{  private D fact;privateDDfact; private WrappedFact<FieldRef, D, Stmt, Method> fact;privateWrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>fact; private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint;  public ConstrainedFact(D fact) {publicpublic ConstrainedFact(DDfact){ ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {ConstrainedFact(WrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>fact){ this.fact = fact;this.fact=fact; this.constraint = null;this.constraint=null; }}  public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {publicpublic ConstrainedFact(DDfact,Constraint<FieldRef>constraint){ ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {ConstrainedFact(WrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>fact,Constraint<FieldRef>constraint){ this.fact = fact;this.fact=fact; this.constraint = constraint;this.constraint=constraint; }}  public D getFact() {publicDDgetFact(){ public WrappedFact<FieldRef, D, Stmt, Method> getFact() {publicWrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>getFact(){ return fact;returnfact; }} 








src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}












src/heros/alias/FlowFunctionProcessor.java



0 → 100644







View file @ 3398e46f








src/heros/alias/FlowFunctionProcessor.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import java.util.Set;importjava.util.Set;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {publicclassFlowFunctionProcessor<Fact,Stmt,Method,FieldextendsAccessPath.FieldRef<Field>>{ private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;privateFlowFunctions<Stmt,Field,Fact,Method>flowFunctions; public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {publicFlowFunctionProcessor(FlowFunctions<Stmt,Field,Fact,Method>flowFunctions){ this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; }}  public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeNormalFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>source){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getNormalFlowFunction(source.getStatement()); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }}  public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeCallFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>source,MethodcalledMethod){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getCallFlowFunction(source.getStatement(),calledMethod); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }} public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeCallToReturnFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>source,StmtreturnSite){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getCallToReturnFlowFunction(source.getStatement(),returnSite); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }} public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeReturnFlow(FactMergeHandler<Fact>factHandler,WrappedFactAtStatement<Field,Fact,Stmt,Method>source,MethodcalleeMethod,StmtreturnSite, IncomingEdge<Field, Fact, Stmt, Method> incEdge) {IncomingEdge<Field,Fact,Stmt,Method>incEdge){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getReturnFlowFunction(incEdge.getCallSite(),calleeMethod,source.getStatement(),returnSite); Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));Set<ConstrainedFact<Field,Fact,Stmt,Method>>targets=flowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver()));  for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {for(ConstrainedFact<Field,Fact,Stmt,Method>constrainedFact:targets){ factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());factHandler.restoreCallingContext(constrainedFact.getFact().getFact(),incEdge.getCallerCallSiteFact().getFact()); }} return targets;returntargets; }} public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeUnbalancedReturnFlow(Factzero,WrappedFactAtStatement<Field,Fact,Stmt,Method>source, Method calleeMethod, Stmt returnSite, Stmt callSite) {MethodcalleeMethod,StmtreturnSite,StmtcallSite){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getReturnFlowFunction(callSite,calleeMethod,source.getStatement(),returnSite); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }}}}








src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......












src/heros/alias/FlowFunctions.java








View file @ 3398e46f








src/heros/alias/FlowFunctions.java










View file @ 3398e46f


3398e46f



......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......


 *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. */ */public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {publicinterfaceFlowFunctions<Stmt,FieldRefextendsAccessPath.FieldRef<FieldRef>,F extendsextends FieldSensitiveFactFieldSensitiveFact<?,<?, FieldRefFieldRef,, FF>,>Method>{public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {publicinterfaceFlowFunctions<Stmt,FieldRefextendsAccessPath.FieldRef<FieldRef>,F,Method>{ /**/**	 * Returns the flow function that computes the flow for a normal statement,	 * Returns the flow function that computes the flow for a normal statement,	 * 	 * 	 * @param curr	 * @param curr	 *            The current statement.	 *            The current statement.	 * @param succ	 * @param succ	 *            The successor for which the flow is computed. This value can	 *            The successor for which the flow is computed. This value can	 *            be used to compute a branched analysis that propagates	 *            be used to compute a branched analysis that propagates	 *            different values depending on where control0flow branches.	 *            different values depending on where control0flow branches.	 */	 */ public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);publicFlowFunction<FieldRef,F>getNormalFlowFunction(Stmtcurr,, StmtStmt succsucc); public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getNormalFlowFunction(Stmtcurr);  /**/**	 * @param destinationMethod	 * @param destinationMethod	 *            The concrete target method for which the flow is computed.	 *            The concrete target method for which the flow is computed.	 */	 */ public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);publicFlowFunction<FieldRef,F>getCallFlowFunction(StmtcallStmt,MethoddestinationMethod); public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getCallFlowFunction(StmtcallStmt,MethoddestinationMethod); /**/**	 * Returns the flow function that computes the flow for a an exit from a	 * Returns the flow function that computes the flow for a an exit from a	 *            does not contain a caller for the method that is returned from.	 *            does not contain a caller for the method that is returned from.	 * @return	 * @return	 */	 */ public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);publicFlowFunction<FieldRef,F>getReturnFlowFunction(StmtcallSite,MethodcalleeMethod,StmtexitStmt,StmtreturnSite); public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getReturnFlowFunction(StmtcallSite,MethodcalleeMethod,StmtexitStmt,StmtreturnSite); /**/**	 * Returns the flow function that computes the flow from a call site to a	 * Returns the flow function that computes the flow from a call site to a	 *            exceptional flow, this may actually be the start of an	 *            exceptional flow, this may actually be the start of an	 *            exception handler.	 *            exception handler.	 */	 */ public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);publicFlowFunction<FieldRef,F>getCallToReturnFlowFunction(StmtcallSite,StmtreturnSite); public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getCallToReturnFlowFunction(StmtcallSite,StmtreturnSite);  








src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}












src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f








src/heros/alias/IFDSTabulationProblem.java










View file @ 3398e46f


3398e46f



......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}


import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SolverConfiguration;importheros.SolverConfiguration;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.solver.Pair;importheros.solver.Pair;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set; * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRefextendsAccessPath.FieldRef<FieldRef>,Dextendsextends FieldSensitiveFactFieldSensitiveFact<?,<?, FieldRefFieldRef,, DD>,>M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRefextendsAccessPath.FieldRef<FieldRef>,D,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{ /**/**	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 */	 */ D zeroValue();DzeroValue(); ZeroHandler<FieldRef> zeroHandler();ZeroHandler<FieldRef>zeroHandler();}}








src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......












src/heros/alias/IncomingEdge.java








View file @ 3398e46f








src/heros/alias/IncomingEdge.java










View file @ 3398e46f


3398e46f



......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class IncomingEdge<D, N> {publicclassIncomingEdge<D,N>{import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult; private D calleeSourceFact;privateDcalleeSourceFact; private N callSite;privateNcallSite; private D callerSourceFact;privateDcallerSourceFact; private D callerCallSiteFact;privateDcallerCallSiteFact;public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassIncomingEdge<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;privateWrappedFact<Field,Fact,Stmt,Method>calleeSourceFact; private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;privatePerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>callerAnalyzer; private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;privateWrappedFactAtStatement<Field,Fact,Stmt,Method>factAtCallSite;  public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {publicIncomingEdge(DcalleeSourceFact,NcallSite,DcallerSourceFact,DcallerCallSiteFact){ super();super(); public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, publicIncomingEdge(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>callerAnalyzer, WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtCallSite, WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {WrappedFact<Field,Fact,Stmt,Method>calleeSourceFact){ this.callerAnalyzer = callerAnalyzer;this.callerAnalyzer=callerAnalyzer; this.factAtCallSite = factAtCallSite;this.factAtCallSite=factAtCallSite; this.calleeSourceFact = calleeSourceFact;this.calleeSourceFact=calleeSourceFact; this.callSite = callSite;this.callSite=callSite; this.callerSourceFact = callerSourceFact;this.callerSourceFact=callerSourceFact; this.callerCallSiteFact = callerCallSiteFact;this.callerCallSiteFact=callerCallSiteFact; }}  public D getCalleeSourceFact() {publicDDgetCalleeSourceFact(){ public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {publicWrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>>getCalleeSourceFact(){ return calleeSourceFact;returncalleeSourceFact; }}  public D getCallerCallSiteFact() {publicDgetCallerCallSiteFact(){ return callerCallSiteFact;returncallerCallSiteFact; public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {publicWrappedFact<Field,Fact,Stmt,Method>getCallerCallSiteFact(){ return factAtCallSite.getFact();returnfactAtCallSite.getFact(); }}  public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {publicWrappedFact<Field,Fact,Stmt,Method>getCallerSourceFact(){ return callerAnalyzer.wrappedSource();returncallerAnalyzer.wrappedSource(); }}  public D getCallerSourceFact() {publicDDgetCallerSourceFacterSourceFact(){ return callerSourceFact;returncallerSourceFactcallerSourceFact; public Stmt getCallSite() {publicStmtStmtgetCallSiteSite(){ return factAtCallSite.getStatement();returnfactAtCallSitefactAtCallSite..getStatementgetStatement();() }}  public N getCallSite() {publicNgetCallSite(){ return callSite;returncallSite; public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {publicPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>getCallerAnalyzer(){ return callerAnalyzer;returncallerAnalyzer; }}  public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {publicvoidregisterInterestCallback(finalPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>interestedAnalyzer){ final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());finalDelta<Field>delta=calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());  if(!factAtCallSite.canDeltaBeApplied(delta))if(!factAtCallSite.canDeltaBeApplied(delta)) return;return;  factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {factAtCallSite.getFact().getResolver().resolve(newDeltaConstraint<Field>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){  @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);WrappedFact<Field,Fact,Stmt,Method>calleeSourceFactWithDelta=newWrappedFact<>(calleeSourceFact.getFact(),delta.applyTo(calleeSourceFact.getAccessPath(),false),resolver); if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath())!=PrefixTestResult.GUARANTEED_PREFIX) throw new AssertionError();thrownewAssertionError(); interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, interestedAnalyzer.addIncomingEdge(newIncomingEdge<>(analyzer, new WrappedFactAtStatement<>(factAtCallSite.getStatement(), newWrappedFactAtStatement<>(factAtCallSite.getStatement(), new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), newWrappedFact<>(factAtCallSite.getFact().getFact(),delta.applyTo(factAtCallSite.getFact().getAccessPath(),false),resolver)), calleeSourceFactWithDelta));calleeSourceFactWithDelta)); }}  @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);callerAnalyzer.getCallEdgeResolver().resolve(newDeltaConstraint<Field>(delta),this); }} });}); }}  @Override@Override public String toString() {publicStringtoString(){ return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";return"[IncEdge CSite:"+callSitec+", Caller-Edge: "+callerSourceFactc+"->"+callerCallSiteFactc+",  CalleeFact: "+calleeSourceFact+"]"; return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";return"[IncEdge CSite:"+getCallSitegetC()+()", Caller-Edge: "+getCallerSourceFactgetC()+()"->"+getCallerCallSiteFactgetC()+()",  CalleeFact: "+calleeSourceFact+"]"; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());result=prime*result+((callSite==null)?0:callSite.hashCode()); result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());result=prime*result+((calleeSourceFact==null)?0:calleeSourceFact.hashCode()); result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());result=prime*result+((callerCallSiteFactCallSiteFact==null)?0:callerCallSiteFactCallSiteFact.hashCode()); result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());result=prime*result+((callerSourceFactcallerSourceFact ==== nullnull)) ?? 00 :: callerSourceFactcallerSourceFact.hashCode()); result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());result=prime*result+((callerAnalyzerAnalyzer==null)?0:callerAnalyzerAnalyzer.hashCode()); result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());result=prime*result+((factAtCallSitefactAtCallSite ==== nullnull)) ?? 00 :: factAtCallSitefactAtCallSite.hashCode()); return result;returnresult; }} return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof IncomingEdge))if(!(!(objobj instanceofinstanceof IncomingEdgeIncomingEdge)) if (getClass() != obj.getClass())if(getClassgetClass()() !=!= objobj..getClassgetClass())( return false;returnfalse; IncomingEdge other = (IncomingEdge) obj;IncomingEdgeother=(IncomingEdge)obj; if (callSite == null) {if(callSite==null){ if (other.callSite != null)if(other.callSite!=null) return false;returnfalse; } else if (!callSite.equals(other.callSite))}elseif(!callSite.equals(other.callSite)) return false;returnfalse; if (calleeSourceFact == null) {if(calleeSourceFact==null){ if (other.calleeSourceFact != null)if(other.calleeSourceFact!=null) return false;returnfalse; } else if (!calleeSourceFact.equals(other.calleeSourceFact))}elseif(!calleeSourceFact.equals(other.calleeSourceFact)) return false;returnfalse; if (callerCallSiteFact == null) {if(callerCallSiteFactCallSiteFact==null){ if (other.callerCallSiteFact != null)if(other.callerCallSiteFactCallSiteFact!=null) if (callerAnalyzer == null) {if(callerAnalyzerAnalyzer==null){ if (other.callerAnalyzer != null)if(other.callerAnalyzerAnalyzer!=null) return false;returnfalse; } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))}elseif(!callerCallSiteFactCallSiteFact.equals(other.callerCallSiteFactCallSiteFact)) } else if (!callerAnalyzer.equals(other.callerAnalyzer))}elseif(!callerAnalyzerAnalyzer.equals(other.callerAnalyzerAnalyzer)) return false;returnfalse; if (callerSourceFact == null) {if(callerSourceFactcallerSourceFact==null){ if (other.callerSourceFact != null)if(other.callerSourceFactcallerSourceFact!=null) if (factAtCallSite == null) {if(factAtCallSitefactAtCallSite==null){ if (other.factAtCallSite != null)if(other.factAtCallSitefactAtCallSite!=null) return false;returnfalse; } else if (!callerSourceFact.equals(other.callerSourceFact))}elseif(!callerSourceFactcallerSourceFact..equalsequals((otherother..callerSourceFactcallerSourceFact)) } else if (!factAtCallSite.equals(other.factAtCallSite))}elseif(!factAtCallSitefactAtCallSite..equalsequals((otherother..factAtCallSitefactAtCallSite)) return false;returnfalse; return true;returntrue; }}



Prev


1


2


3


Next





Prev

1

2

3

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






