



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

d7cafbe8















Commit
d7cafbe8


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




merge only on equal field types







parent
d3ba7760













Changes
15




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d7cafbe8






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......














src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......














src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......














src/heros/alias/FlowFunction.java








View file @ d7cafbe8






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......














src/heros/alias/FlowFunctions.java








View file @ d7cafbe8






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/SubAccessPath.java








View file @ d7cafbe8






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......














test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......














test/heros/alias/AccessPathTest.java








View file @ d7cafbe8






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/Fact.java








View file @ d7cafbe8






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ d7cafbe8






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

d7cafbe8















Commit
d7cafbe8


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




merge only on equal field types







parent
d3ba7760













Changes
15




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d7cafbe8






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......














src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......














src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......














src/heros/alias/FlowFunction.java








View file @ d7cafbe8






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......














src/heros/alias/FlowFunctions.java








View file @ d7cafbe8






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/SubAccessPath.java








View file @ d7cafbe8






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......














test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......














test/heros/alias/AccessPathTest.java








View file @ d7cafbe8






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/Fact.java








View file @ d7cafbe8






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ d7cafbe8






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

d7cafbe8







Open sidebar



Joshua Garcia heros
Commits

d7cafbe8




Open sidebar

Joshua Garcia heros
Commits

d7cafbe8


Joshua GarciaherosherosCommits
d7cafbe8








Commit
d7cafbe8


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




merge only on equal field types







parent
d3ba7760













Changes
15




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d7cafbe8






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......














src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......














src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......














src/heros/alias/FlowFunction.java








View file @ d7cafbe8






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......














src/heros/alias/FlowFunctions.java








View file @ d7cafbe8






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/SubAccessPath.java








View file @ d7cafbe8






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......














test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......














test/heros/alias/AccessPathTest.java








View file @ d7cafbe8






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/Fact.java








View file @ d7cafbe8






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ d7cafbe8






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
d7cafbe8


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




merge only on equal field types







parent
d3ba7760













Changes
15




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d7cafbe8






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......














src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......














src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......














src/heros/alias/FlowFunction.java








View file @ d7cafbe8






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......














src/heros/alias/FlowFunctions.java








View file @ d7cafbe8






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/SubAccessPath.java








View file @ d7cafbe8






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......














test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......














test/heros/alias/AccessPathTest.java








View file @ d7cafbe8






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/Fact.java








View file @ d7cafbe8






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ d7cafbe8






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
d7cafbe8


authored
Feb 05, 2015
by


Johannes Lerch



Browse files



Commit
d7cafbe8


authored
Feb 05, 2015
by


Johannes Lerch

d7cafbe8authoredbyJohannes Lerch

merge only on equal field types






parent
d3ba7760
















parent
d3ba7760





parent












Changes
15
15


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPath.java








View file @ d7cafbe8






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......














src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......














src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......














src/heros/alias/FlowFunction.java








View file @ d7cafbe8






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......














src/heros/alias/FlowFunctions.java








View file @ d7cafbe8






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......














src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......














src/heros/alias/SubAccessPath.java








View file @ d7cafbe8






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......














test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......














test/heros/alias/AccessPathTest.java








View file @ d7cafbe8






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/Fact.java








View file @ d7cafbe8






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ d7cafbe8






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......














src/heros/alias/AccessPath.java








View file @ d7cafbe8






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......












src/heros/alias/AccessPath.java








View file @ d7cafbe8








src/heros/alias/AccessPath.java










View file @ d7cafbe8


d7cafbe8



......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......






......@@ -10,46 +10,46 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {










public class AccessPath<T extends AccessPath.FieldRef<T>> {





















 public static <T> AccessPath<T> empty() {










 public static interface FieldRef<F> {










 boolean shouldBeMergedWith(F fieldRef);










 }










 










 public static <T extends FieldRef<T>> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 private final SubAccessPath<T>[] accesses;










 private final Set<T>[] exclusions;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 for(T field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }



......@@ -58,12 +58,11 @@ public class AccessPath<FieldRef> {









 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());














......@@ -74,7 +73,7 @@ public class AccessPath<FieldRef> {









 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);



......@@ -98,8 +97,8 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 public AccessPath<T> addFieldReference(T... fieldReferences) {










 SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }



......@@ -108,8 +107,8 @@ public class AccessPath<FieldRef> {









 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private Set<T>[] newExclusions;










 private SubAccessPath<T>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {



......@@ -117,9 +116,9 @@ public class AccessPath<FieldRef> {









 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 public AccessPath<T> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);



......@@ -141,7 +140,7 @@ public class AccessPath<FieldRef> {









 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;



......@@ -151,12 +150,12 @@ public class AccessPath<FieldRef> {









 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 Set<T> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }



......@@ -171,7 +170,7 @@ public class AccessPath<FieldRef> {









 return this;










 }





















 public void append(FieldRef fieldRef) {










 public void append(T fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }



......@@ -182,7 +181,7 @@ public class AccessPath<FieldRef> {









 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]



......@@ -199,11 +198,11 @@ public class AccessPath<FieldRef> {









 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 public AccessPath<T> removeFirst(T field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -214,22 +213,22 @@ public class AccessPath<FieldRef> {









 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 public AccessPath<T> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }



......@@ -248,25 +247,22 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();



......@@ -295,48 +291,72 @@ public class AccessPath<FieldRef> {









 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {










 Collection<Transition<T>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 result.addAll(possibleTransitions(index+1, addExclusionTransitions));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));










 }










 return result;










 }










 










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);





















 for(Transition<T> transition : transitions) {










 for(Transition<T> otherTransition : otherTransitions) {










 MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 continue;










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 continue outer;










 }










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 










//		int currentIndex = 0;










//		for(SubAccessPath<T> sub : accesses) {










//			if(!(sub instanceof SpecificFieldAccess))










//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










//			










//			T field = sub.elements().iterator().next();










//			










//			while(true) {










//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










//						currentIndex++;










//					break;










//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










//					currentIndex++;










//				}










//				else










//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










//			}










//		}










//		










//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)



......@@ -383,7 +403,7 @@ public class AccessPath<FieldRef> {









 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 for(Set<T> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;



......@@ -411,19 +431,19 @@ public class AccessPath<FieldRef> {









 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 for(FieldRef excl : exclusion)










 public AccessPath<T> addExclusion(T... exclusion) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);










 for(T excl : exclusion)










 newExclusions.add(excl);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 Set<T>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 return new AccessPath<T>(accesses, newExclusionsArray);










 }










 }





















 public AccessPath<FieldRef> removeAnyAccess() {










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static com.google.common.collect.Iterables.getOnlyElement;importstaticcom.google.common.collect.Iterables.getOnlyElement;import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;importheros.alias.SubAccessPath.SetOfPossibleFieldAccesses;import heros.alias.SubAccessPath.SpecificFieldAccess;importheros.alias.SubAccessPath.SpecificFieldAccess;import heros.alias.Transition.MatchResult;importheros.alias.Transition.MatchResult;import java.util.Arrays;importjava.util.Arrays;import java.util.Collection;importjava.util.Collection;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Function;importcom.google.common.base.Function;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Iterables;importcom.google.common.collect.Iterables;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.Transition.MatchResult;importheros.alias.Transition.MatchResult;import heros.alias.SubAccessPath.*;importheros.alias.SubAccessPath.*;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPath<FieldRef> {publicclassAccessPath<FieldRef>{public class AccessPath<T extends AccessPath.FieldRef<T>> {publicclassAccessPath<TT extendsextends AccessPathAccessPath..FieldRef<<TT>>>{ public static <T> AccessPath<T> empty() {publicstatic<T>AccessPath<T>empty(){ public static interface FieldRef<F> {publicstaticinterfaceFieldRef<F>{ boolean shouldBeMergedWith(F fieldRef);booleanshouldBeMergedWith(FfieldRef); }}  public static <T extends FieldRef<T>> AccessPath<T> empty() {publicstatic<TextendsFieldRef<T>>AccessPath<T>empty(){ return new AccessPath<T>();returnnewAccessPath<T>(); }}  private final SubAccessPath<FieldRef>[] accesses;privatefinalSubAccessPath<FieldRefFieldRef>[]accesses; private final Set<FieldRef>[] exclusions;privatefinalSet<FieldRefFieldRef>[]exclusions; private final SubAccessPath<T>[] accesses;privatefinalSubAccessPath<TT>[]accesses; private final Set<T>[] exclusions;privatefinalSet<TT>[]exclusions;  public AccessPath() {publicAccessPath(){ accesses = new SubAccessPath[0];accesses=newSubAccessPath[0]; exclusions = new Set[0];exclusions=newSet[0]; }}  AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {AccessPath(SubAccessPath<FieldRefFieldRef>[]accesses,Set<FieldRefFieldRef>[]exclusions){ AccessPath(SubAccessPath<T>[] accesses, Set<T>[] exclusions) {AccessPath(SubAccessPath<TT>[]accesses,Set<TT>[]exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; }} public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<FieldRefFieldRef>...fieldReferences){ public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<TT>...fieldReferences){ outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {outer:for(inti=0;i<fieldReferences.length&&i<exclusions.length;i++){ for(FieldRef field : fieldReferences[i].elements()) {for(FieldRefFieldReffield:fieldReferences[i].elements()){ for(T field : fieldReferences[i].elements()) {for(TTfield:fieldReferences[i].elements()){ if(!exclusions[i].contains(field))if(!exclusions[i].contains(field)) continue outer;continueouter; }} return false;returnfalse; }}  public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {publicAccessPath<FieldRefFieldRef>addFieldReference(SubAccessPath<FieldRefFieldRef>...fieldReferences){ public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {publicAccessPath<TT>addFieldReference(SubAccessPath<TT>...fieldReferences){ return addFieldReference(true, fieldReferences);returnaddFieldReference(true,fieldReferences); }}   AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {AccessPath<FieldRef>addFieldReference(booleanmerge,SubAccessPath<FieldRef>...fieldReferences){ AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {AccessPath<T>addFieldReference(booleanmerge,SubAccessPath<T>...fieldReferences){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString()); finiteDepth = false;finiteDepth=false;  for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].intersects(fieldReferences[i])) {if(accesses[j].intersectsintersects(fieldReferences[i])){ if(accesses[j].shouldBeMerged(fieldReferences[i])) {if(accesses[j].shouldBeMergedshouldBeMerged(fieldReferences[i])){ // [..., {j-i}, ...]// [..., {j-i}, ...]  AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);AccessPathBuilderbuilder=newAccessPathBuilder(j+fieldReferences.length-i); return builder.build();returnbuilder.build(); }}  public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRefFieldRef>addFieldReference(FieldRefFieldRef...fieldReferences){ SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];SubAccessPath<FieldRefFieldRef>[]subPath=newSubAccessPath[fieldReferences.length]; public AccessPath<T> addFieldReference(T... fieldReferences) {publicAccessPath<TT>addFieldReference(TT...fieldReferences){ SubAccessPath<T>[] subPath = new SubAccessPath[fieldReferences.length];SubAccessPath<TT>[]subPath=newSubAccessPath[fieldReferences.length]; for(int i=0; i<fieldReferences.length; i++) {for(inti=0;i<fieldReferences.length;i++){ subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);subPath[i]=newSpecificFieldAccess<>(fieldReferences[i]); }}  private class AccessPathBuilder {privateclassAccessPathBuilder{  private Set<FieldRef>[] newExclusions;privateSet<FieldRefFieldRef>[]newExclusions; private SubAccessPath<FieldRef>[] newAccesses;privateSubAccessPath<FieldRefFieldRef>[]newAccesses; private Set<T>[] newExclusions;privateSet<TT>[]newExclusions; private SubAccessPath<T>[] newAccesses;privateSubAccessPath<TT>[]newAccesses; private int currentIndex = 0;privateintcurrentIndex=0; public AccessPathBuilder(int capacity) {publicAccessPathBuilder(intcapacity){ newExclusions = exclusions;newExclusions=exclusions; }}  public AccessPath<FieldRef> build() {publicAccessPath<FieldRefFieldRef>build(){ public AccessPath<T> build() {publicAccessPath<TT>build(){ while(newAccesses.length > 0 && newExclusions.length > 0) {while(newAccesses.length>0&&newExclusions.length>0){ HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);HashSet<FieldRefFieldRef>newHashSet=Sets.newHashSet(newExclusions[0]); HashSet<T> newHashSet = Sets.newHashSet(newExclusions[0]);HashSet<TT>newHashSet=Sets.newHashSet(newExclusions[0]); if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {if(newAccesses[newAccesses.length-1]instanceofSetOfPossibleFieldAccesses&&newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())){ if(newHashSet.isEmpty()) {if(newHashSet.isEmpty()){ removeExclusions(1);removeExclusions(1); newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);newExclusions=Arrays.copyOfRange(newExclusions,length,newExclusions.length); }} public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {publicvoidappend(SubAccessPath<FieldRefFieldRef>[]fieldReferences,intstart,intendExcl){ public void append(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {publicvoidappend(SubAccessPath<TT>[]fieldReferences,intstart,intendExcl){ for(int i=start; i<endExcl; i++) {for(inti=start;i<endExcl;i++){ newAccesses[currentIndex] = fieldReferences[i];newAccesses[currentIndex]=fieldReferences[i]; currentIndex++;currentIndex++; currentIndex+=endExcl-start;currentIndex+=endExcl-start; }} public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<FieldRefFieldRef>[]fieldReferences,intstart,intendExcl){ public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<TT>[]fieldReferences,intstart,intendExcl){ newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); }} public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {publicAccessPathBuildermerge(intsrcIndex,intdestIndexExcl){ Set<FieldRef> set = Sets.newHashSet();Set<FieldRefFieldRef>set=Sets.newHashSet(); Set<T> set = Sets.newHashSet();Set<TT>set=Sets.newHashSet(); for(int i=srcIndex; i<destIndexExcl; i++) {for(inti=srcIndex;i<destIndexExcl;i++){ set.addAll(accesses[i].elements());set.addAll(accesses[i].elements()); }} return this;returnthis; }} public void append(FieldRef fieldRef) {publicvoidappend(FieldRefFieldReffieldRef){ public void append(T fieldRef) {publicvoidappend(TTfieldRef){ newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);newAccesses[currentIndex]=newSubAccessPath.SpecificFieldAccess<>(fieldRef); currentIndex++;currentIndex++; }} return new ExclusionSet(index);returnnewExclusionSet(index); }}  public AccessPath<FieldRef> prepend(FieldRef fieldRef) {publicAccessPath<FieldRefFieldRef>prepend(FieldRefFieldReffieldRef){ public AccessPath<T> prepend(T fieldRef) {publicAccessPath<TT>prepend(TTfieldRef){ for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].contains(fieldRef)) {if(accesses[j].contains(fieldRef)){ // [{0-j}, ...]// [{0-j}, ...] return builder.build();returnbuilder.build(); }} public AccessPath<FieldRef> removeFirst(FieldRef field) {publicAccessPath<FieldRefFieldRef>removeFirst(FieldRefFieldReffield){ public AccessPath<T> removeFirst(T field) {publicAccessPath<TT>removeFirst(TTfield){ for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i].contains(field)) {if(accesses[i].contains(field)){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<FieldRefFieldRef>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<TT>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); elseelse return this;returnthis; }} throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this); }}  public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {publicAccessPath<FieldRefFieldRef>removeFirstExclusionSetIfAvailable(){ public AccessPath<T> removeFirstExclusionSetIfAvailable() {publicAccessPath<TT>removeFirstExclusionSetIfAvailable(){ if(exclusions.length > 0)if(exclusions.length>0) return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));returnnewAccessPath<FieldRefFieldRef>(accesses,Arrays.copyOfRange(exclusions,1,exclusions.length)); return new AccessPath<T>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));returnnewAccessPath<TT>(accesses,Arrays.copyOfRange(exclusions,1,exclusions.length)); elseelse return this;returnthis; }} public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {publicAccessPath<FieldRefFieldRef>mergeExcludedFieldReference(FieldRefFieldRef...fieldRef){ public AccessPath<T> mergeExcludedFieldReference(T... fieldRef) {publicAccessPath<TT>mergeExcludedFieldReference(TT...fieldRef){ if(exclusions.length>0)if(exclusions.length>0) return getExclusions(0).addExclusion(fieldRef);returngetExclusions(0).addExclusion(fieldRef); elseelse return appendExcludedFieldReference(fieldRef);returnappendExcludedFieldReference(fieldRef); }}  public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRefFieldRef>appendExcludedFieldReference(FieldRefFieldRef...fieldReferences){ Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);Set<FieldRefFieldRef>[]newExclusionsArray=Arrays.copyOf(exclusions,exclusions.length+1); public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<TT>appendExcludedFieldReference(TT...fieldReferences){ Set<T>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);Set<TT>[]newExclusionsArray=Arrays.copyOf(exclusions,exclusions.length+1); newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);newExclusionsArray[exclusions.length]=Sets.newHashSet(fieldReferences); return new AccessPath<>(accesses, newExclusionsArray);returnnewAccessPath<>(accesses,newExclusionsArray); }} }} }}  public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {publicPrefixTestResultisPrefixOf(AccessPath<FieldRefFieldRef>accPath){ public PrefixTestResult isPrefixOf(AccessPath<T> accPath) {publicPrefixTestResultisPrefixOf(AccessPath<TT>accPath){ int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0; PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;PrefixTestResultresult=PrefixTestResult.GUARANTEED_PREFIX;  int finalIndex = finalIndex();intfinalIndex=finalIndex(); outer: while(currIndex < finalIndex) {outer:while(currIndex<finalIndex){ Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);Collection<Transition<FieldRefFieldRef>>transitions=possibleTransitions(currIndex); Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);Collection<Transition<FieldRefFieldRef>>otherTransitions=accPath.possibleTransitions(otherIndex); Collection<Transition<T>> transitions = possibleTransitions(currIndex, true);Collection<Transition<TT>>transitions=possibleTransitions(currIndex,, truetrue); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, true);Collection<Transition<TT>>otherTransitions=accPath.possibleTransitions(otherIndex,, truetrue); if(transitions.size() > 1 && otherTransitions.size() > 1)if(transitions.size()>1&&otherTransitions.size()>1) throw new AssertionError();thrownewAssertionError();  for(Transition<FieldRef> transition : transitions) {for(Transition<FieldRef>transition:transitions){ for(Transition<FieldRef> otherTransition : otherTransitions) {for(Transition<FieldRef>otherTransition:otherTransitions){ MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<FieldRef>>match=transition.isPrefixMatchOf(otherTransition); for(Transition<T> transition : transitions) {for(Transition<T>transition:transitions){ for(Transition<T> otherTransition : otherTransitions) {for(Transition<T>otherTransition:otherTransitions){ MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<T>>match=transition.isPrefixMatchOf(otherTransition); if(match.hasMatched()) {if(match.hasMatched()){ if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())if(currIndex==transition.transitionToIndex()&&otherIndex==otherTransition.transitionToIndex()) throw new AssertionError();throwthrow newnew AssertionErrorAssertionError();() continue;continuecontinue;  currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex(); otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex(); return finalIndex;returnfinalIndex; }} private Collection<Transition<FieldRef>> possibleTransitions(int index) {privateCollection<Transition<FieldRefFieldRef>>possibleTransitions(intindex){ Collection<Transition<FieldRef>> result = Lists.newLinkedList();Collection<Transition<FieldRefFieldRef>>result=Lists.newLinkedList(); private Collection<Transition<T>> possibleTransitions(int index, boolean addExclusionTransitions) {privateCollection<Transition<TT>>possibleTransitions(intindex,, booleanboolean addExclusionTransitionsaddExclusionTransitions){ Collection<Transition<T>> result = Lists.newLinkedList();Collection<Transition<TT>>result=Lists.newLinkedList(); if(index < accesses.length) {if(index<accesses.length){ if(accesses[index] instanceof SetOfPossibleFieldAccesses) {if(accesses[index]instanceofSetOfPossibleFieldAccesses){ result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index,accesses[index])); result.addAll(possibleTransitions(index+1));result.addAll(possibleTransitions(index+1)); result.addAll(possibleTransitions(index+1, addExclusionTransitions));result.addAll(possibleTransitions(index+1,, addExclusionTransitionsaddExclusionTransitions)); }} elseelse result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index+1,accesses[index])); } else if(index - accesses.length < exclusions.length) {}elseif(index-accesses.length<exclusions.length){ result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));result.add(newTransition.ExclusionPathTransition<FieldRefFieldRef>(index+1,exclusions[index-accesses.length])); } else if(addExclusionTransitions && index - accesses.length < exclusions.length) {}elseif(addExclusionTransitionsaddExclusionTransitions &&&& index-accesses.length<exclusions.length){ result.add(new Transition.ExclusionPathTransition<T>(index+1, exclusions[index-accesses.length]));result.add(newTransition.ExclusionPathTransition<TT>(index+1,exclusions[index-accesses.length])); }} return result;returnresult; }}  public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {publicSubAccessPath<FieldRef>[]getDeltaTo(AccessPath<FieldRef>accPath){ int currentIndex = 0;intcurrentIndex=0; public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {publicSubAccessPath<T>[]getDeltaTo(AccessPath<T>accPath){ int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  for(SubAccessPath<FieldRef> sub : accesses) {for(SubAccessPath<FieldRef>sub:accesses){ if(!(sub instanceof SpecificFieldAccess))if(!(subinstanceofSpecificFieldAccess)) throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());thrownewIllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());  FieldRef field = sub.elements().iterator().next();FieldReffield=sub.elements().iterator().next();  while(true) {while(true){ if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {if(currentIndex<accPath.accesses.length&&accPath.accesses[currentIndex].contains(field)){ if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)if(accPath.accesses[currentIndex]instanceofSpecificFieldAccess) currentIndex++;currentIndex++; break;break; } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {}elseif(currentIndex<accPath.accesses.length&&accPath.accesses[currentIndex]instanceofSetOfPossibleFieldAccesses){ currentIndex++;currentIndex++; outer: while(true) {outer:while(true){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);Collection<Transition<T>>transitions=possibleTransitions(currIndex,false); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);Collection<Transition<T>>otherTransitions=accPath.possibleTransitions(otherIndex,false); for(Transition<T> transition : transitions) {for(Transition<T>transition:transitions){ for(Transition<T> otherTransition : otherTransitions) {for(Transition<T>otherTransition:otherTransitions){ MatchResult<Transition<T>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<T>>match=transition.isPrefixMatchOf(otherTransition); if(match.hasMatched()) {if(match.hasMatched()){ if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())if(currIndex==transition.transitionToIndex()&&otherIndex==otherTransition.transitionToIndex()) continue;continue;  currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex(); otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex(); continue outer;continueouter; }} }} elseelse throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);thrownewIllegalArgumentException("'"+toString()+"' is not a prefix of the given AccessPath: "+accPath); }} break;break; }}  return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,currentIndex,accPath.accesses.length); return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length); //		int currentIndex = 0;//		int currentIndex = 0;//		for(SubAccessPath<T> sub : accesses) {//		for(SubAccessPath<T> sub : accesses) {//			if(!(sub instanceof SpecificFieldAccess))//			if(!(sub instanceof SpecificFieldAccess))//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());//				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());//			//			//			T field = sub.elements().iterator().next();//			T field = sub.elements().iterator().next();//			//			//			while(true) {//			while(true) {//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {//				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)//					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)//						currentIndex++;//						currentIndex++;//					break;//					break;//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {//				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {//					currentIndex++;//					currentIndex++;//				}//				}//				else//				else//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);//					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);//			}//			}//		}//		}//		//		//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);//		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length); }}  public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRefFieldRef>mergeExcludedFieldReferences(AccessPath<FieldRefFieldRef>accPath){ Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];Set<FieldRefFieldRef>[]newExclusionArray=newSet[Math.max(exclusions.length,accPath.exclusions.length)]; public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {publicAccessPath<TT>mergeExcludedFieldReferences(AccessPath<TT>accPath){ Set<T>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];Set<TT>[]newExclusionArray=newSet[Math.max(exclusions.length,accPath.exclusions.length)]; for(int i=0; i<newExclusionArray.length; i++) {for(inti=0;i<newExclusionArray.length;i++){ newExclusionArray[i] = Sets.newHashSet();newExclusionArray[i]=Sets.newHashSet(); if(i<exclusions.length)if(i<exclusions.length) @Override@Override public String toString() {publicStringtoString(){ String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; for(Set<FieldRef> exclusion : exclusions) {for(Set<FieldRefFieldRef>exclusion:exclusions){ for(Set<T> exclusion : exclusions) {for(Set<TT>exclusion:exclusions){ result += "^" + Joiner.on(",").join(exclusion);result+="^"+Joiner.on(",").join(exclusion); }} return result;returnresult; this.index = index;this.index=index; }}  public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {publicAccessPath<FieldRefFieldRef>addExclusion(FieldRefFieldRef...exclusion){ HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);HashSet<FieldRefFieldRef>newExclusions=Sets.newHashSet(exclusions[index]); for(FieldRef excl : exclusion)for(FieldRefFieldRefexcl:exclusion) public AccessPath<T> addExclusion(T... exclusion) {publicAccessPath<TT>addExclusion(TT...exclusion){ HashSet<T> newExclusions = Sets.newHashSet(exclusions[index]);HashSet<TT>newExclusions=Sets.newHashSet(exclusions[index]); for(T excl : exclusion)for(TTexcl:exclusion) newExclusions.add(excl);newExclusions.add(excl); Set<FieldRef>[] newExclusionsArray = exclusions.clone();Set<FieldRefFieldRef>[]newExclusionsArray=exclusions.clone(); Set<T>[] newExclusionsArray = exclusions.clone();Set<TT>[]newExclusionsArray=exclusions.clone(); newExclusionsArray[index] = newExclusions;newExclusionsArray[index]=newExclusions; return new AccessPath<FieldRef>(accesses, newExclusionsArray);returnnewAccessPath<FieldRefFieldRef>(accesses,newExclusionsArray); return new AccessPath<T>(accesses, newExclusionsArray);returnnewAccessPath<TT>(accesses,newExclusionsArray); }} }} public AccessPath<FieldRef> removeAnyAccess() {publicAccessPath<FieldRefFieldRef>removeAnyAccess(){ public AccessPath<T> removeAnyAccess() {publicAccessPath<TT>removeAnyAccess(){ if(accesses.length > 0)if(accesses.length>0) return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);returnnewAccessPath<FieldRefFieldRef>(newSubAccessPath[0],exclusions); return new AccessPath<T>(new SubAccessPath[0], exclusions);returnnewAccessPath<TT>(newSubAccessPath[0],exclusions); elseelse return this;returnthis; }}








src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......












src/heros/alias/AccessPathUtil.java








View file @ d7cafbe8








src/heros/alias/AccessPathUtil.java










View file @ d7cafbe8


d7cafbe8



......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......






......@@ -20,7 +20,7 @@ import com.google.common.collect.Sets;




















public class AccessPathUtil {





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;



......@@ -30,7 +30,7 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 



......@@ -51,7 +51,7 @@ public class AccessPathUtil {









 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else



......


public class AccessPathUtil {publicclassAccessPathUtil{ public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {publicstatic<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>PrefixTestResultisPrefixOf(DprefixCandidate,Dfact){ public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {publicstatic<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<?,FieldRef,D>>PrefixTestResultisPrefixOf(DprefixCandidate,Dfact){ if(prefixCandidate.getBaseValue() == null) {if(prefixCandidate.getBaseValue()==null){ if(fact.getBaseValue() != null)if(fact.getBaseValue()!=null) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());returnprefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath()); }} public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result)); }} public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {publicstatic<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>DcloneWithAccessPath(Dfact,AccessPath<FieldRef>accPath){ public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {publicstatic<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<?,FieldRef,D>>DcloneWithAccessPath(Dfact,AccessPath<FieldRef>accPath){ if(fact.getAccessPath().equals(accPath))if(fact.getAccessPath().equals(accPath)) return fact;returnfact; elseelse








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......












src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ d7cafbe8








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java










View file @ d7cafbe8


d7cafbe8



......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......


 * @param <M> see {@link IFDSSolver} * @param <M> see {@link IFDSSolver} * @param <I> see {@link IFDSSolver} * @param <I> see {@link IFDSSolver} */ */public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassBiDiFieldSensitiveIFDSSolver<N,BaseValue,FieldRef,DextendsFieldSensitiveFact<BaseValue,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>{public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassBiDiFieldSensitiveIFDSSolver<N,BaseValue,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<BaseValue,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>{ private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;privatefinalIFDSTabulationProblem<N,FieldRef,AbstractionWithSourceStmt,M,I>forwardProblem; private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;privatefinalIFDSTabulationProblem<N,FieldRef,AbstractionWithSourceStmt,M,I>backwardProblem;








src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......












src/heros/alias/DeltaConstraint.java








View file @ d7cafbe8








src/heros/alias/DeltaConstraint.java










View file @ d7cafbe8


d7cafbe8



......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {










public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;



......


import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {publicclassDeltaConstraint<FieldRef>implementsConstraint<FieldRef>{public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassDeltaConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsConstraint<FieldRef>{ private SubAccessPath<FieldRef>[] delta;privateSubAccessPath<FieldRef>[]delta; private AccessPath<FieldRef> accPathAtCallee;privateAccessPath<FieldRef>accPathAtCallee;








src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......












src/heros/alias/FieldSensitiveFact.java








View file @ d7cafbe8








src/heros/alias/FieldSensitiveFact.java










View file @ d7cafbe8


d7cafbe8



......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{










public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 



......


import heros.solver.LinkedNode;importheros.solver.LinkedNode;public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{publicinterfaceFieldSensitiveFact<BaseValue,FieldRef,D>extendsLinkedNode<D>{public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{publicinterfaceFieldSensitiveFact<BaseValue,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>D>extendsLinkedNode<D>{ BaseValue getBaseValue();BaseValuegetBaseValue(); 








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d7cafbe8








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ d7cafbe8


d7cafbe8



......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......






......@@ -41,7 +41,7 @@ import com.google.common.collect.HashMultimap;









import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -643,11 +643,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










//						System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;



......


import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,FieldRef,DextendsFieldSensitiveFact<BaseValue,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>{public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<BaseValue,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>{ public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevelpublicstaticCacheBuilder<Object,Object>DEFAULT_CACHE_BUILDER=CacheBuilder.newBuilder().concurrencyLevel System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d",cacheHits,cache.get(key).size())); System.out.println(edge);System.out.println(edge); System.out.println(icfg.getMethodOf(edge.getTarget()));System.out.println(icfg.getMethodOf(edge.getTarget())); System.out.println("---");System.out.println("---");//						System.out.println("---");//						System.out.println("---");////						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//							System.out.println(cachedEdge);//							System.out.println(cachedEdge);//						}//						} System.out.println("---");System.out.println("---");//						System.out.println("---");//						System.out.println("---");// }} cacheHits++;cacheHits++;//					boolean opposite = false;//					boolean opposite = false;








src/heros/alias/FlowFunction.java








View file @ d7cafbe8






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......












src/heros/alias/FlowFunction.java








View file @ d7cafbe8








src/heros/alias/FlowFunction.java










View file @ d7cafbe8


d7cafbe8



......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......






......@@ -31,14 +31,14 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 










 public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private Constraint<FieldRef> constraint;



......@@ -98,13 +98,13 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public interface Constraint<FieldRef> {










 public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {



......@@ -152,7 +152,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;














......


 *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {publicinterfaceFlowFunction<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>{public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {publicinterfaceFlowFunction<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<?,FieldRef,D>>{ /**/**	 * Returns the target values reachable from the source.	 * Returns the target values reachable from the source.	 */	 */ Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);Set<ConstrainedFact<FieldRef,D>>computeTargets(Dsource);  public static class ConstrainedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {publicstaticclassConstrainedFact<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>{ public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {publicstaticclassConstrainedFact<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<?,FieldRef,D>>{  private D fact;privateDfact; private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint; }} }}  public interface Constraint<FieldRef> {publicinterfaceConstraint<FieldRef>{ public interface Constraint<FieldRef extends AccessPath.FieldRef<FieldRef>> {publicinterfaceConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>{ AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);AccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,booleansourceFact);  boolean canBeAppliedTo(AccessPath<FieldRef> accPath);booleancanBeAppliedTo(AccessPath<FieldRef>accPath); }}  public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {publicclassWriteFieldConstraint<FieldRef>implementsConstraint<FieldRef>{ public class WriteFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassWriteFieldConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsConstraint<FieldRef>{ private FieldRef fieldRef;privateFieldReffieldRef; public WriteFieldConstraint(FieldRef fieldRef) {publicWriteFieldConstraint(FieldReffieldRef){ }} }}  public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {publicclassReadFieldConstraint<FieldRef>implementsConstraint<FieldRef>{ public class ReadFieldConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassReadFieldConstraint<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsConstraint<FieldRef>{ private FieldRef fieldRef;privateFieldReffieldRef;








src/heros/alias/FlowFunctions.java








View file @ d7cafbe8






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......












src/heros/alias/FlowFunctions.java








View file @ d7cafbe8








src/heros/alias/FlowFunctions.java










View file @ d7cafbe8


d7cafbe8



......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......


 *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. */ */public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {publicinterfaceFlowFunctions<Stmt,FieldRef,FextendsFieldSensitiveFact<?,FieldRef,F>,Method>{public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {publicinterfaceFlowFunctions<Stmt,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>FextendsFieldSensitiveFact<?,FieldRef,F>,Method>{ /**/**	 * Returns the flow function that computes the flow for a normal statement,	 * Returns the flow function that computes the flow for a normal statement,








src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......












src/heros/alias/IFDSTabulationProblem.java








View file @ d7cafbe8








src/heros/alias/IFDSTabulationProblem.java










View file @ d7cafbe8


d7cafbe8



......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......


 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>,>DextendsFieldSensitiveFact<?,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{ /**/**	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * Returns a set of flow functions. Those functions are used to compute data-flow facts








src/heros/alias/SubAccessPath.java








View file @ d7cafbe8






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......












src/heros/alias/SubAccessPath.java








View file @ d7cafbe8








src/heros/alias/SubAccessPath.java










View file @ d7cafbe8


d7cafbe8



......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......






......@@ -22,10 +22,14 @@ import com.google.common.collect.Lists;









import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();



......@@ -33,7 +37,7 @@ public interface SubAccessPath<FieldRef> {









 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {



......@@ -93,9 +97,19 @@ public interface SubAccessPath<FieldRef> {









 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 



......@@ -165,6 +179,24 @@ public interface SubAccessPath<FieldRef> {









 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 










 }



......


import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public interface SubAccessPath<FieldRef> {publicinterfaceSubAccessPath<FieldRef>{public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {publicinterfaceSubAccessPath<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>{  boolean contains(FieldRef field);booleancontains(FieldReffield);  boolean shouldBeMerged(FieldRef field);booleanshouldBeMerged(FieldReffield); boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);booleanshouldBeMerged(SubAccessPath<FieldRef>accPath); boolean intersects(SubAccessPath<FieldRef> accPath);booleanintersects(SubAccessPath<FieldRef>accPath); Collection<? extends FieldRef> elements();Collection<?extendsFieldRef>elements(); SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);SetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields);  public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {publicstaticclassSpecificFieldAccess<FieldRef>implementsSubAccessPath<FieldRef>{ public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {publicstaticclassSpecificFieldAccess<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsSubAccessPath<FieldRef>{ private final FieldRef field;privatefinalFieldReffield;  public SpecificFieldAccess(FieldRef field) {publicSpecificFieldAccess(FieldReffield){ public boolean intersects(SubAccessPath<FieldRef> accPath) {publicbooleanintersects(SubAccessPath<FieldRef>accPath){ return accPath.contains(field);returnaccPath.contains(field); }} @Override@Override public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {publicbooleanshouldBeMerged(SubAccessPath<FieldRef>accPath){ return accPath.shouldBeMerged(field);returnaccPath.shouldBeMerged(field); }} @Override@Override public boolean shouldBeMerged(FieldRef field) {publicbooleanshouldBeMerged(FieldReffield){ return this.field.shouldBeMergedWith(field);returnthis.field.shouldBeMergedWith(field); }} }}  public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {publicstaticclassSetOfPossibleFieldAccesses<FieldRef>implementsSubAccessPath<FieldRef>{ public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {publicstaticclassSetOfPossibleFieldAccesses<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsSubAccessPath<FieldRef>{  private final Set<FieldRef> set;privatefinalSet<FieldRef>set;  }} return false;returnfalse; }} @Override@Override public boolean shouldBeMerged(FieldRef field) {publicbooleanshouldBeMerged(FieldReffield){ for(FieldRef f : set) {for(FieldReff:set){ if(f.shouldBeMergedWith(field))if(f.shouldBeMergedWith(field)) return true;returntrue; }} return false;returnfalse; }} @Override@Override public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {publicbooleanshouldBeMerged(SubAccessPath<FieldRef>accPath){ for(FieldRef f : set) {for(FieldReff:set){ if(accPath.shouldBeMerged(f))if(accPath.shouldBeMerged(f)) return true;returntrue; }} return false;returnfalse; }}   }}








test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......












test/heros/alias/Transition.java

→

src/heros/alias/Transition.java








View file @ d7cafbe8








test/heros/alias/Transition.java

→

src/heros/alias/Transition.java





testsrc




View file @ d7cafbe8


d7cafbe8



......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......






......@@ -22,7 +22,7 @@ public interface Transition<FieldRef> {









 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;



......@@ -49,7 +49,7 @@ public interface Transition<FieldRef> {









 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;



......


 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);MatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t);   public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {publicstaticclassSubAccessPathTransition<FieldRef>implementsTransition<FieldRef>{ public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {publicstaticclassSubAccessPathTransition<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsTransition<FieldRef>{  private int transitionToIndex;privateinttransitionToIndex; private SubAccessPath<FieldRef> subAccPath;privateSubAccessPath<FieldRef>subAccPath; }} }}  public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {publicstaticclassExclusionPathTransition<FieldRef>implementsTransition<FieldRef>{ public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {publicstaticclassExclusionPathTransition<FieldRef extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldRefFieldRef>>>implementsTransition<FieldRef>{  private Set<FieldRef> excludedFields;privateSet<FieldRef>excludedFields; private int transitionToIndex;privateinttransitionToIndex;








test/heros/alias/AccessPathTest.java








View file @ d7cafbe8






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}












test/heros/alias/AccessPathTest.java








View file @ d7cafbe8








test/heros/alias/AccessPathTest.java










View file @ d7cafbe8


d7cafbe8



......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}






......@@ -25,159 +25,174 @@ import heros.alias.SubAccessPath.*;









@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 private static FieldRef f(String s) {










 return new FieldRef(s);










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 private static FieldRef[] f(String...s) {










 FieldRef[] result = new FieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {










 Set<FieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new FieldRef(f));










 return new SetOfPossibleFieldAccesses<FieldRef>(set);










 }










 










 private static SpecificFieldAccess<FieldRef> s(String field) {










 return new SpecificFieldAccess<FieldRef>(new FieldRef(field));










 }










 










 private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {










 return new AccessPath<FieldRef>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 AccessPath<FieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......@@ -197,7 +212,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));



......@@ -206,7 +221,7 @@ public class AccessPathTest {









 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));



......@@ -216,10 +231,10 @@ public class AccessPathTest {









 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }










}


@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPathTest {publicclassAccessPathTest{ private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {privatestaticSetOfPossibleFieldAccessesSetOfPossibleFieldAccesses<<StringString>> anyOfanyOf((StringString......fieldsfield){ return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));returnnewSetOfPossibleFieldAccessesSetOfPossibleFieldAccesses<<StringString>(>(SetsSets..newHashSetnewHashSet((fieldsfields));) private static FieldRef f(String s) {privatestaticFieldRefFieldRef ff((StringString s){ return new FieldRef(s);returnnewFieldRefFieldRef((ss); }}  private static SpecificFieldAccess<String> s(String field) {privatestaticSpecificFieldAccess<String>s(Stringfield){ return new SpecificFieldAccess<String>(field);returnnewSpecificFieldAccess<String>(field); private static FieldRef[] f(String...s) {privatestaticFieldRef[]f(String...s){ FieldRef[] result = new FieldRef[s.length];FieldRef[]result=newFieldRef[s.length]; for(int i=0; i<s.length; i++) {for(inti=0;i<s.length;i++){ result[i] = f(s[i]);result[i]=f(s[i]); }} return result;returnresult; }}  private static AccessPath<String> ap(SubAccessPath<String>... path) {privatestaticAccessPath<String>ap(SubAccessPath<String>...path){ return new AccessPath<String>(path, new Set[0]);returnnewAccessPath<String>(path,newSet[0]); private static SetOfPossibleFieldAccesses<FieldRef> anyOf(String...fields) {privatestaticSetOfPossibleFieldAccesses<FieldRef>anyOf(String...fields){ Set<FieldRef> set = Sets.newHashSet();Set<FieldRef>set=Sets.newHashSet(); for(String f : fields)for(Stringf:fields) set.add(new FieldRef(f));set.add(newFieldRef(f)); return new SetOfPossibleFieldAccesses<FieldRef>(set);returnnewSetOfPossibleFieldAccesses<FieldRef>(set); }}  private static SpecificFieldAccess<FieldRef> s(String field) {privatestaticSpecificFieldAccess<FieldRef>s(Stringfield){ return new SpecificFieldAccess<FieldRef>(new FieldRef(field));returnnewSpecificFieldAccess<FieldRef>(newFieldRef(field)); }}  private static AccessPath<FieldRef> ap(SubAccessPath<FieldRef>... path) {privatestaticAccessPath<FieldRef>ap(SubAccessPath<FieldRef>...path){ return new AccessPath<FieldRef>(path, new Set[0]);returnnewAccessPath<FieldRef>(path,newSet[0]); }}  @Test@Test public void addAndMergeAll() {publicvoidaddAndMergeAll(){ AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");AccessPath<StringString>sut=AccessPath.<StringString>empty().addFieldReference("a","b","c"); assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));assertEquals(ap(anyOf("a","b","c")),sut.addFieldReference("a")); AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));AccessPath<FieldRefFieldRef>sut=AccessPath.<FieldRefFieldRef>empty().addFieldReference(ff(("a","b","c"));) assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));assertEquals(ap(anyOf("a","b","c")),sut.addFieldReference(ff(("a")));) }} @Test@Test public void addAndMergeSuffix() {publicvoidaddAndMergeSuffix(){ AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");AccessPath<StringString>sut=AccessPath.<StringString>empty().addFieldReference("a","b","c"); assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));assertEquals(ap(s("a"),anyOf("b","c")),sut.addFieldReference("b")); AccessPath<FieldRef> sut = AccessPath.<FieldRef>empty().addFieldReference(f("a", "b", "c"));AccessPath<FieldRefFieldRef>sut=AccessPath.<FieldRefFieldRef>empty().addFieldReference(ff(("a","b","c"));) assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));assertEquals(ap(s("a"),anyOf("b","c")),sut.addFieldReference(ff(("b")));) }}  @Test@Test public void addWithoutMerge() {publicvoidaddWithoutMerge(){ AccessPath<String> sut = ap(s("a"));AccessPath<StringString>sut=ap(s("a")); assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));assertEquals(ap(s("a"),s("b")),sut.addFieldReference("b")); AccessPath<FieldRef> sut = ap(s("a"));AccessPath<FieldRefFieldRef>sut=ap(s("a")); assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));assertEquals(ap(s("a"),s("b")),sut.addFieldReference(ff(("b")));) }}  @Test@Test public void addMergedFields() {publicvoidaddMergedFields(){ AccessPath<String> sut = ap(s("a"));AccessPath<StringString>sut=ap(s("a")); AccessPath<FieldRef> sut = ap(s("a"));AccessPath<FieldRefFieldRef>sut=ap(s("a")); assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));assertEquals(ap(anyOf("a")),sut.addFieldReference(anyOf("a"))); }} @Test@Test public void addMergedFieldsOnExclusion() {publicvoidaddMergedFieldsOnExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("a"));) assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}  @Test@Test public void addMergedFieldsOnNestedExclusion() {publicvoidaddMergedFieldsOnNestedExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("a")).)appendExcludedFieldReference(ff(("b"));) assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}  @Test@Test public void addFieldThatMerges() {publicvoidaddFieldThatMerges(){ AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");AccessPath<StringString>sut=ap(s("a"),s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x"); assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")).appendExcludedFieldReference("x"),sut.addFieldReference(s("a"))); AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("x"));AccessPath<FieldRefFieldRef>sut=ap(s("a"),s("b")).appendExcludedFieldReference(ff(("c")).)appendExcludedFieldReference(ff(("x"));) assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference(f("x")), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")).appendExcludedFieldReference(ff(("x")),)sut.addFieldReference(s("a"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField(){ AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");AccessPath<StringString>sut=ap(s("a"),s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b"); AccessPath<FieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));AccessPath<FieldRefFieldRef>sut=ap(s("a"),s("b")).appendExcludedFieldReference(ff(("c")).)appendExcludedFieldReference(ff(("b"));) assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(s("a"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField2() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField2(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("a")).)appendExcludedFieldReference(ff(("b"));) assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));assertEquals(ap(anyOf("a","c")),sut.addFieldReference(anyOf("a","c"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField3() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField3(){ AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<StringString>sut=ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b"); AccessPath<FieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<FieldRefFieldRef>sut=ap(s("c")).appendExcludedFieldReference(ff(("a")).)appendExcludedFieldReference(ff(("b"));) assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));assertEquals(ap(anyOf("c")),sut.addFieldReference(anyOf("c"))); }}  @Test@Test public void addOnExclusion() {publicvoidaddOnExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));assertEquals(ap(s("b")).appendExcludedFieldReference("b"),sut.addFieldReference(s("b"))); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("a")).)appendExcludedFieldReference(ff(("b"));) assertEquals(ap(s("b")).appendExcludedFieldReference(f("b")), sut.addFieldReference(s("b")));assertEquals(ap(s("b")).appendExcludedFieldReference(ff(("b")),)sut.addFieldReference(s("b"))); }}  @Test@Test public void addOnNestedExclusion() {publicvoidaddOnNestedExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("a")).)appendExcludedFieldReference(ff(("b"));) assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));assertEquals(ap(anyOf("a","c")),sut.addFieldReference(anyOf("a","c"))); }} @Test(expected=IllegalArgumentException.class)@Test(expected=IllegalArgumentException.class) public void addMergedFieldsOnSingleExclusion() {publicvoidaddMergedFieldsOnSingleExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("a"));) sut.addFieldReference(anyOf("a")); sut.addFieldReference(anyOf("a")); }}  @Test@Test public void prependWithoutMerge() {publicvoidprependWithoutMerge(){ assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));assertEquals(ap(s("c"),s("a"),s("b")),ap(s("a"),s("b")).prepend("c")); assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));assertEquals(ap(s("c"),s("a"),s("b")),ap(s("a"),s("b")).prepend(ff(("c")));) }}  @Test@Test public void prependWithMerge() {publicvoidprependWithMerge(){ assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));assertEquals(ap(anyOf("a"),anyOf("b","c")),ap(s("a"),anyOf("b","c")).prepend("a")); assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));assertEquals(ap(anyOf("a"),anyOf("b","c")),ap(s("a"),anyOf("b","c")).prepend(ff(("a")));) }}  @Test@Test public void prependAndMergeWithSet() {publicvoidprependAndMergeWithSet(){ assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));assertEquals(ap(anyOf("a","b","c")),ap(s("a"),anyOf("b","c")).prepend("b")); assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));assertEquals(ap(anyOf("a","b","c")),ap(s("a"),anyOf("b","c")).prepend(ff(("b")));) }}  @Test@Test public void remove() {publicvoidremove(){ assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));assertEquals(ap(s("b")),ap(s("a"),s("b")).removeFirst("a")); assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));assertEquals(ap(s("b")),ap(s("a"),s("b")).removeFirst(ff(("a")));) }}  @Test@Test public void dontRemoveMergedFields() {publicvoiddontRemoveMergedFields(){ assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));assertEquals(ap(anyOf("a","b")),ap(anyOf("a","b")).removeFirst("a")); assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));assertEquals(ap(anyOf("a","b")),ap(anyOf("a","b")).removeFirst(ff(("a")));) }}  @Test@Test public void removeMergedFieldsIfRemovingSuffix() {publicvoidremoveMergedFieldsIfRemovingSuffix(){ assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));assertEquals(ap(),ap(anyOf("a","b"),s("c")).removeFirst("c")); assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));assertEquals(ap(),ap(anyOf("a","b"),s("c")).removeFirst(ff(("c")));) }}  @Test@Test public void deltaDepth1() {publicvoiddeltaDepth1(){ SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));SubAccessPath<StringString>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"))); SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));SubAccessPath<FieldRefFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"))); assertArrayEquals(new SubAccessPath[] { s("b") }, actual);assertArrayEquals(newSubAccessPath[]{s("b")},actual); }}  @Test@Test public void deltaDepth2() {publicvoiddeltaDepth2(){ SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));SubAccessPath<StringString>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"),s("c"))); SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));SubAccessPath<FieldRefFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"),s("c"))); assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);assertArrayEquals(newSubAccessPath[]{s("b"),s("c")},actual); }}  @Test@Test public void delta() {publicvoiddelta(){ SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<StringString>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),anyOf("b"))); SubAccessPath<FieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<FieldRefFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),anyOf("b"))); assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}  @Test@Test public void delta2() {publicvoiddelta2(){ SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));SubAccessPath<StringString>[]actual=ap(s("f"),s("g"),s("h")).getDeltaTo(ap(anyOf("f","g"),s("h"))); SubAccessPath<FieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));SubAccessPath<FieldRefFieldRef>[]actual=ap(s("f"),s("g"),s("h")).getDeltaTo(ap(anyOf("f","g"),s("h"))); assertArrayEquals(new SubAccessPath[] { }, actual);assertArrayEquals(newSubAccessPath[]{},actual); }}  @Test@Test public void delta3() {publicvoiddelta3(){ SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));SubAccessPath<StringString>[]actual=ap(s("f"),s("f")).getDeltaTo(ap(anyOf("f"))); SubAccessPath<FieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));SubAccessPath<FieldRefFieldRef>[]actual=ap(s("f"),s("f")).getDeltaTo(ap(anyOf("f"))); assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);assertArrayEquals(newSubAccessPath[]{anyOf("f")},actual); }}  @Test@Test public void deltaMatchingMergedField() {publicvoiddeltaMatchingMergedField(){ SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<StringString>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b"))); SubAccessPath<FieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<FieldRefFieldRef>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b"))); assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}   @Test@Test public void prefixOfExclusion() {publicvoidprefixOfExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("f");AccessPath<StringString>sut=ap().appendExcludedFieldReference("f"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("f"));) assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("g"))));  @Test@Test public void prefixOfExclusions() {publicvoidprefixOfExclusions(){ AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");AccessPath<StringString>sut=ap().appendExcludedFieldReference("f","g"); AccessPath<FieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));AccessPath<FieldRefFieldRef>sut=ap().appendExcludedFieldReference(ff(("f","g"));) assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f"),s("h")))); public void mergedFieldsPrefixOf() {publicvoidmergedFieldsPrefixOf(){ assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f"))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f","g"))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(ff(("f"))));) assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(ff(("f","g"))));)  assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f"),s("h")).isPrefixOf(ap(s("f"),s("h")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"),s("h")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).appendExcludedFieldReference(ff(("f")).)isPrefixOf(ap(s("f"),s("h")))); }}}}








test/heros/alias/Fact.java








View file @ d7cafbe8






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......












test/heros/alias/Fact.java








View file @ d7cafbe8








test/heros/alias/Fact.java










View file @ d7cafbe8


d7cafbe8



......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......






......@@ -20,15 +20,15 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, String, Fact> {










public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<String> accessPath;










 public final AccessPath<FieldRef> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<FieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();



......@@ -42,16 +42,20 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 accessPath = accessPath.addFieldReference(new FieldRef(identifier));










 } else {










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 String[] excl = identifier.split(",");










 FieldRef[] fExcl = new FieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new FieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, AccessPath<String> accessPath) {










 public Fact(String baseValue, AccessPath<FieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }



......@@ -67,7 +71,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public AccessPath<String> getAccessPath() {










 public AccessPath<FieldRef> getAccessPath() {










 return accessPath;










 }














......@@ -113,7 +117,7 @@ public class Fact implements FieldSensitiveFact<String, String, Fact> {









 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......


import com.google.common.collect.Lists;importcom.google.common.collect.Lists;public class Fact implements FieldSensitiveFact<String, String, Fact> {publicclassFactimplementsFieldSensitiveFact<String,StringString,Fact>{public class Fact implements FieldSensitiveFact<String, FieldRef, Fact> {publicclassFactimplementsFieldSensitiveFact<String,FieldRefFieldRef,Fact>{ public final String baseValue;publicfinalStringbaseValue; public final AccessPath<String> accessPath;publicfinalAccessPath<StringString>accessPath; public final AccessPath<FieldRef> accessPath;publicfinalAccessPath<FieldRefFieldRef>accessPath;  public Fact(String name) {publicFact(Stringname){ Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)([^\\.\\^]+)"); Matcher matcher = pattern.matcher(name);Matchermatcher=pattern.matcher(name); AccessPath<String> accessPath = new AccessPath<>();AccessPath<StringString>accessPath=newAccessPath<>(); AccessPath<FieldRef> accessPath = new AccessPath<>();AccessPath<FieldRefFieldRef>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  int firstSeparator = matcher.find() ? matcher.start() : name.length();intfirstSeparator=matcher.find()?matcher.start():name.length(); if(separator.equals(".")) {if(separator.equals(".")){ if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.addFieldReference(identifier);accessPath=accessPath.addFieldReference(identifier); accessPath = accessPath.addFieldReference(new FieldRef(identifier));accessPath=accessPath.addFieldReference(newnew FieldRefFieldRef((identifier));) } else {}else{ addedExclusions=true;addedExclusions=true; accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));accessPath=accessPath.appendExcludedFieldReference(identifier.split(",")); String[] excl = identifier.split(",");String[]excl=identifier.split(","); FieldRef[] fExcl = new FieldRef[excl.length];FieldRef[]fExcl=newFieldRef[excl.length]; for(int i=0; i<excl.length; i++)for(inti=0;i<excl.length;i++) fExcl[i] = new FieldRef(excl[i]);fExcl[i]=newFieldRef(excl[i]); accessPath = accessPath.appendExcludedFieldReference(fExcl);accessPath=accessPath.appendExcludedFieldReference(fExcl); }} }} this.accessPath = accessPath;this.accessPath=accessPath; }}  public Fact(String baseValue, AccessPath<String> accessPath) {publicFact(StringbaseValue,AccessPath<StringString>accessPath){ public Fact(String baseValue, AccessPath<FieldRef> accessPath) {publicFact(StringbaseValue,AccessPath<FieldRefFieldRef>accessPath){ this.baseValue = baseValue;this.baseValue=baseValue; this.accessPath = accessPath;this.accessPath=accessPath; }} }} @Override@Override public AccessPath<String> getAccessPath() {publicAccessPath<StringString>getAccessPath(){ public AccessPath<FieldRef> getAccessPath() {publicAccessPath<FieldRefFieldRef>getAccessPath(){ return accessPath;returnaccessPath; }} }} @Override@Override public Fact cloneWithAccessPath(AccessPath<String> accessPath) {publicFactcloneWithAccessPath(AccessPath<StringString>accessPath){ public Fact cloneWithAccessPath(AccessPath<FieldRef> accessPath) {publicFactcloneWithAccessPath(AccessPath<FieldRefFieldRef>accessPath){ return new Fact(baseValue, accessPath);returnnewFact(baseValue,accessPath); }} 








test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file












test/heros/alias/FieldRef.java



0 → 100644







View file @ d7cafbe8








test/heros/alias/FieldRef.java



0 → 100644









View file @ d7cafbe8


d7cafbe8










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















class FieldRef implements AccessPath.FieldRef<FieldRef> {










 










 private String f;





















 public FieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(FieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof FieldRef))










 return false;










 FieldRef other = (FieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;class FieldRef implements AccessPath.FieldRef<FieldRef> {classFieldRefimplementsAccessPath.FieldRef<FieldRef>{  private String f;privateStringf; public FieldRef(String f) {publicFieldRef(Stringf){ this.f = f;this.f=f; }}  @Override@Override public boolean shouldBeMergedWith(FieldRef fieldRef) {publicbooleanshouldBeMergedWith(FieldReffieldRef){ return f.equals(fieldRef.f);returnf.equals(fieldRef.f); }}  @Override@Override public String toString() {publicStringtoString(){ return f;returnf; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((f == null) ? 0 : f.hashCode());result=prime*result+((f==null)?0:f.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof FieldRef))if(!(objinstanceofFieldRef)) return false;returnfalse; FieldRef other = (FieldRef) obj;FieldRefother=(FieldRef)obj; if (f == null) {if(f==null){ if (other.f != null)if(other.f!=null) return false;returnfalse; } else if (!f.equals(other.f))}elseif(!f.equals(other.f)) return false;returnfalse; return true;returntrue; }}}}








test/heros/alias/TestHelper.java








View file @ d7cafbe8






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......












test/heros/alias/TestHelper.java








View file @ d7cafbe8








test/heros/alias/TestHelper.java










View file @ d7cafbe8


d7cafbe8



......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......






......@@ -90,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 public static Constraint<FieldRef> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {










 ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);










 targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -302,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final ConstrainedFact<String, Fact>[] targets;










 public final ConstrainedFact<FieldRef, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -438,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {










 public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, FieldRef, Fact, Method>() {





















 @Override










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -454,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -464,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -474,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -483,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<FieldRef, Fact>() {










 @Override










 public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();










 public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {










 Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -510,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -543,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......


 return new ExpectedFlowFunction(times, new Fact(source));returnnewExpectedFlowFunction(times,newFact(source)); }} public static Constraint<String> readField(String fieldName) {publicstaticConstraint<StringString>readField(StringfieldName){ return new FlowFunction.ReadFieldConstraint<String>(fieldName);returnnewFlowFunction.ReadFieldConstraint<StringString>(>fieldName); public static Constraint<FieldRef> readField(String fieldName) {publicstaticConstraint<FieldRefFieldRef>readField(StringfieldName){ return new FlowFunction.ReadFieldConstraint<FieldRef>(new FieldRef(fieldName));returnnewFlowFunction.ReadFieldConstraint<FieldRefFieldRef>(>(newnew FieldRefFieldRef(fieldName));) }}  public static Constraint<String> writeField(String fieldName) {publicstaticConstraint<StringString>writeField(StringfieldName){ return new FlowFunction.WriteFieldConstraint<String>(fieldName);returnnewFlowFunction.WriteFieldConstraint<StringString>(>fieldName); public static Constraint<FieldRef> writeField(String fieldName) {publicstaticConstraint<FieldRefFieldRef>writeField(StringfieldName){ return new FlowFunction.WriteFieldConstraint<FieldRef>(new FieldRef(fieldName));returnnewFlowFunction.WriteFieldConstraint<FieldRefFieldRef>(>(newnew FieldRefFieldRef(fieldName));) }}  public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,Constraint<StringString>constraint,String...targets){ public static ExpectedFlowFunction flow(String source, Constraint<FieldRef> constraint, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,Constraint<FieldRefFieldRef>constraint,String...targets){ return flow(1, source, constraint, targets);returnflow(1,source,constraint,targets); }}  public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,Constraint<StringString>constraint,String...targets){ ConstrainedFact<String, Fact>[] targetFacts = new ConstrainedFact[targets.length];ConstrainedFact<StringString,Fact>[]targetFacts=newConstrainedFact[targets.length]; public static ExpectedFlowFunction flow(int times, String source, Constraint<FieldRef> constraint, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,Constraint<FieldRefFieldRef>constraint,String...targets){ ConstrainedFact<FieldRef, Fact>[] targetFacts = new ConstrainedFact[targets.length];ConstrainedFact<FieldRefFieldRef,Fact>[]targetFacts=newConstrainedFact[targets.length]; for(int i=0; i<targets.length; i++) {for(inti=0;i<targets.length;i++){ targetFacts[i] = new ConstrainedFact<String, Fact>(new Fact(targets[i]), constraint);targetFacts[i]=newConstrainedFact<StringString,Fact>(newFact(targets[i]),constraint); targetFacts[i] = new ConstrainedFact<FieldRef, Fact>(new Fact(targets[i]), constraint);targetFacts[i]=newConstrainedFact<FieldRefFieldRef,Fact>(newFact(targets[i]),constraint); }} return new ExpectedFlowFunction(times, new Fact(source), targetFacts);returnnewExpectedFlowFunction(times,newFact(source),targetFacts); }} public static class ExpectedFlowFunction {publicstaticclassExpectedFlowFunction{ public final Fact source;publicfinalFactsource; public final ConstrainedFact<String, Fact>[] targets;publicfinalConstrainedFact<StringString,Fact>[]targets; public final ConstrainedFact<FieldRef, Fact>[] targets;publicfinalConstrainedFact<FieldRefFieldRef,Fact>[]targets; public Edge edge;publicEdgeedge; private int times;privateinttimes; public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<String, Fact>... targets) {publicExpectedFlowFunction(inttimes,Factsource,ConstrainedFact<StringString,Fact>...targets){ public ExpectedFlowFunction(int times, Fact source, ConstrainedFact<FieldRef, Fact>... targets) {publicExpectedFlowFunction(inttimes,Factsource,ConstrainedFact<FieldRefFieldRef,Fact>...targets){ this.times = times;this.times=times; this.source = source;this.source=source; this.targets = targets;this.targets=targets; return a.equals(b);returna.equals(b); }} public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,StringString,Fact,Method>flowFunctions(){ return new FlowFunctions<Statement, String, Fact, Method>() {returnnewFlowFunctions<Statement,StringString,Fact,Method>(){ public FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,FieldRefFieldRef,Fact,Method>flowFunctions(){ return new FlowFunctions<Statement, FieldRef, Fact, Method>() {returnnewFlowFunctions<Statement,FieldRefFieldRef,Fact,Method>(){ @Override@Override public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {publicFlowFunction<StringString,Fact>getReturnFlowFunction(StatementcallSite,MethodcalleeMethod,StatementexitStmt,StatementreturnSite){ public FlowFunction<FieldRef, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {publicFlowFunction<FieldRefFieldRef,Fact>getReturnFlowFunction(StatementcallSite,MethodcalleeMethod,StatementexitStmt,StatementreturnSite){ for (final ReturnEdge edge : returnEdges) {for(finalReturnEdgeedge:returnEdges){ if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)if(nullAwareEquals(callSite,edge.callSite)&&edge.calleeMethod.equals(calleeMethod) && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {&&edge.exitStmt.equals(exitStmt)&&nullAwareEquals(edge.returnSite,returnSite)){ }} @Override@Override public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {publicFlowFunction<StringString,Fact>getNormalFlowFunction(finalStatementcurr,finalStatementsucc){ public FlowFunction<FieldRef, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {publicFlowFunction<FieldRefFieldRef,Fact>getNormalFlowFunction(finalStatementcurr,finalStatementsucc){ for (final NormalEdge edge : normalEdges) {for(finalNormalEdgeedge:normalEdges){ if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {if(edge.unit.equals(curr)&&edge.succUnit.equals(succ)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<StringString,Fact>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ public FlowFunction<FieldRef, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<FieldRefFieldRef,Fact>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ for (final Call2ReturnEdge edge : call2retEdges) {for(finalCall2ReturnEdgeedge:call2retEdges){ if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {if(edge.callSite.equals(callSite)&&edge.returnSite.equals(returnSite)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {publicFlowFunction<StringString,Fact>getCallFlowFunction(StatementcallStmt,MethoddestinationMethod){ public FlowFunction<FieldRef, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {publicFlowFunction<FieldRefFieldRef,Fact>getCallFlowFunction(StatementcallStmt,MethoddestinationMethod){ for (final CallEdge edge : callEdges) {for(finalCallEdgeedge:callEdges){ if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {if(edge.callSite.equals(callStmt)&&edge.destinationMethod.equals(destinationMethod)){ return createFlowFunction(edge);returncreateFlowFunction(edge); throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));thrownewAssertionError(String.format("No Flow Function expected for call %s -> %s",callStmt,destinationMethod)); }} private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {privateFlowFunction<StringString,Fact>createFlowFunction(finalEdgeedge){ return new FlowFunction<String, Fact>() {returnnewFlowFunction<StringString,Fact>(){ private FlowFunction<FieldRef, Fact> createFlowFunction(final Edge edge) {privateFlowFunction<FieldRefFieldRef,Fact>createFlowFunction(finalEdgeedge){ return new FlowFunction<FieldRef, Fact>() {returnnewFlowFunction<FieldRefFieldRef,Fact>(){ @Override@Override public Set<ConstrainedFact<String, Fact>> computeTargets(Fact source) {publicSet<ConstrainedFact<StringString,Fact>>computeTargets(Factsource){ Set<ConstrainedFact<String, Fact>> result = Sets.newHashSet();Set<ConstrainedFact<StringString,Fact>>result=Sets.newHashSet(); public Set<ConstrainedFact<FieldRef, Fact>> computeTargets(Fact source) {publicSet<ConstrainedFact<FieldRefFieldRef,Fact>>computeTargets(Factsource){ Set<ConstrainedFact<FieldRef, Fact>> result = Sets.newHashSet();Set<ConstrainedFact<FieldRefFieldRef,Fact>>result=Sets.newHashSet(); boolean found = false;booleanfound=false; for (ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ if (ff.source.equals(source)) {if(ff.source.equals(source)){ }} public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {publicvoidrunSolver(finalbooleanfollowReturnsPastSeeds,finalString...initialSeeds){ FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));FieldSensitiveIFDSSolver<Statement,String,StringString,Fact,Method,InterproceduralCFG<Statement,Method>>solver=newFieldSensitiveIFDSSolver<Statement,String, StringString,Fact,Method,InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds,initialSeeds)); FieldSensitiveIFDSSolver<Statement, String, FieldRef, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String, FieldRef ,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));FieldSensitiveIFDSSolver<Statement,String,FieldRefFieldRef,Fact,Method,InterproceduralCFG<Statement,Method>>solver=newFieldSensitiveIFDSSolver<Statement,String,FieldRefFieldRef ,Fact,Method,InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds,initialSeeds)); solver.solve();solver.solve(); assertAllFlowFunctionsUsed();assertAllFlowFunctionsUsed(); }}   private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<Statement,StringString,Fact,Method,InterproceduralCFG<Statement,Method>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ private IFDSTabulationProblem<Statement, FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<Statement,FieldRefFieldRef,Fact,Method,InterproceduralCFG<Statement,Method>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ final InterproceduralCFG<Statement, Method> icfg = buildIcfg();finalInterproceduralCFG<Statement,Method>icfg=buildIcfg(); final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();finalFlowFunctions<Statement,StringString,Fact,Method>flowFunctions=flowFunctions(); final FlowFunctions<Statement, FieldRef, Fact, Method> flowFunctions = flowFunctions();finalFlowFunctions<Statement,FieldRefFieldRef,Fact,Method>flowFunctions=flowFunctions();  return new IFDSTabulationProblem<Statement,String, Fact, Method, InterproceduralCFG<Statement, Method>>() {returnnewIFDSTabulationProblem<Statement,StringString,Fact,Method,InterproceduralCFG<Statement,Method>>(){ return new IFDSTabulationProblem<Statement,FieldRef, Fact, Method, InterproceduralCFG<Statement, Method>>() {returnnewIFDSTabulationProblem<Statement,FieldRefFieldRef,Fact,Method,InterproceduralCFG<Statement,Method>>(){ @Override@Override public boolean followReturnsPastSeeds() {publicbooleanfollowReturnsPastSeeds(){ }} @Override@Override public FlowFunctions<Statement,String, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,StringString,Fact,Method>flowFunctions(){ public FlowFunctions<Statement,FieldRef, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,FieldRefFieldRef,Fact,Method>flowFunctions(){ return flowFunctions;returnflowFunctions; }}









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






