



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros

d3ba77600d7143051513161cd4078baf5e70a2b0

















d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag










heros


src


heros


alias


AccessPath.java



Find file
Normal viewHistoryPermalink






AccessPath.java



13.7 KB









Newer










Older









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






1




2




3




4




5




6




7




8




9




10




11




12




/*******************************************************************************
 * Copyright (c) 2015 Johannes Lerch.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Johannes Lerch - initial API and implementation
 ******************************************************************************/
package heros.alias;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






13




14




import static com.google.common.collect.Iterables.getOnlyElement;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






15




import java.util.Arrays;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






16




import java.util.Collection;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






17




18




19




import java.util.HashSet;
import java.util.Set;










k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






20




import com.google.common.base.Function;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






21




import com.google.common.base.Joiner;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






22




23




24




import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






25




26




import com.google.common.collect.Sets;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






27




28




29




import heros.alias.Transition.MatchResult;
import heros.alias.SubAccessPath.*;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






30




31




32




@SuppressWarnings("unchecked")
public class AccessPath<FieldRef> {










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






33




34




35




36




37




	public static <T> AccessPath<T> empty() {
		return new AccessPath<T>();
	}
	
	private final SubAccessPath<FieldRef>[] accesses;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






38




	private final Set<FieldRef>[] exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






39




40




	
	public AccessPath() {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






41




		accesses = new SubAccessPath[0];









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






42




43




44




		exclusions = new Set[0];
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






45




46




47




	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {
		this.accesses = accesses;
		this.exclusions = exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






48




49




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






50




51




52




53




54




55




56




	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {
		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {
			for(FieldRef field : fieldReferences[i].elements()) {
				if(!exclusions[i].contains(field))
					continue outer;
			}
			return true;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






57




58




59




60




		}			
		return false;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






61




62




63




64




65




66




	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {
		return addFieldReference(true, fieldReferences);
	}
	
	
	AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






67




		if(isAccessInExclusions(fieldReferences))









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






68




			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






69














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96




97




98




99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




114




115




116




117




118




119




120




121




122




123




124




125




126




127




128




129




130




131




132




133




134




135




136




137




138




139




140




141




142




143




144




145




146




147




148




149




150




151




152




153




154




155




156




157




158




159




160




161




162




163




164




165




166




167




168




169




170




171




172




173




174




175




176




177




178




		if(merge) {
			boolean finiteDepth = true;
			for(int i=fieldReferences.length-1; i>=0; i--) {
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					finiteDepth = false;
					
				for(int j=0; j<accesses.length; j++) {
					if(accesses[j].intersects(fieldReferences[i])) {
						// [..., {j-i}, ...]
						
						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);
						builder.keep(0, j);
						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);
						builder.append(fieldReferences, i+1, fieldReferences.length);
						if(finiteDepth)
							builder.removeExclusions(fieldReferences.length);
						else
							builder.removeExclusions(Integer.MAX_VALUE);
						return builder.build();
					}
				}
			}
		}
		
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);
		builder.keep(0, accesses.length);
		builder.append(fieldReferences, 0, fieldReferences.length);
		builder.removeExclusions(fieldReferences.length);
		return builder.build();
	}
	
	public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {
		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];
		for(int i=0; i<fieldReferences.length; i++) {
			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);
		}
		return addFieldReference(subPath);
	}
	
	private class AccessPathBuilder {
		
		private Set<FieldRef>[] newExclusions;
		private SubAccessPath<FieldRef>[] newAccesses;
		private int currentIndex = 0;

		public AccessPathBuilder(int capacity) {
			newAccesses = new SubAccessPath[capacity];
			newExclusions = exclusions;
		}
		
		public AccessPath<FieldRef> build() {
			while(newAccesses.length > 0 && newExclusions.length > 0) {
				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);
				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {
					if(newHashSet.isEmpty()) {
						removeExclusions(1);
					}
					else {
						newExclusions[0] = newHashSet;
						break;
					}
				} else break;
			}
			
			return new AccessPath<>(newAccesses, newExclusions);
		}

		public void removeExclusions(int length) {
			if(length>=newExclusions.length)
				newExclusions = new Set[0];
			else
				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);
		}

		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			for(int i=start; i<endExcl; i++) {
				newAccesses[currentIndex] = fieldReferences[i];
				currentIndex++;
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					newExclusions = new Set[0];
			}
			currentIndex+=endExcl-start;
		}

		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));
		}

		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {
			Set<FieldRef> set = Sets.newHashSet();
			for(int i=srcIndex; i<destIndexExcl; i++) {
				set.addAll(accesses[i].elements());
			}
			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);
			currentIndex++;
			return this;
		}

		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {
			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);
			currentIndex += destIndexExcl-srcIndex;
			return this;
		}

		public void append(FieldRef fieldRef) {
			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);
			currentIndex++;
		}
		









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






179




180




181




182




183




184




	}

	public ExclusionSet getExclusions(int index) {
		return new ExclusionSet(index);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






185




186




187




188




189




190




191




192




193




194




195




196




197




198




199




	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {
		for(int j=0; j<accesses.length; j++) {
			if(accesses[j].contains(fieldRef)) {
				// [{0-j}, ...]
				
				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);
				builder.merge(0, j+1);
				builder.keep(j+1, accesses.length);
				return builder.build();
			}
		}
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);
		builder.append(fieldRef);
		builder.keep(0, accesses.length);
		return builder.build();









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






200




201




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






202




203




204




205




206




207




208




209




210




211




212




213




214




215




216




217




218




	public AccessPath<FieldRef> removeFirst(FieldRef field) {
		for(int i=0; i<accesses.length; i++) {
			if(accesses[i].contains(field)) {
				if(accesses[i] instanceof SpecificFieldAccess)
					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);
				else
					return this;
			}
			else if(accesses[i] instanceof SpecificFieldAccess)
				throw new IllegalStateException("Trying to remove "+field+" from "+this);
		}
		
		throw new IllegalStateException("Trying to remove "+field+" from "+this);
	}
	
	public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {
		if(exclusions.length > 0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






219




220




221




222




223




224




			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));
		else
			return this;
	}

	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






225




		if(exclusions.length>0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






226




227




228




229




230




			return getExclusions(0).addExclusion(fieldRef);
		else
			return appendExcludedFieldReference(fieldRef);
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






231




232




233




234




235




	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {
		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);
		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);
		return new AccessPath<>(accesses, newExclusionsArray);
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






236




237




238




239




240




241




242




243




244




245




246




247




248




249





	public static enum PrefixTestResult {
		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);
		
		private int value;

		private PrefixTestResult(int value) {
			this.value = value;
		}
		
		public boolean atLeast(PrefixTestResult minimum) {
			return value >= minimum.value;
		}
	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






250




	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






251




252




253




254




	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {
		int currIndex = 0;
		int otherIndex = 0;
		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






255




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




278




279




		int finalIndex = finalIndex();
		outer: while(currIndex < finalIndex) {
			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);
			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);

			if(transitions.size() > 1 && otherTransitions.size() > 1)
				throw new AssertionError();
			
			for(Transition<FieldRef> transition : transitions) {
				for(Transition<FieldRef> otherTransition : otherTransitions) {
					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);
					if(match.hasMatched()) {
						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())
							throw new AssertionError();
						
						currIndex = transition.transitionToIndex();
						otherIndex = otherTransition.transitionToIndex();
						if(!match.isGuaranteedMatch())
							result = PrefixTestResult.POTENTIAL_PREFIX;
						
						continue outer;
					}
				}
			}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






280




			return PrefixTestResult.NO_PREFIX;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






281




		}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






282




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






283




284




285




286




287




288




289




290




		return result;
	}
	
	private int finalIndex() {
		if(exclusions.length > 0)
			return accesses.length + exclusions.length;
		
		int finalIndex = 0;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






291




		for(int i=0; i<accesses.length; i++) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






292




293




			if(accesses[i] instanceof SpecificFieldAccess)
				finalIndex = i+1;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






294




		}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






295




296




297




298




299




300




301




302




303




		return finalIndex;
	}

	private Collection<Transition<FieldRef>> possibleTransitions(int index) {
		Collection<Transition<FieldRef>> result = Lists.newLinkedList();
		if(index < accesses.length) {
			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {
				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));
				result.addAll(possibleTransitions(index+1));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






304




			}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






305




306




307




308




			else
				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));
		} else if(index - accesses.length < exclusions.length) {
			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






309




		}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






310




		return result;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






311




312




	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






313




314




315




316




317




318




319




320




321




322




323




324




325




326




327




328




329




330




331




332




333




334




335




	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {
		int currentIndex = 0;
		
		for(SubAccessPath<FieldRef> sub : accesses) {
			if(!(sub instanceof SpecificFieldAccess))
				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());
			
			FieldRef field = sub.elements().iterator().next();
			
			while(true) {
				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {
					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)
						currentIndex++;
					break;
				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {
					currentIndex++;
				}
				else
					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);
			}
		}
		
		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






336




337




338




339




340




341




342




343




344




345




346




347




348




349




	}
	
	public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {
		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];
		for(int i=0; i<newExclusionArray.length; i++) {
			newExclusionArray[i] = Sets.newHashSet();
			if(i<exclusions.length)
				newExclusionArray[i].addAll(exclusions[i]);
			if(i<accPath.exclusions.length)
				newExclusionArray[i].addAll(accPath.exclusions[i]);
		}
		return new AccessPath<>(accesses, newExclusionArray);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






350




351




352




353




	public boolean mayHaveEmptyAccessPath() {
		return finalIndex() == 0;
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






354




355




356




357




358




359




360




361




362




363




364




365




366




367




368




369




370




371




372




373




374




375




376




377




378




379




380




381




382




383




384




385




386




387




388




389




390




391




	public boolean isEmpty() {
		return exclusions.length == 0 && accesses.length == 0;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(accesses);
		result = prime * result + Arrays.hashCode(exclusions);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof AccessPath))
			return false;
		AccessPath other = (AccessPath) obj;
		if (!Arrays.equals(accesses, other.accesses))
			return false;
		if (!Arrays.equals(exclusions, other.exclusions))
			return false;
		return true;
	}

	@Override
	public String toString() {
		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";
		for(Set<FieldRef> exclusion : exclusions) {
			result += "^" + Joiner.on(",").join(exclusion);
		}
		return result;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






392




393




394




395




396




397




398




399




400




401




402




403




404




405




//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {
//		T[] newAccesses = (T[]) new Object[accesses.length];
//		for(int i=0; i<accesses.length; i++) {
//			newAccesses[i] = function.apply(accesses[i]);
//		}
//		Set<T>[] newExclusions = new Set[exclusions.length];
//		for(int i=0; i<exclusions.length; i++) {
//			newExclusions[i] = Sets.newHashSet();
//			for(FieldRef excl : exclusions[i]) {
//				newExclusions[i].add(function.apply(excl));
//			}
//		}
//		return new AccessPath<T>(newAccesses, newExclusions);
//	}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






406




	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






407




408




409




410




411




412




413




	public class ExclusionSet {
		private int index;
	
		private ExclusionSet(int index) {
			this.index = index;
		}
		









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






414




		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






415




			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






416




417




			for(FieldRef excl : exclusion)
				newExclusions.add(excl);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






418




419




420




421




422




			Set<FieldRef>[] newExclusionsArray = exclusions.clone();
			newExclusionsArray[index] = newExclusions;
			return new AccessPath<FieldRef>(accesses, newExclusionsArray);
		}
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






423














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






424




	public AccessPath<FieldRef> removeAnyAccess() {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






425




		if(accesses.length > 0)









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






426




427




428




429




430




431




432




			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);
		else
			return this;
	}

	public boolean hasEmptyAccessPath() {
		return accesses.length == 0;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






433




	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






434




}












H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros

d3ba77600d7143051513161cd4078baf5e70a2b0

















d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag










heros


src


heros


alias


AccessPath.java



Find file
Normal viewHistoryPermalink






AccessPath.java



13.7 KB









Newer










Older









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






1




2




3




4




5




6




7




8




9




10




11




12




/*******************************************************************************
 * Copyright (c) 2015 Johannes Lerch.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Johannes Lerch - initial API and implementation
 ******************************************************************************/
package heros.alias;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






13




14




import static com.google.common.collect.Iterables.getOnlyElement;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






15




import java.util.Arrays;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






16




import java.util.Collection;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






17




18




19




import java.util.HashSet;
import java.util.Set;










k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






20




import com.google.common.base.Function;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






21




import com.google.common.base.Joiner;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






22




23




24




import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






25




26




import com.google.common.collect.Sets;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






27




28




29




import heros.alias.Transition.MatchResult;
import heros.alias.SubAccessPath.*;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






30




31




32




@SuppressWarnings("unchecked")
public class AccessPath<FieldRef> {










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






33




34




35




36




37




	public static <T> AccessPath<T> empty() {
		return new AccessPath<T>();
	}
	
	private final SubAccessPath<FieldRef>[] accesses;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






38




	private final Set<FieldRef>[] exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






39




40




	
	public AccessPath() {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






41




		accesses = new SubAccessPath[0];









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






42




43




44




		exclusions = new Set[0];
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






45




46




47




	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {
		this.accesses = accesses;
		this.exclusions = exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






48




49




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






50




51




52




53




54




55




56




	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {
		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {
			for(FieldRef field : fieldReferences[i].elements()) {
				if(!exclusions[i].contains(field))
					continue outer;
			}
			return true;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






57




58




59




60




		}			
		return false;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






61




62




63




64




65




66




	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {
		return addFieldReference(true, fieldReferences);
	}
	
	
	AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






67




		if(isAccessInExclusions(fieldReferences))









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






68




			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






69














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96




97




98




99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




114




115




116




117




118




119




120




121




122




123




124




125




126




127




128




129




130




131




132




133




134




135




136




137




138




139




140




141




142




143




144




145




146




147




148




149




150




151




152




153




154




155




156




157




158




159




160




161




162




163




164




165




166




167




168




169




170




171




172




173




174




175




176




177




178




		if(merge) {
			boolean finiteDepth = true;
			for(int i=fieldReferences.length-1; i>=0; i--) {
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					finiteDepth = false;
					
				for(int j=0; j<accesses.length; j++) {
					if(accesses[j].intersects(fieldReferences[i])) {
						// [..., {j-i}, ...]
						
						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);
						builder.keep(0, j);
						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);
						builder.append(fieldReferences, i+1, fieldReferences.length);
						if(finiteDepth)
							builder.removeExclusions(fieldReferences.length);
						else
							builder.removeExclusions(Integer.MAX_VALUE);
						return builder.build();
					}
				}
			}
		}
		
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);
		builder.keep(0, accesses.length);
		builder.append(fieldReferences, 0, fieldReferences.length);
		builder.removeExclusions(fieldReferences.length);
		return builder.build();
	}
	
	public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {
		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];
		for(int i=0; i<fieldReferences.length; i++) {
			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);
		}
		return addFieldReference(subPath);
	}
	
	private class AccessPathBuilder {
		
		private Set<FieldRef>[] newExclusions;
		private SubAccessPath<FieldRef>[] newAccesses;
		private int currentIndex = 0;

		public AccessPathBuilder(int capacity) {
			newAccesses = new SubAccessPath[capacity];
			newExclusions = exclusions;
		}
		
		public AccessPath<FieldRef> build() {
			while(newAccesses.length > 0 && newExclusions.length > 0) {
				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);
				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {
					if(newHashSet.isEmpty()) {
						removeExclusions(1);
					}
					else {
						newExclusions[0] = newHashSet;
						break;
					}
				} else break;
			}
			
			return new AccessPath<>(newAccesses, newExclusions);
		}

		public void removeExclusions(int length) {
			if(length>=newExclusions.length)
				newExclusions = new Set[0];
			else
				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);
		}

		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			for(int i=start; i<endExcl; i++) {
				newAccesses[currentIndex] = fieldReferences[i];
				currentIndex++;
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					newExclusions = new Set[0];
			}
			currentIndex+=endExcl-start;
		}

		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));
		}

		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {
			Set<FieldRef> set = Sets.newHashSet();
			for(int i=srcIndex; i<destIndexExcl; i++) {
				set.addAll(accesses[i].elements());
			}
			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);
			currentIndex++;
			return this;
		}

		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {
			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);
			currentIndex += destIndexExcl-srcIndex;
			return this;
		}

		public void append(FieldRef fieldRef) {
			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);
			currentIndex++;
		}
		









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






179




180




181




182




183




184




	}

	public ExclusionSet getExclusions(int index) {
		return new ExclusionSet(index);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






185




186




187




188




189




190




191




192




193




194




195




196




197




198




199




	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {
		for(int j=0; j<accesses.length; j++) {
			if(accesses[j].contains(fieldRef)) {
				// [{0-j}, ...]
				
				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);
				builder.merge(0, j+1);
				builder.keep(j+1, accesses.length);
				return builder.build();
			}
		}
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);
		builder.append(fieldRef);
		builder.keep(0, accesses.length);
		return builder.build();









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






200




201




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






202




203




204




205




206




207




208




209




210




211




212




213




214




215




216




217




218




	public AccessPath<FieldRef> removeFirst(FieldRef field) {
		for(int i=0; i<accesses.length; i++) {
			if(accesses[i].contains(field)) {
				if(accesses[i] instanceof SpecificFieldAccess)
					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);
				else
					return this;
			}
			else if(accesses[i] instanceof SpecificFieldAccess)
				throw new IllegalStateException("Trying to remove "+field+" from "+this);
		}
		
		throw new IllegalStateException("Trying to remove "+field+" from "+this);
	}
	
	public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {
		if(exclusions.length > 0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






219




220




221




222




223




224




			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));
		else
			return this;
	}

	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






225




		if(exclusions.length>0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






226




227




228




229




230




			return getExclusions(0).addExclusion(fieldRef);
		else
			return appendExcludedFieldReference(fieldRef);
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






231




232




233




234




235




	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {
		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);
		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);
		return new AccessPath<>(accesses, newExclusionsArray);
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






236




237




238




239




240




241




242




243




244




245




246




247




248




249





	public static enum PrefixTestResult {
		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);
		
		private int value;

		private PrefixTestResult(int value) {
			this.value = value;
		}
		
		public boolean atLeast(PrefixTestResult minimum) {
			return value >= minimum.value;
		}
	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






250




	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






251




252




253




254




	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {
		int currIndex = 0;
		int otherIndex = 0;
		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






255




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




278




279




		int finalIndex = finalIndex();
		outer: while(currIndex < finalIndex) {
			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);
			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);

			if(transitions.size() > 1 && otherTransitions.size() > 1)
				throw new AssertionError();
			
			for(Transition<FieldRef> transition : transitions) {
				for(Transition<FieldRef> otherTransition : otherTransitions) {
					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);
					if(match.hasMatched()) {
						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())
							throw new AssertionError();
						
						currIndex = transition.transitionToIndex();
						otherIndex = otherTransition.transitionToIndex();
						if(!match.isGuaranteedMatch())
							result = PrefixTestResult.POTENTIAL_PREFIX;
						
						continue outer;
					}
				}
			}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






280




			return PrefixTestResult.NO_PREFIX;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






281




		}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






282




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






283




284




285




286




287




288




289




290




		return result;
	}
	
	private int finalIndex() {
		if(exclusions.length > 0)
			return accesses.length + exclusions.length;
		
		int finalIndex = 0;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






291




		for(int i=0; i<accesses.length; i++) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






292




293




			if(accesses[i] instanceof SpecificFieldAccess)
				finalIndex = i+1;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






294




		}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






295




296




297




298




299




300




301




302




303




		return finalIndex;
	}

	private Collection<Transition<FieldRef>> possibleTransitions(int index) {
		Collection<Transition<FieldRef>> result = Lists.newLinkedList();
		if(index < accesses.length) {
			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {
				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));
				result.addAll(possibleTransitions(index+1));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






304




			}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






305




306




307




308




			else
				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));
		} else if(index - accesses.length < exclusions.length) {
			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






309




		}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






310




		return result;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






311




312




	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






313




314




315




316




317




318




319




320




321




322




323




324




325




326




327




328




329




330




331




332




333




334




335




	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {
		int currentIndex = 0;
		
		for(SubAccessPath<FieldRef> sub : accesses) {
			if(!(sub instanceof SpecificFieldAccess))
				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());
			
			FieldRef field = sub.elements().iterator().next();
			
			while(true) {
				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {
					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)
						currentIndex++;
					break;
				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {
					currentIndex++;
				}
				else
					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);
			}
		}
		
		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






336




337




338




339




340




341




342




343




344




345




346




347




348




349




	}
	
	public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {
		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];
		for(int i=0; i<newExclusionArray.length; i++) {
			newExclusionArray[i] = Sets.newHashSet();
			if(i<exclusions.length)
				newExclusionArray[i].addAll(exclusions[i]);
			if(i<accPath.exclusions.length)
				newExclusionArray[i].addAll(accPath.exclusions[i]);
		}
		return new AccessPath<>(accesses, newExclusionArray);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






350




351




352




353




	public boolean mayHaveEmptyAccessPath() {
		return finalIndex() == 0;
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






354




355




356




357




358




359




360




361




362




363




364




365




366




367




368




369




370




371




372




373




374




375




376




377




378




379




380




381




382




383




384




385




386




387




388




389




390




391




	public boolean isEmpty() {
		return exclusions.length == 0 && accesses.length == 0;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(accesses);
		result = prime * result + Arrays.hashCode(exclusions);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof AccessPath))
			return false;
		AccessPath other = (AccessPath) obj;
		if (!Arrays.equals(accesses, other.accesses))
			return false;
		if (!Arrays.equals(exclusions, other.exclusions))
			return false;
		return true;
	}

	@Override
	public String toString() {
		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";
		for(Set<FieldRef> exclusion : exclusions) {
			result += "^" + Joiner.on(",").join(exclusion);
		}
		return result;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






392




393




394




395




396




397




398




399




400




401




402




403




404




405




//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {
//		T[] newAccesses = (T[]) new Object[accesses.length];
//		for(int i=0; i<accesses.length; i++) {
//			newAccesses[i] = function.apply(accesses[i]);
//		}
//		Set<T>[] newExclusions = new Set[exclusions.length];
//		for(int i=0; i<exclusions.length; i++) {
//			newExclusions[i] = Sets.newHashSet();
//			for(FieldRef excl : exclusions[i]) {
//				newExclusions[i].add(function.apply(excl));
//			}
//		}
//		return new AccessPath<T>(newAccesses, newExclusions);
//	}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






406




	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






407




408




409




410




411




412




413




	public class ExclusionSet {
		private int index;
	
		private ExclusionSet(int index) {
			this.index = index;
		}
		









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






414




		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






415




			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






416




417




			for(FieldRef excl : exclusion)
				newExclusions.add(excl);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






418




419




420




421




422




			Set<FieldRef>[] newExclusionsArray = exclusions.clone();
			newExclusionsArray[index] = newExclusions;
			return new AccessPath<FieldRef>(accesses, newExclusionsArray);
		}
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






423














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






424




	public AccessPath<FieldRef> removeAnyAccess() {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






425




		if(accesses.length > 0)









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






426




427




428




429




430




431




432




			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);
		else
			return this;
	}

	public boolean hasEmptyAccessPath() {
		return accesses.length == 0;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






433




	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






434




}











Open sidebar



Joshua Garcia heros

d3ba77600d7143051513161cd4078baf5e70a2b0







Open sidebar



Joshua Garcia heros

d3ba77600d7143051513161cd4078baf5e70a2b0




Open sidebar

Joshua Garcia heros

d3ba77600d7143051513161cd4078baf5e70a2b0


Joshua Garciaherosheros
d3ba77600d7143051513161cd4078baf5e70a2b0










d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag










heros


src


heros


alias


AccessPath.java



Find file
Normal viewHistoryPermalink






AccessPath.java



13.7 KB









Newer










Older









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






1




2




3




4




5




6




7




8




9




10




11




12




/*******************************************************************************
 * Copyright (c) 2015 Johannes Lerch.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Johannes Lerch - initial API and implementation
 ******************************************************************************/
package heros.alias;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






13




14




import static com.google.common.collect.Iterables.getOnlyElement;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






15




import java.util.Arrays;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






16




import java.util.Collection;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






17




18




19




import java.util.HashSet;
import java.util.Set;










k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






20




import com.google.common.base.Function;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






21




import com.google.common.base.Joiner;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






22




23




24




import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






25




26




import com.google.common.collect.Sets;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






27




28




29




import heros.alias.Transition.MatchResult;
import heros.alias.SubAccessPath.*;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






30




31




32




@SuppressWarnings("unchecked")
public class AccessPath<FieldRef> {










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






33




34




35




36




37




	public static <T> AccessPath<T> empty() {
		return new AccessPath<T>();
	}
	
	private final SubAccessPath<FieldRef>[] accesses;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






38




	private final Set<FieldRef>[] exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






39




40




	
	public AccessPath() {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






41




		accesses = new SubAccessPath[0];









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






42




43




44




		exclusions = new Set[0];
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






45




46




47




	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {
		this.accesses = accesses;
		this.exclusions = exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






48




49




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






50




51




52




53




54




55




56




	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {
		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {
			for(FieldRef field : fieldReferences[i].elements()) {
				if(!exclusions[i].contains(field))
					continue outer;
			}
			return true;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






57




58




59




60




		}			
		return false;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






61




62




63




64




65




66




	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {
		return addFieldReference(true, fieldReferences);
	}
	
	
	AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






67




		if(isAccessInExclusions(fieldReferences))









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






68




			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






69














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96




97




98




99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




114




115




116




117




118




119




120




121




122




123




124




125




126




127




128




129




130




131




132




133




134




135




136




137




138




139




140




141




142




143




144




145




146




147




148




149




150




151




152




153




154




155




156




157




158




159




160




161




162




163




164




165




166




167




168




169




170




171




172




173




174




175




176




177




178




		if(merge) {
			boolean finiteDepth = true;
			for(int i=fieldReferences.length-1; i>=0; i--) {
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					finiteDepth = false;
					
				for(int j=0; j<accesses.length; j++) {
					if(accesses[j].intersects(fieldReferences[i])) {
						// [..., {j-i}, ...]
						
						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);
						builder.keep(0, j);
						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);
						builder.append(fieldReferences, i+1, fieldReferences.length);
						if(finiteDepth)
							builder.removeExclusions(fieldReferences.length);
						else
							builder.removeExclusions(Integer.MAX_VALUE);
						return builder.build();
					}
				}
			}
		}
		
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);
		builder.keep(0, accesses.length);
		builder.append(fieldReferences, 0, fieldReferences.length);
		builder.removeExclusions(fieldReferences.length);
		return builder.build();
	}
	
	public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {
		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];
		for(int i=0; i<fieldReferences.length; i++) {
			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);
		}
		return addFieldReference(subPath);
	}
	
	private class AccessPathBuilder {
		
		private Set<FieldRef>[] newExclusions;
		private SubAccessPath<FieldRef>[] newAccesses;
		private int currentIndex = 0;

		public AccessPathBuilder(int capacity) {
			newAccesses = new SubAccessPath[capacity];
			newExclusions = exclusions;
		}
		
		public AccessPath<FieldRef> build() {
			while(newAccesses.length > 0 && newExclusions.length > 0) {
				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);
				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {
					if(newHashSet.isEmpty()) {
						removeExclusions(1);
					}
					else {
						newExclusions[0] = newHashSet;
						break;
					}
				} else break;
			}
			
			return new AccessPath<>(newAccesses, newExclusions);
		}

		public void removeExclusions(int length) {
			if(length>=newExclusions.length)
				newExclusions = new Set[0];
			else
				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);
		}

		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			for(int i=start; i<endExcl; i++) {
				newAccesses[currentIndex] = fieldReferences[i];
				currentIndex++;
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					newExclusions = new Set[0];
			}
			currentIndex+=endExcl-start;
		}

		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));
		}

		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {
			Set<FieldRef> set = Sets.newHashSet();
			for(int i=srcIndex; i<destIndexExcl; i++) {
				set.addAll(accesses[i].elements());
			}
			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);
			currentIndex++;
			return this;
		}

		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {
			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);
			currentIndex += destIndexExcl-srcIndex;
			return this;
		}

		public void append(FieldRef fieldRef) {
			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);
			currentIndex++;
		}
		









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






179




180




181




182




183




184




	}

	public ExclusionSet getExclusions(int index) {
		return new ExclusionSet(index);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






185




186




187




188




189




190




191




192




193




194




195




196




197




198




199




	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {
		for(int j=0; j<accesses.length; j++) {
			if(accesses[j].contains(fieldRef)) {
				// [{0-j}, ...]
				
				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);
				builder.merge(0, j+1);
				builder.keep(j+1, accesses.length);
				return builder.build();
			}
		}
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);
		builder.append(fieldRef);
		builder.keep(0, accesses.length);
		return builder.build();









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






200




201




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






202




203




204




205




206




207




208




209




210




211




212




213




214




215




216




217




218




	public AccessPath<FieldRef> removeFirst(FieldRef field) {
		for(int i=0; i<accesses.length; i++) {
			if(accesses[i].contains(field)) {
				if(accesses[i] instanceof SpecificFieldAccess)
					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);
				else
					return this;
			}
			else if(accesses[i] instanceof SpecificFieldAccess)
				throw new IllegalStateException("Trying to remove "+field+" from "+this);
		}
		
		throw new IllegalStateException("Trying to remove "+field+" from "+this);
	}
	
	public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {
		if(exclusions.length > 0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






219




220




221




222




223




224




			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));
		else
			return this;
	}

	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






225




		if(exclusions.length>0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






226




227




228




229




230




			return getExclusions(0).addExclusion(fieldRef);
		else
			return appendExcludedFieldReference(fieldRef);
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






231




232




233




234




235




	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {
		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);
		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);
		return new AccessPath<>(accesses, newExclusionsArray);
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






236




237




238




239




240




241




242




243




244




245




246




247




248




249





	public static enum PrefixTestResult {
		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);
		
		private int value;

		private PrefixTestResult(int value) {
			this.value = value;
		}
		
		public boolean atLeast(PrefixTestResult minimum) {
			return value >= minimum.value;
		}
	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






250




	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






251




252




253




254




	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {
		int currIndex = 0;
		int otherIndex = 0;
		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






255




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




278




279




		int finalIndex = finalIndex();
		outer: while(currIndex < finalIndex) {
			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);
			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);

			if(transitions.size() > 1 && otherTransitions.size() > 1)
				throw new AssertionError();
			
			for(Transition<FieldRef> transition : transitions) {
				for(Transition<FieldRef> otherTransition : otherTransitions) {
					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);
					if(match.hasMatched()) {
						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())
							throw new AssertionError();
						
						currIndex = transition.transitionToIndex();
						otherIndex = otherTransition.transitionToIndex();
						if(!match.isGuaranteedMatch())
							result = PrefixTestResult.POTENTIAL_PREFIX;
						
						continue outer;
					}
				}
			}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






280




			return PrefixTestResult.NO_PREFIX;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






281




		}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






282




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






283




284




285




286




287




288




289




290




		return result;
	}
	
	private int finalIndex() {
		if(exclusions.length > 0)
			return accesses.length + exclusions.length;
		
		int finalIndex = 0;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






291




		for(int i=0; i<accesses.length; i++) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






292




293




			if(accesses[i] instanceof SpecificFieldAccess)
				finalIndex = i+1;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






294




		}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






295




296




297




298




299




300




301




302




303




		return finalIndex;
	}

	private Collection<Transition<FieldRef>> possibleTransitions(int index) {
		Collection<Transition<FieldRef>> result = Lists.newLinkedList();
		if(index < accesses.length) {
			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {
				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));
				result.addAll(possibleTransitions(index+1));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






304




			}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






305




306




307




308




			else
				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));
		} else if(index - accesses.length < exclusions.length) {
			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






309




		}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






310




		return result;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






311




312




	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






313




314




315




316




317




318




319




320




321




322




323




324




325




326




327




328




329




330




331




332




333




334




335




	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {
		int currentIndex = 0;
		
		for(SubAccessPath<FieldRef> sub : accesses) {
			if(!(sub instanceof SpecificFieldAccess))
				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());
			
			FieldRef field = sub.elements().iterator().next();
			
			while(true) {
				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {
					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)
						currentIndex++;
					break;
				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {
					currentIndex++;
				}
				else
					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);
			}
		}
		
		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






336




337




338




339




340




341




342




343




344




345




346




347




348




349




	}
	
	public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {
		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];
		for(int i=0; i<newExclusionArray.length; i++) {
			newExclusionArray[i] = Sets.newHashSet();
			if(i<exclusions.length)
				newExclusionArray[i].addAll(exclusions[i]);
			if(i<accPath.exclusions.length)
				newExclusionArray[i].addAll(accPath.exclusions[i]);
		}
		return new AccessPath<>(accesses, newExclusionArray);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






350




351




352




353




	public boolean mayHaveEmptyAccessPath() {
		return finalIndex() == 0;
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






354




355




356




357




358




359




360




361




362




363




364




365




366




367




368




369




370




371




372




373




374




375




376




377




378




379




380




381




382




383




384




385




386




387




388




389




390




391




	public boolean isEmpty() {
		return exclusions.length == 0 && accesses.length == 0;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(accesses);
		result = prime * result + Arrays.hashCode(exclusions);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof AccessPath))
			return false;
		AccessPath other = (AccessPath) obj;
		if (!Arrays.equals(accesses, other.accesses))
			return false;
		if (!Arrays.equals(exclusions, other.exclusions))
			return false;
		return true;
	}

	@Override
	public String toString() {
		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";
		for(Set<FieldRef> exclusion : exclusions) {
			result += "^" + Joiner.on(",").join(exclusion);
		}
		return result;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






392




393




394




395




396




397




398




399




400




401




402




403




404




405




//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {
//		T[] newAccesses = (T[]) new Object[accesses.length];
//		for(int i=0; i<accesses.length; i++) {
//			newAccesses[i] = function.apply(accesses[i]);
//		}
//		Set<T>[] newExclusions = new Set[exclusions.length];
//		for(int i=0; i<exclusions.length; i++) {
//			newExclusions[i] = Sets.newHashSet();
//			for(FieldRef excl : exclusions[i]) {
//				newExclusions[i].add(function.apply(excl));
//			}
//		}
//		return new AccessPath<T>(newAccesses, newExclusions);
//	}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






406




	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






407




408




409




410




411




412




413




	public class ExclusionSet {
		private int index;
	
		private ExclusionSet(int index) {
			this.index = index;
		}
		









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






414




		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






415




			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






416




417




			for(FieldRef excl : exclusion)
				newExclusions.add(excl);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






418




419




420




421




422




			Set<FieldRef>[] newExclusionsArray = exclusions.clone();
			newExclusionsArray[index] = newExclusions;
			return new AccessPath<FieldRef>(accesses, newExclusionsArray);
		}
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






423














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






424




	public AccessPath<FieldRef> removeAnyAccess() {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






425




		if(accesses.length > 0)









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






426




427




428




429




430




431




432




			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);
		else
			return this;
	}

	public boolean hasEmptyAccessPath() {
		return accesses.length == 0;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






433




	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






434




}














d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag










heros


src


heros


alias


AccessPath.java



Find file
Normal viewHistoryPermalink






AccessPath.java



13.7 KB









Newer










Older









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






1




2




3




4




5




6




7




8




9




10




11




12




/*******************************************************************************
 * Copyright (c) 2015 Johannes Lerch.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Johannes Lerch - initial API and implementation
 ******************************************************************************/
package heros.alias;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






13




14




import static com.google.common.collect.Iterables.getOnlyElement;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






15




import java.util.Arrays;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






16




import java.util.Collection;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






17




18




19




import java.util.HashSet;
import java.util.Set;










k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






20




import com.google.common.base.Function;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






21




import com.google.common.base.Joiner;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






22




23




24




import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






25




26




import com.google.common.collect.Sets;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






27




28




29




import heros.alias.Transition.MatchResult;
import heros.alias.SubAccessPath.*;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






30




31




32




@SuppressWarnings("unchecked")
public class AccessPath<FieldRef> {










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






33




34




35




36




37




	public static <T> AccessPath<T> empty() {
		return new AccessPath<T>();
	}
	
	private final SubAccessPath<FieldRef>[] accesses;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






38




	private final Set<FieldRef>[] exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






39




40




	
	public AccessPath() {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






41




		accesses = new SubAccessPath[0];









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






42




43




44




		exclusions = new Set[0];
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






45




46




47




	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {
		this.accesses = accesses;
		this.exclusions = exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






48




49




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






50




51




52




53




54




55




56




	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {
		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {
			for(FieldRef field : fieldReferences[i].elements()) {
				if(!exclusions[i].contains(field))
					continue outer;
			}
			return true;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






57




58




59




60




		}			
		return false;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






61




62




63




64




65




66




	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {
		return addFieldReference(true, fieldReferences);
	}
	
	
	AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






67




		if(isAccessInExclusions(fieldReferences))









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






68




			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






69














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96




97




98




99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




114




115




116




117




118




119




120




121




122




123




124




125




126




127




128




129




130




131




132




133




134




135




136




137




138




139




140




141




142




143




144




145




146




147




148




149




150




151




152




153




154




155




156




157




158




159




160




161




162




163




164




165




166




167




168




169




170




171




172




173




174




175




176




177




178




		if(merge) {
			boolean finiteDepth = true;
			for(int i=fieldReferences.length-1; i>=0; i--) {
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					finiteDepth = false;
					
				for(int j=0; j<accesses.length; j++) {
					if(accesses[j].intersects(fieldReferences[i])) {
						// [..., {j-i}, ...]
						
						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);
						builder.keep(0, j);
						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);
						builder.append(fieldReferences, i+1, fieldReferences.length);
						if(finiteDepth)
							builder.removeExclusions(fieldReferences.length);
						else
							builder.removeExclusions(Integer.MAX_VALUE);
						return builder.build();
					}
				}
			}
		}
		
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);
		builder.keep(0, accesses.length);
		builder.append(fieldReferences, 0, fieldReferences.length);
		builder.removeExclusions(fieldReferences.length);
		return builder.build();
	}
	
	public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {
		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];
		for(int i=0; i<fieldReferences.length; i++) {
			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);
		}
		return addFieldReference(subPath);
	}
	
	private class AccessPathBuilder {
		
		private Set<FieldRef>[] newExclusions;
		private SubAccessPath<FieldRef>[] newAccesses;
		private int currentIndex = 0;

		public AccessPathBuilder(int capacity) {
			newAccesses = new SubAccessPath[capacity];
			newExclusions = exclusions;
		}
		
		public AccessPath<FieldRef> build() {
			while(newAccesses.length > 0 && newExclusions.length > 0) {
				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);
				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {
					if(newHashSet.isEmpty()) {
						removeExclusions(1);
					}
					else {
						newExclusions[0] = newHashSet;
						break;
					}
				} else break;
			}
			
			return new AccessPath<>(newAccesses, newExclusions);
		}

		public void removeExclusions(int length) {
			if(length>=newExclusions.length)
				newExclusions = new Set[0];
			else
				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);
		}

		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			for(int i=start; i<endExcl; i++) {
				newAccesses[currentIndex] = fieldReferences[i];
				currentIndex++;
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					newExclusions = new Set[0];
			}
			currentIndex+=endExcl-start;
		}

		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));
		}

		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {
			Set<FieldRef> set = Sets.newHashSet();
			for(int i=srcIndex; i<destIndexExcl; i++) {
				set.addAll(accesses[i].elements());
			}
			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);
			currentIndex++;
			return this;
		}

		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {
			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);
			currentIndex += destIndexExcl-srcIndex;
			return this;
		}

		public void append(FieldRef fieldRef) {
			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);
			currentIndex++;
		}
		









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






179




180




181




182




183




184




	}

	public ExclusionSet getExclusions(int index) {
		return new ExclusionSet(index);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






185




186




187




188




189




190




191




192




193




194




195




196




197




198




199




	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {
		for(int j=0; j<accesses.length; j++) {
			if(accesses[j].contains(fieldRef)) {
				// [{0-j}, ...]
				
				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);
				builder.merge(0, j+1);
				builder.keep(j+1, accesses.length);
				return builder.build();
			}
		}
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);
		builder.append(fieldRef);
		builder.keep(0, accesses.length);
		return builder.build();









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






200




201




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






202




203




204




205




206




207




208




209




210




211




212




213




214




215




216




217




218




	public AccessPath<FieldRef> removeFirst(FieldRef field) {
		for(int i=0; i<accesses.length; i++) {
			if(accesses[i].contains(field)) {
				if(accesses[i] instanceof SpecificFieldAccess)
					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);
				else
					return this;
			}
			else if(accesses[i] instanceof SpecificFieldAccess)
				throw new IllegalStateException("Trying to remove "+field+" from "+this);
		}
		
		throw new IllegalStateException("Trying to remove "+field+" from "+this);
	}
	
	public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {
		if(exclusions.length > 0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






219




220




221




222




223




224




			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));
		else
			return this;
	}

	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






225




		if(exclusions.length>0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






226




227




228




229




230




			return getExclusions(0).addExclusion(fieldRef);
		else
			return appendExcludedFieldReference(fieldRef);
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






231




232




233




234




235




	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {
		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);
		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);
		return new AccessPath<>(accesses, newExclusionsArray);
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






236




237




238




239




240




241




242




243




244




245




246




247




248




249





	public static enum PrefixTestResult {
		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);
		
		private int value;

		private PrefixTestResult(int value) {
			this.value = value;
		}
		
		public boolean atLeast(PrefixTestResult minimum) {
			return value >= minimum.value;
		}
	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






250




	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






251




252




253




254




	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {
		int currIndex = 0;
		int otherIndex = 0;
		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






255




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




278




279




		int finalIndex = finalIndex();
		outer: while(currIndex < finalIndex) {
			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);
			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);

			if(transitions.size() > 1 && otherTransitions.size() > 1)
				throw new AssertionError();
			
			for(Transition<FieldRef> transition : transitions) {
				for(Transition<FieldRef> otherTransition : otherTransitions) {
					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);
					if(match.hasMatched()) {
						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())
							throw new AssertionError();
						
						currIndex = transition.transitionToIndex();
						otherIndex = otherTransition.transitionToIndex();
						if(!match.isGuaranteedMatch())
							result = PrefixTestResult.POTENTIAL_PREFIX;
						
						continue outer;
					}
				}
			}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






280




			return PrefixTestResult.NO_PREFIX;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






281




		}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






282




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






283




284




285




286




287




288




289




290




		return result;
	}
	
	private int finalIndex() {
		if(exclusions.length > 0)
			return accesses.length + exclusions.length;
		
		int finalIndex = 0;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






291




		for(int i=0; i<accesses.length; i++) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






292




293




			if(accesses[i] instanceof SpecificFieldAccess)
				finalIndex = i+1;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






294




		}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






295




296




297




298




299




300




301




302




303




		return finalIndex;
	}

	private Collection<Transition<FieldRef>> possibleTransitions(int index) {
		Collection<Transition<FieldRef>> result = Lists.newLinkedList();
		if(index < accesses.length) {
			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {
				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));
				result.addAll(possibleTransitions(index+1));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






304




			}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






305




306




307




308




			else
				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));
		} else if(index - accesses.length < exclusions.length) {
			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






309




		}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






310




		return result;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






311




312




	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






313




314




315




316




317




318




319




320




321




322




323




324




325




326




327




328




329




330




331




332




333




334




335




	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {
		int currentIndex = 0;
		
		for(SubAccessPath<FieldRef> sub : accesses) {
			if(!(sub instanceof SpecificFieldAccess))
				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());
			
			FieldRef field = sub.elements().iterator().next();
			
			while(true) {
				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {
					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)
						currentIndex++;
					break;
				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {
					currentIndex++;
				}
				else
					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);
			}
		}
		
		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






336




337




338




339




340




341




342




343




344




345




346




347




348




349




	}
	
	public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {
		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];
		for(int i=0; i<newExclusionArray.length; i++) {
			newExclusionArray[i] = Sets.newHashSet();
			if(i<exclusions.length)
				newExclusionArray[i].addAll(exclusions[i]);
			if(i<accPath.exclusions.length)
				newExclusionArray[i].addAll(accPath.exclusions[i]);
		}
		return new AccessPath<>(accesses, newExclusionArray);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






350




351




352




353




	public boolean mayHaveEmptyAccessPath() {
		return finalIndex() == 0;
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






354




355




356




357




358




359




360




361




362




363




364




365




366




367




368




369




370




371




372




373




374




375




376




377




378




379




380




381




382




383




384




385




386




387




388




389




390




391




	public boolean isEmpty() {
		return exclusions.length == 0 && accesses.length == 0;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(accesses);
		result = prime * result + Arrays.hashCode(exclusions);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof AccessPath))
			return false;
		AccessPath other = (AccessPath) obj;
		if (!Arrays.equals(accesses, other.accesses))
			return false;
		if (!Arrays.equals(exclusions, other.exclusions))
			return false;
		return true;
	}

	@Override
	public String toString() {
		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";
		for(Set<FieldRef> exclusion : exclusions) {
			result += "^" + Joiner.on(",").join(exclusion);
		}
		return result;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






392




393




394




395




396




397




398




399




400




401




402




403




404




405




//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {
//		T[] newAccesses = (T[]) new Object[accesses.length];
//		for(int i=0; i<accesses.length; i++) {
//			newAccesses[i] = function.apply(accesses[i]);
//		}
//		Set<T>[] newExclusions = new Set[exclusions.length];
//		for(int i=0; i<exclusions.length; i++) {
//			newExclusions[i] = Sets.newHashSet();
//			for(FieldRef excl : exclusions[i]) {
//				newExclusions[i].add(function.apply(excl));
//			}
//		}
//		return new AccessPath<T>(newAccesses, newExclusions);
//	}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






406




	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






407




408




409




410




411




412




413




	public class ExclusionSet {
		private int index;
	
		private ExclusionSet(int index) {
			this.index = index;
		}
		









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






414




		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






415




			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






416




417




			for(FieldRef excl : exclusion)
				newExclusions.add(excl);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






418




419




420




421




422




			Set<FieldRef>[] newExclusionsArray = exclusions.clone();
			newExclusionsArray[index] = newExclusions;
			return new AccessPath<FieldRef>(accesses, newExclusionsArray);
		}
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






423














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






424




	public AccessPath<FieldRef> removeAnyAccess() {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






425




		if(accesses.length > 0)









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






426




427




428




429




430




431




432




			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);
		else
			return this;
	}

	public boolean hasEmptyAccessPath() {
		return accesses.length == 0;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






433




	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






434




}










d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag










heros


src


heros


alias


AccessPath.java



Find file
Normal viewHistoryPermalink




d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag










heros


src


heros


alias


AccessPath.java





d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag








d3ba77600d7143051513161cd4078baf5e70a2b0


Switch branch/tag





d3ba77600d7143051513161cd4078baf5e70a2b0

Switch branch/tag





Switch branch/tag



Switch branch/tagSwitch branch/tag
heros

src

heros

alias

AccessPath.java
Find file
Normal viewHistoryPermalink




AccessPath.java



13.7 KB









Newer










Older









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






1




2




3




4




5




6




7




8




9




10




11




12




/*******************************************************************************
 * Copyright (c) 2015 Johannes Lerch.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Johannes Lerch - initial API and implementation
 ******************************************************************************/
package heros.alias;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






13




14




import static com.google.common.collect.Iterables.getOnlyElement;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






15




import java.util.Arrays;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






16




import java.util.Collection;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






17




18




19




import java.util.HashSet;
import java.util.Set;










k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






20




import com.google.common.base.Function;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






21




import com.google.common.base.Joiner;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






22




23




24




import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






25




26




import com.google.common.collect.Sets;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






27




28




29




import heros.alias.Transition.MatchResult;
import heros.alias.SubAccessPath.*;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






30




31




32




@SuppressWarnings("unchecked")
public class AccessPath<FieldRef> {










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






33




34




35




36




37




	public static <T> AccessPath<T> empty() {
		return new AccessPath<T>();
	}
	
	private final SubAccessPath<FieldRef>[] accesses;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






38




	private final Set<FieldRef>[] exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






39




40




	
	public AccessPath() {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






41




		accesses = new SubAccessPath[0];









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






42




43




44




		exclusions = new Set[0];
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






45




46




47




	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {
		this.accesses = accesses;
		this.exclusions = exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






48




49




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






50




51




52




53




54




55




56




	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {
		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {
			for(FieldRef field : fieldReferences[i].elements()) {
				if(!exclusions[i].contains(field))
					continue outer;
			}
			return true;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






57




58




59




60




		}			
		return false;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






61




62




63




64




65




66




	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {
		return addFieldReference(true, fieldReferences);
	}
	
	
	AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






67




		if(isAccessInExclusions(fieldReferences))









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






68




			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






69














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96




97




98




99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




114




115




116




117




118




119




120




121




122




123




124




125




126




127




128




129




130




131




132




133




134




135




136




137




138




139




140




141




142




143




144




145




146




147




148




149




150




151




152




153




154




155




156




157




158




159




160




161




162




163




164




165




166




167




168




169




170




171




172




173




174




175




176




177




178




		if(merge) {
			boolean finiteDepth = true;
			for(int i=fieldReferences.length-1; i>=0; i--) {
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					finiteDepth = false;
					
				for(int j=0; j<accesses.length; j++) {
					if(accesses[j].intersects(fieldReferences[i])) {
						// [..., {j-i}, ...]
						
						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);
						builder.keep(0, j);
						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);
						builder.append(fieldReferences, i+1, fieldReferences.length);
						if(finiteDepth)
							builder.removeExclusions(fieldReferences.length);
						else
							builder.removeExclusions(Integer.MAX_VALUE);
						return builder.build();
					}
				}
			}
		}
		
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);
		builder.keep(0, accesses.length);
		builder.append(fieldReferences, 0, fieldReferences.length);
		builder.removeExclusions(fieldReferences.length);
		return builder.build();
	}
	
	public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {
		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];
		for(int i=0; i<fieldReferences.length; i++) {
			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);
		}
		return addFieldReference(subPath);
	}
	
	private class AccessPathBuilder {
		
		private Set<FieldRef>[] newExclusions;
		private SubAccessPath<FieldRef>[] newAccesses;
		private int currentIndex = 0;

		public AccessPathBuilder(int capacity) {
			newAccesses = new SubAccessPath[capacity];
			newExclusions = exclusions;
		}
		
		public AccessPath<FieldRef> build() {
			while(newAccesses.length > 0 && newExclusions.length > 0) {
				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);
				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {
					if(newHashSet.isEmpty()) {
						removeExclusions(1);
					}
					else {
						newExclusions[0] = newHashSet;
						break;
					}
				} else break;
			}
			
			return new AccessPath<>(newAccesses, newExclusions);
		}

		public void removeExclusions(int length) {
			if(length>=newExclusions.length)
				newExclusions = new Set[0];
			else
				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);
		}

		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			for(int i=start; i<endExcl; i++) {
				newAccesses[currentIndex] = fieldReferences[i];
				currentIndex++;
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					newExclusions = new Set[0];
			}
			currentIndex+=endExcl-start;
		}

		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));
		}

		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {
			Set<FieldRef> set = Sets.newHashSet();
			for(int i=srcIndex; i<destIndexExcl; i++) {
				set.addAll(accesses[i].elements());
			}
			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);
			currentIndex++;
			return this;
		}

		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {
			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);
			currentIndex += destIndexExcl-srcIndex;
			return this;
		}

		public void append(FieldRef fieldRef) {
			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);
			currentIndex++;
		}
		









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






179




180




181




182




183




184




	}

	public ExclusionSet getExclusions(int index) {
		return new ExclusionSet(index);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






185




186




187




188




189




190




191




192




193




194




195




196




197




198




199




	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {
		for(int j=0; j<accesses.length; j++) {
			if(accesses[j].contains(fieldRef)) {
				// [{0-j}, ...]
				
				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);
				builder.merge(0, j+1);
				builder.keep(j+1, accesses.length);
				return builder.build();
			}
		}
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);
		builder.append(fieldRef);
		builder.keep(0, accesses.length);
		return builder.build();









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






200




201




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






202




203




204




205




206




207




208




209




210




211




212




213




214




215




216




217




218




	public AccessPath<FieldRef> removeFirst(FieldRef field) {
		for(int i=0; i<accesses.length; i++) {
			if(accesses[i].contains(field)) {
				if(accesses[i] instanceof SpecificFieldAccess)
					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);
				else
					return this;
			}
			else if(accesses[i] instanceof SpecificFieldAccess)
				throw new IllegalStateException("Trying to remove "+field+" from "+this);
		}
		
		throw new IllegalStateException("Trying to remove "+field+" from "+this);
	}
	
	public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {
		if(exclusions.length > 0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






219




220




221




222




223




224




			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));
		else
			return this;
	}

	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






225




		if(exclusions.length>0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






226




227




228




229




230




			return getExclusions(0).addExclusion(fieldRef);
		else
			return appendExcludedFieldReference(fieldRef);
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






231




232




233




234




235




	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {
		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);
		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);
		return new AccessPath<>(accesses, newExclusionsArray);
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






236




237




238




239




240




241




242




243




244




245




246




247




248




249





	public static enum PrefixTestResult {
		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);
		
		private int value;

		private PrefixTestResult(int value) {
			this.value = value;
		}
		
		public boolean atLeast(PrefixTestResult minimum) {
			return value >= minimum.value;
		}
	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






250




	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






251




252




253




254




	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {
		int currIndex = 0;
		int otherIndex = 0;
		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






255




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




278




279




		int finalIndex = finalIndex();
		outer: while(currIndex < finalIndex) {
			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);
			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);

			if(transitions.size() > 1 && otherTransitions.size() > 1)
				throw new AssertionError();
			
			for(Transition<FieldRef> transition : transitions) {
				for(Transition<FieldRef> otherTransition : otherTransitions) {
					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);
					if(match.hasMatched()) {
						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())
							throw new AssertionError();
						
						currIndex = transition.transitionToIndex();
						otherIndex = otherTransition.transitionToIndex();
						if(!match.isGuaranteedMatch())
							result = PrefixTestResult.POTENTIAL_PREFIX;
						
						continue outer;
					}
				}
			}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






280




			return PrefixTestResult.NO_PREFIX;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






281




		}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






282




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






283




284




285




286




287




288




289




290




		return result;
	}
	
	private int finalIndex() {
		if(exclusions.length > 0)
			return accesses.length + exclusions.length;
		
		int finalIndex = 0;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






291




		for(int i=0; i<accesses.length; i++) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






292




293




			if(accesses[i] instanceof SpecificFieldAccess)
				finalIndex = i+1;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






294




		}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






295




296




297




298




299




300




301




302




303




		return finalIndex;
	}

	private Collection<Transition<FieldRef>> possibleTransitions(int index) {
		Collection<Transition<FieldRef>> result = Lists.newLinkedList();
		if(index < accesses.length) {
			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {
				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));
				result.addAll(possibleTransitions(index+1));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






304




			}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






305




306




307




308




			else
				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));
		} else if(index - accesses.length < exclusions.length) {
			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






309




		}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






310




		return result;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






311




312




	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






313




314




315




316




317




318




319




320




321




322




323




324




325




326




327




328




329




330




331




332




333




334




335




	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {
		int currentIndex = 0;
		
		for(SubAccessPath<FieldRef> sub : accesses) {
			if(!(sub instanceof SpecificFieldAccess))
				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());
			
			FieldRef field = sub.elements().iterator().next();
			
			while(true) {
				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {
					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)
						currentIndex++;
					break;
				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {
					currentIndex++;
				}
				else
					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);
			}
		}
		
		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






336




337




338




339




340




341




342




343




344




345




346




347




348




349




	}
	
	public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {
		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];
		for(int i=0; i<newExclusionArray.length; i++) {
			newExclusionArray[i] = Sets.newHashSet();
			if(i<exclusions.length)
				newExclusionArray[i].addAll(exclusions[i]);
			if(i<accPath.exclusions.length)
				newExclusionArray[i].addAll(accPath.exclusions[i]);
		}
		return new AccessPath<>(accesses, newExclusionArray);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






350




351




352




353




	public boolean mayHaveEmptyAccessPath() {
		return finalIndex() == 0;
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






354




355




356




357




358




359




360




361




362




363




364




365




366




367




368




369




370




371




372




373




374




375




376




377




378




379




380




381




382




383




384




385




386




387




388




389




390




391




	public boolean isEmpty() {
		return exclusions.length == 0 && accesses.length == 0;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(accesses);
		result = prime * result + Arrays.hashCode(exclusions);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof AccessPath))
			return false;
		AccessPath other = (AccessPath) obj;
		if (!Arrays.equals(accesses, other.accesses))
			return false;
		if (!Arrays.equals(exclusions, other.exclusions))
			return false;
		return true;
	}

	@Override
	public String toString() {
		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";
		for(Set<FieldRef> exclusion : exclusions) {
			result += "^" + Joiner.on(",").join(exclusion);
		}
		return result;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






392




393




394




395




396




397




398




399




400




401




402




403




404




405




//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {
//		T[] newAccesses = (T[]) new Object[accesses.length];
//		for(int i=0; i<accesses.length; i++) {
//			newAccesses[i] = function.apply(accesses[i]);
//		}
//		Set<T>[] newExclusions = new Set[exclusions.length];
//		for(int i=0; i<exclusions.length; i++) {
//			newExclusions[i] = Sets.newHashSet();
//			for(FieldRef excl : exclusions[i]) {
//				newExclusions[i].add(function.apply(excl));
//			}
//		}
//		return new AccessPath<T>(newAccesses, newExclusions);
//	}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






406




	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






407




408




409




410




411




412




413




	public class ExclusionSet {
		private int index;
	
		private ExclusionSet(int index) {
			this.index = index;
		}
		









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






414




		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






415




			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






416




417




			for(FieldRef excl : exclusion)
				newExclusions.add(excl);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






418




419




420




421




422




			Set<FieldRef>[] newExclusionsArray = exclusions.clone();
			newExclusionsArray[index] = newExclusions;
			return new AccessPath<FieldRef>(accesses, newExclusionsArray);
		}
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






423














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






424




	public AccessPath<FieldRef> removeAnyAccess() {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






425




		if(accesses.length > 0)









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






426




427




428




429




430




431




432




			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);
		else
			return this;
	}

	public boolean hasEmptyAccessPath() {
		return accesses.length == 0;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






433




	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






434




}








AccessPath.java



13.7 KB










AccessPath.java



13.7 KB









Newer










Older
NewerOlder







cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






1




2




3




4




5




6




7




8




9




10




11




12




/*******************************************************************************
 * Copyright (c) 2015 Johannes Lerch.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Johannes Lerch - initial API and implementation
 ******************************************************************************/
package heros.alias;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






13




14




import static com.google.common.collect.Iterables.getOnlyElement;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






15




import java.util.Arrays;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






16




import java.util.Collection;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






17




18




19




import java.util.HashSet;
import java.util.Set;










k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






20




import com.google.common.base.Function;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






21




import com.google.common.base.Joiner;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






22




23




24




import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






25




26




import com.google.common.collect.Sets;










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






27




28




29




import heros.alias.Transition.MatchResult;
import heros.alias.SubAccessPath.*;










cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






30




31




32




@SuppressWarnings("unchecked")
public class AccessPath<FieldRef> {










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






33




34




35




36




37




	public static <T> AccessPath<T> empty() {
		return new AccessPath<T>();
	}
	
	private final SubAccessPath<FieldRef>[] accesses;









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






38




	private final Set<FieldRef>[] exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






39




40




	
	public AccessPath() {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






41




		accesses = new SubAccessPath[0];









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






42




43




44




		exclusions = new Set[0];
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






45




46




47




	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {
		this.accesses = accesses;
		this.exclusions = exclusions;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






48




49




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






50




51




52




53




54




55




56




	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {
		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {
			for(FieldRef field : fieldReferences[i].elements()) {
				if(!exclusions[i].contains(field))
					continue outer;
			}
			return true;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






57




58




59




60




		}			
		return false;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






61




62




63




64




65




66




	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {
		return addFieldReference(true, fieldReferences);
	}
	
	
	AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






67




		if(isAccessInExclusions(fieldReferences))









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






68




			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






69














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96




97




98




99




100




101




102




103




104




105




106




107




108




109




110




111




112




113




114




115




116




117




118




119




120




121




122




123




124




125




126




127




128




129




130




131




132




133




134




135




136




137




138




139




140




141




142




143




144




145




146




147




148




149




150




151




152




153




154




155




156




157




158




159




160




161




162




163




164




165




166




167




168




169




170




171




172




173




174




175




176




177




178




		if(merge) {
			boolean finiteDepth = true;
			for(int i=fieldReferences.length-1; i>=0; i--) {
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					finiteDepth = false;
					
				for(int j=0; j<accesses.length; j++) {
					if(accesses[j].intersects(fieldReferences[i])) {
						// [..., {j-i}, ...]
						
						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);
						builder.keep(0, j);
						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);
						builder.append(fieldReferences, i+1, fieldReferences.length);
						if(finiteDepth)
							builder.removeExclusions(fieldReferences.length);
						else
							builder.removeExclusions(Integer.MAX_VALUE);
						return builder.build();
					}
				}
			}
		}
		
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);
		builder.keep(0, accesses.length);
		builder.append(fieldReferences, 0, fieldReferences.length);
		builder.removeExclusions(fieldReferences.length);
		return builder.build();
	}
	
	public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {
		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];
		for(int i=0; i<fieldReferences.length; i++) {
			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);
		}
		return addFieldReference(subPath);
	}
	
	private class AccessPathBuilder {
		
		private Set<FieldRef>[] newExclusions;
		private SubAccessPath<FieldRef>[] newAccesses;
		private int currentIndex = 0;

		public AccessPathBuilder(int capacity) {
			newAccesses = new SubAccessPath[capacity];
			newExclusions = exclusions;
		}
		
		public AccessPath<FieldRef> build() {
			while(newAccesses.length > 0 && newExclusions.length > 0) {
				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);
				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {
					if(newHashSet.isEmpty()) {
						removeExclusions(1);
					}
					else {
						newExclusions[0] = newHashSet;
						break;
					}
				} else break;
			}
			
			return new AccessPath<>(newAccesses, newExclusions);
		}

		public void removeExclusions(int length) {
			if(length>=newExclusions.length)
				newExclusions = new Set[0];
			else
				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);
		}

		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			for(int i=start; i<endExcl; i++) {
				newAccesses[currentIndex] = fieldReferences[i];
				currentIndex++;
				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)
					newExclusions = new Set[0];
			}
			currentIndex+=endExcl-start;
		}

		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {
			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));
		}

		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {
			Set<FieldRef> set = Sets.newHashSet();
			for(int i=srcIndex; i<destIndexExcl; i++) {
				set.addAll(accesses[i].elements());
			}
			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);
			currentIndex++;
			return this;
		}

		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {
			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);
			currentIndex += destIndexExcl-srcIndex;
			return this;
		}

		public void append(FieldRef fieldRef) {
			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);
			currentIndex++;
		}
		









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






179




180




181




182




183




184




	}

	public ExclusionSet getExclusions(int index) {
		return new ExclusionSet(index);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






185




186




187




188




189




190




191




192




193




194




195




196




197




198




199




	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {
		for(int j=0; j<accesses.length; j++) {
			if(accesses[j].contains(fieldRef)) {
				// [{0-j}, ...]
				
				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);
				builder.merge(0, j+1);
				builder.keep(j+1, accesses.length);
				return builder.build();
			}
		}
		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);
		builder.append(fieldRef);
		builder.keep(0, accesses.length);
		return builder.build();









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






200




201




	}










regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






202




203




204




205




206




207




208




209




210




211




212




213




214




215




216




217




218




	public AccessPath<FieldRef> removeFirst(FieldRef field) {
		for(int i=0; i<accesses.length; i++) {
			if(accesses[i].contains(field)) {
				if(accesses[i] instanceof SpecificFieldAccess)
					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);
				else
					return this;
			}
			else if(accesses[i] instanceof SpecificFieldAccess)
				throw new IllegalStateException("Trying to remove "+field+" from "+this);
		}
		
		throw new IllegalStateException("Trying to remove "+field+" from "+this);
	}
	
	public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {
		if(exclusions.length > 0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






219




220




221




222




223




224




			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));
		else
			return this;
	}

	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






225




		if(exclusions.length>0)









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






226




227




228




229




230




			return getExclusions(0).addExclusion(fieldRef);
		else
			return appendExcludedFieldReference(fieldRef);
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






231




232




233




234




235




	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {
		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);
		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);
		return new AccessPath<>(accesses, newExclusionsArray);
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






236




237




238




239




240




241




242




243




244




245




246




247




248




249





	public static enum PrefixTestResult {
		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);
		
		private int value;

		private PrefixTestResult(int value) {
			this.value = value;
		}
		
		public boolean atLeast(PrefixTestResult minimum) {
			return value >= minimum.value;
		}
	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






250




	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






251




252




253




254




	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {
		int currIndex = 0;
		int otherIndex = 0;
		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






255




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






256




257




258




259




260




261




262




263




264




265




266




267




268




269




270




271




272




273




274




275




276




277




278




279




		int finalIndex = finalIndex();
		outer: while(currIndex < finalIndex) {
			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);
			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);

			if(transitions.size() > 1 && otherTransitions.size() > 1)
				throw new AssertionError();
			
			for(Transition<FieldRef> transition : transitions) {
				for(Transition<FieldRef> otherTransition : otherTransitions) {
					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);
					if(match.hasMatched()) {
						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())
							throw new AssertionError();
						
						currIndex = transition.transitionToIndex();
						otherIndex = otherTransition.transitionToIndex();
						if(!match.isGuaranteedMatch())
							result = PrefixTestResult.POTENTIAL_PREFIX;
						
						continue outer;
					}
				}
			}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






280




			return PrefixTestResult.NO_PREFIX;









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






281




		}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






282




		









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






283




284




285




286




287




288




289




290




		return result;
	}
	
	private int finalIndex() {
		if(exclusions.length > 0)
			return accesses.length + exclusions.length;
		
		int finalIndex = 0;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






291




		for(int i=0; i<accesses.length; i++) {









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






292




293




			if(accesses[i] instanceof SpecificFieldAccess)
				finalIndex = i+1;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






294




		}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






295




296




297




298




299




300




301




302




303




		return finalIndex;
	}

	private Collection<Transition<FieldRef>> possibleTransitions(int index) {
		Collection<Transition<FieldRef>> result = Lists.newLinkedList();
		if(index < accesses.length) {
			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {
				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));
				result.addAll(possibleTransitions(index+1));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






304




			}









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






305




306




307




308




			else
				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));
		} else if(index - accesses.length < exclusions.length) {
			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






309




		}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






310




		return result;









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






311




312




	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






313




314




315




316




317




318




319




320




321




322




323




324




325




326




327




328




329




330




331




332




333




334




335




	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {
		int currentIndex = 0;
		
		for(SubAccessPath<FieldRef> sub : accesses) {
			if(!(sub instanceof SpecificFieldAccess))
				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());
			
			FieldRef field = sub.elements().iterator().next();
			
			while(true) {
				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {
					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)
						currentIndex++;
					break;
				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {
					currentIndex++;
				}
				else
					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);
			}
		}
		
		return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






336




337




338




339




340




341




342




343




344




345




346




347




348




349




	}
	
	public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {
		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];
		for(int i=0; i<newExclusionArray.length; i++) {
			newExclusionArray[i] = Sets.newHashSet();
			if(i<exclusions.length)
				newExclusionArray[i].addAll(exclusions[i]);
			if(i<accPath.exclusions.length)
				newExclusionArray[i].addAll(accPath.exclusions[i]);
		}
		return new AccessPath<>(accesses, newExclusionArray);
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






350




351




352




353




	public boolean mayHaveEmptyAccessPath() {
		return finalIndex() == 0;
	}
	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






354




355




356




357




358




359




360




361




362




363




364




365




366




367




368




369




370




371




372




373




374




375




376




377




378




379




380




381




382




383




384




385




386




387




388




389




390




391




	public boolean isEmpty() {
		return exclusions.length == 0 && accesses.length == 0;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(accesses);
		result = prime * result + Arrays.hashCode(exclusions);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof AccessPath))
			return false;
		AccessPath other = (AccessPath) obj;
		if (!Arrays.equals(accesses, other.accesses))
			return false;
		if (!Arrays.equals(exclusions, other.exclusions))
			return false;
		return true;
	}

	@Override
	public String toString() {
		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";
		for(Set<FieldRef> exclusion : exclusions) {
			result += "^" + Joiner.on(",").join(exclusion);
		}
		return result;
	}
	









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






392




393




394




395




396




397




398




399




400




401




402




403




404




405




//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {
//		T[] newAccesses = (T[]) new Object[accesses.length];
//		for(int i=0; i<accesses.length; i++) {
//			newAccesses[i] = function.apply(accesses[i]);
//		}
//		Set<T>[] newExclusions = new Set[exclusions.length];
//		for(int i=0; i<exclusions.length; i++) {
//			newExclusions[i] = Sets.newHashSet();
//			for(FieldRef excl : exclusions[i]) {
//				newExclusions[i].add(function.apply(excl));
//			}
//		}
//		return new AccessPath<T>(newAccesses, newExclusions);
//	}









k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015






406




	









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






407




408




409




410




411




412




413




	public class ExclusionSet {
		private int index;
	
		private ExclusionSet(int index) {
			this.index = index;
		}
		









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






414




		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






415




			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);









Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015






416




417




			for(FieldRef excl : exclusion)
				newExclusions.add(excl);









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






418




419




420




421




422




			Set<FieldRef>[] newExclusionsArray = exclusions.clone();
			newExclusionsArray[index] = newExclusions;
			return new AccessPath<FieldRef>(accesses, newExclusionsArray);
		}
	}









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






423














regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






424




	public AccessPath<FieldRef> removeAnyAccess() {









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






425




		if(accesses.length > 0)









regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015






426




427




428




429




430




431




432




			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);
		else
			return this;
	}

	public boolean hasEmptyAccessPath() {
		return accesses.length == 0;









Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015






433




	}









cleaning code



 


Johannes Lerch
committed
Jan 07, 2015






434




}







cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

1

2

3

4

5

6

7

8

9

10

11

12
/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

13

14
import static com.google.common.collect.Iterables.getOnlyElement;importstaticcom.google.common.collect.Iterables.getOnlyElement;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

15
import java.util.Arrays;importjava.util.Arrays;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

16
import java.util.Collection;importjava.util.Collection;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

17

18

19
import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

20
import com.google.common.base.Function;importcom.google.common.base.Function;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

21
import com.google.common.base.Joiner;importcom.google.common.base.Joiner;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

22

23

24
import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Iterables;importcom.google.common.collect.Iterables;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

25

26
import com.google.common.collect.Sets;importcom.google.common.collect.Sets;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

27

28

29
import heros.alias.Transition.MatchResult;importheros.alias.Transition.MatchResult;import heros.alias.SubAccessPath.*;importheros.alias.SubAccessPath.*;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

30

31

32
@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPath<FieldRef> {publicclassAccessPath<FieldRef>{



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

33

34

35

36

37
	public static <T> AccessPath<T> empty() {publicstatic<T>AccessPath<T>empty(){		return new AccessPath<T>();returnnewAccessPath<T>();	}}		private final SubAccessPath<FieldRef>[] accesses;privatefinalSubAccessPath<FieldRef>[]accesses;



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

38
	private final Set<FieldRef>[] exclusions;privatefinalSet<FieldRef>[]exclusions;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

39

40
		public AccessPath() {publicAccessPath(){



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

41
		accesses = new SubAccessPath[0];accesses=newSubAccessPath[0];



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

42

43

44
		exclusions = new Set[0];exclusions=newSet[0];	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

45

46

47
	AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {AccessPath(SubAccessPath<FieldRef>[]accesses,Set<FieldRef>[]exclusions){		this.accesses = accesses;this.accesses=accesses;		this.exclusions = exclusions;this.exclusions=exclusions;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

48

49
	}}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

50

51

52

53

54

55

56
	public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<FieldRef>...fieldReferences){		outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {outer:for(inti=0;i<fieldReferences.length&&i<exclusions.length;i++){			for(FieldRef field : fieldReferences[i].elements()) {for(FieldReffield:fieldReferences[i].elements()){				if(!exclusions[i].contains(field))if(!exclusions[i].contains(field))					continue outer;continueouter;			}}			return true;returntrue;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

57

58

59

60
		}			}		return false;returnfalse;	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

61

62

63

64

65

66
	public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {publicAccessPath<FieldRef>addFieldReference(SubAccessPath<FieldRef>...fieldReferences){		return addFieldReference(true, fieldReferences);returnaddFieldReference(true,fieldReferences);	}}			AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {AccessPath<FieldRef>addFieldReference(booleanmerge,SubAccessPath<FieldRef>...fieldReferences){



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

67
		if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences))



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

68
			throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

69




regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

177

178
		if(merge) {if(merge){			boolean finiteDepth = true;booleanfiniteDepth=true;			for(int i=fieldReferences.length-1; i>=0; i--) {for(inti=fieldReferences.length-1;i>=0;i--){				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)if(fieldReferences[i]instanceofSetOfPossibleFieldAccesses)					finiteDepth = false;finiteDepth=false;									for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){					if(accesses[j].intersects(fieldReferences[i])) {if(accesses[j].intersects(fieldReferences[i])){						// [..., {j-i}, ...]// [..., {j-i}, ...]												AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);AccessPathBuilderbuilder=newAccessPathBuilder(j+fieldReferences.length-i);						builder.keep(0, j);builder.keep(0,j);						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);builder.merge(j,accesses.length).mergeWithLast(fieldReferences,0,i);						builder.append(fieldReferences, i+1, fieldReferences.length);builder.append(fieldReferences,i+1,fieldReferences.length);						if(finiteDepth)if(finiteDepth)							builder.removeExclusions(fieldReferences.length);builder.removeExclusions(fieldReferences.length);						elseelse							builder.removeExclusions(Integer.MAX_VALUE);builder.removeExclusions(Integer.MAX_VALUE);						return builder.build();returnbuilder.build();					}}				}}			}}		}}				AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+fieldReferences.length);		builder.keep(0, accesses.length);builder.keep(0,accesses.length);		builder.append(fieldReferences, 0, fieldReferences.length);builder.append(fieldReferences,0,fieldReferences.length);		builder.removeExclusions(fieldReferences.length);builder.removeExclusions(fieldReferences.length);		return builder.build();returnbuilder.build();	}}		public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRef>addFieldReference(FieldRef...fieldReferences){		SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];SubAccessPath<FieldRef>[]subPath=newSubAccessPath[fieldReferences.length];		for(int i=0; i<fieldReferences.length; i++) {for(inti=0;i<fieldReferences.length;i++){			subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);subPath[i]=newSpecificFieldAccess<>(fieldReferences[i]);		}}		return addFieldReference(subPath);returnaddFieldReference(subPath);	}}		private class AccessPathBuilder {privateclassAccessPathBuilder{				private Set<FieldRef>[] newExclusions;privateSet<FieldRef>[]newExclusions;		private SubAccessPath<FieldRef>[] newAccesses;privateSubAccessPath<FieldRef>[]newAccesses;		private int currentIndex = 0;privateintcurrentIndex=0;		public AccessPathBuilder(int capacity) {publicAccessPathBuilder(intcapacity){			newAccesses = new SubAccessPath[capacity];newAccesses=newSubAccessPath[capacity];			newExclusions = exclusions;newExclusions=exclusions;		}}				public AccessPath<FieldRef> build() {publicAccessPath<FieldRef>build(){			while(newAccesses.length > 0 && newExclusions.length > 0) {while(newAccesses.length>0&&newExclusions.length>0){				HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);HashSet<FieldRef>newHashSet=Sets.newHashSet(newExclusions[0]);				if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {if(newAccesses[newAccesses.length-1]instanceofSetOfPossibleFieldAccesses&&newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())){					if(newHashSet.isEmpty()) {if(newHashSet.isEmpty()){						removeExclusions(1);removeExclusions(1);					}}					else {else{						newExclusions[0] = newHashSet;newExclusions[0]=newHashSet;						break;break;					}}				} else break;}elsebreak;			}}						return new AccessPath<>(newAccesses, newExclusions);returnnewAccessPath<>(newAccesses,newExclusions);		}}		public void removeExclusions(int length) {publicvoidremoveExclusions(intlength){			if(length>=newExclusions.length)if(length>=newExclusions.length)				newExclusions = new Set[0];newExclusions=newSet[0];			elseelse				newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);newExclusions=Arrays.copyOfRange(newExclusions,length,newExclusions.length);		}}		public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {publicvoidappend(SubAccessPath<FieldRef>[]fieldReferences,intstart,intendExcl){			for(int i=start; i<endExcl; i++) {for(inti=start;i<endExcl;i++){				newAccesses[currentIndex] = fieldReferences[i];newAccesses[currentIndex]=fieldReferences[i];				currentIndex++;currentIndex++;				if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)if(fieldReferences[i]instanceofSetOfPossibleFieldAccesses)					newExclusions = new Set[0];newExclusions=newSet[0];			}}			currentIndex+=endExcl-start;currentIndex+=endExcl-start;		}}		public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<FieldRef>[]fieldReferences,intstart,intendExcl){			newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl));		}}		public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {publicAccessPathBuildermerge(intsrcIndex,intdestIndexExcl){			Set<FieldRef> set = Sets.newHashSet();Set<FieldRef>set=Sets.newHashSet();			for(int i=srcIndex; i<destIndexExcl; i++) {for(inti=srcIndex;i<destIndexExcl;i++){				set.addAll(accesses[i].elements());set.addAll(accesses[i].elements());			}}			newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);newAccesses[currentIndex]=newSubAccessPath.SetOfPossibleFieldAccesses<>(set);			currentIndex++;currentIndex++;			return this;returnthis;		}}		public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {publicAccessPathBuilderkeep(intsrcIndex,intdestIndexExcl){			System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);System.arraycopy(accesses,srcIndex,newAccesses,currentIndex,destIndexExcl-srcIndex);			currentIndex += destIndexExcl-srcIndex;currentIndex+=destIndexExcl-srcIndex;			return this;returnthis;		}}		public void append(FieldRef fieldRef) {publicvoidappend(FieldReffieldRef){			newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);newAccesses[currentIndex]=newSubAccessPath.SpecificFieldAccess<>(fieldRef);			currentIndex++;currentIndex++;		}}		



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

179

180

181

182

183

184
	}}	public ExclusionSet getExclusions(int index) {publicExclusionSetgetExclusions(intindex){		return new ExclusionSet(index);returnnewExclusionSet(index);	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

185

186

187

188

189

190

191

192

193

194

195

196

197

198

199
	public AccessPath<FieldRef> prepend(FieldRef fieldRef) {publicAccessPath<FieldRef>prepend(FieldReffieldRef){		for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){			if(accesses[j].contains(fieldRef)) {if(accesses[j].contains(fieldRef)){				// [{0-j}, ...]// [{0-j}, ...]								AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length-j);				builder.merge(0, j+1);builder.merge(0,j+1);				builder.keep(j+1, accesses.length);builder.keep(j+1,accesses.length);				return builder.build();returnbuilder.build();			}}		}}		AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+1);		builder.append(fieldRef);builder.append(fieldRef);		builder.keep(0, accesses.length);builder.keep(0,accesses.length);		return builder.build();returnbuilder.build();



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

200

201
	}}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218
	public AccessPath<FieldRef> removeFirst(FieldRef field) {publicAccessPath<FieldRef>removeFirst(FieldReffield){		for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){			if(accesses[i].contains(field)) {if(accesses[i].contains(field)){				if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess)					return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<FieldRef>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions);				elseelse					return this;returnthis;			}}			else if(accesses[i] instanceof SpecificFieldAccess)elseif(accesses[i]instanceofSpecificFieldAccess)				throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this);		}}				throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this);	}}		public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {publicAccessPath<FieldRef>removeFirstExclusionSetIfAvailable(){		if(exclusions.length > 0)if(exclusions.length>0)



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

219

220

221

222

223

224
			return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));returnnewAccessPath<FieldRef>(accesses,Arrays.copyOfRange(exclusions,1,exclusions.length));		elseelse			return this;returnthis;	}}	public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {publicAccessPath<FieldRef>mergeExcludedFieldReference(FieldRef...fieldRef){



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

225
		if(exclusions.length>0)if(exclusions.length>0)



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

226

227

228

229

230
			return getExclusions(0).addExclusion(fieldRef);returngetExclusions(0).addExclusion(fieldRef);		elseelse			return appendExcludedFieldReference(fieldRef);returnappendExcludedFieldReference(fieldRef);	}}	



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

231

232

233

234

235
	public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRef>appendExcludedFieldReference(FieldRef...fieldReferences){		Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);Set<FieldRef>[]newExclusionsArray=Arrays.copyOf(exclusions,exclusions.length+1);		newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);newExclusionsArray[exclusions.length]=Sets.newHashSet(fieldReferences);		return new AccessPath<>(accesses, newExclusionsArray);returnnewAccessPath<>(accesses,newExclusionsArray);	}}



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

236

237

238

239

240

241

242

243

244

245

246

247

248

249
	public static enum PrefixTestResult {publicstaticenumPrefixTestResult{		GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);GUARANTEED_PREFIX(2),POTENTIAL_PREFIX(1),NO_PREFIX(0);				private int value;privateintvalue;		private PrefixTestResult(int value) {privatePrefixTestResult(intvalue){			this.value = value;this.value=value;		}}				public boolean atLeast(PrefixTestResult minimum) {publicbooleanatLeast(PrefixTestResultminimum){			return value >= minimum.value;returnvalue>=minimum.value;		}}	}}



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

250
	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

251

252

253

254
	public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {publicPrefixTestResultisPrefixOf(AccessPath<FieldRef>accPath){		int currIndex = 0;intcurrIndex=0;		int otherIndex = 0;intotherIndex=0;		PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;PrefixTestResultresult=PrefixTestResult.GUARANTEED_PREFIX;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

255
		



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277

278

279
		int finalIndex = finalIndex();intfinalIndex=finalIndex();		outer: while(currIndex < finalIndex) {outer:while(currIndex<finalIndex){			Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);Collection<Transition<FieldRef>>transitions=possibleTransitions(currIndex);			Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);Collection<Transition<FieldRef>>otherTransitions=accPath.possibleTransitions(otherIndex);			if(transitions.size() > 1 && otherTransitions.size() > 1)if(transitions.size()>1&&otherTransitions.size()>1)				throw new AssertionError();thrownewAssertionError();						for(Transition<FieldRef> transition : transitions) {for(Transition<FieldRef>transition:transitions){				for(Transition<FieldRef> otherTransition : otherTransitions) {for(Transition<FieldRef>otherTransition:otherTransitions){					MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<FieldRef>>match=transition.isPrefixMatchOf(otherTransition);					if(match.hasMatched()) {if(match.hasMatched()){						if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())if(currIndex==transition.transitionToIndex()&&otherIndex==otherTransition.transitionToIndex())							throw new AssertionError();thrownewAssertionError();												currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex();						otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex();						if(!match.isGuaranteedMatch())if(!match.isGuaranteedMatch())							result = PrefixTestResult.POTENTIAL_PREFIX;result=PrefixTestResult.POTENTIAL_PREFIX;												continue outer;continueouter;					}}				}}			}}



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

280
			return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX;



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

281
		}}



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

282
		



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

283

284

285

286

287

288

289

290
		return result;returnresult;	}}		private int finalIndex() {privateintfinalIndex(){		if(exclusions.length > 0)if(exclusions.length>0)			return accesses.length + exclusions.length;returnaccesses.length+exclusions.length;				int finalIndex = 0;intfinalIndex=0;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

291
		for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

292

293
			if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess)				finalIndex = i+1;finalIndex=i+1;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

294
		}}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

295

296

297

298

299

300

301

302

303
		return finalIndex;returnfinalIndex;	}}	private Collection<Transition<FieldRef>> possibleTransitions(int index) {privateCollection<Transition<FieldRef>>possibleTransitions(intindex){		Collection<Transition<FieldRef>> result = Lists.newLinkedList();Collection<Transition<FieldRef>>result=Lists.newLinkedList();		if(index < accesses.length) {if(index<accesses.length){			if(accesses[index] instanceof SetOfPossibleFieldAccesses) {if(accesses[index]instanceofSetOfPossibleFieldAccesses){				result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index,accesses[index]));				result.addAll(possibleTransitions(index+1));result.addAll(possibleTransitions(index+1));



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

304
			}}



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

305

306

307

308
			elseelse				result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index+1,accesses[index]));		} else if(index - accesses.length < exclusions.length) {}elseif(index-accesses.length<exclusions.length){			result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));result.add(newTransition.ExclusionPathTransition<FieldRef>(index+1,exclusions[index-accesses.length]));



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

309
		}}



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

310
		return result;returnresult;



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

311

312
	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

313

314

315

316

317

318

319

320

321

322

323

324

325

326

327

328

329

330

331

332

333

334

335
	public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {publicSubAccessPath<FieldRef>[]getDeltaTo(AccessPath<FieldRef>accPath){		int currentIndex = 0;intcurrentIndex=0;				for(SubAccessPath<FieldRef> sub : accesses) {for(SubAccessPath<FieldRef>sub:accesses){			if(!(sub instanceof SpecificFieldAccess))if(!(subinstanceofSpecificFieldAccess))				throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());thrownewIllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());						FieldRef field = sub.elements().iterator().next();FieldReffield=sub.elements().iterator().next();						while(true) {while(true){				if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {if(currentIndex<accPath.accesses.length&&accPath.accesses[currentIndex].contains(field)){					if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)if(accPath.accesses[currentIndex]instanceofSpecificFieldAccess)						currentIndex++;currentIndex++;					break;break;				} else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {}elseif(currentIndex<accPath.accesses.length&&accPath.accesses[currentIndex]instanceofSetOfPossibleFieldAccesses){					currentIndex++;currentIndex++;				}}				elseelse					throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);thrownewIllegalArgumentException("'"+toString()+"' is not a prefix of the given AccessPath: "+accPath);			}}		}}				return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,currentIndex,accPath.accesses.length);



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

336

337

338

339

340

341

342

343

344

345

346

347

348

349
	}}		public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>mergeExcludedFieldReferences(AccessPath<FieldRef>accPath){		Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];Set<FieldRef>[]newExclusionArray=newSet[Math.max(exclusions.length,accPath.exclusions.length)];		for(int i=0; i<newExclusionArray.length; i++) {for(inti=0;i<newExclusionArray.length;i++){			newExclusionArray[i] = Sets.newHashSet();newExclusionArray[i]=Sets.newHashSet();			if(i<exclusions.length)if(i<exclusions.length)				newExclusionArray[i].addAll(exclusions[i]);newExclusionArray[i].addAll(exclusions[i]);			if(i<accPath.exclusions.length)if(i<accPath.exclusions.length)				newExclusionArray[i].addAll(accPath.exclusions[i]);newExclusionArray[i].addAll(accPath.exclusions[i]);		}}		return new AccessPath<>(accesses, newExclusionArray);returnnewAccessPath<>(accesses,newExclusionArray);	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

350

351

352

353
	public boolean mayHaveEmptyAccessPath() {publicbooleanmayHaveEmptyAccessPath(){		return finalIndex() == 0;returnfinalIndex()==0;	}}	



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

354

355

356

357

358

359

360

361

362

363

364

365

366

367

368

369

370

371

372

373

374

375

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391
	public boolean isEmpty() {publicbooleanisEmpty(){		return exclusions.length == 0 && accesses.length == 0;returnexclusions.length==0&&accesses.length==0;	}}		@Override@Override	public int hashCode() {publicinthashCode(){		final int prime = 31;finalintprime=31;		int result = 1;intresult=1;		result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses);		result = prime * result + Arrays.hashCode(exclusions);result=prime*result+Arrays.hashCode(exclusions);		return result;returnresult;	}}	@Override@Override	public boolean equals(Object obj) {publicbooleanequals(Objectobj){		if (this == obj)if(this==obj)			return true;returntrue;		if (obj == null)if(obj==null)			return false;returnfalse;		if (!(obj instanceof AccessPath))if(!(objinstanceofAccessPath))			return false;returnfalse;		AccessPath other = (AccessPath) obj;AccessPathother=(AccessPath)obj;		if (!Arrays.equals(accesses, other.accesses))if(!Arrays.equals(accesses,other.accesses))			return false;returnfalse;		if (!Arrays.equals(exclusions, other.exclusions))if(!Arrays.equals(exclusions,other.exclusions))			return false;returnfalse;		return true;returntrue;	}}	@Override@Override	public String toString() {publicStringtoString(){		String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):"";		for(Set<FieldRef> exclusion : exclusions) {for(Set<FieldRef>exclusion:exclusions){			result += "^" + Joiner.on(",").join(exclusion);result+="^"+Joiner.on(",").join(exclusion);		}}		return result;returnresult;	}}	



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

392

393

394

395

396

397

398

399

400

401

402

403

404

405
//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {//		T[] newAccesses = (T[]) new Object[accesses.length];//		T[] newAccesses = (T[]) new Object[accesses.length];//		for(int i=0; i<accesses.length; i++) {//		for(int i=0; i<accesses.length; i++) {//			newAccesses[i] = function.apply(accesses[i]);//			newAccesses[i] = function.apply(accesses[i]);//		}//		}//		Set<T>[] newExclusions = new Set[exclusions.length];//		Set<T>[] newExclusions = new Set[exclusions.length];//		for(int i=0; i<exclusions.length; i++) {//		for(int i=0; i<exclusions.length; i++) {//			newExclusions[i] = Sets.newHashSet();//			newExclusions[i] = Sets.newHashSet();//			for(FieldRef excl : exclusions[i]) {//			for(FieldRef excl : exclusions[i]) {//				newExclusions[i].add(function.apply(excl));//				newExclusions[i].add(function.apply(excl));//			}//			}//		}//		}//		return new AccessPath<T>(newAccesses, newExclusions);//		return new AccessPath<T>(newAccesses, newExclusions);//	}//	}



k-limitting; fix in constraint propagation


 

 


Johannes Lerch
committed
Jan 14, 2015



k-limitting; fix in constraint propagation


 

 

k-limitting; fix in constraint propagation

 

Johannes Lerch
committed
Jan 14, 2015

406
	



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

407

408

409

410

411

412

413
	public class ExclusionSet {publicclassExclusionSet{		private int index;privateintindex;			private ExclusionSet(int index) {privateExclusionSet(intindex){			this.index = index;this.index=index;		}}		



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

414
		public AccessPath<FieldRef> addExclusion(FieldRef... exclusion) {publicAccessPath<FieldRef>addExclusion(FieldRef...exclusion){



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

415
			HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);HashSet<FieldRef>newExclusions=Sets.newHashSet(exclusions[index]);



Bugfix, Helper functions, and renaming


 

 


Johannes Lerch
committed
Jan 08, 2015



Bugfix, Helper functions, and renaming


 

 

Bugfix, Helper functions, and renaming

 

Johannes Lerch
committed
Jan 08, 2015

416

417
			for(FieldRef excl : exclusion)for(FieldRefexcl:exclusion)				newExclusions.add(excl);newExclusions.add(excl);



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

418

419

420

421

422
			Set<FieldRef>[] newExclusionsArray = exclusions.clone();Set<FieldRef>[]newExclusionsArray=exclusions.clone();			newExclusionsArray[index] = newExclusions;newExclusionsArray[index]=newExclusions;			return new AccessPath<FieldRef>(accesses, newExclusionsArray);returnnewAccessPath<FieldRef>(accesses,newExclusionsArray);		}}	}}



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

423




regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

424
	public AccessPath<FieldRef> removeAnyAccess() {publicAccessPath<FieldRef>removeAnyAccess(){



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

425
		if(accesses.length > 0)if(accesses.length>0)



regexp access path


 

 


Johannes Lerch
committed
Feb 05, 2015



regexp access path


 

 

regexp access path

 

Johannes Lerch
committed
Feb 05, 2015

426

427

428

429

430

431

432
			return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);returnnewAccessPath<FieldRef>(newSubAccessPath[0],exclusions);		elseelse			return this;returnthis;	}}	public boolean hasEmptyAccessPath() {publicbooleanhasEmptyAccessPath(){		return accesses.length == 0;returnaccesses.length==0;



Split prefix check into potential and guaranteed prefix


 

 


Johannes Lerch
committed
Jan 22, 2015



Split prefix check into potential and guaranteed prefix


 

 

Split prefix check into potential and guaranteed prefix

 

Johannes Lerch
committed
Jan 22, 2015

433
	}}



cleaning code



 


Johannes Lerch
committed
Jan 07, 2015



cleaning code



 

cleaning code


Johannes Lerch
committed
Jan 07, 2015

434
}}





