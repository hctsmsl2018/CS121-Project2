



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab






Sign in




Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab






Sign in




Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab






Sign in




Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

e60e669d















Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......














src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file














src/heros/alias/TestDebugger.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......














src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}














src/heros/alias/WrappedFact.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......














src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......














src/heros/alias/ZeroHandler.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














test/heros/alias/AccessPathTest.java








View file @ e60e669d






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}














test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ e60e669d






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment











H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

e60e669d















Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......














src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file














src/heros/alias/TestDebugger.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......














src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}














src/heros/alias/WrappedFact.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......














src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......














src/heros/alias/ZeroHandler.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














test/heros/alias/AccessPathTest.java








View file @ e60e669d






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}














test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ e60e669d






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Open sidebar



Joshua Garcia heros
Commits

e60e669d







Open sidebar



Joshua Garcia heros
Commits

e60e669d




Open sidebar

Joshua Garcia heros
Commits

e60e669d


Joshua GarciaherosherosCommits
e60e669d








Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......














src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file














src/heros/alias/TestDebugger.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......














src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}














src/heros/alias/WrappedFact.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......














src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......














src/heros/alias/ZeroHandler.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














test/heros/alias/AccessPathTest.java








View file @ e60e669d






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}














test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ e60e669d






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment











Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files




removed unnecessary merge code in access path







parent
1f74a4f2













Changes
36




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......














src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file














src/heros/alias/TestDebugger.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......














src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}














src/heros/alias/WrappedFact.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......














src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......














src/heros/alias/ZeroHandler.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














test/heros/alias/AccessPathTest.java








View file @ e60e669d






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}














test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ e60e669d






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......









Prev


1


2


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment







Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch



Browse files



Commit
e60e669d


authored
Mar 25, 2015
by


Johannes Lerch

e60e669dauthoredbyJohannes Lerch

removed unnecessary merge code in access path






parent
1f74a4f2
















parent
1f74a4f2





parent












Changes
36
36


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......














src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file














src/heros/alias/TestDebugger.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......














src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}














src/heros/alias/WrappedFact.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......














src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......














src/heros/alias/ZeroHandler.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......














test/heros/alias/AccessPathTest.java








View file @ e60e669d






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}














test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......














test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......














test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......














test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file














test/heros/alias/TestHelper.java








View file @ e60e669d






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......









Prev


1


2


Next













src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......












src/heros/alias/ReturnSiteResolver.java








View file @ e60e669d








src/heros/alias/ReturnSiteResolver.java










View file @ e60e669d


e60e669d



......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......






......@@ -20,7 +20,7 @@ import java.util.Set;









import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {










public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;



......@@ -91,9 +91,9 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);



......@@ -151,7 +151,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {














......@@ -170,7 +170,7 @@ public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact,









 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);



......


import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassReturnSiteResolver<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassReturnSiteResolver<Field,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ private Stmt returnSite;privateStmtreturnSite; private AccessPath<Field> resolvedAccPath;privateAccessPath<Field>resolvedAccPath; if(!constraint.canBeAppliedTo(resolvedAccPath))if(!constraint.canBeAppliedTo(resolvedAccPath)) return;return;  AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath,, falsefalse); AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath); ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);ReturnSiteResolver<Field,Fact,Stmt,Method>nestedResolver=getOrCreateNestedResolver(candidateAccPath); if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath,, falsefalse))) if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath))) throw new AssertionError();thrownewAssertionError();  nestedResolver.registerCallback(callback);nestedResolver.registerCallback(callback); resolveViaDeltaAndPotentiallyDelegateToCallSite();resolveViaDeltaAndPotentiallyDelegateToCallSite(); } else {}else{ //resolve via incoming facts resolver//resolve via incoming facts resolver Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);Delta<Field>delta=usedAccessPathOfIncResolver.applyTo(incAccessPath,, truetrue).getDeltaTo(resolvedAccPath); Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath);Delta<Field>delta=usedAccessPathOfIncResolver.applyTo(incAccessPath).getDeltaTo(resolvedAccPath); assert delta.accesses.length <= 1;assertdelta.accesses.length<=1; incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {incResolver.resolve(newDeltaConstraint<>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ }} private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {privatevoidresolveViaDeltaAndPotentiallyDelegateToCallSite(){ final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);finalAccessPath<Field>currAccPath=callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath,, truetrue),), truetrue); final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));finalAccessPath<Field>currAccPath=callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath));) if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {if(resolvedAccPath.isPrefixOf(currAccPath)==PrefixTestResult.GUARANTEED_PREFIX){ incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));incomingFacts.add(newReturnEdge(incFact,incAccessPath,null,resolverAtCaller,callDelta,usedAccessPathOfIncResolver)); ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);ReturnSiteResolver.this.interest(analyzer,ReturnSiteResolver.this);








src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file












src/heros/alias/SubAccessPath.java

deleted


100644 → 0







View file @ 1f74a4f2








src/heros/alias/SubAccessPath.java

deleted


100644 → 0









View file @ 1f74a4f2


1f74a4f2










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {










 










 boolean contains(FieldRef field);










 










 boolean shouldBeMerged(FieldRef field);





















 boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);





















 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);










 










 <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);





















 










 public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 return accPath.shouldBeMerged(field);










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 return this.field.shouldBeMergedWith(field);










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 return new SpecificFieldAccess<U>(function.apply(field));










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(FieldRef field) {










 for(FieldRef f : set) {










 if(f.shouldBeMergedWith(field))










 return true;










 }










 return false;










 }





















 @Override










 public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f : set) {










 if(accPath.shouldBeMerged(f))










 return true;










 }










 return false;










 }










 










 @Override










 public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {










 Set<U> newSet = Sets.newHashSet();










 for(FieldRef f : set) {










 newSet.add(function.apply(f));










 }










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 }





















}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Collection;importjava.util.Collection;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Function;importcom.google.common.base.Function;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public interface SubAccessPath<FieldRef extends AccessPath.FieldRef<FieldRef>> {publicinterfaceSubAccessPath<FieldRefextendsAccessPath.FieldRef<FieldRef>>{  boolean contains(FieldRef field);booleancontains(FieldReffield);  boolean shouldBeMerged(FieldRef field);booleanshouldBeMerged(FieldReffield); boolean shouldBeMerged(SubAccessPath<FieldRef> accPath);booleanshouldBeMerged(SubAccessPath<FieldRef>accPath); boolean intersects(SubAccessPath<FieldRef> accPath);booleanintersects(SubAccessPath<FieldRef>accPath); Collection<? extends FieldRef> elements();Collection<?extendsFieldRef>elements();  SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);SetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields);  <U extends AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function);<UextendsAccessPath.FieldRef<U>>SubAccessPath<U>map(Function<FieldRef,U>function);  public static class SpecificFieldAccess<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {publicstaticclassSpecificFieldAccess<FieldRefextendsAccessPath.FieldRef<FieldRef>>implementsSubAccessPath<FieldRef>{ private final FieldRef field;privatefinalFieldReffield;  public SpecificFieldAccess(FieldRef field) {publicSpecificFieldAccess(FieldReffield){ this.field = field;this.field=field; }} @Override@Override public boolean contains(FieldRef field) {publicbooleancontains(FieldReffield){ return this.field.equals(field);returnthis.field.equals(field); }} @Override@Override public Collection<? extends FieldRef> elements() {publicCollection<?extendsFieldRef>elements(){ return Sets.newHashSet(field);returnSets.newHashSet(field); }} @Override@Override public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {publicSetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields){ HashSet<FieldRef> set = Sets.newHashSet();HashSet<FieldRef>set=Sets.newHashSet(); for(SubAccessPath<FieldRef> f : fields) {for(SubAccessPath<FieldRef>f:fields){ set.addAll(f.elements());set.addAll(f.elements()); }} return new SetOfPossibleFieldAccesses<>(set);returnnewSetOfPossibleFieldAccesses<>(set); }}  @Override@Override public String toString() {publicStringtoString(){ return field.toString();returnfield.toString(); }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((field == null) ? 0 : field.hashCode());result=prime*result+((field==null)?0:field.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof SpecificFieldAccess))if(!(objinstanceofSpecificFieldAccess)) return false;returnfalse; SpecificFieldAccess other = (SpecificFieldAccess) obj;SpecificFieldAccessother=(SpecificFieldAccess)obj; if (field == null) {if(field==null){ if (other.field != null)if(other.field!=null) return false;returnfalse; } else if (!field.equals(other.field))}elseif(!field.equals(other.field)) return false;returnfalse; return true;returntrue; }} @Override@Override public boolean intersects(SubAccessPath<FieldRef> accPath) {publicbooleanintersects(SubAccessPath<FieldRef>accPath){ return accPath.contains(field);returnaccPath.contains(field); }} @Override@Override public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {publicbooleanshouldBeMerged(SubAccessPath<FieldRef>accPath){ return accPath.shouldBeMerged(field);returnaccPath.shouldBeMerged(field); }} @Override@Override public boolean shouldBeMerged(FieldRef field) {publicbooleanshouldBeMerged(FieldReffield){ return this.field.shouldBeMergedWith(field);returnthis.field.shouldBeMergedWith(field); }}  @Override@Override public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {public<Uextendsheros.alias.AccessPath.FieldRef<U>>SubAccessPath<U>map(Function<FieldRef,U>function){ return new SpecificFieldAccess<U>(function.apply(field));returnnewSpecificFieldAccess<U>(function.apply(field)); }} }}  public static class SetOfPossibleFieldAccesses<FieldRef extends AccessPath.FieldRef<FieldRef>> implements SubAccessPath<FieldRef> {publicstaticclassSetOfPossibleFieldAccesses<FieldRefextendsAccessPath.FieldRef<FieldRef>>implementsSubAccessPath<FieldRef>{  private final Set<FieldRef> set;privatefinalSet<FieldRef>set;  public SetOfPossibleFieldAccesses() {publicSetOfPossibleFieldAccesses(){ set = Sets.newHashSet();set=Sets.newHashSet(); }} public SetOfPossibleFieldAccesses(Set<FieldRef> set) {publicSetOfPossibleFieldAccesses(Set<FieldRef>set){ this.set = set;this.set=set; }} @Override@Override public boolean contains(FieldRef field) {publicbooleancontains(FieldReffield){ return set.contains(field);returnset.contains(field); }}  @Override@Override public Collection<? extends FieldRef> elements() {publicCollection<?extendsFieldRef>elements(){ return set;returnset; }} @Override@Override public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {publicSetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields){ HashSet<FieldRef> newSet = Sets.newHashSet(set);HashSet<FieldRef>newSet=Sets.newHashSet(set); for(SubAccessPath<FieldRef> f : fields) {for(SubAccessPath<FieldRef>f:fields){ newSet.addAll(f.elements());newSet.addAll(f.elements()); }}  return new SetOfPossibleFieldAccesses<>(newSet);returnnewSetOfPossibleFieldAccesses<>(newSet); }}  @Override@Override public String toString() {publicStringtoString(){ return "{"+Joiner.on(",").join(set)+"}";return"{"+Joiner.on(",").join(set)+"}"; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((set == null) ? 0 : set.hashCode());result=prime*result+((set==null)?0:set.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof SetOfPossibleFieldAccesses))if(!(objinstanceofSetOfPossibleFieldAccesses)) return false;returnfalse; SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;SetOfPossibleFieldAccessesother=(SetOfPossibleFieldAccesses)obj; if (set == null) {if(set==null){ if (other.set != null)if(other.set!=null) return false;returnfalse; } else if (!set.equals(other.set))}elseif(!set.equals(other.set)) return false;returnfalse; return true;returntrue; }} @Override@Override public boolean intersects(SubAccessPath<FieldRef> accPath) {publicbooleanintersects(SubAccessPath<FieldRef>accPath){ for(FieldRef f:set) {for(FieldReff:set){ if(accPath.contains(f))if(accPath.contains(f)) return true;returntrue; }} return false;returnfalse; }} @Override@Override public boolean shouldBeMerged(FieldRef field) {publicbooleanshouldBeMerged(FieldReffield){ for(FieldRef f : set) {for(FieldReff:set){ if(f.shouldBeMergedWith(field))if(f.shouldBeMergedWith(field)) return true;returntrue; }} return false;returnfalse; }} @Override@Override public boolean shouldBeMerged(SubAccessPath<FieldRef> accPath) {publicbooleanshouldBeMerged(SubAccessPath<FieldRef>accPath){ for(FieldRef f : set) {for(FieldReff:set){ if(accPath.shouldBeMerged(f))if(accPath.shouldBeMerged(f)) return true;returntrue; }} return false;returnfalse; }}  @Override@Override public <U extends heros.alias.AccessPath.FieldRef<U>> SubAccessPath<U> map(Function<FieldRef, U> function) {public<Uextendsheros.alias.AccessPath.FieldRef<U>>SubAccessPath<U>map(Function<FieldRef,U>function){ Set<U> newSet = Sets.newHashSet();Set<U>newSet=Sets.newHashSet(); for(FieldRef f : set) {for(FieldReff:set){ newSet.add(function.apply(f));newSet.add(function.apply(f)); }} return new SetOfPossibleFieldAccesses<>(newSet);returnnewSetOfPossibleFieldAccesses<>(newSet); }} }}}}








src/heros/alias/TestDebugger.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......












src/heros/alias/TestDebugger.java








View file @ e60e669d








src/heros/alias/TestDebugger.java










View file @ e60e669d


e60e669d



......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......






......@@ -19,7 +19,7 @@ import com.google.common.collect.Sets;









import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {










public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;



......


import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.alias.TestHelper.Edge;importheros.alias.TestHelper.Edge;public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicclassTestDebugger<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{public class TestDebugger<Field, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicclassTestDebugger<Field,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ private JsonDocument root = new JsonDocument();privateJsonDocumentroot=newJsonDocument(); private I icfg;privateIicfg;








src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}












src/heros/alias/Transition.java

deleted


100644 → 0







View file @ 1f74a4f2








src/heros/alias/Transition.java

deleted


100644 → 0









View file @ 1f74a4f2


1f74a4f2










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 break;










 }










 }










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Collection;importjava.util.Collection;import java.util.Set;importjava.util.Set;import com.google.common.base.Optional;importcom.google.common.base.Optional;public interface Transition<FieldRef> {publicinterfaceTransition<FieldRef>{ int transitionToIndex();inttransitionToIndex();  MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);MatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t);   public static class SubAccessPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {publicstaticclassSubAccessPathTransition<FieldRefextendsAccessPath.FieldRef<FieldRef>>implementsTransition<FieldRef>{  private int transitionToIndex;privateinttransitionToIndex; private SubAccessPath<FieldRef> subAccPath;privateSubAccessPath<FieldRef>subAccPath; public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {publicSubAccessPathTransition(inttransitionToIndex,SubAccessPath<FieldRef>subAccPath){ this.transitionToIndex = transitionToIndex;this.transitionToIndex=transitionToIndex; this.subAccPath = subAccPath;this.subAccPath=subAccPath;  }} @Override@Override public int transitionToIndex() {publicinttransitionToIndex(){ return transitionToIndex;returntransitionToIndex; }} @Override@Override public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {publicMatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t){ if(t instanceof SubAccessPathTransition) {if(tinstanceofSubAccessPathTransition){ if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>)t).subAccPath)) return new MatchResult<Transition<FieldRef>>(true, true);returnnewMatchResult<Transition<FieldRef>>(true,true); } }  return new MatchResult<>(false, false);returnnewMatchResult<>(false,false); }} }}  public static class ExclusionPathTransition<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Transition<FieldRef> {publicstaticclassExclusionPathTransition<FieldRefextendsAccessPath.FieldRef<FieldRef>>implementsTransition<FieldRef>{  private Set<FieldRef> excludedFields;privateSet<FieldRef>excludedFields; private int transitionToIndex;privateinttransitionToIndex; public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {publicExclusionPathTransition(inttransitionToIndex,Set<FieldRef>excludedFields){ this.transitionToIndex = transitionToIndex;this.transitionToIndex=transitionToIndex; this.excludedFields = excludedFields;this.excludedFields=excludedFields; }}  @Override@Override public int transitionToIndex() {publicinttransitionToIndex(){ return transitionToIndex;returntransitionToIndex; }} @Override@Override public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {publicMatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t){ if(t instanceof SubAccessPathTransition) {if(tinstanceofSubAccessPathTransition){ if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>)t).subAccPath.elements())) return new MatchResult<Transition<FieldRef>>(true, true);returnnewMatchResult<Transition<FieldRef>>(true,true); } else {}else{ Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;Set<FieldRef>otherExcludedFields=((ExclusionPathTransition<FieldRef>)t).excludedFields; boolean intersection = false;booleanintersection=false; boolean containsAll = excludedFields.containsAll(otherExcludedFields);booleancontainsAll=excludedFields.containsAll(otherExcludedFields); boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);booleanoppositeContainsAll=otherExcludedFields.containsAll(excludedFields); for(FieldRef field : excludedFields) {for(FieldReffield:excludedFields){ if(otherExcludedFields.contains(field)) {if(otherExcludedFields.contains(field)){ intersection = true;intersection=true; break;break; }} }} boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);booleanpotentialMatch=oppositeContainsAll||!intersection||(!containsAll&&!oppositeContainsAll); return new MatchResult<>(potentialMatch, oppositeContainsAll);returnnewMatchResult<>(potentialMatch,oppositeContainsAll); }}  return new MatchResult<>(false, false);returnnewMatchResult<>(false,false); }} }}  public static class MatchResult<T> {publicstaticclassMatchResult<T>{  private boolean match;privatebooleanmatch; private boolean guaranteedMatch;privatebooleanguaranteedMatch; public MatchResult(boolean match, boolean guaranteedMatch) {publicMatchResult(booleanmatch,booleanguaranteedMatch){ this.match = match;this.match=match; this.guaranteedMatch = guaranteedMatch;this.guaranteedMatch=guaranteedMatch; }}  public boolean hasMatched() {publicbooleanhasMatched(){ return match;returnmatch; }}  public boolean isGuaranteedMatch() {publicbooleanisGuaranteedMatch(){ return guaranteedMatch;returnguaranteedMatch; }} }}}}








src/heros/alias/WrappedFact.java








View file @ e60e669d






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......












src/heros/alias/WrappedFact.java








View file @ e60e669d








src/heros/alias/WrappedFact.java










View file @ e60e669d


e60e669d



......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......






......@@ -12,7 +12,7 @@ package heros.alias;




















import heros.alias.FlowFunction.Constraint;





















public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{










public class WrappedFact<Field, Fact, Stmt, Method>{





















 private final Fact fact;










 private final AccessPath<Field> accessPath;



......@@ -32,19 +32,19 @@ public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, M









 return fact;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......


import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{publicclassWrappedFact<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public class WrappedFact<Field, Fact, Stmt, Method>{publicclassWrappedFact<Field,Fact,Stmt,Method>{ private final Fact fact;privatefinalFactfact; private final AccessPath<Field> accessPath;privatefinalAccessPath<Field>accessPath; return fact;returnfact; }}  public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {publicWrappedFact<Field,Fact,Stmt,Method>applyDelta(AccessPath.Delta<Field>delta,, booleanboolean mergemerge){ return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?returnnewWrappedFact<>(fact,delta.applyTo(accessPath,, mergemerge),resolver);//TODO keep resolver? public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {publicWrappedFact<Field,Fact,Stmt,Method>applyDelta(AccessPath.Delta<Field>delta){ return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?returnnewWrappedFact<>(fact,delta.applyTo(accessPath),resolver);//TODO keep resolver? }} public AccessPath<Field> getAccessPath() {publicAccessPath<Field>getAccessPath(){ return accessPath;returnaccessPath; }}  public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {publicWrappedFact<Field,Fact,Stmt,Method>applyConstraint(Constraint<Field>constraint,FactzeroValue,, booleanboolean sourceFactsourceFact){ public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue) {publicWrappedFact<Field,Fact,Stmt,Method>applyConstraint(Constraint<Field>constraint,FactzeroValue){ if(fact.equals(zeroValue))if(fact.equals(zeroValue)) return this;returnthis; elseelse return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);returnnewWrappedFact<>(fact,constraint.applyToAccessPath(accessPath,, sourceFactsourceFact),resolver); return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);returnnewWrappedFact<>(fact,constraint.applyToAccessPath(accessPath),resolver); }}  @Override@Override








src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......












src/heros/alias/WrappedFactAtStatement.java








View file @ e60e669d








src/heros/alias/WrappedFactAtStatement.java










View file @ e60e669d


e60e669d



......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {










public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {





















 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassWrappedFactAtStatement<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>{public class WrappedFactAtStatement<Field, Fact, Stmt, Method> {publicclassWrappedFactAtStatement<Field,Fact,Stmt,Method>{ private WrappedFact<Field,Fact, Stmt, Method> fact;privateWrappedFact<Field,Fact,Stmt,Method>fact; private Stmt stmt;privateStmtstmt;








src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......












src/heros/alias/ZeroCallEdgeResolver.java








View file @ e60e669d








src/heros/alias/ZeroCallEdgeResolver.java










View file @ e60e669d


e60e669d



......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......






......@@ -13,7 +13,7 @@ package heros.alias;









import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {










public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;














......@@ -24,7 +24,7 @@ public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact




















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))










 callback.interest(analyzer, this);










 }










 



......


import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {publicclassZeroCallEdgeResolver<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>extendsCallEdgeResolver<Field,Fact,Stmt,Method>{public class ZeroCallEdgeResolver<Field, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {publicclassZeroCallEdgeResolver<Field,Fact,Stmt,Method>extendsCallEdgeResolver<Field,Fact,Stmt,Method>{ private ZeroHandler<Field> zeroHandler;privateZeroHandler<Field>zeroHandler; @Override@Override public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {publicvoidresolve(Constraint<Field>constraint,InterestCallback<Field,Fact,Stmt,Method>callback){ if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(newAccessPath<Field>(),, truetrue))) if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>())))if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(newAccessPath<Field>()))) callback.interest(analyzer, this);callback.interest(analyzer,this); }} 








src/heros/alias/ZeroHandler.java








View file @ e60e669d






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}












src/heros/alias/ZeroHandler.java








View file @ e60e669d








src/heros/alias/ZeroHandler.java










View file @ e60e669d


e60e669d



......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}






......@@ -10,7 +10,7 @@









 ******************************************************************************/










package heros.alias;





















public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {










public interface ZeroHandler<Field> {





















 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {publicinterfaceZeroHandler<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>>>{public interface ZeroHandler<Field> {publicinterfaceZeroHandler<Field>{ boolean shouldGenerateAccessPath(AccessPath<Field> accPath);booleanshouldGenerateAccessPath(AccessPath<Field>accPath);}}








src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......












src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java








View file @ e60e669d








src/heros/alias/bidi/SourceStmtAnnotatedMethodAnalyzer.java










View file @ e60e669d


e60e669d



......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......






......@@ -19,7 +19,7 @@ import heros.alias.PerAccessPathMethodAnalyzer;









import heros.alias.WrappedFact;










import heros.alias.WrappedFactAtStatement;





















public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>










public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>










 implements MethodAnalyzer<Field, Fact, Stmt, Method> {





















 private Method method;



......


import heros.alias.WrappedFact;importheros.alias.WrappedFact;import heros.alias.WrappedFactAtStatement;importheros.alias.WrappedFactAtStatement;public class SourceStmtAnnotatedMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>publicclassSourceStmtAnnotatedMethodAnalyzer<Field extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>Fact,Stmt,Method>public class SourceStmtAnnotatedMethodAnalyzer<Field, Fact, Stmt, Method>publicclassSourceStmtAnnotatedMethodAnalyzer<Field,Fact,Stmt,Method> implements MethodAnalyzer<Field, Fact, Stmt, Method> {implementsMethodAnalyzer<Field,Fact,Stmt,Method>{ private Method method;privateMethodmethod;








test/heros/alias/AccessPathTest.java








View file @ e60e669d






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}












test/heros/alias/AccessPathTest.java








View file @ e60e669d








test/heros/alias/AccessPathTest.java










View file @ e60e669d


e60e669d



......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}






......@@ -12,277 +12,71 @@ package heros.alias;




















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static TestFieldRef f(String s) {










 return new TestFieldRef(s);










 }










 










 private static TestFieldRef[] f(String...s) {










 TestFieldRef[] result = new TestFieldRef[s.length];










 for(int i=0; i<s.length; i++) {










 result[i] = f(s[i]);










 }










 return result;










 }





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)










 set.add(new TestFieldRef(f));










 return new SetOfPossibleFieldAccesses<TestFieldRef>(set);










 }










 










 private static SpecificFieldAccess<TestFieldRef> s(String field) {










 return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));










 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<TestFieldRef> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 private static AccessPath<String> ap(String... path) {










 return new AccessPath<String>(path, Sets.<String> newHashSet());










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 public void append() {










 AccessPath<String> sut = ap("a");










 assertEquals(ap("a", "b"), sut.append("b"));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(s("b")), sut.addFieldReference(s("b")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap("b"), sut.append("b"));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.append("a"); 










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));










 public void prepend() {










 assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));










 assertEquals(ap("b"), ap("a", "b").removeFirst());










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;










 assertArrayEquals(new String[] { "b" }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;










 assertArrayEquals(new String[] { "b", "c" }, actual);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 AccessPath<String> actual = ap().appendExcludedFieldReference("f");










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));










 }





















 @Test










 public void subsumes() {










 assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));










 assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));










 assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));










 










 assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));










 assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));










 }





















 @Test










 public void subsumesWithExclusions() {










 assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));










 assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));










 










 assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));










 assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));










 }










}


import static org.junit.Assert.*;importstaticorg.junit.Assert.*;import java.util.Set;importjava.util.Set;import org.junit.Assert;importorg.junit.Assert;import org.junit.Test;importorg.junit.Test;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.SubAccessPath.*;importheros.alias.SubAccessPath.*;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPathTest {publicclassAccessPathTest{ private static TestFieldRef f(String s) {privatestaticTestFieldReff(Strings){ return new TestFieldRef(s);returnnewTestFieldRef(s); }}  private static TestFieldRef[] f(String...s) {privatestaticTestFieldRef[]f(String...s){ TestFieldRef[] result = new TestFieldRef[s.length];TestFieldRef[]result=newTestFieldRef[s.length]; for(int i=0; i<s.length; i++) {for(inti=0;i<s.length;i++){ result[i] = f(s[i]);result[i]=f(s[i]); }} return result;returnresult; }} private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {privatestaticSetOfPossibleFieldAccesses<TestFieldRef>anyOf(String...fields){ Set<TestFieldRef> set = Sets.newHashSet();Set<TestFieldRef>set=Sets.newHashSet(); for(String f : fields)for(Stringf:fields) set.add(new TestFieldRef(f));set.add(newTestFieldRef(f)); return new SetOfPossibleFieldAccesses<TestFieldRef>(set);returnnewSetOfPossibleFieldAccesses<TestFieldRef>(set); }}  private static SpecificFieldAccess<TestFieldRef> s(String field) {privatestaticSpecificFieldAccess<TestFieldRef>s(Stringfield){ return new SpecificFieldAccess<TestFieldRef>(new TestFieldRef(field));returnnewSpecificFieldAccess<TestFieldRef>(newTestFieldRef(field)); }}  private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {privatestaticAccessPath<TestFieldRef>ap(SubAccessPath<TestFieldRef>...path){ return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());returnnewAccessPath<TestFieldRef>(path,Sets.<TestFieldRef>newHashSet()); }}  @Test@Test public void addAndMergeAll() {publicvoidaddAndMergeAll(){ AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));AccessPath<TestFieldRef>sut=AccessPath.<TestFieldRef>empty().addFieldReference(f("a","b","c")); assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference(f("a")));assertEquals(ap(anyOf("a","b","c")),sut.addFieldReference(f("a"))); }} @Test@Test public void addAndMergeSuffix() {publicvoidaddAndMergeSuffix(){ AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a", "b", "c"));AccessPath<TestFieldRef>sut=AccessPath.<TestFieldRef>empty().addFieldReference(f("a","b","c")); assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));assertEquals(ap(s("a"),anyOf("b","c")),sut.addFieldReference(f("b"))); }}  @Test@Test public void addMultipleFieldsAndMerge() {publicvoidaddMultipleFieldsAndMerge(){ AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));AccessPath<TestFieldRef>sut=AccessPath.<TestFieldRef>empty().addFieldReference(f("a")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(f("b","a"))); }}  @Test@Test public void addWithoutMerge() {publicvoidaddWithoutMerge(){ AccessPath<TestFieldRef> sut = ap(s("a"));AccessPath<TestFieldRef>sut=ap(s("a")); assertEquals(ap(s("a"), s("b")), sut.addFieldReference(f("b")));assertEquals(ap(s("a"),s("b")),sut.addFieldReference(f("b"))); }}  @Test@Test public void addMergedFields() {publicvoidaddMergedFields(){ AccessPath<TestFieldRef> sut = ap(s("a"));AccessPath<TestFieldRef>sut=ap(s("a")); assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));assertEquals(ap(anyOf("a")),sut.addFieldReference(anyOf("a"))); }} @Test@Test public void addMergedFieldsOnExclusion() {publicvoidaddMergedFieldsOnExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}  @Test@Test public void addMergedFieldsOnNestedExclusion() {publicvoidaddMergedFieldsOnNestedExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}  @Test@Test public void addFieldThatMerges() {publicvoidaddFieldThatMerges(){ AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("x"));AccessPath<TestFieldRef>sut=ap(s("a"),s("b")).appendExcludedFieldReference(f("x")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(s("a"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField(){ AccessPath<TestFieldRef> sut = ap(s("a"), s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b"));AccessPath<TestFieldRef>sut=ap(s("a"),s("b")).appendExcludedFieldReference(f("c")).appendExcludedFieldReference(f("b")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(s("a"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField2() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField2(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b")); assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));assertEquals(ap(anyOf("a","c")),sut.addFieldReference(anyOf("a","c"))); private static AccessPath<String> ap(String... path) {privatestaticAccessPath<String>ap(String...path){ return new AccessPath<String>(path, Sets.<String> newHashSet());returnnewAccessPath<String>(path,Sets.<String>newHashSet()); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField3() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField3ddFieldThatMergesResultingInExclusionOfMergedField3(){ AccessPath<TestFieldRef> sut = ap(s("c")).appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<TestFieldRefTestFieldRef>> sutsut == apap((ss(("c""c")).)).appendExcludedFieldReferenceappendExcludedFieldReference((ff(("a""a")).)).appendExcludedFieldReferenceappendExcludedFieldReference((ff(("b""b"));) assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));assertEquals(ap(anyOfanyOf(("c""c")),)), sutsut..addFieldReferenceaddFieldReference((anyOfanyOf(("c""c")));) public void append() {publicvoidappendppend(){ AccessPath<String> sut = ap("a");AccessPath<StringString>> sutsut == apap(("a""a"); assertEquals(ap("a", "b"), sut.append("b"));assertEquals(ap("a""a",, "b""b"),), sutsut..appendappend(("b""b")); }}  @Test@Test public void addOnExclusion() {publicvoidaddOnExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<TestFieldRefTestFieldRef>sut=ap().appendExcludedFieldReference(ff(("a"));) assertEquals(ap(s("b")), sut.addFieldReference(s("b")));assertEquals(ap(ss(("b")),)sut.addFieldReferenceddFieldReference((ss("b")));) AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<StringString>sut=ap().appendExcludedFieldReference("a"); assertEquals(ap("b"), sut.append("b"));assertEquals(ap("b"),sut.appendppend("b")); }}  @Test@Test public void addOnNestedExclusion() {publicvoidaddOnNestedExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b")); assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));assertEquals(ap(anyOf("a","c")),sut.addFieldReference(anyOf("a","c"))); }} @Test(expected=IllegalArgumentException.class)@Test(expected=IllegalArgumentException.class) public void addMergedFieldsOnSingleExclusion() {publicvoidaddMergedFieldsOnSingleExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a")); sut.addFieldReference(anyOf("a")); sut.addFieldReference(anyOf("a")); }}  @Test@Test public void prependWithoutMerge() {publicvoidprependWithoutMerge(){ assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend(f("c")));assertEquals(ap(s("c"),s("a"),s("b")),ap(s("a"),s("b")).prepend(f("c"))); }}  @Test@Test public void prependWithMerge() {publicvoidprependWithMerge(){ assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("a")));assertEquals(ap(anyOf("a"),anyOf("b","c")),ap(s("a"),anyOf("b","c")).prepend(f("a"))); AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<String>sut=ap().appendExcludedFieldReference("a"); sut.append("a"); sut.append("a"); }}  @Test@Test public void prependAndMergeWithSet() {publicvoidprependAndMergeWithSetAndMergeWithSet(){ assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend(f("b")));assertEquals(ap(anyOfanyOf(("a""a,"b"b,"c"c")),)ap(ss(("a"),)anyOfanyOf(("b""b",, "c""c")).)prepend(ff(("b""b")));) public void prepend() {publicvoidprepend(){ assertEquals(ap("c", "a", "b"), ap("a", "b").prepend("c"));assertEquals(ap("c""c,"a"a,"b"b"),ap("a","b""b").prepend("c""c")); }}  @Test@Test public void remove() {publicvoidremove(){ assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst(f("a")));assertEquals(ap(s("b")),ap(s("a"),s("b")).removeFirst(f("a"))); }}  @Test@Test public void dontRemoveMergedFields() {publicvoiddontRemoveMergedFields(){ assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst(f("a")));assertEquals(ap(anyOf("a","b")),ap(anyOf("a","b")).removeFirst(f("a"))); }}  @Test@Test public void removeMergedFieldsIfRemovingSuffix() {publicvoidremoveMergedFieldsIfRemovingSuffix(){ assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst(f("c")));assertEquals(ap(),ap(anyOf("a","b"),s("c")).removeFirst(f("c"))); assertEquals(ap("b"), ap("a", "b").removeFirst());assertEquals(ap("b"),ap("a","b").removeFirst()); }}  @Test@Test public void deltaDepth1() {publicvoiddeltaDepth1(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;SubAccessPathubAccessPath<<TestFieldRefTestFieldRef>[]>actual=ap(ss(("a")).)getDeltaTo(ap(ss(("a"),)ss(("b"))).)accesses; assertArrayEquals(new SubAccessPath[] { s("b") }, actual);assertArrayEquals(newSubAccessPathubAccessPath[]{ss(("b"))},actual); String[] actual = ap("a").getDeltaTo(ap("a", "b")).accesses;Stringtring[]actual=ap("a").getDeltaTo(ap("a","b")).accesses; assertArrayEquals(new String[] { "b" }, actual);assertArrayEquals(newStringtring[]{"b"},actual); }}  @Test@Test public void deltaDepth2() {publicvoiddeltaDepth2(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"),s("c"))).accesses; assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);assertArrayEquals(newSubAccessPath[]{s("b"),s("c")},actual); }}  @Test@Test public void delta() {publicvoiddelta(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),anyOf("b"))).accesses; assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}  @Test@Test public void delta2() {publicvoiddelta2(){ SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("f"),s("g"),s("h")).getDeltaTo(ap(anyOf("f","g"),s("h"))).accesses; assertArrayEquals(new SubAccessPath[] { }, actual);assertArrayEquals(newSubAccessPath[]{},actual); }}  @Test@Test public void delta3() {publicvoiddelta3(){ SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("f"),s("f")).getDeltaTo(ap(anyOf("f"))).accesses; assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);assertArrayEquals(newSubAccessPath[]{anyOf("f")},actual); }}  @Test@Test public void deltaFromSetToSet() {publicvoiddeltaFromSetToSet(){ Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));Delta<TestFieldRef>actual=ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g"))); assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);assertArrayEquals(newSubAccessPath[]{anyOf("a")},actual.accesses); assertEquals(Sets.newHashSet(f("g")), actual.exclusions);assertEquals(Sets.newHashSet(f("g")),actual.exclusions); String[] actual = ap("a").getDeltaTo(ap("a", "b", "c")).accesses;String[]actual=ap("a").getDeltaTo(ap("a","b","c")).accesses; assertArrayEquals(new String[] { "b", "c" }, actual);assertArrayEquals(newString[]{"b","c"},actual); }}  @Test@Test public void emptyDeltaOnEqualExclusions() {publicvoidemptyDeltaOnEqualExclusions(){ AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));AccessPath<TestFieldRef>actual=ap().appendExcludedFieldReference(f("f")); assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);assertEquals(0,actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length); assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f")))); }}  @Test@Test public void deltaMatchingMergedField() {publicvoiddeltaMatchingMergedField(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b"))).accesses; assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}  @Test@Test public void prefixOfMergedField() {publicvoidprefixOfMergedField(){ assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f")).isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f")).isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f")).isPrefixOf(ap(anyOf("f"),s("h")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f"),s("h")).isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void noPrefixOfMergedField() {publicvoidnoPrefixOfMergedField(){ assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,ap(s("g")).isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.NO_PREFIX,ap(s("g")).isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void prefixOfExclusion() {publicvoidprefixOfExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("f")); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void prefixOfExclusions() {publicvoidprefixOfExclusions(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("f","g")); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f"),s("h")))); AccessPath<String> actual = ap().appendExcludedFieldReference("f");AccessPath<String>actual=ap().appendExcludedFieldReference("f"); assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length);assertEquals(0,actual.getDeltaTo(ap().appendExcludedFieldReference("f")).accesses.length); assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f")));assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference("f")).exclusions.equals(Sets.newHashSet("f"))); }}  @Test@Test public void multipleExclPrefixOfMultipleExcl() {publicvoidmultipleExclPrefixOfMultipleExcl(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("f","g")); assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));assertEquals(PrefixTestResult.POTENTIAL_PREFIX,sut.isPrefixOf(ap().appendExcludedFieldReference(f("f","h")))); }}  @Test@Test public void mergedFieldsPrefixOf() {publicvoidmergedFieldsPrefixOf(){ assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference(f("f","g"))));  assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f"),s("h")).isPrefixOf(ap(s("f"),s("h")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).appendExcludedFieldReference(f("f")).isPrefixOf(ap(s("f"),s("h")))); }} @Test@Test public void subsumes() {publicvoidsubsumes(){ assertTrue(ap(anyOf("f")).subsumes(ap(s("f"))));assertTrue(ap(anyOf("f")).subsumes(ap(s("f")))); assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));assertFalse(ap(s("f")).subsumes(ap(anyOf("f"))));  assertTrue(ap(anyOf("f", "g")).subsumes(ap(s("f"), s("g"))));assertTrue(ap(anyOf("f","g")).subsumes(ap(s("f"),s("g")))); assertFalse(ap(s("f"), s("g")).subsumes(ap(anyOf("f", "g"))));assertFalse(ap(s("f"),s("g")).subsumes(ap(anyOf("f","g"))));  assertTrue(ap(anyOf("f", "g")).subsumes(ap(anyOf("f"), anyOf("g"))));assertTrue(ap(anyOf("f","g")).subsumes(ap(anyOf("f"),anyOf("g")))); assertFalse(ap(anyOf("f"), anyOf("g")).subsumes(ap(anyOf("f", "g"))));assertFalse(ap(anyOf("f"),anyOf("g")).subsumes(ap(anyOf("f","g")))); }} @Test@Test public void subsumesWithExclusions() {publicvoidsubsumesWithExclusions(){ assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a"))));assertTrue(ap().subsumes(ap().appendExcludedFieldReference(f("a")))); assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));assertFalse(ap().appendExcludedFieldReference(f("a")).subsumes(ap()));  assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a", "b"))));assertTrue(ap().appendExcludedFieldReference(f("a")).subsumes(ap().appendExcludedFieldReference(f("a","b")))); assertFalse(ap().appendExcludedFieldReference(f("a", "b")).subsumes(ap().appendExcludedFieldReference(f("a"))));assertFalse(ap().appendExcludedFieldReference(f("a","b")).subsumes(ap().appendExcludedFieldReference(f("a")))); AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");AccessPath<String>sut=ap().appendExcludedFieldReference("f","g"); assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference("f", "h")));assertEquals(PrefixTestResult.POTENTIAL_PREFIX,sut.isPrefixOf(ap().appendExcludedFieldReference("f","h"))); }}}}








test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......












test/heros/alias/AccessPathUtilTest.java








View file @ e60e669d








test/heros/alias/AccessPathUtilTest.java










View file @ e60e669d


e60e669d



......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......






......@@ -24,10 +24,10 @@ import org.junit.Test;




















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......@@ -37,14 +37,11 @@ public class AccessPathUtilTest {









 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 accessPath = accessPath.append(identifier);










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 accessPath = accessPath.appendExcludedFieldReference(excl);










 }










 }










 return accessPath;



......@@ -107,7 +104,7 @@ public class AccessPathUtilTest {









 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));



......


public class AccessPathUtilTest {publicclassAccessPathUtilTest{ public static AccessPath<TestFieldRef> ap(String ap) {publicstaticAccessPath<TestFieldRefTestFieldRef>ap(Stringap){ public static AccessPath<String> ap(String ap) {publicstaticAccessPath<StringString>ap(Stringap){ Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)?([^\\.\\^]+)"); Matcher matcher = pattern.matcher(ap);Matchermatcher=pattern.matcher(ap); AccessPath<TestFieldRef> accessPath = new AccessPath<>();AccessPath<TestFieldRefTestFieldRef>accessPath=newAccessPath<>(); AccessPath<String> accessPath = new AccessPath<>();AccessPath<StringString>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  while(matcher.find()) {while(matcher.find()){ if(".".equals(separator) || separator == null) {if(".".equals(separator)||separator==null){ if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));accessPath=accessPath.addFieldReferenceddFieldReference((newnew TestFieldRefTestFieldRef(identifier));) accessPath = accessPath.append(identifier);accessPath=accessPath.appendppend(identifier); } else {}else{ addedExclusions=true;addedExclusions=true; String[] excl = identifier.split(",");String[]excl=identifier.split(","); TestFieldRef[] fExcl = new TestFieldRef[excl.length];TestFieldRef[]fExcl=newTestFieldRef[excl.length]; for(int i=0; i<excl.length; i++)for(inti=0;i<excl.length;i++) fExcl[i] = new TestFieldRef(excl[i]);fExcl[i]=newTestFieldRef(excl[i]); accessPath = accessPath.appendExcludedFieldReference(fExcl);accessPath=accessPath.appendExcludedFieldReference(fExcl); accessPath = accessPath.appendExcludedFieldReference(excl);accessPath=accessPath.appendExcludedFieldReference(excl); }} }} return accessPath;returnaccessPath; @Test@Test public void testExclusionRequiresFieldAccess() {publicvoidtestExclusionRequiresFieldAccess(){ assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f"))); assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap(""))); assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));assertEquals(NO_PREFIX, ap("^f").isPrefixOf(ap("")));  assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g"))); assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));








test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......












test/heros/alias/ControlFlowJoinResolverTest.java








View file @ e60e669d








test/heros/alias/ControlFlowJoinResolverTest.java










View file @ e60e669d


e60e669d



......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ControlFlowJoinResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -102,11 +102,11 @@ public class ControlFlowJoinResolverTest {









 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......


public class ControlFlowJoinResolverTest {publicclassControlFlowJoinResolverTest{ private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<TestFieldRefTestFieldRef>getDeltaConstraint(String...fieldRefs){ private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<StringString>getDeltaConstraint(String...fieldRefs){ return new DeltaConstraint<>(getDelta(fieldRefs));returnnewDeltaConstraint<>(getDelta(fieldRefs)); }} private static Delta<TestFieldRef> getDelta(String... fieldRefs) {privatestaticDelta<TestFieldRefTestFieldRef>getDelta(String...fieldRefs){ AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);AccessPath<TestFieldRefTestFieldRef>accPath=createAccessPath(fieldRefs); return new AccessPath<TestFieldRef>().getDeltaTo(accPath);returnnewAccessPath<TestFieldRefTestFieldRef>().getDeltaTo(accPath); private static Delta<String> getDelta(String... fieldRefs) {privatestaticDelta<StringString>getDelta(String...fieldRefs){ AccessPath<String> accPath = createAccessPath(fieldRefs);AccessPath<StringString>accPath=createAccessPath(fieldRefs); return new AccessPath<String>().getDeltaTo(accPath);returnnewAccessPath<StringString>().getDeltaTo(accPath); }} protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<TestFieldRefTestFieldRef>createAccessPath(String...fieldRefs){ AccessPath<TestFieldRef> accPath = new AccessPath<>();AccessPath<TestFieldRefTestFieldRef>accPath=newAccessPath<>(); protected static AccessPath<String> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<StringString>createAccessPath(String...fieldRefs){ AccessPath<String> accPath = new AccessPath<>();AccessPath<StringString>accPath=newAccessPath<>(); for (String fieldRef : fieldRefs) {for(StringfieldRef:fieldRefs){ accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));accPath=accPath.addFieldReferenceddFieldReference((newnew TestFieldRefTestFieldRef(fieldRef));) accPath = accPath.append(fieldRef);accPath=accPath.appendppend(fieldRef); }} return accPath;returnaccPath; }} private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>analyzer; private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<StringString,TestFact,TestStatement,TestMethod>analyzer; private TestStatement joinStmt;privateTestStatementjoinStmt; private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;privateControlFlowJoinResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>sut; private ControlFlowJoinResolver<String, TestFact, TestStatement, TestMethod> sut;privateControlFlowJoinResolver<StringString,TestFact,TestStatement,TestMethod>sut; private TestFact fact;privateTestFactfact; private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>callback; private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>callEdgeResolver; private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<StringString,TestFact,TestStatement,TestMethod>callback; private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<StringString,TestFact,TestStatement,TestMethod>callEdgeResolver; @Before@Before public void before() {publicvoidbefore(){ @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver)); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  @Test@Test public void resolveViaIncomingResolver() {publicvoidresolveViaIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<StringString,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Mockito.doAnswer(new Answer(){Mockito.doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>argCallback= (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<StringString,TestFact,TestStatement,TestMethod>argCallback= (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<StringString,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; argCallback.interest(null, nestedResolver);argCallback.interest(null,nestedResolver); return null;returnnull; }}   private class ResolverArgumentMatcher extendsprivateclassResolverArgumentMatcherextends ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>>{ ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>>{ private AccessPath<TestFieldRef> accPath;privateAccessPath<TestFieldRefTestFieldRef>accPath; private AccessPath<String> accPath;privateAccessPath<StringString>accPath; public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {publicResolverArgumentMatcher(AccessPath<TestFieldRefTestFieldRef>accPath){ public ResolverArgumentMatcher(AccessPath<String> accPath) {publicResolverArgumentMatcher(AccessPath<StringString>accPath){ this.accPath = accPath;this.accPath=accPath; }}








test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......












test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ e60e669d








test/heros/alias/FieldSensitiveIFDSSolverTest.java










View file @ e60e669d


e60e669d



......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......






......@@ -25,7 +25,7 @@ import static heros.alias.TestHelper.*;









public class FieldSensitiveIFDSSolverTest {





















 private TestHelper helper;










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 @Before










 public void before() {



......


public class FieldSensitiveIFDSSolverTest {publicclassFieldSensitiveIFDSSolverTest{ private TestHelper helper;privateTestHelperhelper; private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;privateTestDebugger<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>debugger; private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;privateTestDebugger<StringString,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>debugger; @Before@Before public void before() {publicvoidbefore(){








test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......












test/heros/alias/ReturnSiteResolverTest.java








View file @ e60e669d








test/heros/alias/ReturnSiteResolverTest.java










View file @ e60e669d


e60e669d



......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......






......@@ -24,29 +24,29 @@ import org.mockito.verification.VerificationMode;




















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 private static Delta<String> getDelta(String... fieldRefs) {










 AccessPath<String> accPath = createAccessPath(fieldRefs);










 return new AccessPath<String>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 accPath = accPath.append(fieldRef);










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;










 private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;










 private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {



......@@ -74,7 +74,7 @@ public class ReturnSiteResolverTest {




















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -82,13 +82,13 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }



......@@ -109,11 +109,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -127,11 +127,11 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }



......@@ -151,7 +151,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......@@ -159,8 +159,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {



......@@ -178,11 +178,11 @@ public class ReturnSiteResolverTest {









 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }



......@@ -197,8 +197,8 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));










 










 doAnswer(new Answer() {










 @Override



......@@ -218,7 +218,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);



......@@ -227,11 +227,11 @@ public class ReturnSiteResolverTest {









 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {










 ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;










 private AccessPath<String> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {










 this.accPath = accPath;










 }














......


public class ReturnSiteResolverTest {publicclassReturnSiteResolverTest{ private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<TestFieldRefTestFieldRef>getDeltaConstraint(String...fieldRefs){ private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<StringString>getDeltaConstraint(String...fieldRefs){ return new DeltaConstraint<>(getDelta(fieldRefs));returnnewDeltaConstraint<>(getDelta(fieldRefs)); }} private static Delta<TestFieldRef> getDelta(String... fieldRefs) {privatestaticDelta<TestFieldRefTestFieldRef>getDelta(String...fieldRefs){ AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);AccessPath<TestFieldRefTestFieldRef>accPath=createAccessPath(fieldRefs); return new AccessPath<TestFieldRef>().getDeltaTo(accPath);returnnewAccessPath<TestFieldRefTestFieldRef>().getDeltaTo(accPath); private static Delta<String> getDelta(String... fieldRefs) {privatestaticDelta<StringString>getDelta(String...fieldRefs){ AccessPath<String> accPath = createAccessPath(fieldRefs);AccessPath<StringString>accPath=createAccessPath(fieldRefs); return new AccessPath<String>().getDeltaTo(accPath);returnnewAccessPath<StringString>().getDeltaTo(accPath); }} protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<TestFieldRefTestFieldRef>createAccessPath(String...fieldRefs){ AccessPath<TestFieldRef> accPath = new AccessPath<>();AccessPath<TestFieldRefTestFieldRef>accPath=newAccessPath<>(); protected static AccessPath<String> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<StringString>createAccessPath(String...fieldRefs){ AccessPath<String> accPath = new AccessPath<>();AccessPath<StringString>accPath=newAccessPath<>(); for (String fieldRef : fieldRefs) {for(StringfieldRef:fieldRefs){ accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));accPath=accPath.addFieldReferenceddFieldReference((newnew TestFieldRefTestFieldRef(fieldRef));) accPath = accPath.append(fieldRef);accPath=accPath.appendppend(fieldRef); }} return accPath;returnaccPath; }} private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>analyzer; private PerAccessPathMethodAnalyzer<String, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<StringString,TestFact,TestStatement,TestMethod>analyzer; private TestStatement returnSite;privateTestStatementreturnSite; private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;privateReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>sut; private ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> sut;privateReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>sut; private TestFact fact;privateTestFactfact; private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>callback; private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>callEdgeResolver; private InterestCallback<String, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<StringString,TestFact,TestStatement,TestMethod>callback; private Resolver<String, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<StringString,TestFact,TestStatement,TestMethod>callEdgeResolver; @Before@Before public void before() {publicvoidbefore(){ @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  @Test@Test public void resolveViaIncomingResolver() {publicvoidresolveViaIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<StringString,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Mockito.doAnswer(new Answer(){Mockito.doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>argCallback= (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; InterestCallback<String, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<StringString,TestFact,TestStatement,TestMethod>argCallback= (InterestCallback<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<StringString,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; argCallback.interest(null, nestedResolver);argCallback.interest(null,nestedResolver); return null;returnnull; }}  @Test@Test public void resolveViaDeltaTwice() {publicvoidresolveViaDeltaTwice(){ final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>innerCallback=mock(InterestCallback.class); final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<StringString,TestFact,TestStatement,TestMethod>innerCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), innerCallback);resolver.resolve(getDeltaConstraint("b"),innerCallback); return null;returnnull; }}  @Test@Test public void resolveViaDeltaAndThenViaCallSite() {publicvoidresolveViaDeltaAndThenViaCallSite(){ final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>innerCallback=mock(InterestCallback.class); final InterestCallback<String, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<StringString,TestFact,TestStatement,TestMethod>innerCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), innerCallback);resolver.resolve(getDeltaConstraint("b"),innerCallback); return null;returnnull; }}  @Test@Test public void resolveViaResolverAtCallSite() {publicvoidresolveViaResolverAtCallSite(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  @Test@Test public void resolveViaResolverAtCallSiteTwice() {publicvoidresolveViaResolverAtCallSiteTwice(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<String, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<StringString,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ }} }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));}).when(nestedResolver).resolve(eq(getDeltaConstraint("b")),any(InterestCallback.class));  final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);finalInterestCallback<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>secondCallback=mock(InterestCallback.class); final InterestCallback<String, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);finalInterestCallback<StringString,TestFact,TestStatement,TestMethod>secondCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver)invocation.getArguments()[1]; ReturnSiteResolver<String, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), secondCallback);resolver.resolve(getDeltaConstraint("b"),secondCallback); return null;returnnull; }}  @Test@Test public void resolveAsEmptyViaIncomingResolver() {publicvoidresolveAsEmptyViaIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));Delta<TestFieldRefTestFieldRef>delta=newAccessPath<TestFieldRefTestFieldRef>().getDeltaTo(newAccessPath<TestFieldRefTestFieldRef>().appendExcludedFieldReference(newTestFieldRefTestFieldRef("a"))); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Delta<String> delta = new AccessPath<String>().getDeltaTo(new AccessPath<String>().appendExcludedFieldReference(new String("a")));Delta<StringString>delta=newAccessPath<StringString>().getDeltaTo(newAccessPath<StringString>().appendExcludedFieldReference(newStringString("a")));  doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override  @Test@Test public void resolveViaCallSiteResolver() {publicvoidresolveViaCallSiteResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Resolver<String, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<StringString,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class);  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); }}  private class ReturnSiteResolverArgumentMatcher extendsprivateclassReturnSiteResolverArgumentMatcherextends ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>>{ ArgumentMatcher<ReturnSiteResolver<String, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<StringString,TestFact,TestStatement,TestMethod>>{ private AccessPath<TestFieldRef> accPath;privateAccessPath<TestFieldRefTestFieldRef>accPath; private AccessPath<String> accPath;privateAccessPath<StringString>accPath; public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {publicReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRefTestFieldRef>accPath){ public ReturnSiteResolverArgumentMatcher(AccessPath<String> accPath) {publicReturnSiteResolverArgumentMatcher(AccessPath<StringString>accPath){ this.accPath = accPath;this.accPath=accPath; }}








test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file












test/heros/alias/TestFieldRef.java

deleted


100644 → 0







View file @ 1f74a4f2








test/heros/alias/TestFieldRef.java

deleted


100644 → 0









View file @ 1f74a4f2


1f74a4f2










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {










 










 public final String f;





















 public TestFieldRef(String f) {










 this.f = f;










 }










 










 @Override










 public boolean shouldBeMergedWith(TestFieldRef fieldRef) {










 return f.equals(fieldRef.f);










 }










 










 @Override










 public String toString() {










 return f;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((f == null) ? 0 : f.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof TestFieldRef))










 return false;










 TestFieldRef other = (TestFieldRef) obj;










 if (f == null) {










 if (other.f != null)










 return false;










 } else if (!f.equals(other.f))










 return false;










 return true;










 }










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class TestFieldRef implements AccessPath.FieldRef<TestFieldRef> {publicclassTestFieldRefimplementsAccessPath.FieldRef<TestFieldRef>{  public final String f;publicfinalStringf; public TestFieldRef(String f) {publicTestFieldRef(Stringf){ this.f = f;this.f=f; }}  @Override@Override public boolean shouldBeMergedWith(TestFieldRef fieldRef) {publicbooleanshouldBeMergedWith(TestFieldReffieldRef){ return f.equals(fieldRef.f);returnf.equals(fieldRef.f); }}  @Override@Override public String toString() {publicStringtoString(){ return f;returnf; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((f == null) ? 0 : f.hashCode());result=prime*result+((f==null)?0:f.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof TestFieldRef))if(!(objinstanceofTestFieldRef)) return false;returnfalse; TestFieldRef other = (TestFieldRef) obj;TestFieldRefother=(TestFieldRef)obj; if (f == null) {if(f==null){ if (other.f != null)if(other.f!=null) return false;returnfalse; } else if (!f.equals(other.f))}elseif(!f.equals(other.f)) return false;returnfalse; return true;returntrue; }}}}








test/heros/alias/TestHelper.java








View file @ e60e669d






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......












test/heros/alias/TestHelper.java








View file @ e60e669d








test/heros/alias/TestHelper.java










View file @ e60e669d


e60e669d



......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......






......@@ -44,9 +44,9 @@ public class TestHelper {









 private List<ReturnEdge> returnEdges = Lists.newLinkedList();










 private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();










 private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();










 private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;










 private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;





















 public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {










 this.debugger = debugger;










 }














......@@ -94,7 +94,7 @@ public class TestHelper {









 public static ExpectedFlowFunction kill(int times, String source) {










 return new ExpectedFlowFunction(times, new TestFact(source)) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 throw new IllegalStateException();










 }










 



......@@ -108,8 +108,8 @@ public class TestHelper {









 public static AccessPathTransformer readField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.read(new String(fieldName)).generate(target);










 }





















 @Override



......@@ -122,8 +122,8 @@ public class TestHelper {









 public static AccessPathTransformer prependField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.prepend(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -136,8 +136,8 @@ public class TestHelper {









 public static AccessPathTransformer overwriteField(final String fieldName) {










 return new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.overwrite(new String(fieldName)).generate(target);










 }










 










 @Override



......@@ -158,7 +158,7 @@ public class TestHelper {









 }










 return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return transformer.apply(target, accPathHandler);










 }










 



......@@ -171,7 +171,7 @@ public class TestHelper {









 










 private static interface AccessPathTransformer {





















 ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); 










 ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); 










 










 }










 



......@@ -182,7 +182,7 @@ public class TestHelper {









 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new AccessPathTransformer() {










 @Override










 public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 return accPathHandler.generate(target);










 }










 



......@@ -416,7 +416,7 @@ public class TestHelper {









 










 public abstract String transformerString();





















 public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);










 public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);










 }










 










 private static interface EdgeVisitor {



......@@ -539,11 +539,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {










 public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {










 return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -555,7 +555,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return createFlowFunction(edge);



......@@ -565,7 +565,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -575,7 +575,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -584,12 +584,12 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {










 private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {










 @Override










 public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,










 AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {










 Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -615,7 +615,7 @@ public class TestHelper {




















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 Scheduler scheduler = new Scheduler();










 FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(










 createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {










 @Override










 public void merge(TestFact previousFact, TestFact currentFact) {



......@@ -648,11 +648,11 @@ public class TestHelper {









 }










 }





















 private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();










 final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();










 final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {










 return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -675,7 +675,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {










 public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {










 return flowFunctions;










 }














......@@ -699,10 +699,10 @@ public class TestHelper {









 }










 










 @Override










 public ZeroHandler<TestFieldRef> zeroHandler() {










 return new ZeroHandler<TestFieldRef>() {










 public ZeroHandler<String> zeroHandler() {










 return new ZeroHandler<String>() {










 @Override










 public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {










 public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {










 return true;










 }










 };



......


 private List<ReturnEdge> returnEdges = Lists.newLinkedList();privateList<ReturnEdge>returnEdges=Lists.newLinkedList(); private Map<TestStatement, TestMethod> stmt2method = Maps.newHashMap();privateMap<TestStatement,TestMethod>stmt2method=Maps.newHashMap(); private Multiset<ExpectedFlowFunction> remainingFlowFunctions = HashMultiset.create();privateMultiset<ExpectedFlowFunction>remainingFlowFunctions=HashMultiset.create(); private TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;privateTestDebugger<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>debugger; private TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger;privateTestDebugger<StringString,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>debugger; public TestHelper(TestDebugger<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {publicTestHelper(TestDebugger<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>debugger){ public TestHelper(TestDebugger<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> debugger) {publicTestHelper(TestDebugger<StringString,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>debugger){ this.debugger = debugger;this.debugger=debugger; }} public static ExpectedFlowFunction kill(int times, String source) {publicstaticExpectedFlowFunctionkill(inttimes,Stringsource){ return new ExpectedFlowFunction(times, new TestFact(source)) {returnnewExpectedFlowFunction(times,newTestFact(source)){ @Override@Override public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ throw new IllegalStateException();thrownewIllegalStateException(); }}  public static AccessPathTransformer readField(final String fieldName) {publicstaticAccessPathTransformerreadField(finalStringfieldName){ return new AccessPathTransformer() {returnnewAccessPathTransformer(){ @Override@Override public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.read(new TestFieldRef(fieldName)).generate(target);returnaccPathHandler.read(newTestFieldRefTestFieldRef(fieldName)).generate(target); public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.read(new String(fieldName)).generate(target);returnaccPathHandler.read(newStringString(fieldName)).generate(target); }} @Override@Override public static AccessPathTransformer prependField(final String fieldName) {publicstaticAccessPathTransformerprependField(finalStringfieldName){ return new AccessPathTransformer() {returnnewAccessPathTransformer(){ @Override@Override public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.prepend(new TestFieldRef(fieldName)).generate(target);returnaccPathHandler.prepend(newTestFieldRefTestFieldRef(fieldName)).generate(target); public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.prepend(new String(fieldName)).generate(target);returnaccPathHandler.prepend(newStringString(fieldName)).generate(target); }}  @Override@Override public static AccessPathTransformer overwriteField(final String fieldName) {publicstaticAccessPathTransformeroverwriteField(finalStringfieldName){ return new AccessPathTransformer() {returnnewAccessPathTransformer(){ @Override@Override public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.overwrite(new TestFieldRef(fieldName)).generate(target);returnaccPathHandler.overwrite(newTestFieldRefTestFieldRef(fieldName)).generate(target); public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.overwrite(new String(fieldName)).generate(target);returnaccPathHandler.overwrite(newStringString(fieldName)).generate(target); }}  @Override@Override }} return new ExpectedFlowFunction(times, new TestFact(source), targetFacts) {returnnewExpectedFlowFunction(times,newTestFact(source),targetFacts){ @Override@Override public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ return transformer.apply(target, accPathHandler);returntransformer.apply(target,accPathHandler); }}   private static interface AccessPathTransformer {privatestaticinterfaceAccessPathTransformer{ ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler); ConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler); ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler); ConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler);  }}  public static ExpectedFlowFunction flow(int times, String source, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,String...targets){ return flow(times, source, new AccessPathTransformer() {returnflow(times,source,newAccessPathTransformer(){ @Override@Override public ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ public ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {publicConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ return accPathHandler.generate(target);returnaccPathHandler.generate(target); }}   public abstract String transformerString();publicabstractStringtransformerString(); public abstract FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler);publicabstractFlowFunction.ConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler); public abstract FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod> apply(TestFact target, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler);publicabstractFlowFunction.ConstrainedFact<StringString,TestFact,TestStatement,TestMethod>apply(TestFacttarget,AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler); }}  private static interface EdgeVisitor {privatestaticinterfaceEdgeVisitor{ return a.equals(b);returna.equals(b); }} public FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions() {publicFlowFunctions<TestStatement,TestFieldRefTestFieldRef,TestFact,TestMethod>flowFunctions(){ return new FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod>() {returnnewFlowFunctions<TestStatement,TestFieldRefTestFieldRef,TestFact,TestMethod>(){ public FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions() {publicFlowFunctions<TestStatement,StringString,TestFact,TestMethod>flowFunctions(){ return new FlowFunctions<TestStatement, String, TestFact, TestMethod>() {returnnewFlowFunctions<TestStatement,StringString,TestFact,TestMethod>(){ @Override@Override public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {publicFlowFunction<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>getReturnFlowFunction(TestStatementcallSite,TestMethodcalleeMethod,TestStatementexitStmt,TestStatementreturnSite){ public FlowFunction<String, TestFact, TestStatement, TestMethod> getReturnFlowFunction(TestStatement callSite, TestMethod calleeMethod, TestStatement exitStmt, TestStatement returnSite) {publicFlowFunction<StringString,TestFact,TestStatement,TestMethod>getReturnFlowFunction(TestStatementcallSite,TestMethodcalleeMethod,TestStatementexitStmt,TestStatementreturnSite){ for (final ReturnEdge edge : returnEdges) {for(finalReturnEdgeedge:returnEdges){ if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)if(nullAwareEquals(callSite,edge.callSite)&&edge.calleeMethod.equals(calleeMethod) && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {&&edge.exitStmt.equals(exitStmt)&&nullAwareEquals(edge.returnSite,returnSite)){ }} @Override@Override public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {publicFlowFunction<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>getNormalFlowFunction(finalTestStatementcurr){ public FlowFunction<String, TestFact, TestStatement, TestMethod> getNormalFlowFunction(final TestStatement curr) {publicFlowFunction<StringString,TestFact,TestStatement,TestMethod>getNormalFlowFunction(finalTestStatementcurr){ for (final NormalEdge edge : normalEdges) {for(finalNormalEdgeedge:normalEdges){ if (edge.unit.equals(curr)) {if(edge.unit.equals(curr)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {publicFlowFunction<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>getCallToReturnFlowFunction(TestStatementcallSite,TestStatementreturnSite){ public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallToReturnFlowFunction(TestStatement callSite, TestStatement returnSite) {publicFlowFunction<StringString,TestFact,TestStatement,TestMethod>getCallToReturnFlowFunction(TestStatementcallSite,TestStatementreturnSite){ for (final Call2ReturnEdge edge : call2retEdges) {for(finalCall2ReturnEdgeedge:call2retEdges){ if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {if(edge.callSite.equals(callSite)&&edge.returnSite.equals(returnSite)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {publicFlowFunction<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>getCallFlowFunction(TestStatementcallStmt,TestMethoddestinationMethod){ public FlowFunction<String, TestFact, TestStatement, TestMethod> getCallFlowFunction(TestStatement callStmt, TestMethod destinationMethod) {publicFlowFunction<StringString,TestFact,TestStatement,TestMethod>getCallFlowFunction(TestStatementcallStmt,TestMethoddestinationMethod){ for (final CallEdge edge : callEdges) {for(finalCallEdgeedge:callEdges){ if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {if(edge.callSite.equals(callStmt)&&edge.destinationMethod.equals(destinationMethod)){ return createFlowFunction(edge);returncreateFlowFunction(edge); throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));thrownewAssertionError(String.format("No Flow Function expected for call %s -> %s",callStmt,destinationMethod)); }} private FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {privateFlowFunction<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>createFlowFunction(finalEdgeedge){ return new FlowFunction<TestFieldRef, TestFact, TestStatement, TestMethod>() {returnnewFlowFunction<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>(){ private FlowFunction<String, TestFact, TestStatement, TestMethod> createFlowFunction(final Edge edge) {privateFlowFunction<StringString,TestFact,TestStatement,TestMethod>createFlowFunction(finalEdgeedge){ return new FlowFunction<String, TestFact, TestStatement, TestMethod>() {returnnewFlowFunction<StringString,TestFact,TestStatement,TestMethod>(){ @Override@Override public Set<FlowFunction.ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,publicSet<FlowFunction.ConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>>computeTargets(TestFactsource, AccessPathHandler<TestFieldRef, TestFact, TestStatement, TestMethod> accPathHandler) {AccessPathHandler<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>accPathHandler){ Set<ConstrainedFact<TestFieldRef, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();Set<ConstrainedFact<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod>>result=Sets.newHashSet(); public Set<FlowFunction.ConstrainedFact<String, TestFact, TestStatement, TestMethod>> computeTargets(TestFact source,publicSet<FlowFunction.ConstrainedFact<StringString,TestFact,TestStatement,TestMethod>>computeTargets(TestFactsource, AccessPathHandler<String, TestFact, TestStatement, TestMethod> accPathHandler) {AccessPathHandler<StringString,TestFact,TestStatement,TestMethod>accPathHandler){ Set<ConstrainedFact<String, TestFact, TestStatement, TestMethod>> result = Sets.newHashSet();Set<ConstrainedFact<StringString,TestFact,TestStatement,TestMethod>>result=Sets.newHashSet(); boolean found = false;booleanfound=false; for (ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ if (ff.source.equals(source)) {if(ff.source.equals(source)){ public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {publicvoidrunSolver(finalbooleanfollowReturnsPastSeeds,finalString...initialSeeds){ Scheduler scheduler = new Scheduler();Schedulerscheduler=newScheduler(); FieldSensitiveIFDSSolver<TestFieldRef, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<TestFieldRef ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(FieldSensitiveIFDSSolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>solver=newFieldSensitiveIFDSSolver<TestFieldRefTestFieldRef,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>( FieldSensitiveIFDSSolver<String, TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>> solver = new FieldSensitiveIFDSSolver<String ,TestFact, TestStatement, TestMethod, InterproceduralCFG<TestStatement,TestMethod>>(FieldSensitiveIFDSSolver<StringString,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>solver=newFieldSensitiveIFDSSolver<StringString,TestFact,TestStatement,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>( createTabulationProblem(followReturnsPastSeeds, initialSeeds), new FactMergeHandler<TestFact>() {createTabulationProblem(followReturnsPastSeeds,initialSeeds),newFactMergeHandler<TestFact>(){ @Override@Override public void merge(TestFact previousFact, TestFact currentFact) {publicvoidmerge(TestFactpreviousFact,TestFactcurrentFact){ }} }} private IFDSTabulationProblem<TestStatement, TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<TestStatement,TestFieldRefTestFieldRef,TestFact,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ private IFDSTabulationProblem<TestStatement, String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<TestStatement,StringString,TestFact,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ final InterproceduralCFG<TestStatement, TestMethod> icfg = buildIcfg();finalInterproceduralCFG<TestStatement,TestMethod>icfg=buildIcfg(); final FlowFunctions<TestStatement, TestFieldRef, TestFact, TestMethod> flowFunctions = flowFunctions();finalFlowFunctions<TestStatement,TestFieldRefTestFieldRef,TestFact,TestMethod>flowFunctions=flowFunctions(); final FlowFunctions<TestStatement, String, TestFact, TestMethod> flowFunctions = flowFunctions();finalFlowFunctions<TestStatement,StringString,TestFact,TestMethod>flowFunctions=flowFunctions();  return new IFDSTabulationProblem<TestStatement,TestFieldRef, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {returnnewIFDSTabulationProblem<TestStatement,TestFieldRefTestFieldRef,TestFact,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>(){ return new IFDSTabulationProblem<TestStatement,String, TestFact, TestMethod, InterproceduralCFG<TestStatement, TestMethod>>() {returnnewIFDSTabulationProblem<TestStatement,StringString,TestFact,TestMethod,InterproceduralCFG<TestStatement,TestMethod>>(){ @Override@Override public boolean followReturnsPastSeeds() {publicbooleanfollowReturnsPastSeeds(){ }} @Override@Override public FlowFunctions<TestStatement,TestFieldRef, TestFact, TestMethod> flowFunctions() {publicFlowFunctions<TestStatement,TestFieldRefTestFieldRef,TestFact,TestMethod>flowFunctions(){ public FlowFunctions<TestStatement,String, TestFact, TestMethod> flowFunctions() {publicFlowFunctions<TestStatement,StringString,TestFact,TestMethod>flowFunctions(){ return flowFunctions;returnflowFunctions; }} }}  @Override@Override public ZeroHandler<TestFieldRef> zeroHandler() {publicZeroHandler<TestFieldRefTestFieldRef>zeroHandler(){ return new ZeroHandler<TestFieldRef>() {returnnewZeroHandler<TestFieldRefTestFieldRef>(){ public ZeroHandler<String> zeroHandler() {publicZeroHandler<StringString>zeroHandler(){ return new ZeroHandler<String>() {returnnewZeroHandler<StringString>(){ @Override@Override public boolean shouldGenerateAccessPath(AccessPath<TestFieldRef> accPath) {publicbooleanshouldGenerateAccessPath(AccessPath<TestFieldRefTestFieldRef>accPath){ public boolean shouldGenerateAccessPath(AccessPath<String> accPath) {publicbooleanshouldGenerateAccessPath(AccessPath<StringString>accPath){ return true;returntrue; }} };};



Prev


1


2


Next





Prev

1

2

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






