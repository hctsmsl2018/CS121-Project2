



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

d83b5de1















Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Expand all
Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1





This diff is collapsed.
Click to expand it.













src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

d83b5de1















Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Expand all
Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1





This diff is collapsed.
Click to expand it.













src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

d83b5de1







Open sidebar



Joshua Garcia heros
Commits

d83b5de1




Open sidebar

Joshua Garcia heros
Commits

d83b5de1


Joshua GarciaherosherosCommits
d83b5de1








Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Expand all
Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1





This diff is collapsed.
Click to expand it.













src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Expand all
Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1





This diff is collapsed.
Click to expand it.













src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files



Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden

d83b5de1authoredbyEric Bodden

initial checkin






parent
56cf8f0e
















parent
56cf8f0e





parent












Changes
42
42


Expand all
Hide whitespace changes

Inline
Side-by-side






Expand all
Hide whitespace changes

Inline
Side-by-side




Expand all
Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1





This diff is collapsed.
Click to expand it.













src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next













src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}












src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}


package soot.jimple.interproc.ifds.edgefunc;packagesoot.jimple.interproc.ifds.edgefunc;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;public class AllBottom<V> implements EdgeFunction<V> {publicclassAllBottom<V>implementsEdgeFunction<V>{  private final V bottomElement;privatefinalVbottomElement; public AllBottom(V bottomElement){publicAllBottom(VbottomElement){ this.bottomElement = bottomElement;this.bottomElement=bottomElement; } } public V computeTarget(V source) {publicVcomputeTarget(Vsource){ return bottomElement;returnbottomElement; }} public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {publicEdgeFunction<V>composeWith(EdgeFunction<V>secondFunction){ return secondFunction;returnsecondFunction; }} public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {publicEdgeFunction<V>joinWith(EdgeFunction<V>otherFunction){ if(otherFunction == this || otherFunction.equalTo(this)) return this;if(otherFunction==this||otherFunction.equalTo(this))returnthis; if(otherFunction instanceof AllTop) {if(otherFunctioninstanceofAllTop){ return this;returnthis; }} if(otherFunction instanceof EdgeIdentity) {if(otherFunctioninstanceofEdgeIdentity){ return this;returnthis; }} throw new IllegalStateException("unexpected edge function: "+otherFunction);thrownewIllegalStateException("unexpected edge function: "+otherFunction); }} public boolean equalTo(EdgeFunction<V> other) {publicbooleanequalTo(EdgeFunction<V>other){ if(other instanceof AllBottom) {if(otherinstanceofAllBottom){ @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") AllBottom allBottom = (AllBottom) other;AllBottomallBottom=(AllBottom)other; return allBottom.bottomElement.equals(bottomElement);returnallBottom.bottomElement.equals(bottomElement); } } return false;returnfalse; }}  public String toString() {publicStringtoString(){ return "allbottom";return"allbottom"; }}}}








src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}












src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}


package soot.jimple.interproc.ifds.edgefunc;packagesoot.jimple.interproc.ifds.edgefunc;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;public class AllTop<V> implements EdgeFunction<V> {publicclassAllTop<V>implementsEdgeFunction<V>{  private final V topElement; privatefinalVtopElement; public AllTop(V topElement){publicAllTop(VtopElement){ this.topElement = topElement;this.topElement=topElement; } } public V computeTarget(V source) {publicVcomputeTarget(Vsource){ return topElement;returntopElement; }} public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {publicEdgeFunction<V>composeWith(EdgeFunction<V>secondFunction){ return secondFunction;returnsecondFunction; }} public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {publicEdgeFunction<V>joinWith(EdgeFunction<V>otherFunction){ return otherFunction;returnotherFunction; }} public boolean equalTo(EdgeFunction<V> other) {publicbooleanequalTo(EdgeFunction<V>other){ if(other instanceof AllTop) {if(otherinstanceofAllTop){ @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") AllTop allTop = (AllTop) other;AllTopallTop=(AllTop)other; return allTop.topElement.equals(topElement);returnallTop.topElement.equals(topElement); } } return false;returnfalse; }} public String toString() {publicStringtoString(){ return "alltop";return"alltop"; }} }}








src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}












src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}


package soot.jimple.interproc.ifds.edgefunc;packagesoot.jimple.interproc.ifds.edgefunc;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;/**/** * The identity function on graph edges * The identity function on graph edges * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. */ */public class EdgeIdentity<V> implements EdgeFunction<V> {publicclassEdgeIdentity<V>implementsEdgeFunction<V>{  @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") private final static EdgeIdentity instance = new EdgeIdentity();privatefinalstaticEdgeIdentityinstance=newEdgeIdentity();  private EdgeIdentity(){} //use v() insteadprivateEdgeIdentity(){}//use v() instead public V computeTarget(V source) {publicVcomputeTarget(Vsource){ return source;returnsource; }} public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {publicEdgeFunction<V>composeWith(EdgeFunction<V>secondFunction){ return secondFunction;returnsecondFunction; }} public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {publicEdgeFunction<V>joinWith(EdgeFunction<V>otherFunction){ if(otherFunction == this || otherFunction.equalTo(this)) return this;if(otherFunction==this||otherFunction.equalTo(this))returnthis; if(otherFunction instanceof AllBottom) {if(otherFunctioninstanceofAllBottom){ return otherFunction;returnotherFunction; }} if(otherFunction instanceof AllTop) {if(otherFunctioninstanceofAllTop){ return this;returnthis; }} //do not know how to join; hence ask other function to decide on this//do not know how to join; hence ask other function to decide on this return otherFunction.joinWith(this);returnotherFunction.joinWith(this); }}  public boolean equalTo(EdgeFunction<V> other) {publicbooleanequalTo(EdgeFunction<V>other){ //singleton//singleton return other==this;returnother==this; }} @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public static <A> EdgeIdentity<A> v() {publicstatic<A>EdgeIdentity<A>v(){ return instance;returninstance; }} public String toString() {publicStringtoString(){ return "id";return"id"; }}}}








src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;/**/** * Represents the ordered composition of a set of flow functions. * Represents the ordered composition of a set of flow functions. */ */public class Compose<D> implements FlowFunction<D> {publicclassCompose<D>implementsFlowFunction<D>{  private final FlowFunction<D>[] funcs;privatefinalFlowFunction<D>[]funcs; public Compose(FlowFunction<D>... funcs){publicCompose(FlowFunction<D>...funcs){ this.funcs = funcs;this.funcs=funcs; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ Set<D> curr = Sets.newHashSet();Set<D>curr=Sets.newHashSet(); curr.add(source);curr.add(source); for (FlowFunction<D> func : funcs) {for(FlowFunction<D>func:funcs){ Set<D> next = Sets.newHashSet();Set<D>next=Sets.newHashSet(); for(D d: curr)for(Dd:curr) next.addAll(func.computeTargets(d));next.addAll(func.computeTargets(d)); curr = next;curr=next; }} return curr;returncurr; }} }}








src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;/**/** * Function that creates a new value (e.g. returns a set containing a fixed value when given * Function that creates a new value (e.g. returns a set containing a fixed value when given * a specific parameter), but acts like the identity function for all other parameters. * a specific parameter), but acts like the identity function for all other parameters. * * * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public class Gen<D> implements FlowFunction<D> {publicclassGen<D>implementsFlowFunction<D>{  private final D genValue;privatefinalDgenValue; private final D zeroValue;privatefinalDzeroValue;  public Gen(D genValue, D zeroValue){publicGen(DgenValue,DzeroValue){ this.genValue = genValue;this.genValue=genValue; this.zeroValue = zeroValue;this.zeroValue=zeroValue; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==zeroValue) {if(source==zeroValue){ HashSet<D> res = new HashSet<D>();HashSet<D>res=newHashSet<D>(); res.add(source);res.add(source); res.add(genValue);res.add(genValue); return res;returnres; } else}else return Collections.singleton(source);returnCollections.singleton(source); }} }}








src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}












src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;public class Identity<D> implements FlowFunction<D> {publicclassIdentity<D>implementsFlowFunction<D>{  @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") private final static Identity instance = new Identity();privatefinalstaticIdentityinstance=newIdentity();  private Identity(){} //use v() insteadprivateIdentity(){}//use v() instead public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ return Collections.singleton(source);returnCollections.singleton(source); }} @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public static <D> Identity<D> v() {publicstatic<D>Identity<D>v(){ return instance;returninstance; }}}}








src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}












src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;/**/** * Function that kills a specific value (i.e. returns an empty set for when given this * Function that kills a specific value (i.e. returns an empty set for when given this * value as an argument), but behaves like the identity function for all other values. * value as an argument), but behaves like the identity function for all other values. * * * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public class Kill<D> implements FlowFunction<D> {publicclassKill<D>implementsFlowFunction<D>{  private final D killValue;privatefinalDkillValue;  public Kill(D killValue){publicKill(DkillValue){ this.killValue = killValue;this.killValue=killValue; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==killValue) {if(source==killValue){ return Collections.emptySet();returnCollections.emptySet(); } else}else return Collections.singleton(source);returnCollections.singleton(source); }} }}








src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}












src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;/**/** * The empty function, i.e. a function which returns an empty set for all points * The empty function, i.e. a function which returns an empty set for all points * in the definition space. * in the definition space. *   *   * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public class KillAll<D> implements FlowFunction<D> {publicclassKillAll<D>implementsFlowFunction<D>{  @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") private final static KillAll instance = new KillAll();privatefinalstaticKillAllinstance=newKillAll();  private KillAll(){} //use v() insteadprivateKillAll(){}//use v() instead public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ return Collections.emptySet();returnCollections.emptySet(); }}  @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public static <D> KillAll<D> v() {publicstatic<D>KillAll<D>v(){ return instance;returninstance; }}}}








src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}












src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;public class Transfer<D> implements FlowFunction<D> {publicclassTransfer<D>implementsFlowFunction<D>{  private final D toValue;privatefinalDtoValue; private final D fromValue;privatefinalDfromValue;  public Transfer(D toValue, D fromValue){publicTransfer(DtoValue,DfromValue){ this.toValue = toValue;this.toValue=toValue; this.fromValue = fromValue;this.fromValue=fromValue; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==fromValue) {if(source==fromValue){ HashSet<D> res = new HashSet<D>();HashSet<D>res=newHashSet<D>(); res.add(source);res.add(source); res.add(toValue);res.add(toValue); return res;returnres; } else if(source==toValue) {}elseif(source==toValue){ return Collections.emptySet();returnCollections.emptySet(); } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} }}








src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.Local;importsoot.Local;import soot.NullType;importsoot.NullType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.Value;importsoot.Value;import soot.jimple.AssignStmt;importsoot.jimple.AssignStmt;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.IdentityStmt;importsoot.jimple.IdentityStmt;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.ParameterRef;importsoot.jimple.ParameterRef;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.internal.JimpleLocal;importsoot.jimple.internal.JimpleLocal;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Gen;importsoot.jimple.interproc.ifds.flowfunc.Gen;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.Kill;importsoot.jimple.interproc.ifds.flowfunc.Kill;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.flowfunc.Transfer;importsoot.jimple.interproc.ifds.flowfunc.Transfer;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSLocalInfoFlowextendsDefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit,SootMethod>>{ public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {publicIFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg); super(icfg); }} public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { publicFlowFunctions<Unit,Local,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit,Local,SootMethod>() {returnnewFlowFunctions<Unit,Local,SootMethod>(){ @Override@Override public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {publicFlowFunction<Local>getNormalFlowFunction(Unitsrc,Unitdest){ if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {if(srcinstanceofIdentityStmt&&interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()){ IdentityStmt is = (IdentityStmt) src;IdentityStmtis=(IdentityStmt)src; Local leftLocal = (Local) is.getLeftOp();LocalleftLocal=(Local)is.getLeftOp(); Value right = is.getRightOp();Valueright=is.getRightOp(); if (right instanceof ParameterRef) {if(rightinstanceofParameterRef){ return new Gen<Local>(leftLocal,zeroValue());returnnewGen<Local>(leftLocal,zeroValue()); }} }}  if(src instanceof AssignStmt) {if(srcinstanceofAssignStmt){ AssignStmt assignStmt = (AssignStmt) src;AssignStmtassignStmt=(AssignStmt)src; Value right = assignStmt.getRightOp();Valueright=assignStmt.getRightOp(); if(assignStmt.getLeftOp() instanceof Local) {if(assignStmt.getLeftOp()instanceofLocal){ final Local leftLocal = (Local) assignStmt.getLeftOp();finalLocalleftLocal=(Local)assignStmt.getLeftOp(); if(right instanceof Local) {if(rightinstanceofLocal){ final Local rightLocal = (Local) right;finalLocalrightLocal=(Local)right; return new Transfer<Local>(leftLocal, rightLocal);returnnewTransfer<Local>(leftLocal,rightLocal); } else {}else{ return new Kill<Local>(leftLocal);returnnewKill<Local>(leftLocal); }} }} }} return Identity.v();returnIdentity.v(); }} @Override@Override public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {publicFlowFunction<Local>getCallFlowFunction(Unitsrc,finalSootMethoddest){ Stmt stmt = (Stmt) src;Stmtstmt=(Stmt)src; InvokeExpr ie = stmt.getInvokeExpr();InvokeExprie=stmt.getInvokeExpr(); final List<Value> callArgs = ie.getArgs();finalList<Value>callArgs=ie.getArgs(); final List<Local> paramLocals = new ArrayList<Local>();finalList<Local>paramLocals=newArrayList<Local>(); for(int i=0;i<dest.getParameterCount();i++) {for(inti=0;i<dest.getParameterCount();i++){ paramLocals.add(dest.getActiveBody().getParameterLocal(i));paramLocals.add(dest.getActiveBody().getParameterLocal(i)); }} return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ int argIndex = callArgs.indexOf(source);intargIndex=callArgs.indexOf(source); if(argIndex>-1) {if(argIndex>-1){ return Collections.singleton(paramLocals.get(argIndex));returnCollections.singleton(paramLocals.get(argIndex)); }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {publicFlowFunction<Local>getReturnFlowFunction(UnitcallSite,SootMethodcallee,UnitexitStmt,UnitretSite){ if (exitStmt instanceof ReturnStmt) { if(exitStmtinstanceofReturnStmt){ ReturnStmt returnStmt = (ReturnStmt) exitStmt;ReturnStmtreturnStmt=(ReturnStmt)exitStmt; Value op = returnStmt.getOp();Valueop=returnStmt.getOp(); if(op instanceof Local) {if(opinstanceofLocal){ if(callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ DefinitionStmt defnStmt = (DefinitionStmt) callSite;DefinitionStmtdefnStmt=(DefinitionStmt)callSite; Value leftOp = defnStmt.getLeftOp();ValueleftOp=defnStmt.getLeftOp(); if(leftOp instanceof Local) {if(leftOpinstanceofLocal){ final Local tgtLocal = (Local) leftOp;finalLocaltgtLocal=(Local)leftOp; final Local retLocal = (Local) op;finalLocalretLocal=(Local)op; return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ if(source==retLocal)if(source==retLocal) return Collections.singleton(tgtLocal);returnCollections.singleton(tgtLocal); return Collections.emptySet();returnCollections.emptySet(); }}  };}; }} }} }} } } return KillAll.v();returnKillAll.v(); }} @Override@Override public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {publicFlowFunction<Local>getCallToReturnFlowFunction(Unitcall,UnitreturnSite){ return Identity.v();returnIdentity.v(); }} }; }; }} @Override@Override public Local createZeroValue() {publicLocalcreateZeroValue(){ return new JimpleLocal("zero", NullType.v());returnnewJimpleLocal("zero",NullType.v()); }} @Override@Override public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }}}}








src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.Local;importsoot.Local;import soot.PointsToAnalysis;importsoot.PointsToAnalysis;import soot.PointsToSet;importsoot.PointsToSet;import soot.PrimType;importsoot.PrimType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Type;importsoot.Type;import soot.Unit;importsoot.Unit;import soot.UnknownType;importsoot.UnknownType;import soot.Value;importsoot.Value;import soot.jimple.ArrayRef;importsoot.jimple.ArrayRef;import soot.jimple.Constant;importsoot.jimple.Constant;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.InstanceFieldRef;importsoot.jimple.InstanceFieldRef;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.Jimple;importsoot.jimple.Jimple;import soot.jimple.NewExpr;importsoot.jimple.NewExpr;import soot.jimple.Ref;importsoot.jimple.Ref;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;import soot.toolkits.scalar.Pair;importsoot.toolkits.scalar.Pair;@SuppressWarnings("serial")@SuppressWarnings("serial")public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSPossibleTypesextendsDefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit,SootMethod>>{ public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {publicIFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg);super(icfg); }} public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {publicFlowFunctions<Unit,Pair<Value,Type>,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {returnnewFlowFunctions<Unit,Pair<Value,Type>,SootMethod>(){ public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {publicFlowFunction<Pair<Value,Type>>getNormalFlowFunction(Unitsrc,Unitdest){ if(src instanceof DefinitionStmt) {if(srcinstanceofDefinitionStmt){ DefinitionStmt defnStmt = (DefinitionStmt) src;DefinitionStmtdefnStmt=(DefinitionStmt)src; if(defnStmt.containsInvokeExpr()) return Identity.v();if(defnStmt.containsInvokeExpr())returnIdentity.v(); final Value right = defnStmt.getRightOp();finalValueright=defnStmt.getRightOp(); final Value left = defnStmt.getLeftOp();finalValueleft=defnStmt.getLeftOp(); //won't track primitive-typed variables//won't track primitive-typed variables if(right.getType() instanceof PrimType) return Identity.v();if(right.getType()instanceofPrimType)returnIdentity.v();  if(right instanceof Constant || right instanceof NewExpr) {if(rightinstanceofConstant||rightinstanceofNewExpr){ return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {publicSet<Pair<Value,Type>>computeTargets(Pair<Value,Type>source){ if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {if(source==newPair<Value,Type>(Jimple.v().newLocal("<dummy>",UnknownType.v()),UnknownType.v())){ Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();Set<Pair<Value,Type>>res=newLinkedHashSet<Pair<Value,Type>>(); res.add(new Pair<Value,Type>(left,right.getType()));res.add(newPair<Value,Type>(left,right.getType())); res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));res.add(newPair<Value,Type>(Jimple.v().newLocal("<dummy>",UnknownType.v()),UnknownType.v())); return res;returnres; } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {}elseif(source.getO1()instanceofLocal&&source.getO1().equivTo(left)){ //strong update for local variables//strong update for local variables return Collections.emptySet();returnCollections.emptySet(); } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} };}; } else if(right instanceof Ref || right instanceof Local) {}elseif(rightinstanceofRef||rightinstanceofLocal){ return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {publicSet<Pair<Value,Type>>computeTargets(finalPair<Value,Type>source){ Value value = source.getO1();Valuevalue=source.getO1(); if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {if(source.getO1()instanceofLocal&&source.getO1().equivTo(left)){ //strong update for local variables//strong update for local variables return Collections.emptySet();returnCollections.emptySet(); } else if(maybeSameLocation(value,right)) {}elseif(maybeSameLocation(value,right)){ return new LinkedHashSet<Pair<Value,Type>>() {{returnnewLinkedHashSet<Pair<Value,Type>>(){{ add(new Pair<Value,Type>(left,source.getO2())); add(newPair<Value,Type>(left,source.getO2())); add(source); add(source); }};}}; } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} private boolean maybeSameLocation(Value v1, Value v2) {privatebooleanmaybeSameLocation(Valuev1,Valuev2){ if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&if(!(v1instanceofInstanceFieldRef&&v2instanceofInstanceFieldRef)&& !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {!(v1instanceofArrayRef&&v2instanceofArrayRef)){ return v1.equivTo(v2);returnv1.equivTo(v2); }} if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {if(v1instanceofInstanceFieldRef&&v2instanceofInstanceFieldRef){ InstanceFieldRef ifr1 = (InstanceFieldRef) v1;InstanceFieldRefifr1=(InstanceFieldRef)v1; InstanceFieldRef ifr2 = (InstanceFieldRef) v2;InstanceFieldRefifr2=(InstanceFieldRef)v2; if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;if(!ifr1.getField().getName().equals(ifr2.getField().getName()))returnfalse;  Local base1 = (Local) ifr1.getBase();Localbase1=(Local)ifr1.getBase(); Local base2 = (Local) ifr2.getBase();Localbase2=(Local)ifr2.getBase(); PointsToAnalysis pta = Scene.v().getPointsToAnalysis();PointsToAnalysispta=Scene.v().getPointsToAnalysis(); PointsToSet pts1 = pta.reachingObjects(base1);PointsToSetpts1=pta.reachingObjects(base1); PointsToSet pts2 = pta.reachingObjects(base2); PointsToSetpts2=pta.reachingObjects(base2); return pts1.hasNonEmptyIntersection(pts2);returnpts1.hasNonEmptyIntersection(pts2); } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef}else{//v1 instanceof ArrayRef && v2 instanceof ArrayRef ArrayRef ar1 = (ArrayRef) v1;ArrayRefar1=(ArrayRef)v1; ArrayRef ar2 = (ArrayRef) v2;ArrayRefar2=(ArrayRef)v2; Local base1 = (Local) ar1.getBase();Localbase1=(Local)ar1.getBase(); Local base2 = (Local) ar2.getBase();Localbase2=(Local)ar2.getBase(); PointsToAnalysis pta = Scene.v().getPointsToAnalysis();PointsToAnalysispta=Scene.v().getPointsToAnalysis(); PointsToSet pts1 = pta.reachingObjects(base1);PointsToSetpts1=pta.reachingObjects(base1); PointsToSet pts2 = pta.reachingObjects(base2); PointsToSetpts2=pta.reachingObjects(base2); return pts1.hasNonEmptyIntersection(pts2);returnpts1.hasNonEmptyIntersection(pts2); }} }} };}; } } }} return Identity.v();returnIdentity.v(); }} public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {publicFlowFunction<Pair<Value,Type>>getCallFlowFunction(finalUnitsrc,finalSootMethoddest){ Stmt stmt = (Stmt) src;Stmtstmt=(Stmt)src; InvokeExpr ie = stmt.getInvokeExpr();InvokeExprie=stmt.getInvokeExpr(); final List<Value> callArgs = ie.getArgs();finalList<Value>callArgs=ie.getArgs(); final List<Local> paramLocals = new ArrayList<Local>();finalList<Local>paramLocals=newArrayList<Local>(); for(int i=0;i<dest.getParameterCount();i++) {for(inti=0;i<dest.getParameterCount();i++){ paramLocals.add(dest.getActiveBody().getParameterLocal(i));paramLocals.add(dest.getActiveBody().getParameterLocal(i)); } } return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {publicSet<Pair<Value,Type>>computeTargets(Pair<Value,Type>source){ Value value = source.getO1();Valuevalue=source.getO1(); int argIndex = callArgs.indexOf(value);intargIndex=callArgs.indexOf(value); if(argIndex>-1) {if(argIndex>-1){ return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));returnCollections.singleton(newPair<Value,Type>(paramLocals.get(argIndex),source.getO2())); }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {publicFlowFunction<Pair<Value,Type>>getReturnFlowFunction(UnitcallSite,SootMethodcallee,UnitexitStmt,UnitretSite){ if (exitStmt instanceof ReturnStmt) { if(exitStmtinstanceofReturnStmt){ ReturnStmt returnStmt = (ReturnStmt) exitStmt;ReturnStmtreturnStmt=(ReturnStmt)exitStmt; Value op = returnStmt.getOp();Valueop=returnStmt.getOp(); if(op instanceof Local) {if(opinstanceofLocal){ if(callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ DefinitionStmt defnStmt = (DefinitionStmt) callSite;DefinitionStmtdefnStmt=(DefinitionStmt)callSite; Value leftOp = defnStmt.getLeftOp();ValueleftOp=defnStmt.getLeftOp(); if(leftOp instanceof Local) {if(leftOpinstanceofLocal){ final Local tgtLocal = (Local) leftOp;finalLocaltgtLocal=(Local)leftOp; final Local retLocal = (Local) op;finalLocalretLocal=(Local)op; return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {publicSet<Pair<Value,Type>>computeTargets(Pair<Value,Type>source){ if(source==retLocal)if(source==retLocal) return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));returnCollections.singleton(newPair<Value,Type>(tgtLocal,source.getO2())); return Collections.emptySet();returnCollections.emptySet(); }}  };}; }} }} }} }} return KillAll.v();returnKillAll.v(); }} public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {publicFlowFunction<Pair<Value,Type>>getCallToReturnFlowFunction(Unitcall,UnitreturnSite){ return Identity.v();returnIdentity.v(); }} };}; }} public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }} public Pair<Value,Type> createZeroValue() {publicPair<Value,Type>createZeroValue(){ return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());returnnewPair<Value,Type>(Jimple.v().newLocal("<dummy>",UnknownType.v()),UnknownType.v()); }}}}








src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}












src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.EquivalentValue;importsoot.EquivalentValue;import soot.Local;importsoot.Local;import soot.NullType;importsoot.NullType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.Value;importsoot.Value;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.Jimple;importsoot.jimple.Jimple;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.ReturnVoidStmt;importsoot.jimple.ReturnVoidStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.internal.JimpleLocal;importsoot.jimple.internal.JimpleLocal;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;import soot.toolkits.scalar.Pair;importsoot.toolkits.scalar.Pair;public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSReachingDefinitionsextendsDefaultIFDSTabulationProblem<Pair<Value,Set<DefinitionStmt>>,InterproceduralCFG<Unit,SootMethod>>{ public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {publicIFDSReachingDefinitions(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg);super(icfg); }}  @Override@Override public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {publicFlowFunctions<Unit,Pair<Value,Set<DefinitionStmt>>,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {returnnewFlowFunctions<Unit,Pair<Value,Set<DefinitionStmt>>,SootMethod>(){ @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getNormalFlowFunction(finalUnitcurr,Unitsucc){ if (curr instanceof DefinitionStmt) {if(currinstanceofDefinitionStmt){ final DefinitionStmt assignment = (DefinitionStmt) curr;finalDefinitionStmtassignment=(DefinitionStmt)curr; return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if (source != zeroValue()) {if(source!=zeroValue()){ if (source.getO1().equivTo(assignment.getLeftOp())) {if(source.getO1().equivTo(assignment.getLeftOp())){ return Collections.emptySet();returnCollections.emptySet(); }} return Collections.singleton(source);returnCollections.singleton(source); } else {}else{ LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();LinkedHashSet<Pair<Value,Set<DefinitionStmt>>>res=newLinkedHashSet<Pair<Value,Set<DefinitionStmt>>>(); res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),res.add(newPair<Value,Set<DefinitionStmt>>(assignment.getLeftOp(), Collections.<DefinitionStmt> singleton(assignment)));Collections.<DefinitionStmt>singleton(assignment))); return res;returnres; }} }} };}; }} return Identity.v();returnIdentity.v(); }} @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getCallFlowFunction(UnitcallStmt, final SootMethod destinationMethod) {finalSootMethoddestinationMethod){ Stmt stmt = (Stmt) callStmt;Stmtstmt=(Stmt)callStmt; InvokeExpr invokeExpr = stmt.getInvokeExpr();InvokeExprinvokeExpr=stmt.getInvokeExpr(); final List<Value> args = invokeExpr.getArgs();finalList<Value>args=invokeExpr.getArgs(); final List<Local> localArguments = new ArrayList<Local>(args.size());finalList<Local>localArguments=newArrayList<Local>(args.size()); for (Value value : args) {for(Valuevalue:args){ if (value instanceof Local)if(valueinstanceofLocal) localArguments.add((Local) value);localArguments.add((Local)value); elseelse localArguments.add(null);localArguments.add(null); }} return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if(localArguments.contains(source.getO1())) {if(localArguments.contains(source.getO1())){ int paramIndex = args.indexOf(source.getO1());intparamIndex=args.indexOf(source.getO1()); Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(Pair<Value,Set<DefinitionStmt>>pair=newPair<Value,Set<DefinitionStmt>>( new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),newEquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex),paramIndex)), source.getO2());source.getO2()); return Collections.singleton(pair);returnCollections.singleton(pair); }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getReturnFlowFunction(finalUnitcallSite, SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {SootMethodcalleeMethod,finalUnitexitStmt,UnitreturnSite){ if (!(callSite instanceof DefinitionStmt))if(!(callSiteinstanceofDefinitionStmt)) return KillAll.v();returnKillAll.v(); if (exitStmt instanceof ReturnVoidStmt)if(exitStmtinstanceofReturnVoidStmt) return KillAll.v();returnKillAll.v(); return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if(exitStmt instanceof ReturnStmt) {if(exitStmtinstanceofReturnStmt){ ReturnStmt returnStmt = (ReturnStmt) exitStmt;ReturnStmtreturnStmt=(ReturnStmt)exitStmt; if (returnStmt.getOp().equivTo(source.getO1())) {if(returnStmt.getOp().equivTo(source.getO1())){ DefinitionStmt definitionStmt = (DefinitionStmt) callSite;DefinitionStmtdefinitionStmt=(DefinitionStmt)callSite; Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(Pair<Value,Set<DefinitionStmt>>pair=newPair<Value,Set<DefinitionStmt>>( definitionStmt.getLeftOp(), source.getO2());definitionStmt.getLeftOp(),source.getO2()); return Collections.singleton(pair);returnCollections.singleton(pair); }} }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getCallToReturnFlowFunction(UnitcallSite,UnitreturnSite){ if (!(callSite instanceof DefinitionStmt))if(!(callSiteinstanceofDefinitionStmt)) return Identity.v();returnIdentity.v();  final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;finalDefinitionStmtdefinitionStmt=(DefinitionStmt)callSite; return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if(source.getO1().equivTo(definitionStmt.getLeftOp())) {if(source.getO1().equivTo(definitionStmt.getLeftOp())){ return Collections.emptySet();returnCollections.emptySet(); } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} };}; }} };}; }} @Override@Override public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }} public Pair<Value, Set<DefinitionStmt>> createZeroValue() {publicPair<Value,Set<DefinitionStmt>>createZeroValue(){ return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());returnnewPair<Value,Set<DefinitionStmt>>(newJimpleLocal("<<zero>>",NullType.v()),Collections.<DefinitionStmt>emptySet()); }}}}








src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}












src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.Local;importsoot.Local;import soot.NullType;importsoot.NullType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.Value;importsoot.Value;import soot.ValueBox;importsoot.ValueBox;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.ThrowStmt;importsoot.jimple.ThrowStmt;import soot.jimple.internal.JimpleLocal;importsoot.jimple.internal.JimpleLocal;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.Kill;importsoot.jimple.interproc.ifds.flowfunc.Kill;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;import soot.util.Chain;importsoot.util.Chain;public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSUninitializedVariablesextendsDefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit,SootMethod>>{ public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {publicIFDSUninitializedVariables(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg); super(icfg); }} @Override@Override public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {publicFlowFunctions<Unit,Local,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit, Local, SootMethod>() {returnnewFlowFunctions<Unit,Local,SootMethod>(){ @Override@Override public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {publicFlowFunction<Local>getNormalFlowFunction(Unitcurr,Unitsucc){ final SootMethod m = interproceduralCFG().getMethodOf(curr);finalSootMethodm=interproceduralCFG().getMethodOf(curr); if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {if(Scene.v().getEntryPoints().contains(m)&&interproceduralCFG().isStartPoint(curr)){ return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){  @Override@Override public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ if (source == zeroValue()) {if(source==zeroValue()){ Set<Local> res = new LinkedHashSet<Local>();Set<Local>res=newLinkedHashSet<Local>(); res.addAll(m.getActiveBody().getLocals());res.addAll(m.getActiveBody().getLocals()); for(int i=0;i<m.getParameterCount();i++) for(inti=0;i<m.getParameterCount();i++) res.remove(m.getActiveBody().getParameterLocal(i));res.remove(m.getActiveBody().getParameterLocal(i)); return res;returnres; }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }}  if (curr instanceof DefinitionStmt) {if(currinstanceofDefinitionStmt){ final DefinitionStmt definition = (DefinitionStmt) curr;finalDefinitionStmtdefinition=(DefinitionStmt)curr; final Value leftOp = definition.getLeftOp();finalValueleftOp=definition.getLeftOp(); if(leftOp instanceof Local) {if(leftOpinstanceofLocal){ final Local leftOpLocal = (Local) leftOp;finalLocalleftOpLocal=(Local)leftOp; return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ @Override@Override public Set<Local> computeTargets(final Local source) {publicSet<Local>computeTargets(finalLocalsource){ List<ValueBox> useBoxes = definition.getUseBoxes();List<ValueBox>useBoxes=definition.getUseBoxes(); for (ValueBox valueBox : useBoxes) {for(ValueBoxvalueBox:useBoxes){ if (valueBox.getValue().equivTo(source)) {if(valueBox.getValue().equivTo(source)){ LinkedHashSet<Local> res = new LinkedHashSet<Local>();LinkedHashSet<Local>res=newLinkedHashSet<Local>(); res.add(source);res.add(source); res.add(leftOpLocal); res.add(leftOpLocal); return res;returnres; }} }} if (leftOp.equivTo(source))if(leftOp.equivTo(source)) return Collections.emptySet();returnCollections.emptySet(); return Collections.singleton(source);returnCollections.singleton(source); }} };}; }} }} return Identity.v();returnIdentity.v(); }} @Override@Override public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {publicFlowFunction<Local>getCallFlowFunction(UnitcallStmt,finalSootMethoddestinationMethod){ Stmt stmt = (Stmt) callStmt;Stmtstmt=(Stmt)callStmt; InvokeExpr invokeExpr = stmt.getInvokeExpr();InvokeExprinvokeExpr=stmt.getInvokeExpr(); final List<Value> args = invokeExpr.getArgs();finalList<Value>args=invokeExpr.getArgs(); final List<Local> localArguments = new ArrayList<Local>();finalList<Local>localArguments=newArrayList<Local>(); for (Value value : args)for(Valuevalue:args) if (value instanceof Local)if(valueinstanceofLocal) localArguments.add((Local) value);localArguments.add((Local)value); return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ @Override@Override public Set<Local> computeTargets(final Local source) {publicSet<Local>computeTargets(finalLocalsource){ for (Local localArgument : localArguments) {for(LocallocalArgument:localArguments){ if (source.equivTo(localArgument)) {if(source.equivTo(localArgument)){ return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));returnCollections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument))); }} }} if (source == zeroValue()) {if(source==zeroValue()){ //gen all locals that are not parameter locals //gen all locals that are not parameter locals  Chain<Local> locals = destinationMethod.getActiveBody().getLocals();Chain<Local>locals=destinationMethod.getActiveBody().getLocals(); LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);LinkedHashSet<Local>uninitializedLocals=newLinkedHashSet<Local>(locals); for(int i=0;i<destinationMethod.getParameterCount();i++) { for(inti=0;i<destinationMethod.getParameterCount();i++){ uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i)); }} return uninitializedLocals;returnuninitializedLocals; }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,publicFlowFunction<Local>getReturnFlowFunction(finalUnitcallSite,SootMethodcalleeMethod, final Unit exitStmt, Unit returnSite) {finalUnitexitStmt,UnitreturnSite){ if (callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ final DefinitionStmt definition = (DefinitionStmt) callSite;finalDefinitionStmtdefinition=(DefinitionStmt)callSite; if(definition.getLeftOp() instanceof Local) {if(definition.getLeftOp()instanceofLocal){ final Local leftOpLocal = (Local) definition.getLeftOp(); finalLocalleftOpLocal=(Local)definition.getLeftOp(); if (exitStmt instanceof ReturnStmt) {if(exitStmtinstanceofReturnStmt){ final ReturnStmt returnStmt = (ReturnStmt) exitStmt;finalReturnStmtreturnStmt=(ReturnStmt)exitStmt; return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){  @Override@Override public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ if (returnStmt.getOp().equivTo(source))if(returnStmt.getOp().equivTo(source)) return Collections.singleton(leftOpLocal);returnCollections.singleton(leftOpLocal); return Collections.emptySet();returnCollections.emptySet(); }}  };}; } else if (exitStmt instanceof ThrowStmt) {}elseif(exitStmtinstanceofThrowStmt){ //if we throw an exception, LHS of call is undefined//if we throw an exception, LHS of call is undefined return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){  @Override@Override public Set<Local> computeTargets(final Local source) {publicSet<Local>computeTargets(finalLocalsource){ if (source == zeroValue())if(source==zeroValue()) return Collections.singleton(leftOpLocal);returnCollections.singleton(leftOpLocal); elseelse return Collections.emptySet();returnCollections.emptySet(); }}  };}; }} }} }}  return KillAll.v();returnKillAll.v(); }} @Override@Override public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {publicFlowFunction<Local>getCallToReturnFlowFunction(UnitcallSite,UnitreturnSite){ if (callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ DefinitionStmt definition = (DefinitionStmt) callSite;DefinitionStmtdefinition=(DefinitionStmt)callSite; if(definition.getLeftOp() instanceof Local) {if(definition.getLeftOp()instanceofLocal){ final Local leftOpLocal = (Local) definition.getLeftOp(); finalLocalleftOpLocal=(Local)definition.getLeftOp(); return new Kill<Local>(leftOpLocal);returnnewKill<Local>(leftOpLocal); }} }} return Identity.v();returnIdentity.v(); }} };}; }} @Override@Override public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }} @Override@Override public Local createZeroValue() {publicLocalcreateZeroValue(){ return new JimpleLocal("<<zero>>", NullType.v());returnnewJimpleLocal("<<zero>>",NullType.v()); }}}}








src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1





This diff is collapsed.
Click to expand it.











src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644









View file @ d83b5de1


d83b5de1


This diff is collapsed.
Click to expand it.




This diff is collapsed.
Click to expand it.


This diff is collapsed.
Click to expand it.









src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}












src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;importstaticsoot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;importstaticsoot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.EdgeFunctions;importsoot.jimple.interproc.ifds.EdgeFunctions;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.IDETabulationProblem;importsoot.jimple.interproc.ifds.IDETabulationProblem;import soot.jimple.interproc.ifds.IFDSTabulationProblem;importsoot.jimple.interproc.ifds.IFDSTabulationProblem;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.JoinLattice;importsoot.jimple.interproc.ifds.JoinLattice;import soot.jimple.interproc.ifds.edgefunc.AllBottom;importsoot.jimple.interproc.ifds.edgefunc.AllBottom;import soot.jimple.interproc.ifds.edgefunc.AllTop;importsoot.jimple.interproc.ifds.edgefunc.AllTop;import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;importsoot.jimple.interproc.ifds.edgefunc.EdgeIdentity;/**/** * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver} * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver} * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem. * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem. * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE * problem in which the environments (D to N mappings) represent the set's characteristic function. * problem in which the environments (D to N mappings) represent the set's characteristic function. *  *  * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. * @see IFDSTabulationProblem * @see IFDSTabulationProblem */ */public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {publicclassIFDSSolver<N,D,M,IextendsInterproceduralCFG<N,M>>extendsIDESolver<N,D,M,IFDSSolver.BinaryDomain,I>{ static enum BinaryDomain { TOP,BOTTOM } staticenumBinaryDomain{TOP,BOTTOM}  private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);privatefinalstaticEdgeFunction<BinaryDomain>ALL_BOTTOM=newAllBottom<BinaryDomain>(BOTTOM);  /**/**	 * Creates a solver for the given problem. The solver must then be started by calling	 * Creates a solver for the given problem. The solver must then be started by calling	 * {@link #solve()}.	 * {@link #solve()}.	 */	 */ public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {publicIFDSSolver(finalIFDSTabulationProblem<N,D,M,I>ifdsProblem){ super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {super(newIDETabulationProblem<N,D,M,BinaryDomain,I>(){ public FlowFunctions<N,D,M> flowFunctions() {publicFlowFunctions<N,D,M>flowFunctions(){ return ifdsProblem.flowFunctions();returnifdsProblem.flowFunctions(); }} public I interproceduralCFG() {publicIinterproceduralCFG(){ return ifdsProblem.interproceduralCFG();returnifdsProblem.interproceduralCFG(); }} public Set<N> initialSeeds() {publicSet<N>initialSeeds(){ return ifdsProblem.initialSeeds();returnifdsProblem.initialSeeds(); }} public D zeroValue() {publicDzeroValue(){ return ifdsProblem.zeroValue();returnifdsProblem.zeroValue(); }} public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {publicEdgeFunctions<N,D,M,BinaryDomain>edgeFunctions(){ return new IFDSEdgeFunctions();returnnewIFDSEdgeFunctions(); }} public JoinLattice<BinaryDomain> joinLattice() {publicJoinLattice<BinaryDomain>joinLattice(){ return new JoinLattice<BinaryDomain>() {returnnewJoinLattice<BinaryDomain>(){ public BinaryDomain topElement() {publicBinaryDomaintopElement(){ return BinaryDomain.TOP;returnBinaryDomain.TOP; }} public BinaryDomain bottomElement() {publicBinaryDomainbottomElement(){ return BinaryDomain.BOTTOM;returnBinaryDomain.BOTTOM; }} public BinaryDomain join(BinaryDomain left, BinaryDomain right) {publicBinaryDomainjoin(BinaryDomainleft,BinaryDomainright){ if(left==TOP && right==TOP) {if(left==TOP&&right==TOP){ return TOP;returnTOP; } else {}else{ return BOTTOM;returnBOTTOM; }} }} };}; }} @Override@Override public EdgeFunction<BinaryDomain> allTopFunction() {publicEdgeFunction<BinaryDomain>allTopFunction(){ return new AllTop<BinaryDomain>(TOP);returnnewAllTop<BinaryDomain>(TOP); }}  class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {classIFDSEdgeFunctionsimplementsEdgeFunctions<N,D,M,BinaryDomain>{  public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {publicEdgeFunction<BinaryDomain>getNormalEdgeFunction(Nsrc,DsrcNode,Ntgt,DtgtNode){ if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(srcNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }}  public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {publicEdgeFunction<BinaryDomain>getCallEdgeFunction(NcallStmt,DsrcNode,MdestinationMethod,DdestNode){ if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(srcNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }}  public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {publicEdgeFunction<BinaryDomain>getReturnEdgeFunction(NcallSite,McalleeMethod,NexitStmt,DexitNode,NreturnSite,DretNode){ if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(exitNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }}  public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {publicEdgeFunction<BinaryDomain>getCallToReturnEdgeFunction(NcallStmt,DcallNode,NreturnSite,DreturnSideNode){ if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(callNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }} }} });}); }}  /**/**	 * Returns the set of facts that hold at the given statement.	 * Returns the set of facts that hold at the given statement.	 */	 */ public Set<D> ifdsResultsAt(N statement) {publicSet<D>ifdsResultsAt(Nstatement){ return resultsAt(statement).keySet();returnresultsAt(statement).keySet(); }}}}








src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}












src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import java.util.Collections;importjava.util.Collections;import java.util.HashMap;importjava.util.HashMap;import java.util.LinkedHashMap;importjava.util.LinkedHashMap;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.DontSynchronize;importsoot.jimple.interproc.ifds.DontSynchronize;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.SynchronizedBy;importsoot.jimple.interproc.ifds.SynchronizedBy;import soot.jimple.interproc.ifds.ThreadSafe;importsoot.jimple.interproc.ifds.ThreadSafe;import com.google.common.collect.HashBasedTable;importcom.google.common.collect.HashBasedTable;import com.google.common.collect.Table;importcom.google.common.collect.Table;import com.google.common.collect.Table.Cell;importcom.google.common.collect.Table.Cell;/**/** * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses * elements from the list through three different indices. * elements from the list through three different indices. */ */@ThreadSafe@ThreadSafepublic class JumpFunctions<N,D,L> {publicclassJumpFunctions<N,D,L>{  //mapping from target node and value to a list of all source values and associated functions//mapping from target node and value to a list of all source values and associated functions //where the list is implemented as a mapping from the source value to the function//where the list is implemented as a mapping from the source value to the function //we exclude empty default functions//we exclude empty default functions @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();protectedTable<N,D,Map<D,EdgeFunction<L>>>nonEmptyReverseLookup=HashBasedTable.create();  //mapping from source value and target node to a list of all target values and associated functions//mapping from source value and target node to a list of all target values and associated functions //where the list is implemented as a mapping from the source value to the function//where the list is implemented as a mapping from the source value to the function //we exclude empty default functions //we exclude empty default functions  @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();protectedTable<D,N,Map<D,EdgeFunction<L>>>nonEmptyForwardLookup=HashBasedTable.create(); //a mapping from target node to a list of triples consisting of source value,//a mapping from target node to a list of triples consisting of source value, //target value and associated function; the triple is implemented by a table//target value and associated function; the triple is implemented by a table //we exclude empty default functions //we exclude empty default functions  @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();protectedMap<N,Table<D,D,EdgeFunction<L>>>nonEmptyLookupByTargetNode=newHashMap<N,Table<D,D,EdgeFunction<L>>>(); @DontSynchronize("immutable") @DontSynchronize("immutable") private final EdgeFunction<L> allTop;privatefinalEdgeFunction<L>allTop;  public JumpFunctions(EdgeFunction<L> allTop) {publicJumpFunctions(EdgeFunction<L>allTop){ this.allTop = allTop;this.allTop=allTop; }} /**/**	 * Records a jump function. The source statement is implicit.	 * Records a jump function. The source statement is implicit.	 * @see PathEdge	 * @see PathEdge	 */	 */ public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {publicsynchronizedvoidaddFunction(DsourceVal,Ntarget,DtargetVal,EdgeFunction<L>function){ assert sourceVal!=null;assertsourceVal!=null; assert target!=null;asserttarget!=null; assert targetVal!=null;asserttargetVal!=null; assert function!=null;assertfunction!=null;  //we do not store the default function (all-top)//we do not store the default function (all-top) if(function.equalTo(allTop)) return;if(function.equalTo(allTop))return;  Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);Map<D,EdgeFunction<L>>sourceValToFunc=nonEmptyReverseLookup.get(target,targetVal); if(sourceValToFunc==null) {if(sourceValToFunc==null){ sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();sourceValToFunc=newLinkedHashMap<D,EdgeFunction<L>>(); nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc); }} sourceValToFunc.put(sourceVal, function);sourceValToFunc.put(sourceVal,function);  Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);Map<D,EdgeFunction<L>>targetValToFunc=nonEmptyForwardLookup.get(sourceVal,target); if(targetValToFunc==null) {if(targetValToFunc==null){ targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();targetValToFunc=newLinkedHashMap<D,EdgeFunction<L>>(); nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc); }} targetValToFunc.put(targetVal, function);targetValToFunc.put(targetVal,function); Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);Table<D,D,EdgeFunction<L>>table=nonEmptyLookupByTargetNode.get(target); if(table==null) {if(table==null){ table = HashBasedTable.create();table=HashBasedTable.create(); nonEmptyLookupByTargetNode.put(target,table);nonEmptyLookupByTargetNode.put(target,table); }} table.put(sourceVal, targetVal, function);table.put(sourceVal,targetVal,function); }}  /**/**     * Returns, for a given target statement and value all associated     * Returns, for a given target statement and value all associated     * source values, and for each the associated edge function.     * source values, and for each the associated edge function.     * The return value is a mapping from source value to function.     * The return value is a mapping from source value to function.	 */	 */ public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {publicsynchronizedMap<D,EdgeFunction<L>>reverseLookup(Ntarget,DtargetVal){ assert target!=null;asserttarget!=null; assert targetVal!=null;asserttargetVal!=null; Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);Map<D,EdgeFunction<L>>res=nonEmptyReverseLookup.get(target,targetVal); if(res==null) return Collections.emptyMap();if(res==null)returnCollections.emptyMap(); return res;returnres; }}  /**/**	 * Returns, for a given source value and target statement all	 * Returns, for a given source value and target statement all	 * associated target values, and for each the associated edge function. 	 * associated target values, and for each the associated edge function.      * The return value is a mapping from target value to function.     * The return value is a mapping from target value to function.	 */	 */ public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {publicsynchronizedMap<D,EdgeFunction<L>>forwardLookup(DsourceVal,Ntarget){ assert sourceVal!=null;assertsourceVal!=null; assert target!=null;asserttarget!=null; Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);Map<D,EdgeFunction<L>>res=nonEmptyForwardLookup.get(sourceVal,target); if(res==null) return Collections.emptyMap();if(res==null)returnCollections.emptyMap(); return res;returnres; }}  /**/**	 * Returns for a given target statement all jump function records with this target.	 * Returns for a given target statement all jump function records with this target.	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).	 */	 */ public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {publicsynchronizedSet<Cell<D,D,EdgeFunction<L>>>lookupByTarget(Ntarget){ assert target!=null;asserttarget!=null; Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);Table<D,D,EdgeFunction<L>>table=nonEmptyLookupByTargetNode.get(target); if(table==null) return Collections.emptySet();if(table==null)returnCollections.emptySet(); Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();Set<Cell<D,D,EdgeFunction<L>>>res=table.cellSet(); if(res==null) return Collections.emptySet();if(res==null)returnCollections.emptySet(); return res;returnres; }} }}








src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}












src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;/**/** * A path edge as described in the IFDS/IDE algorithms. * A path edge as described in the IFDS/IDE algorithms. * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}. * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}. * Hence, we don't store it. * Hence, we don't store it. * * * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. */ */public class PathEdge<N,D,M> {publicclassPathEdge<N,D,M>{ protected final N target;protectedfinalNtarget; protected final D dSource, dTarget;protectedfinalDdSource,dTarget; /**/**	 * @param dSource The fact at the source.	 * @param dSource The fact at the source.	 * @param target The target statement.	 * @param target The target statement.	 * @param dTarget The fact at the target.	 * @param dTarget The fact at the target.	 */	 */ public PathEdge(D dSource, N target, D dTarget) {publicPathEdge(DdSource,Ntarget,DdTarget){ super();super(); this.target = target;this.target=target; this.dSource = dSource;this.dSource=dSource; this.dTarget = dTarget;this.dTarget=dTarget; }}  public N getTarget() {publicNgetTarget(){ return target;returntarget; }} public D factAtSource() {publicDfactAtSource(){ return dSource;returndSource; }} public D factAtTarget() {publicDfactAtTarget(){ return dTarget;returndTarget; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());result=prime*result+((dSource==null)?0:dSource.hashCode()); result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());result=prime*result+((dTarget==null)?0:dTarget.hashCode()); result = prime * result + ((target == null) ? 0 : target.hashCode());result=prime*result+((target==null)?0:target.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") PathEdge other = (PathEdge) obj;PathEdgeother=(PathEdge)obj; if (dSource == null) {if(dSource==null){ if (other.dSource != null)if(other.dSource!=null) return false;returnfalse; } else if (!dSource.equals(other.dSource))}elseif(!dSource.equals(other.dSource)) return false;returnfalse; if (dTarget == null) {if(dTarget==null){ if (other.dTarget != null)if(other.dTarget!=null) return false;returnfalse; } else if (!dTarget.equals(other.dTarget))}elseif(!dTarget.equals(other.dTarget)) return false;returnfalse; if (target == null) {if(target==null){ if (other.target != null)if(other.target!=null) return false;returnfalse; } else if (!target.equals(other.target))}elseif(!target.equals(other.target)) return false;returnfalse; return true;returntrue; }} @Override@Override public String toString() {publicStringtoString(){ StringBuffer result = new StringBuffer();StringBufferresult=newStringBuffer(); result.append("<");result.append("<"); result.append(dSource);result.append(dSource); result.append("> -> <");result.append("> -> <"); result.append(target.toString());result.append(target.toString()); result.append(",");result.append(","); result.append(dTarget);result.append(dTarget); result.append(">");result.append(">"); return result.toString();returnresult.toString(); }}}}








src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}












src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import java.util.Collections;importjava.util.Collections;import java.util.Map;importjava.util.Map;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.SynchronizedBy;importsoot.jimple.interproc.ifds.SynchronizedBy;import soot.jimple.interproc.ifds.ThreadSafe;importsoot.jimple.interproc.ifds.ThreadSafe;import com.google.common.collect.HashBasedTable;importcom.google.common.collect.HashBasedTable;import com.google.common.collect.Table;importcom.google.common.collect.Table;/**/** * A data structure to record summary functions in an indexed fashion, for fast retrieval. * A data structure to record summary functions in an indexed fashion, for fast retrieval. */ */@ThreadSafe@ThreadSafepublic class SummaryFunctions<N,D,V> {publicclassSummaryFunctions<N,D,V>{  @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();protectedTable<N,D,Table<N,D,EdgeFunction<V>>>table=HashBasedTable.create();  /**/**	 * Inserts a summary function.	 * Inserts a summary function.	 * @param callSite The call site with which this function is associated.	 * @param callSite The call site with which this function is associated.	 * @param sourceVal The source value at the call site. 	 * @param sourceVal The source value at the call site. 	 * @param retSite The return site (in the caller) with which this function is associated.	 * @param retSite The return site (in the caller) with which this function is associated.	 * @param targetVal The target value at the return site.	 * @param targetVal The target value at the return site.	 * @param function The edge function used to compute V-type values from the source node to the target node.  	 * @param function The edge function used to compute V-type values from the source node to the target node.  	 */	 */ public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {publicsynchronizedvoidinsertFunction(NcallSite,DsourceVal,NretSite,DtargetVal,EdgeFunction<V>function){ assert callSite!=null;assertcallSite!=null; assert sourceVal!=null;assertsourceVal!=null; assert retSite!=null;assertretSite!=null; assert targetVal!=null;asserttargetVal!=null; assert function!=null;assertfunction!=null;  Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);Table<N,D,EdgeFunction<V>>targetAndTargetValToFunction=table.get(callSite,sourceVal); if(targetAndTargetValToFunction==null) {if(targetAndTargetValToFunction==null){ targetAndTargetValToFunction = HashBasedTable.create();targetAndTargetValToFunction=HashBasedTable.create(); table.put(callSite,sourceVal,targetAndTargetValToFunction);table.put(callSite,sourceVal,targetAndTargetValToFunction); }} targetAndTargetValToFunction.put(retSite, targetVal, function);targetAndTargetValToFunction.put(retSite,targetVal,function); }} /**/**	 * Retrieves all summary functions for a given call site, source value and	 * Retrieves all summary functions for a given call site, source value and	 * return site (in the caller).	 * return site (in the caller).	 * The result contains a mapping from target value to associated edge function.	 * The result contains a mapping from target value to associated edge function.	 */	 */ public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {publicsynchronizedMap<D,EdgeFunction<V>>summariesFor(NcallSite,DsourceVal,NreturnSite){ assert callSite!=null;assertcallSite!=null; assert sourceVal!=null;assertsourceVal!=null; assert returnSite!=null;assertreturnSite!=null; Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);Table<N,D,EdgeFunction<V>>res=table.get(callSite,sourceVal); if(res==null) return Collections.emptyMap();if(res==null)returnCollections.emptyMap(); else {else{ return res.row(returnSite);returnres.row(returnSite); }} }}}}








src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}












src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}


package soot.jimple.interproc.ifds.template;packagesoot.jimple.interproc.ifds.template;import soot.Body;importsoot.Body;import soot.Unit;importsoot.Unit;import soot.toolkits.graph.DirectedGraph;importsoot.toolkits.graph.DirectedGraph;import soot.toolkits.graph.InverseGraph;importsoot.toolkits.graph.InverseGraph;/**/** * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs. * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs. * This should be used for backward analyses. * This should be used for backward analyses. */ */public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {publicclassBackwardsInterproceduralCFGextendsJimpleBasedInterproceduralCFG{ @Override@Override protected DirectedGraph<Unit> makeGraph(Body body) {protectedDirectedGraph<Unit>makeGraph(Bodybody){ return new InverseGraph<Unit>(super.makeGraph(body));returnnewInverseGraph<Unit>(super.makeGraph(body)); }} }}








src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}












src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}


package soot.jimple.interproc.ifds.template;packagesoot.jimple.interproc.ifds.template;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.EdgeFunctions;importsoot.jimple.interproc.ifds.EdgeFunctions;import soot.jimple.interproc.ifds.IDETabulationProblem;importsoot.jimple.interproc.ifds.IDETabulationProblem;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.JoinLattice;importsoot.jimple.interproc.ifds.JoinLattice;/**/** * This is a template for {@link IDETabulationProblem}s that automatically caches values * This is a template for {@link IDETabulationProblem}s that automatically caches values * that ought to be cached. This class uses the Factory Method design pattern. * that ought to be cached. This class uses the Factory Method design pattern. * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently * reused for solving multiple different {@link IDETabulationProblem}s. * reused for solving multiple different {@link IDETabulationProblem}s. * This class is specific to Soot.  * This class is specific to Soot.  *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>publicabstractclassDefaultIDETabulationProblem<D,V,IextendsInterproceduralCFG<Unit,SootMethod>> extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{extendsDefaultIFDSTabulationProblem<D,I>implementsIDETabulationProblem<Unit,D,SootMethod,V,I>{ private final EdgeFunction<V> allTopFunction;privatefinalEdgeFunction<V>allTopFunction; private final JoinLattice<V> joinLattice;privatefinalJoinLattice<V>joinLattice; private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;privatefinalEdgeFunctions<Unit,D,SootMethod,V>edgeFunctions;  public DefaultIDETabulationProblem(I icfg) {publicDefaultIDETabulationProblem(Iicfg){ super(icfg);super(icfg); this.allTopFunction = createAllTopFunction();this.allTopFunction=createAllTopFunction(); this.joinLattice = createJoinLattice();this.joinLattice=createJoinLattice(); this.edgeFunctions = createEdgeFunctionsFactory();this.edgeFunctions=createEdgeFunctionsFactory(); }} protected abstract EdgeFunction<V> createAllTopFunction();protectedabstractEdgeFunction<V>createAllTopFunction(); protected abstract JoinLattice<V> createJoinLattice();protectedabstractJoinLattice<V>createJoinLattice(); protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();protectedabstractEdgeFunctions<Unit,D,SootMethod,V>createEdgeFunctionsFactory();  @Override@Override public final EdgeFunction<V> allTopFunction() {publicfinalEdgeFunction<V>allTopFunction(){ return allTopFunction;returnallTopFunction; }}  @Override@Override public final JoinLattice<V> joinLattice() {publicfinalJoinLattice<V>joinLattice(){ return joinLattice;returnjoinLattice; }}  @Override@Override public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {publicfinalEdgeFunctions<Unit,D,SootMethod,V>edgeFunctions(){ return edgeFunctions;returnedgeFunctions; }} }}



Prev


1


2


3


Next





Prev

1

2

3

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






