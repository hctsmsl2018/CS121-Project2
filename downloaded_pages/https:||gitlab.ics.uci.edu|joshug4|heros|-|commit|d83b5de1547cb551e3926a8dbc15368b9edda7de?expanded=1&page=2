



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

d83b5de1















Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}














src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

d83b5de1















Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}














src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

d83b5de1







Open sidebar



Joshua Garcia heros
Commits

d83b5de1




Open sidebar

Joshua Garcia heros
Commits

d83b5de1


Joshua GarciaherosherosCommits
d83b5de1








Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}














src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}














src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files



Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden

d83b5de1authoredbyEric Bodden

initial checkin






parent
56cf8f0e
















parent
56cf8f0e





parent












Changes
42
42


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}














src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}














src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}














src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}














src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}














src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}














src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}














src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}














src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}














src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}














src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}














src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}














src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}














src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}









Prev


1


2


3


Next













src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}












src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/edgefunc/AllBottom.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllBottom<V> implements EdgeFunction<V> {










 










 private final V bottomElement;





















 public AllBottom(V bottomElement){










 this.bottomElement = bottomElement;










 } 





















 public V computeTarget(V source) {










 return bottomElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllTop) {










 return this;










 }










 if(otherFunction instanceof EdgeIdentity) {










 return this;










 }










 throw new IllegalStateException("unexpected edge function: "+otherFunction);










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllBottom) {










 @SuppressWarnings("rawtypes")










 AllBottom allBottom = (AllBottom) other;










 return allBottom.bottomElement.equals(bottomElement);










 } 










 return false;










 }










 










 public String toString() {










 return "allbottom";










 }





















}


package soot.jimple.interproc.ifds.edgefunc;packagesoot.jimple.interproc.ifds.edgefunc;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;public class AllBottom<V> implements EdgeFunction<V> {publicclassAllBottom<V>implementsEdgeFunction<V>{  private final V bottomElement;privatefinalVbottomElement; public AllBottom(V bottomElement){publicAllBottom(VbottomElement){ this.bottomElement = bottomElement;this.bottomElement=bottomElement; } } public V computeTarget(V source) {publicVcomputeTarget(Vsource){ return bottomElement;returnbottomElement; }} public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {publicEdgeFunction<V>composeWith(EdgeFunction<V>secondFunction){ return secondFunction;returnsecondFunction; }} public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {publicEdgeFunction<V>joinWith(EdgeFunction<V>otherFunction){ if(otherFunction == this || otherFunction.equalTo(this)) return this;if(otherFunction==this||otherFunction.equalTo(this))returnthis; if(otherFunction instanceof AllTop) {if(otherFunctioninstanceofAllTop){ return this;returnthis; }} if(otherFunction instanceof EdgeIdentity) {if(otherFunctioninstanceofEdgeIdentity){ return this;returnthis; }} throw new IllegalStateException("unexpected edge function: "+otherFunction);thrownewIllegalStateException("unexpected edge function: "+otherFunction); }} public boolean equalTo(EdgeFunction<V> other) {publicbooleanequalTo(EdgeFunction<V>other){ if(other instanceof AllBottom) {if(otherinstanceofAllBottom){ @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") AllBottom allBottom = (AllBottom) other;AllBottomallBottom=(AllBottom)other; return allBottom.bottomElement.equals(bottomElement);returnallBottom.bottomElement.equals(bottomElement); } } return false;returnfalse; }}  public String toString() {publicStringtoString(){ return "allbottom";return"allbottom"; }}}}








src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}












src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/edgefunc/AllTop.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;
































public class AllTop<V> implements EdgeFunction<V> {










 










 private final V topElement; 





















 public AllTop(V topElement){










 this.topElement = topElement;










 } 





















 public V computeTarget(V source) {










 return topElement;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 return otherFunction;










 }





















 public boolean equalTo(EdgeFunction<V> other) {










 if(other instanceof AllTop) {










 @SuppressWarnings("rawtypes")










 AllTop allTop = (AllTop) other;










 return allTop.topElement.equals(topElement);










 } 










 return false;










 }





















 public String toString() {










 return "alltop";










 }










 










}


package soot.jimple.interproc.ifds.edgefunc;packagesoot.jimple.interproc.ifds.edgefunc;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;public class AllTop<V> implements EdgeFunction<V> {publicclassAllTop<V>implementsEdgeFunction<V>{  private final V topElement; privatefinalVtopElement; public AllTop(V topElement){publicAllTop(VtopElement){ this.topElement = topElement;this.topElement=topElement; } } public V computeTarget(V source) {publicVcomputeTarget(Vsource){ return topElement;returntopElement; }} public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {publicEdgeFunction<V>composeWith(EdgeFunction<V>secondFunction){ return secondFunction;returnsecondFunction; }} public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {publicEdgeFunction<V>joinWith(EdgeFunction<V>otherFunction){ return otherFunction;returnotherFunction; }} public boolean equalTo(EdgeFunction<V> other) {publicbooleanequalTo(EdgeFunction<V>other){ if(other instanceof AllTop) {if(otherinstanceofAllTop){ @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") AllTop allTop = (AllTop) other;AllTopallTop=(AllTop)other; return allTop.topElement.equals(topElement);returnallTop.topElement.equals(topElement); } } return false;returnfalse; }} public String toString() {publicStringtoString(){ return "alltop";return"alltop"; }} }}








src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}












src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/edgefunc/EdgeIdentity.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}













package soot.jimple.interproc.ifds.edgefunc;





















import soot.jimple.interproc.ifds.EdgeFunction;





















/**










 * The identity function on graph edges










 * @param <V> The type of values to be computed along flow edges.










 */










public class EdgeIdentity<V> implements EdgeFunction<V> {










 










 @SuppressWarnings("rawtypes")










 private final static EdgeIdentity instance = new EdgeIdentity();










 










 private EdgeIdentity(){} //use v() instead





















 public V computeTarget(V source) {










 return source;










 }





















 public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {










 return secondFunction;










 }





















 public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {










 if(otherFunction == this || otherFunction.equalTo(this)) return this;










 if(otherFunction instanceof AllBottom) {










 return otherFunction;










 }










 if(otherFunction instanceof AllTop) {










 return this;










 }










 //do not know how to join; hence ask other function to decide on this










 return otherFunction.joinWith(this);










 }










 










 public boolean equalTo(EdgeFunction<V> other) {










 //singleton










 return other==this;










 }





















 @SuppressWarnings("unchecked")










 public static <A> EdgeIdentity<A> v() {










 return instance;










 }





















 public String toString() {










 return "id";










 }
































}


package soot.jimple.interproc.ifds.edgefunc;packagesoot.jimple.interproc.ifds.edgefunc;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;/**/** * The identity function on graph edges * The identity function on graph edges * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. */ */public class EdgeIdentity<V> implements EdgeFunction<V> {publicclassEdgeIdentity<V>implementsEdgeFunction<V>{  @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") private final static EdgeIdentity instance = new EdgeIdentity();privatefinalstaticEdgeIdentityinstance=newEdgeIdentity();  private EdgeIdentity(){} //use v() insteadprivateEdgeIdentity(){}//use v() instead public V computeTarget(V source) {publicVcomputeTarget(Vsource){ return source;returnsource; }} public EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction) {publicEdgeFunction<V>composeWith(EdgeFunction<V>secondFunction){ return secondFunction;returnsecondFunction; }} public EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction) {publicEdgeFunction<V>joinWith(EdgeFunction<V>otherFunction){ if(otherFunction == this || otherFunction.equalTo(this)) return this;if(otherFunction==this||otherFunction.equalTo(this))returnthis; if(otherFunction instanceof AllBottom) {if(otherFunctioninstanceofAllBottom){ return otherFunction;returnotherFunction; }} if(otherFunction instanceof AllTop) {if(otherFunctioninstanceofAllTop){ return this;returnthis; }} //do not know how to join; hence ask other function to decide on this//do not know how to join; hence ask other function to decide on this return otherFunction.joinWith(this);returnotherFunction.joinWith(this); }}  public boolean equalTo(EdgeFunction<V> other) {publicbooleanequalTo(EdgeFunction<V>other){ //singleton//singleton return other==this;returnother==this; }} @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public static <A> EdgeIdentity<A> v() {publicstatic<A>EdgeIdentity<A>v(){ return instance;returninstance; }} public String toString() {publicStringtoString(){ return "id";return"id"; }}}}








src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Compose.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















import com.google.common.collect.Sets;





















/**










 * Represents the ordered composition of a set of flow functions.










 */










public class Compose<D> implements FlowFunction<D> {










 










 private final FlowFunction<D>[] funcs;





















 public Compose(FlowFunction<D>... funcs){










 this.funcs = funcs;










 } 





















 public Set<D> computeTargets(D source) {










 Set<D> curr = Sets.newHashSet();










 curr.add(source);










 for (FlowFunction<D> func : funcs) {










 Set<D> next = Sets.newHashSet();










 for(D d: curr)










 next.addAll(func.computeTargets(d));










 curr = next;










 }










 return curr;










 }










 










}




\ No newline at end of file


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;/**/** * Represents the ordered composition of a set of flow functions. * Represents the ordered composition of a set of flow functions. */ */public class Compose<D> implements FlowFunction<D> {publicclassCompose<D>implementsFlowFunction<D>{  private final FlowFunction<D>[] funcs;privatefinalFlowFunction<D>[]funcs; public Compose(FlowFunction<D>... funcs){publicCompose(FlowFunction<D>...funcs){ this.funcs = funcs;this.funcs=funcs; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ Set<D> curr = Sets.newHashSet();Set<D>curr=Sets.newHashSet(); curr.add(source);curr.add(source); for (FlowFunction<D> func : funcs) {for(FlowFunction<D>func:funcs){ Set<D> next = Sets.newHashSet();Set<D>next=Sets.newHashSet(); for(D d: curr)for(Dd:curr) next.addAll(func.computeTargets(d));next.addAll(func.computeTargets(d)); curr = next;curr=next; }} return curr;returncurr; }} }}








src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Gen.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that creates a new value (e.g. returns a set containing a fixed value when given










 * a specific parameter), but acts like the identity function for all other parameters.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Gen<D> implements FlowFunction<D> {










 










 private final D genValue;










 private final D zeroValue;










 










 public Gen(D genValue, D zeroValue){










 this.genValue = genValue;










 this.zeroValue = zeroValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(genValue);










 return res;










 } else










 return Collections.singleton(source);










 }










 










}




\ No newline at end of file


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;/**/** * Function that creates a new value (e.g. returns a set containing a fixed value when given * Function that creates a new value (e.g. returns a set containing a fixed value when given * a specific parameter), but acts like the identity function for all other parameters. * a specific parameter), but acts like the identity function for all other parameters. * * * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public class Gen<D> implements FlowFunction<D> {publicclassGen<D>implementsFlowFunction<D>{  private final D genValue;privatefinalDgenValue; private final D zeroValue;privatefinalDzeroValue;  public Gen(D genValue, D zeroValue){publicGen(DgenValue,DzeroValue){ this.genValue = genValue;this.genValue=genValue; this.zeroValue = zeroValue;this.zeroValue=zeroValue; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==zeroValue) {if(source==zeroValue){ HashSet<D> res = new HashSet<D>();HashSet<D>res=newHashSet<D>(); res.add(source);res.add(source); res.add(genValue);res.add(genValue); return res;returnres; } else}else return Collections.singleton(source);returnCollections.singleton(source); }} }}








src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}












src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Identity.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Identity<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static Identity instance = new Identity();










 










 private Identity(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.singleton(source);










 }





















 @SuppressWarnings("unchecked")










 public static <D> Identity<D> v() {










 return instance;










 }





















}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;public class Identity<D> implements FlowFunction<D> {publicclassIdentity<D>implementsFlowFunction<D>{  @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") private final static Identity instance = new Identity();privatefinalstaticIdentityinstance=newIdentity();  private Identity(){} //use v() insteadprivateIdentity(){}//use v() instead public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ return Collections.singleton(source);returnCollections.singleton(source); }} @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public static <D> Identity<D> v() {publicstatic<D>Identity<D>v(){ return instance;returninstance; }}}}








src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}












src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Kill.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * Function that kills a specific value (i.e. returns an empty set for when given this










 * value as an argument), but behaves like the identity function for all other values.










 *










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class Kill<D> implements FlowFunction<D> {










 










 private final D killValue;










 










 public Kill(D killValue){










 this.killValue = killValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==killValue) {










 return Collections.emptySet();










 } else










 return Collections.singleton(source);










 }










 










}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;/**/** * Function that kills a specific value (i.e. returns an empty set for when given this * Function that kills a specific value (i.e. returns an empty set for when given this * value as an argument), but behaves like the identity function for all other values. * value as an argument), but behaves like the identity function for all other values. * * * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public class Kill<D> implements FlowFunction<D> {publicclassKill<D>implementsFlowFunction<D>{  private final D killValue;privatefinalDkillValue;  public Kill(D killValue){publicKill(DkillValue){ this.killValue = killValue;this.killValue=killValue; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==killValue) {if(source==killValue){ return Collections.emptySet();returnCollections.emptySet(); } else}else return Collections.singleton(source);returnCollections.singleton(source); }} }}








src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}












src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/KillAll.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















/**










 * The empty function, i.e. a function which returns an empty set for all points










 * in the definition space.










 *  










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public class KillAll<D> implements FlowFunction<D> {










 










 @SuppressWarnings("rawtypes")










 private final static KillAll instance = new KillAll();










 










 private KillAll(){} //use v() instead





















 public Set<D> computeTargets(D source) {










 return Collections.emptySet();










 }










 










 @SuppressWarnings("unchecked")










 public static <D> KillAll<D> v() {










 return instance;










 }





















}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;/**/** * The empty function, i.e. a function which returns an empty set for all points * The empty function, i.e. a function which returns an empty set for all points * in the definition space. * in the definition space. *   *   * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public class KillAll<D> implements FlowFunction<D> {publicclassKillAll<D>implementsFlowFunction<D>{  @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") private final static KillAll instance = new KillAll();privatefinalstaticKillAllinstance=newKillAll();  private KillAll(){} //use v() insteadprivateKillAll(){}//use v() instead public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ return Collections.emptySet();returnCollections.emptySet(); }}  @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public static <D> KillAll<D> v() {publicstatic<D>KillAll<D>v(){ return instance;returninstance; }}}}








src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}












src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/flowfunc/Transfer.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}













package soot.jimple.interproc.ifds.flowfunc;





















import java.util.Collections;










import java.util.HashSet;










import java.util.Set;





















import soot.jimple.interproc.ifds.FlowFunction;





















public class Transfer<D> implements FlowFunction<D> {










 










 private final D toValue;










 private final D fromValue;










 










 public Transfer(D toValue, D fromValue){










 this.toValue = toValue;










 this.fromValue = fromValue;










 } 





















 public Set<D> computeTargets(D source) {










 if(source==fromValue) {










 HashSet<D> res = new HashSet<D>();










 res.add(source);










 res.add(toValue);










 return res;










 } else if(source==toValue) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 










}


package soot.jimple.interproc.ifds.flowfunc;packagesoot.jimple.interproc.ifds.flowfunc;import java.util.Collections;importjava.util.Collections;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;public class Transfer<D> implements FlowFunction<D> {publicclassTransfer<D>implementsFlowFunction<D>{  private final D toValue;privatefinalDtoValue; private final D fromValue;privatefinalDfromValue;  public Transfer(D toValue, D fromValue){publicTransfer(DtoValue,DfromValue){ this.toValue = toValue;this.toValue=toValue; this.fromValue = fromValue;this.fromValue=fromValue; } } public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==fromValue) {if(source==fromValue){ HashSet<D> res = new HashSet<D>();HashSet<D>res=newHashSet<D>(); res.add(source);res.add(source); res.add(toValue);res.add(toValue); return res;returnres; } else if(source==toValue) {}elseif(source==toValue){ return Collections.emptySet();returnCollections.emptySet(); } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} }}








src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSLocalInfoFlow.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.AssignStmt;










import soot.jimple.DefinitionStmt;










import soot.jimple.IdentityStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ParameterRef;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Gen;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.flowfunc.Transfer;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;





















public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg); 










 }





















 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { 










 return new FlowFunctions<Unit,Local,SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {










 if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {










 IdentityStmt is = (IdentityStmt) src;










 Local leftLocal = (Local) is.getLeftOp();










 Value right = is.getRightOp();










 if (right instanceof ParameterRef) {










 return new Gen<Local>(leftLocal,zeroValue());










 }










 }










 










 if(src instanceof AssignStmt) {










 AssignStmt assignStmt = (AssignStmt) src;










 Value right = assignStmt.getRightOp();










 if(assignStmt.getLeftOp() instanceof Local) {










 final Local leftLocal = (Local) assignStmt.getLeftOp();










 if(right instanceof Local) {










 final Local rightLocal = (Local) right;










 return new Transfer<Local>(leftLocal, rightLocal);










 } else {










 return new Kill<Local>(leftLocal);










 }










 }










 }










 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 }










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 int argIndex = callArgs.indexOf(source);










 if(argIndex>-1) {










 return Collections.singleton(paramLocals.get(argIndex));










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Local>() {





















 public Set<Local> computeTargets(Local source) {










 if(source==retLocal)










 return Collections.singleton(tgtLocal);










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 } 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 }; 










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("zero", NullType.v());










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }










}




\ No newline at end of file


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.Local;importsoot.Local;import soot.NullType;importsoot.NullType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.Value;importsoot.Value;import soot.jimple.AssignStmt;importsoot.jimple.AssignStmt;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.IdentityStmt;importsoot.jimple.IdentityStmt;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.ParameterRef;importsoot.jimple.ParameterRef;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.internal.JimpleLocal;importsoot.jimple.internal.JimpleLocal;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Gen;importsoot.jimple.interproc.ifds.flowfunc.Gen;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.Kill;importsoot.jimple.interproc.ifds.flowfunc.Kill;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.flowfunc.Transfer;importsoot.jimple.interproc.ifds.flowfunc.Transfer;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;public class IFDSLocalInfoFlow extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSLocalInfoFlowextendsDefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit,SootMethod>>{ public IFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod> icfg) {publicIFDSLocalInfoFlow(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg); super(icfg); }} public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() { publicFlowFunctions<Unit,Local,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit,Local,SootMethod>() {returnnewFlowFunctions<Unit,Local,SootMethod>(){ @Override@Override public FlowFunction<Local> getNormalFlowFunction(Unit src, Unit dest) {publicFlowFunction<Local>getNormalFlowFunction(Unitsrc,Unitdest){ if (src instanceof IdentityStmt && interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()) {if(srcinstanceofIdentityStmt&&interproceduralCFG().getMethodOf(src)==Scene.v().getMainMethod()){ IdentityStmt is = (IdentityStmt) src;IdentityStmtis=(IdentityStmt)src; Local leftLocal = (Local) is.getLeftOp();LocalleftLocal=(Local)is.getLeftOp(); Value right = is.getRightOp();Valueright=is.getRightOp(); if (right instanceof ParameterRef) {if(rightinstanceofParameterRef){ return new Gen<Local>(leftLocal,zeroValue());returnnewGen<Local>(leftLocal,zeroValue()); }} }}  if(src instanceof AssignStmt) {if(srcinstanceofAssignStmt){ AssignStmt assignStmt = (AssignStmt) src;AssignStmtassignStmt=(AssignStmt)src; Value right = assignStmt.getRightOp();Valueright=assignStmt.getRightOp(); if(assignStmt.getLeftOp() instanceof Local) {if(assignStmt.getLeftOp()instanceofLocal){ final Local leftLocal = (Local) assignStmt.getLeftOp();finalLocalleftLocal=(Local)assignStmt.getLeftOp(); if(right instanceof Local) {if(rightinstanceofLocal){ final Local rightLocal = (Local) right;finalLocalrightLocal=(Local)right; return new Transfer<Local>(leftLocal, rightLocal);returnnewTransfer<Local>(leftLocal,rightLocal); } else {}else{ return new Kill<Local>(leftLocal);returnnewKill<Local>(leftLocal); }} }} }} return Identity.v();returnIdentity.v(); }} @Override@Override public FlowFunction<Local> getCallFlowFunction(Unit src, final SootMethod dest) {publicFlowFunction<Local>getCallFlowFunction(Unitsrc,finalSootMethoddest){ Stmt stmt = (Stmt) src;Stmtstmt=(Stmt)src; InvokeExpr ie = stmt.getInvokeExpr();InvokeExprie=stmt.getInvokeExpr(); final List<Value> callArgs = ie.getArgs();finalList<Value>callArgs=ie.getArgs(); final List<Local> paramLocals = new ArrayList<Local>();finalList<Local>paramLocals=newArrayList<Local>(); for(int i=0;i<dest.getParameterCount();i++) {for(inti=0;i<dest.getParameterCount();i++){ paramLocals.add(dest.getActiveBody().getParameterLocal(i));paramLocals.add(dest.getActiveBody().getParameterLocal(i)); }} return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ int argIndex = callArgs.indexOf(source);intargIndex=callArgs.indexOf(source); if(argIndex>-1) {if(argIndex>-1){ return Collections.singleton(paramLocals.get(argIndex));returnCollections.singleton(paramLocals.get(argIndex)); }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Local> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {publicFlowFunction<Local>getReturnFlowFunction(UnitcallSite,SootMethodcallee,UnitexitStmt,UnitretSite){ if (exitStmt instanceof ReturnStmt) { if(exitStmtinstanceofReturnStmt){ ReturnStmt returnStmt = (ReturnStmt) exitStmt;ReturnStmtreturnStmt=(ReturnStmt)exitStmt; Value op = returnStmt.getOp();Valueop=returnStmt.getOp(); if(op instanceof Local) {if(opinstanceofLocal){ if(callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ DefinitionStmt defnStmt = (DefinitionStmt) callSite;DefinitionStmtdefnStmt=(DefinitionStmt)callSite; Value leftOp = defnStmt.getLeftOp();ValueleftOp=defnStmt.getLeftOp(); if(leftOp instanceof Local) {if(leftOpinstanceofLocal){ final Local tgtLocal = (Local) leftOp;finalLocaltgtLocal=(Local)leftOp; final Local retLocal = (Local) op;finalLocalretLocal=(Local)op; return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ if(source==retLocal)if(source==retLocal) return Collections.singleton(tgtLocal);returnCollections.singleton(tgtLocal); return Collections.emptySet();returnCollections.emptySet(); }}  };}; }} }} }} } } return KillAll.v();returnKillAll.v(); }} @Override@Override public FlowFunction<Local> getCallToReturnFlowFunction(Unit call, Unit returnSite) {publicFlowFunction<Local>getCallToReturnFlowFunction(Unitcall,UnitreturnSite){ return Identity.v();returnIdentity.v(); }} }; }; }} @Override@Override public Local createZeroValue() {publicLocalcreateZeroValue(){ return new JimpleLocal("zero", NullType.v());returnnewJimpleLocal("zero",NullType.v()); }} @Override@Override public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }}}}








src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSPossibleTypes.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.PointsToAnalysis;










import soot.PointsToSet;










import soot.PrimType;










import soot.Scene;










import soot.SootMethod;










import soot.Type;










import soot.Unit;










import soot.UnknownType;










import soot.Value;










import soot.jimple.ArrayRef;










import soot.jimple.Constant;










import soot.jimple.DefinitionStmt;










import soot.jimple.InstanceFieldRef;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.NewExpr;










import soot.jimple.Ref;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















@SuppressWarnings("serial")










public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {










 super(icfg);










 }





















 public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {





















 public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {










 if(src instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) src;










 if(defnStmt.containsInvokeExpr()) return Identity.v();










 final Value right = defnStmt.getRightOp();










 final Value left = defnStmt.getLeftOp();










 //won't track primitive-typed variables










 if(right.getType() instanceof PrimType) return Identity.v();










 










 if(right instanceof Constant || right instanceof NewExpr) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {










 if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {










 Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();










 res.add(new Pair<Value,Type>(left,right.getType()));










 res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));










 return res;










 } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 } else if(right instanceof Ref || right instanceof Local) {










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {










 Value value = source.getO1();










 if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {










 //strong update for local variables










 return Collections.emptySet();










 } else if(maybeSameLocation(value,right)) {










 return new LinkedHashSet<Pair<Value,Type>>() {{










 add(new Pair<Value,Type>(left,source.getO2())); 










 add(source); 










 }};










 } else {










 return Collections.singleton(source);










 }










 }





















 private boolean maybeSameLocation(Value v1, Value v2) {










 if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&










 !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {










 return v1.equivTo(v2);










 }










 if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {










 InstanceFieldRef ifr1 = (InstanceFieldRef) v1;










 InstanceFieldRef ifr2 = (InstanceFieldRef) v2;










 if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;










 










 Local base1 = (Local) ifr1.getBase();










 Local base2 = (Local) ifr2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef










 ArrayRef ar1 = (ArrayRef) v1;










 ArrayRef ar2 = (ArrayRef) v2;





















 Local base1 = (Local) ar1.getBase();










 Local base2 = (Local) ar2.getBase();










 PointsToAnalysis pta = Scene.v().getPointsToAnalysis();










 PointsToSet pts1 = pta.reachingObjects(base1);










 PointsToSet pts2 = pta.reachingObjects(base2); 










 return pts1.hasNonEmptyIntersection(pts2);










 }










 }










 };










 } 










 }










 return Identity.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {










 Stmt stmt = (Stmt) src;










 InvokeExpr ie = stmt.getInvokeExpr();










 final List<Value> callArgs = ie.getArgs();










 final List<Local> paramLocals = new ArrayList<Local>();










 for(int i=0;i<dest.getParameterCount();i++) {










 paramLocals.add(dest.getActiveBody().getParameterLocal(i));










 } 










 return new FlowFunction<Pair<Value,Type>>() {










 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 Value value = source.getO1();










 int argIndex = callArgs.indexOf(value);










 if(argIndex>-1) {










 return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));










 }










 return Collections.emptySet();










 }










 };










 }





















 public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {










 if (exitStmt instanceof ReturnStmt) { 










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 Value op = returnStmt.getOp();










 if(op instanceof Local) {










 if(callSite instanceof DefinitionStmt) {










 DefinitionStmt defnStmt = (DefinitionStmt) callSite;










 Value leftOp = defnStmt.getLeftOp();










 if(leftOp instanceof Local) {










 final Local tgtLocal = (Local) leftOp;










 final Local retLocal = (Local) op;










 return new FlowFunction<Pair<Value,Type>>() {





















 public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {










 if(source==retLocal)










 return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 }










 return KillAll.v();










 }





















 public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {










 return Identity.v();










 }










 };










 }





















 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value,Type> createZeroValue() {










 return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());










 }










}




\ No newline at end of file


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.Local;importsoot.Local;import soot.PointsToAnalysis;importsoot.PointsToAnalysis;import soot.PointsToSet;importsoot.PointsToSet;import soot.PrimType;importsoot.PrimType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Type;importsoot.Type;import soot.Unit;importsoot.Unit;import soot.UnknownType;importsoot.UnknownType;import soot.Value;importsoot.Value;import soot.jimple.ArrayRef;importsoot.jimple.ArrayRef;import soot.jimple.Constant;importsoot.jimple.Constant;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.InstanceFieldRef;importsoot.jimple.InstanceFieldRef;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.Jimple;importsoot.jimple.Jimple;import soot.jimple.NewExpr;importsoot.jimple.NewExpr;import soot.jimple.Ref;importsoot.jimple.Ref;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;import soot.toolkits.scalar.Pair;importsoot.toolkits.scalar.Pair;@SuppressWarnings("serial")@SuppressWarnings("serial")public class IFDSPossibleTypes extends DefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSPossibleTypesextendsDefaultIFDSTabulationProblem<Pair<Value,Type>,InterproceduralCFG<Unit,SootMethod>>{ public IFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod> icfg) {publicIFDSPossibleTypes(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg);super(icfg); }} public FlowFunctions<Unit, Pair<Value,Type>, SootMethod> createFlowFunctionsFactory() {publicFlowFunctions<Unit,Pair<Value,Type>,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit,Pair<Value,Type>,SootMethod>() {returnnewFlowFunctions<Unit,Pair<Value,Type>,SootMethod>(){ public FlowFunction<Pair<Value,Type>> getNormalFlowFunction(Unit src, Unit dest) {publicFlowFunction<Pair<Value,Type>>getNormalFlowFunction(Unitsrc,Unitdest){ if(src instanceof DefinitionStmt) {if(srcinstanceofDefinitionStmt){ DefinitionStmt defnStmt = (DefinitionStmt) src;DefinitionStmtdefnStmt=(DefinitionStmt)src; if(defnStmt.containsInvokeExpr()) return Identity.v();if(defnStmt.containsInvokeExpr())returnIdentity.v(); final Value right = defnStmt.getRightOp();finalValueright=defnStmt.getRightOp(); final Value left = defnStmt.getLeftOp();finalValueleft=defnStmt.getLeftOp(); //won't track primitive-typed variables//won't track primitive-typed variables if(right.getType() instanceof PrimType) return Identity.v();if(right.getType()instanceofPrimType)returnIdentity.v();  if(right instanceof Constant || right instanceof NewExpr) {if(rightinstanceofConstant||rightinstanceofNewExpr){ return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value, Type>> computeTargets(Pair<Value, Type> source) {publicSet<Pair<Value,Type>>computeTargets(Pair<Value,Type>source){ if(source==new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v())) {if(source==newPair<Value,Type>(Jimple.v().newLocal("<dummy>",UnknownType.v()),UnknownType.v())){ Set<Pair<Value, Type>> res = new LinkedHashSet<Pair<Value,Type>>();Set<Pair<Value,Type>>res=newLinkedHashSet<Pair<Value,Type>>(); res.add(new Pair<Value,Type>(left,right.getType()));res.add(newPair<Value,Type>(left,right.getType())); res.add(new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v()));res.add(newPair<Value,Type>(Jimple.v().newLocal("<dummy>",UnknownType.v()),UnknownType.v())); return res;returnres; } else if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {}elseif(source.getO1()instanceofLocal&&source.getO1().equivTo(left)){ //strong update for local variables//strong update for local variables return Collections.emptySet();returnCollections.emptySet(); } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} };}; } else if(right instanceof Ref || right instanceof Local) {}elseif(rightinstanceofRef||rightinstanceofLocal){ return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value, Type>> computeTargets(final Pair<Value, Type> source) {publicSet<Pair<Value,Type>>computeTargets(finalPair<Value,Type>source){ Value value = source.getO1();Valuevalue=source.getO1(); if(source.getO1() instanceof Local && source.getO1().equivTo(left)) {if(source.getO1()instanceofLocal&&source.getO1().equivTo(left)){ //strong update for local variables//strong update for local variables return Collections.emptySet();returnCollections.emptySet(); } else if(maybeSameLocation(value,right)) {}elseif(maybeSameLocation(value,right)){ return new LinkedHashSet<Pair<Value,Type>>() {{returnnewLinkedHashSet<Pair<Value,Type>>(){{ add(new Pair<Value,Type>(left,source.getO2())); add(newPair<Value,Type>(left,source.getO2())); add(source); add(source); }};}}; } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} private boolean maybeSameLocation(Value v1, Value v2) {privatebooleanmaybeSameLocation(Valuev1,Valuev2){ if(!(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) &&if(!(v1instanceofInstanceFieldRef&&v2instanceofInstanceFieldRef)&& !(v1 instanceof ArrayRef && v2 instanceof ArrayRef)) {!(v1instanceofArrayRef&&v2instanceofArrayRef)){ return v1.equivTo(v2);returnv1.equivTo(v2); }} if(v1 instanceof InstanceFieldRef && v2 instanceof InstanceFieldRef) {if(v1instanceofInstanceFieldRef&&v2instanceofInstanceFieldRef){ InstanceFieldRef ifr1 = (InstanceFieldRef) v1;InstanceFieldRefifr1=(InstanceFieldRef)v1; InstanceFieldRef ifr2 = (InstanceFieldRef) v2;InstanceFieldRefifr2=(InstanceFieldRef)v2; if(!ifr1.getField().getName().equals(ifr2.getField().getName())) return false;if(!ifr1.getField().getName().equals(ifr2.getField().getName()))returnfalse;  Local base1 = (Local) ifr1.getBase();Localbase1=(Local)ifr1.getBase(); Local base2 = (Local) ifr2.getBase();Localbase2=(Local)ifr2.getBase(); PointsToAnalysis pta = Scene.v().getPointsToAnalysis();PointsToAnalysispta=Scene.v().getPointsToAnalysis(); PointsToSet pts1 = pta.reachingObjects(base1);PointsToSetpts1=pta.reachingObjects(base1); PointsToSet pts2 = pta.reachingObjects(base2); PointsToSetpts2=pta.reachingObjects(base2); return pts1.hasNonEmptyIntersection(pts2);returnpts1.hasNonEmptyIntersection(pts2); } else { //v1 instanceof ArrayRef && v2 instanceof ArrayRef}else{//v1 instanceof ArrayRef && v2 instanceof ArrayRef ArrayRef ar1 = (ArrayRef) v1;ArrayRefar1=(ArrayRef)v1; ArrayRef ar2 = (ArrayRef) v2;ArrayRefar2=(ArrayRef)v2; Local base1 = (Local) ar1.getBase();Localbase1=(Local)ar1.getBase(); Local base2 = (Local) ar2.getBase();Localbase2=(Local)ar2.getBase(); PointsToAnalysis pta = Scene.v().getPointsToAnalysis();PointsToAnalysispta=Scene.v().getPointsToAnalysis(); PointsToSet pts1 = pta.reachingObjects(base1);PointsToSetpts1=pta.reachingObjects(base1); PointsToSet pts2 = pta.reachingObjects(base2); PointsToSetpts2=pta.reachingObjects(base2); return pts1.hasNonEmptyIntersection(pts2);returnpts1.hasNonEmptyIntersection(pts2); }} }} };}; } } }} return Identity.v();returnIdentity.v(); }} public FlowFunction<Pair<Value,Type>> getCallFlowFunction(final Unit src, final SootMethod dest) {publicFlowFunction<Pair<Value,Type>>getCallFlowFunction(finalUnitsrc,finalSootMethoddest){ Stmt stmt = (Stmt) src;Stmtstmt=(Stmt)src; InvokeExpr ie = stmt.getInvokeExpr();InvokeExprie=stmt.getInvokeExpr(); final List<Value> callArgs = ie.getArgs();finalList<Value>callArgs=ie.getArgs(); final List<Local> paramLocals = new ArrayList<Local>();finalList<Local>paramLocals=newArrayList<Local>(); for(int i=0;i<dest.getParameterCount();i++) {for(inti=0;i<dest.getParameterCount();i++){ paramLocals.add(dest.getActiveBody().getParameterLocal(i));paramLocals.add(dest.getActiveBody().getParameterLocal(i)); } } return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {publicSet<Pair<Value,Type>>computeTargets(Pair<Value,Type>source){ Value value = source.getO1();Valuevalue=source.getO1(); int argIndex = callArgs.indexOf(value);intargIndex=callArgs.indexOf(value); if(argIndex>-1) {if(argIndex>-1){ return Collections.singleton(new Pair<Value,Type>(paramLocals.get(argIndex), source.getO2()));returnCollections.singleton(newPair<Value,Type>(paramLocals.get(argIndex),source.getO2())); }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} public FlowFunction<Pair<Value,Type>> getReturnFlowFunction(Unit callSite, SootMethod callee, Unit exitStmt, Unit retSite) {publicFlowFunction<Pair<Value,Type>>getReturnFlowFunction(UnitcallSite,SootMethodcallee,UnitexitStmt,UnitretSite){ if (exitStmt instanceof ReturnStmt) { if(exitStmtinstanceofReturnStmt){ ReturnStmt returnStmt = (ReturnStmt) exitStmt;ReturnStmtreturnStmt=(ReturnStmt)exitStmt; Value op = returnStmt.getOp();Valueop=returnStmt.getOp(); if(op instanceof Local) {if(opinstanceofLocal){ if(callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ DefinitionStmt defnStmt = (DefinitionStmt) callSite;DefinitionStmtdefnStmt=(DefinitionStmt)callSite; Value leftOp = defnStmt.getLeftOp();ValueleftOp=defnStmt.getLeftOp(); if(leftOp instanceof Local) {if(leftOpinstanceofLocal){ final Local tgtLocal = (Local) leftOp;finalLocaltgtLocal=(Local)leftOp; final Local retLocal = (Local) op;finalLocalretLocal=(Local)op; return new FlowFunction<Pair<Value,Type>>() {returnnewFlowFunction<Pair<Value,Type>>(){ public Set<Pair<Value,Type>> computeTargets(Pair<Value,Type> source) {publicSet<Pair<Value,Type>>computeTargets(Pair<Value,Type>source){ if(source==retLocal)if(source==retLocal) return Collections.singleton(new Pair<Value,Type>(tgtLocal, source.getO2()));returnCollections.singleton(newPair<Value,Type>(tgtLocal,source.getO2())); return Collections.emptySet();returnCollections.emptySet(); }}  };}; }} }} }} }} return KillAll.v();returnKillAll.v(); }} public FlowFunction<Pair<Value,Type>> getCallToReturnFlowFunction(Unit call, Unit returnSite) {publicFlowFunction<Pair<Value,Type>>getCallToReturnFlowFunction(Unitcall,UnitreturnSite){ return Identity.v();returnIdentity.v(); }} };}; }} public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }} public Pair<Value,Type> createZeroValue() {publicPair<Value,Type>createZeroValue(){ return new Pair<Value, Type>(Jimple.v().newLocal("<dummy>", UnknownType.v()), UnknownType.v());returnnewPair<Value,Type>(Jimple.v().newLocal("<dummy>",UnknownType.v()),UnknownType.v()); }}}}








src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}












src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSReachingDefinitions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.EquivalentValue;










import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.Jimple;










import soot.jimple.ReturnStmt;










import soot.jimple.ReturnVoidStmt;










import soot.jimple.Stmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.toolkits.scalar.Pair;





















public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {










 public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg);










 }










 










 @Override










 public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt assignment = (DefinitionStmt) curr;





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {










 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if (source != zeroValue()) {










 if (source.getO1().equivTo(assignment.getLeftOp())) {










 return Collections.emptySet();










 }










 return Collections.singleton(source);










 } else {










 LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();










 res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),










 Collections.<DefinitionStmt> singleton(assignment)));










 return res;










 }










 }










 };










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,










 final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>(args.size());










 for (Value value : args) {










 if (value instanceof Local)










 localArguments.add((Local) value);










 else










 localArguments.add(null);










 }





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(localArguments.contains(source.getO1())) {










 int paramIndex = args.indexOf(source.getO1());










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),










 source.getO2());










 return Collections.singleton(pair);










 }





















 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,










 SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return KillAll.v();





















 if (exitStmt instanceof ReturnVoidStmt)










 return KillAll.v();





















 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(exitStmt instanceof ReturnStmt) {










 ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 if (returnStmt.getOp().equivTo(source.getO1())) {










 DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(










 definitionStmt.getLeftOp(), source.getO2());










 return Collections.singleton(pair);










 }










 }










 return Collections.emptySet();










 }










 };










 }





















 @Override










 public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (!(callSite instanceof DefinitionStmt))










 return Identity.v();










 










 final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;










 return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {





















 @Override










 public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {










 if(source.getO1().equivTo(definitionStmt.getLeftOp())) {










 return Collections.emptySet();










 } else {










 return Collections.singleton(source);










 }










 }










 };










 }










 };










 }





















 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 public Pair<Value, Set<DefinitionStmt>> createZeroValue() {










 return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());










 }





















}


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.EquivalentValue;importsoot.EquivalentValue;import soot.Local;importsoot.Local;import soot.NullType;importsoot.NullType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.Value;importsoot.Value;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.Jimple;importsoot.jimple.Jimple;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.ReturnVoidStmt;importsoot.jimple.ReturnVoidStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.internal.JimpleLocal;importsoot.jimple.internal.JimpleLocal;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;import soot.toolkits.scalar.Pair;importsoot.toolkits.scalar.Pair;public class IFDSReachingDefinitions extends DefaultIFDSTabulationProblem<Pair<Value, Set<DefinitionStmt>>,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSReachingDefinitionsextendsDefaultIFDSTabulationProblem<Pair<Value,Set<DefinitionStmt>>,InterproceduralCFG<Unit,SootMethod>>{ public IFDSReachingDefinitions(InterproceduralCFG<Unit, SootMethod> icfg) {publicIFDSReachingDefinitions(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg);super(icfg); }}  @Override@Override public FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod> createFlowFunctionsFactory() {publicFlowFunctions<Unit,Pair<Value,Set<DefinitionStmt>>,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit, Pair<Value, Set<DefinitionStmt>>, SootMethod>() {returnnewFlowFunctions<Unit,Pair<Value,Set<DefinitionStmt>>,SootMethod>(){ @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getNormalFlowFunction(final Unit curr, Unit succ) {publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getNormalFlowFunction(finalUnitcurr,Unitsucc){ if (curr instanceof DefinitionStmt) {if(currinstanceofDefinitionStmt){ final DefinitionStmt assignment = (DefinitionStmt) curr;finalDefinitionStmtassignment=(DefinitionStmt)curr; return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if (source != zeroValue()) {if(source!=zeroValue()){ if (source.getO1().equivTo(assignment.getLeftOp())) {if(source.getO1().equivTo(assignment.getLeftOp())){ return Collections.emptySet();returnCollections.emptySet(); }} return Collections.singleton(source);returnCollections.singleton(source); } else {}else{ LinkedHashSet<Pair<Value, Set<DefinitionStmt>>> res = new LinkedHashSet<Pair<Value, Set<DefinitionStmt>>>();LinkedHashSet<Pair<Value,Set<DefinitionStmt>>>res=newLinkedHashSet<Pair<Value,Set<DefinitionStmt>>>(); res.add(new Pair<Value, Set<DefinitionStmt>>(assignment.getLeftOp(),res.add(newPair<Value,Set<DefinitionStmt>>(assignment.getLeftOp(), Collections.<DefinitionStmt> singleton(assignment)));Collections.<DefinitionStmt>singleton(assignment))); return res;returnres; }} }} };}; }} return Identity.v();returnIdentity.v(); }} @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallFlowFunction(Unit callStmt,publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getCallFlowFunction(UnitcallStmt, final SootMethod destinationMethod) {finalSootMethoddestinationMethod){ Stmt stmt = (Stmt) callStmt;Stmtstmt=(Stmt)callStmt; InvokeExpr invokeExpr = stmt.getInvokeExpr();InvokeExprinvokeExpr=stmt.getInvokeExpr(); final List<Value> args = invokeExpr.getArgs();finalList<Value>args=invokeExpr.getArgs(); final List<Local> localArguments = new ArrayList<Local>(args.size());finalList<Local>localArguments=newArrayList<Local>(args.size()); for (Value value : args) {for(Valuevalue:args){ if (value instanceof Local)if(valueinstanceofLocal) localArguments.add((Local) value);localArguments.add((Local)value); elseelse localArguments.add(null);localArguments.add(null); }} return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if(localArguments.contains(source.getO1())) {if(localArguments.contains(source.getO1())){ int paramIndex = args.indexOf(source.getO1());intparamIndex=args.indexOf(source.getO1()); Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(Pair<Value,Set<DefinitionStmt>>pair=newPair<Value,Set<DefinitionStmt>>( new EquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex), paramIndex)),newEquivalentValue(Jimple.v().newParameterRef(destinationMethod.getParameterType(paramIndex),paramIndex)), source.getO2());source.getO2()); return Collections.singleton(pair);returnCollections.singleton(pair); }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getReturnFlowFunction(final Unit callSite,publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getReturnFlowFunction(finalUnitcallSite, SootMethod calleeMethod, final Unit exitStmt, Unit returnSite) {SootMethodcalleeMethod,finalUnitexitStmt,UnitreturnSite){ if (!(callSite instanceof DefinitionStmt))if(!(callSiteinstanceofDefinitionStmt)) return KillAll.v();returnKillAll.v(); if (exitStmt instanceof ReturnVoidStmt)if(exitStmtinstanceofReturnVoidStmt) return KillAll.v();returnKillAll.v(); return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if(exitStmt instanceof ReturnStmt) {if(exitStmtinstanceofReturnStmt){ ReturnStmt returnStmt = (ReturnStmt) exitStmt;ReturnStmtreturnStmt=(ReturnStmt)exitStmt; if (returnStmt.getOp().equivTo(source.getO1())) {if(returnStmt.getOp().equivTo(source.getO1())){ DefinitionStmt definitionStmt = (DefinitionStmt) callSite;DefinitionStmtdefinitionStmt=(DefinitionStmt)callSite; Pair<Value, Set<DefinitionStmt>> pair = new Pair<Value, Set<DefinitionStmt>>(Pair<Value,Set<DefinitionStmt>>pair=newPair<Value,Set<DefinitionStmt>>( definitionStmt.getLeftOp(), source.getO2());definitionStmt.getLeftOp(),source.getO2()); return Collections.singleton(pair);returnCollections.singleton(pair); }} }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Pair<Value, Set<DefinitionStmt>>> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {publicFlowFunction<Pair<Value,Set<DefinitionStmt>>>getCallToReturnFlowFunction(UnitcallSite,UnitreturnSite){ if (!(callSite instanceof DefinitionStmt))if(!(callSiteinstanceofDefinitionStmt)) return Identity.v();returnIdentity.v();  final DefinitionStmt definitionStmt = (DefinitionStmt) callSite;finalDefinitionStmtdefinitionStmt=(DefinitionStmt)callSite; return new FlowFunction<Pair<Value, Set<DefinitionStmt>>>() {returnnewFlowFunction<Pair<Value,Set<DefinitionStmt>>>(){ @Override@Override public Set<Pair<Value, Set<DefinitionStmt>>> computeTargets(Pair<Value, Set<DefinitionStmt>> source) {publicSet<Pair<Value,Set<DefinitionStmt>>>computeTargets(Pair<Value,Set<DefinitionStmt>>source){ if(source.getO1().equivTo(definitionStmt.getLeftOp())) {if(source.getO1().equivTo(definitionStmt.getLeftOp())){ return Collections.emptySet();returnCollections.emptySet(); } else {}else{ return Collections.singleton(source);returnCollections.singleton(source); }} }} };}; }} };}; }} @Override@Override public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }} public Pair<Value, Set<DefinitionStmt>> createZeroValue() {publicPair<Value,Set<DefinitionStmt>>createZeroValue(){ return new Pair<Value, Set<DefinitionStmt>>(new JimpleLocal("<<zero>>", NullType.v()), Collections.<DefinitionStmt> emptySet());returnnewPair<Value,Set<DefinitionStmt>>(newJimpleLocal("<<zero>>",NullType.v()),Collections.<DefinitionStmt>emptySet()); }}}}








src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}












src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/problems/IFDSUninitializedVariables.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}













package soot.jimple.interproc.ifds.problems;





















import java.util.ArrayList;










import java.util.Collections;










import java.util.LinkedHashSet;










import java.util.List;










import java.util.Set;





















import soot.Local;










import soot.NullType;










import soot.Scene;










import soot.SootMethod;










import soot.Unit;










import soot.Value;










import soot.ValueBox;










import soot.jimple.DefinitionStmt;










import soot.jimple.InvokeExpr;










import soot.jimple.ReturnStmt;










import soot.jimple.Stmt;










import soot.jimple.ThrowStmt;










import soot.jimple.internal.JimpleLocal;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.flowfunc.Identity;










import soot.jimple.interproc.ifds.flowfunc.Kill;










import soot.jimple.interproc.ifds.flowfunc.KillAll;










import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;










import soot.util.Chain;





















public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {





















 public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {










 super(icfg); 










 }





















 @Override










 public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {










 return new FlowFunctions<Unit, Local, SootMethod>() {





















 @Override










 public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {










 final SootMethod m = interproceduralCFG().getMethodOf(curr);










 if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (source == zeroValue()) {










 Set<Local> res = new LinkedHashSet<Local>();










 res.addAll(m.getActiveBody().getLocals());










 for(int i=0;i<m.getParameterCount();i++) 










 res.remove(m.getActiveBody().getParameterLocal(i));










 return res;










 }










 return Collections.emptySet();










 }










 };










 }










 










 if (curr instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) curr;










 final Value leftOp = definition.getLeftOp();










 if(leftOp instanceof Local) {










 final Local leftOpLocal = (Local) leftOp;










 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 List<ValueBox> useBoxes = definition.getUseBoxes();










 for (ValueBox valueBox : useBoxes) {










 if (valueBox.getValue().equivTo(source)) {










 LinkedHashSet<Local> res = new LinkedHashSet<Local>();










 res.add(source);










 res.add(leftOpLocal); 










 return res;










 }










 }





















 if (leftOp.equivTo(source))










 return Collections.emptySet();





















 return Collections.singleton(source);










 }





















 };










 }










 }





















 return Identity.v();










 }





















 @Override










 public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {










 Stmt stmt = (Stmt) callStmt;










 InvokeExpr invokeExpr = stmt.getInvokeExpr();










 final List<Value> args = invokeExpr.getArgs();





















 final List<Local> localArguments = new ArrayList<Local>();










 for (Value value : args)










 if (value instanceof Local)










 localArguments.add((Local) value);





















 return new FlowFunction<Local>() {





















 @Override










 public Set<Local> computeTargets(final Local source) {










 for (Local localArgument : localArguments) {










 if (source.equivTo(localArgument)) {










 return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));










 }










 }





















 if (source == zeroValue()) {










 //gen all locals that are not parameter locals 










 Chain<Local> locals = destinationMethod.getActiveBody().getLocals();










 LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);










 for(int i=0;i<destinationMethod.getParameterCount();i++) { 










 uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));










 }










 return uninitializedLocals;










 }





















 return Collections.emptySet();










 }





















 };










 }





















 @Override










 public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,










 final Unit exitStmt, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 final DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 if (exitStmt instanceof ReturnStmt) {










 final ReturnStmt returnStmt = (ReturnStmt) exitStmt;










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(Local source) {










 if (returnStmt.getOp().equivTo(source))










 return Collections.singleton(leftOpLocal);










 return Collections.emptySet();










 }










 










 };










 } else if (exitStmt instanceof ThrowStmt) {










 //if we throw an exception, LHS of call is undefined










 return new FlowFunction<Local>() {










 










 @Override










 public Set<Local> computeTargets(final Local source) {










 if (source == zeroValue())










 return Collections.singleton(leftOpLocal);










 else










 return Collections.emptySet();










 }










 










 };










 }










 }










 }










 










 return KillAll.v();










 }





















 @Override










 public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {










 if (callSite instanceof DefinitionStmt) {










 DefinitionStmt definition = (DefinitionStmt) callSite;










 if(definition.getLeftOp() instanceof Local) {










 final Local leftOpLocal = (Local) definition.getLeftOp(); 










 return new Kill<Local>(leftOpLocal);










 }










 }










 return Identity.v();










 }










 };










 }










 @Override










 public Set<Unit> initialSeeds() {










 return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());










 }





















 @Override










 public Local createZeroValue() {










 return new JimpleLocal("<<zero>>", NullType.v());










 }





















}


package soot.jimple.interproc.ifds.problems;packagesoot.jimple.interproc.ifds.problems;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collections;importjava.util.Collections;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import soot.Local;importsoot.Local;import soot.NullType;importsoot.NullType;import soot.Scene;importsoot.Scene;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.Value;importsoot.Value;import soot.ValueBox;importsoot.ValueBox;import soot.jimple.DefinitionStmt;importsoot.jimple.DefinitionStmt;import soot.jimple.InvokeExpr;importsoot.jimple.InvokeExpr;import soot.jimple.ReturnStmt;importsoot.jimple.ReturnStmt;import soot.jimple.Stmt;importsoot.jimple.Stmt;import soot.jimple.ThrowStmt;importsoot.jimple.ThrowStmt;import soot.jimple.internal.JimpleLocal;importsoot.jimple.internal.JimpleLocal;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.flowfunc.Identity;importsoot.jimple.interproc.ifds.flowfunc.Identity;import soot.jimple.interproc.ifds.flowfunc.Kill;importsoot.jimple.interproc.ifds.flowfunc.Kill;import soot.jimple.interproc.ifds.flowfunc.KillAll;importsoot.jimple.interproc.ifds.flowfunc.KillAll;import soot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;importsoot.jimple.interproc.ifds.template.DefaultIFDSTabulationProblem;import soot.util.Chain;importsoot.util.Chain;public class IFDSUninitializedVariables extends DefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit, SootMethod>> {publicclassIFDSUninitializedVariablesextendsDefaultIFDSTabulationProblem<Local,InterproceduralCFG<Unit,SootMethod>>{ public IFDSUninitializedVariables(InterproceduralCFG<Unit, SootMethod> icfg) {publicIFDSUninitializedVariables(InterproceduralCFG<Unit,SootMethod>icfg){ super(icfg); super(icfg); }} @Override@Override public FlowFunctions<Unit, Local, SootMethod> createFlowFunctionsFactory() {publicFlowFunctions<Unit,Local,SootMethod>createFlowFunctionsFactory(){ return new FlowFunctions<Unit, Local, SootMethod>() {returnnewFlowFunctions<Unit,Local,SootMethod>(){ @Override@Override public FlowFunction<Local> getNormalFlowFunction(Unit curr, Unit succ) {publicFlowFunction<Local>getNormalFlowFunction(Unitcurr,Unitsucc){ final SootMethod m = interproceduralCFG().getMethodOf(curr);finalSootMethodm=interproceduralCFG().getMethodOf(curr); if(Scene.v().getEntryPoints().contains(m) && interproceduralCFG().isStartPoint(curr)) {if(Scene.v().getEntryPoints().contains(m)&&interproceduralCFG().isStartPoint(curr)){ return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){  @Override@Override public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ if (source == zeroValue()) {if(source==zeroValue()){ Set<Local> res = new LinkedHashSet<Local>();Set<Local>res=newLinkedHashSet<Local>(); res.addAll(m.getActiveBody().getLocals());res.addAll(m.getActiveBody().getLocals()); for(int i=0;i<m.getParameterCount();i++) for(inti=0;i<m.getParameterCount();i++) res.remove(m.getActiveBody().getParameterLocal(i));res.remove(m.getActiveBody().getParameterLocal(i)); return res;returnres; }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }}  if (curr instanceof DefinitionStmt) {if(currinstanceofDefinitionStmt){ final DefinitionStmt definition = (DefinitionStmt) curr;finalDefinitionStmtdefinition=(DefinitionStmt)curr; final Value leftOp = definition.getLeftOp();finalValueleftOp=definition.getLeftOp(); if(leftOp instanceof Local) {if(leftOpinstanceofLocal){ final Local leftOpLocal = (Local) leftOp;finalLocalleftOpLocal=(Local)leftOp; return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ @Override@Override public Set<Local> computeTargets(final Local source) {publicSet<Local>computeTargets(finalLocalsource){ List<ValueBox> useBoxes = definition.getUseBoxes();List<ValueBox>useBoxes=definition.getUseBoxes(); for (ValueBox valueBox : useBoxes) {for(ValueBoxvalueBox:useBoxes){ if (valueBox.getValue().equivTo(source)) {if(valueBox.getValue().equivTo(source)){ LinkedHashSet<Local> res = new LinkedHashSet<Local>();LinkedHashSet<Local>res=newLinkedHashSet<Local>(); res.add(source);res.add(source); res.add(leftOpLocal); res.add(leftOpLocal); return res;returnres; }} }} if (leftOp.equivTo(source))if(leftOp.equivTo(source)) return Collections.emptySet();returnCollections.emptySet(); return Collections.singleton(source);returnCollections.singleton(source); }} };}; }} }} return Identity.v();returnIdentity.v(); }} @Override@Override public FlowFunction<Local> getCallFlowFunction(Unit callStmt, final SootMethod destinationMethod) {publicFlowFunction<Local>getCallFlowFunction(UnitcallStmt,finalSootMethoddestinationMethod){ Stmt stmt = (Stmt) callStmt;Stmtstmt=(Stmt)callStmt; InvokeExpr invokeExpr = stmt.getInvokeExpr();InvokeExprinvokeExpr=stmt.getInvokeExpr(); final List<Value> args = invokeExpr.getArgs();finalList<Value>args=invokeExpr.getArgs(); final List<Local> localArguments = new ArrayList<Local>();finalList<Local>localArguments=newArrayList<Local>(); for (Value value : args)for(Valuevalue:args) if (value instanceof Local)if(valueinstanceofLocal) localArguments.add((Local) value);localArguments.add((Local)value); return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){ @Override@Override public Set<Local> computeTargets(final Local source) {publicSet<Local>computeTargets(finalLocalsource){ for (Local localArgument : localArguments) {for(LocallocalArgument:localArguments){ if (source.equivTo(localArgument)) {if(source.equivTo(localArgument)){ return Collections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument)));returnCollections.<Local>singleton(destinationMethod.getActiveBody().getParameterLocal(args.indexOf(localArgument))); }} }} if (source == zeroValue()) {if(source==zeroValue()){ //gen all locals that are not parameter locals //gen all locals that are not parameter locals  Chain<Local> locals = destinationMethod.getActiveBody().getLocals();Chain<Local>locals=destinationMethod.getActiveBody().getLocals(); LinkedHashSet<Local> uninitializedLocals = new LinkedHashSet<Local>(locals);LinkedHashSet<Local>uninitializedLocals=newLinkedHashSet<Local>(locals); for(int i=0;i<destinationMethod.getParameterCount();i++) { for(inti=0;i<destinationMethod.getParameterCount();i++){ uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i));uninitializedLocals.remove(destinationMethod.getActiveBody().getParameterLocal(i)); }} return uninitializedLocals;returnuninitializedLocals; }} return Collections.emptySet();returnCollections.emptySet(); }} };}; }} @Override@Override public FlowFunction<Local> getReturnFlowFunction(final Unit callSite, SootMethod calleeMethod,publicFlowFunction<Local>getReturnFlowFunction(finalUnitcallSite,SootMethodcalleeMethod, final Unit exitStmt, Unit returnSite) {finalUnitexitStmt,UnitreturnSite){ if (callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ final DefinitionStmt definition = (DefinitionStmt) callSite;finalDefinitionStmtdefinition=(DefinitionStmt)callSite; if(definition.getLeftOp() instanceof Local) {if(definition.getLeftOp()instanceofLocal){ final Local leftOpLocal = (Local) definition.getLeftOp(); finalLocalleftOpLocal=(Local)definition.getLeftOp(); if (exitStmt instanceof ReturnStmt) {if(exitStmtinstanceofReturnStmt){ final ReturnStmt returnStmt = (ReturnStmt) exitStmt;finalReturnStmtreturnStmt=(ReturnStmt)exitStmt; return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){  @Override@Override public Set<Local> computeTargets(Local source) {publicSet<Local>computeTargets(Localsource){ if (returnStmt.getOp().equivTo(source))if(returnStmt.getOp().equivTo(source)) return Collections.singleton(leftOpLocal);returnCollections.singleton(leftOpLocal); return Collections.emptySet();returnCollections.emptySet(); }}  };}; } else if (exitStmt instanceof ThrowStmt) {}elseif(exitStmtinstanceofThrowStmt){ //if we throw an exception, LHS of call is undefined//if we throw an exception, LHS of call is undefined return new FlowFunction<Local>() {returnnewFlowFunction<Local>(){  @Override@Override public Set<Local> computeTargets(final Local source) {publicSet<Local>computeTargets(finalLocalsource){ if (source == zeroValue())if(source==zeroValue()) return Collections.singleton(leftOpLocal);returnCollections.singleton(leftOpLocal); elseelse return Collections.emptySet();returnCollections.emptySet(); }}  };}; }} }} }}  return KillAll.v();returnKillAll.v(); }} @Override@Override public FlowFunction<Local> getCallToReturnFlowFunction(Unit callSite, Unit returnSite) {publicFlowFunction<Local>getCallToReturnFlowFunction(UnitcallSite,UnitreturnSite){ if (callSite instanceof DefinitionStmt) {if(callSiteinstanceofDefinitionStmt){ DefinitionStmt definition = (DefinitionStmt) callSite;DefinitionStmtdefinition=(DefinitionStmt)callSite; if(definition.getLeftOp() instanceof Local) {if(definition.getLeftOp()instanceofLocal){ final Local leftOpLocal = (Local) definition.getLeftOp(); finalLocalleftOpLocal=(Local)definition.getLeftOp(); return new Kill<Local>(leftOpLocal);returnnewKill<Local>(leftOpLocal); }} }} return Identity.v();returnIdentity.v(); }} };}; }} @Override@Override public Set<Unit> initialSeeds() {publicSet<Unit>initialSeeds(){ return Collections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst());returnCollections.singleton(Scene.v().getMainMethod().getActiveBody().getUnits().getFirst()); }} @Override@Override public Local createZeroValue() {publicLocalcreateZeroValue(){ return new JimpleLocal("<<zero>>", NullType.v());returnnewJimpleLocal("<<zero>>",NullType.v()); }}}}








src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}












src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/IDESolver.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}













package soot.jimple.interproc.ifds.solver;
































import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.PrintWriter;










import java.util.ArrayList;










import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.HashSet;










import java.util.Iterator;










import java.util.LinkedHashSet;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.Set;










import java.util.concurrent.ExecutorService;










import java.util.concurrent.Executors;










import java.util.concurrent.TimeUnit;










import java.util.concurrent.atomic.AtomicInteger;





















import soot.PatchingChain;










import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctionCache;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunction;










import soot.jimple.interproc.ifds.FlowFunctionCache;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ZeroedFlowFunctions;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;










import soot.toolkits.scalar.Pair;





















import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Maps;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv,










 * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be










 * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}.










 * 










 * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s










 * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This










 * is to produce, as much as possible, reproducible benchmarking results. We have found










 * that the iteration order can matter a lot in terms of speed.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {










 










 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 private static final boolean DEBUG = false;










 










 private static final boolean DUMP_RESULTS = false;










 










 //executor for dispatching individual compute jobs (may be multi-threaded)










 @DontSynchronize("only used by single thread")










 private ExecutorService executor;










 










 @DontSynchronize("only used by single thread")










 private int numThreads;










 










 //the number of currently running tasks










 private final AtomicInteger numTasks = new AtomicInteger();





















 @SynchronizedBy("consistent lock on field")










 //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction










 //of the exploded super graph. As we observed in experiments, this can speed up the construction.










 private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final JumpFunctions<N,D,V> jumpFn;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();





















 @SynchronizedBy("thread safe data structure, only modified internally")










 private final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();





















 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();










 










 @DontSynchronize("stateless")










 private final FlowFunctions<N, D, M> flowFunctions;





















 @DontSynchronize("stateless")










 private final EdgeFunctions<N,D,M,V> edgeFunctions;





















 @DontSynchronize("only used by single thread")










 private final Set<N> initialSeeds;





















 @DontSynchronize("stateless")










 private final JoinLattice<V> valueLattice;










 










 @DontSynchronize("stateless")










 private final EdgeFunction<V> allTop;










 










 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();





















 @DontSynchronize("only used by single thread - phase II not parallelized (yet)")










 private final Table<N,D,V> val = HashBasedTable.create(); 










 










 @DontSynchronize("benign races")










 public long flowFunctionApplicationCount;





















 @DontSynchronize("benign races")










 public long flowFunctionConstructionCount;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionConstruction;










 










 @DontSynchronize("benign races")










 public long durationFlowFunctionApplication;





















 @DontSynchronize("stateless")










 private final D zeroValue;










 










 @DontSynchronize("readOnly")










 private final FlowFunctionCache<N,D,M> ffCache; 





















 @DontSynchronize("readOnly")










 private final EdgeFunctionCache<N,D,M,V> efCache;





















 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);










 }










 










 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {










 if(DEBUG) {










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();










 }










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG();










 FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());










 EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();










 if(flowFunctionCacheBuilder!=null) {










 ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










 flowFunctions = ffCache;










 } else {










 ffCache = null;










 }










 if(edgeFunctionCacheBuilder!=null) {










 efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);










 edgeFunctions = efCache;










 } else {










 efCache = null;










 }










 this.flowFunctions = flowFunctions;










 this.edgeFunctions = edgeFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.valueLattice = tabulationProblem.joinLattice();










 this.allTop = tabulationProblem.allTopFunction();










 this.jumpFn = new JumpFunctions<N,D,V>(allTop);










 }





















 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * Uses a number of threads equal to the return value of










	 * <code>Runtime.getRuntime().availableProcessors()</code>.










	 */










 public void solve() {










 solve(Runtime.getRuntime().availableProcessors());










 }










 










 /**










	 * Runs the solver on the configured problem. This can take some time.










	 * @param numThreads The number of threads to use.










	 */










 public void solve(int numThreads) {










 if(numThreads<2) {










 this.executor = Executors.newSingleThreadExecutor();










 this.numThreads = 1;










 } else {










 this.executor = Executors.newFixedThreadPool(numThreads);










 this.numThreads = numThreads;










 }










 










 for(N startPoint: initialSeeds) {










 propagate(zeroValue, startPoint, zeroValue, allTop);










 pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));










 jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());










 }










 {










 final long before = System.currentTimeMillis();










 forwardComputeJumpFunctionsSLRPs(); 










 durationFlowFunctionConstruction = System.currentTimeMillis() - before;










 }










 {










 final long before = System.currentTimeMillis();










 computeValues();










 durationFlowFunctionApplication = System.currentTimeMillis() - before;










 }










 if(DEBUG) 










 printStats();










 










 if(DUMP_RESULTS)










 dumpResults();










 










 executor.shutdown();










 }





















 /**










	 * Forward-tabulates the same-level realizable paths and associated functions.










	 * Note that this is a little different from the original IFDS formulations because










	 * we can have statements that are, for instance, both "normal" and "exit" statements.










	 * This is for instance the case on a "throw" statement that may on the one hand










	 * lead to a catch block but on the other hand exit the method depending










	 * on the exception being thrown.










	 */










 private void forwardComputeJumpFunctionsSLRPs() {










 while(true) {










 










 synchronized (pathWorklist) {










 if(!pathWorklist.isEmpty()) {










 //pop edge










 Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();










 PathEdge<N,D,M> edge = iter.next();










 iter.remove();










 numTasks.getAndIncrement();





















 //dispatch processing of edge (potentially in a different thread)










 executor.execute(new PathEdgeProcessingTask(edge));










 propagationCount++;










 } else if(numTasks.intValue()==0){










 //path worklist is empty; no running tasks, we are done










 return;










 } else {










 //the path worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 pathWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 }










 










 /**










	 * Computes the final values for edge functions.










	 */










 private void computeValues() { 










 //Phase II(i)










 for(N startPoint: initialSeeds) {










 setVal(startPoint, zeroValue, valueLattice.bottomElement());










 Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); 










 nodeWorklist.add(superGraphNode);










 }










 while(true) {










 synchronized (nodeWorklist) {










 if(!nodeWorklist.isEmpty()) {










 //pop job










 Pair<N,D> nAndD = nodeWorklist.remove(0); 










 numTasks.getAndIncrement();










 










 //dispatch processing of job (potentially in a different thread)










 executor.execute(new ValuePropagationTask(nAndD));










 } else if(numTasks.intValue()==0) {










 //node worklist is empty; no running tasks, we are done










 break;










 } else {










 //the node worklist is empty but we still have running tasks










 //wait until woken up, then try again










 try {










 nodeWorklist.wait();










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }










 }










 }










 //Phase II(ii)










 //we create an array of all nodes and then dispatch fractions of this array to multiple threads










 Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();










 @SuppressWarnings("unchecked")










 N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];










 int i=0;










 for (N n : allNonCallStartNodes) {










 nonCallStartNodesArray[i] = n;










 i++;










 } 










 for(int t=0;t<numThreads; t++) {










 executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));










 }










 //wait until done










 executor.shutdown();










 try {










 executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);










 } catch (InterruptedException e) {










 throw new RuntimeException(e);










 }










 }





















 private void propagateValueAtStart(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2(); 










 M p = icfg.getMethodOf(n);










 for(N c: icfg.getCallsFromWithin(p)) { 










 Set<Entry<D, EdgeFunction<V>>> entries; 










 synchronized (jumpFn) {










 entries = jumpFn.forwardLookup(d,c).entrySet();










 for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {










 D dPrime = dPAndFP.getKey();










 EdgeFunction<V> fPrime = dPAndFP.getValue();










 N sP = n;










 propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValueAtCall(Pair<N, D> nAndD, N n) {










 D d = nAndD.getO2();










 for(M q: icfg.getCalleesOfCallAt(n)) {










 FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);










 flowFunctionConstructionCount++;










 for(D dPrime: callFlowFunction.computeTargets(d)) {










 EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);










 for(N startPoint: icfg.getStartPointsOf(q)) {










 propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 










 private void propagateValue(N nHashN, D nHashD, V v) {










 synchronized (val) {










 V valNHash = val(nHashN, nHashD);










 V vPrime = valueLattice.join(valNHash,v);










 if(!vPrime.equals(valNHash)) {










 setVal(nHashN, nHashD, vPrime);










 synchronized (nodeWorklist) {










 nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));










 }










 }










 }










 }





















 private V val(N nHashN, D nHashD){ 










 V l = val.get(nHashN, nHashD);










 if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper










 else return l;










 }










 










 private void setVal(N nHashN, D nHashD,V l){ 










 val.put(nHashN, nHashD,l);










 if(DEBUG)










 System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);










 }





















 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...










 final D d2 = edge.factAtTarget();










 










 Set<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 flowFunctionConstructionCount++;










 Set<D> res = function.computeTargets(d2);










 for(N sP: icfg.getStartPointsOf(sCalledProcN)) { 










 for(D d3: res) {










 propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15










 










 Set<Cell<N, D, EdgeFunction<V>>> endSumm;










 synchronized (incoming) {










 //line 15.1 of Naeem/Lhotak/Rodriguez










 addIncoming(sP,d3,n,d2);










 //line 15.2, copy to avoid concurrent modification exceptions by other threads










 endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); 










 }










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {










 N eP = entry.getRowKey();










 D d4 = entry.getColumnKey();










 EdgeFunction<V> fCalleeSummary = entry.getValue();










 for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);










 flowFunctionConstructionCount++;










 for(D d5: retFunction.computeTargets(d4)) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);










 } 










 }










 }










 }










 }










 } 










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez










 EdgeFunction<V> f = jumpFunction(edge);










 List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 flowFunctionConstructionCount++;










 for(D d3: callToReturnFlowFunction.computeTargets(d2)) {










 EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);










 propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));










 }





















 Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);










 for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {










 D d3 = d3AndF3.getKey();










 EdgeFunction<V> f3 = d3AndF3.getValue();










 if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 propagate(d1, returnSiteN, d3, f.composeWith(f3));










 }










 }










 }





















 private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {










 synchronized (jumpFn) {










 EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());










 if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paper










 return function;










 }










 }





















 /**










	 * Lines 21-32 of the algorithm.	










	 */










 private void processExit(PathEdge<N,D,M> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 EdgeFunction<V> f = jumpFunction(edge);










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {










 //line 21.1 of Naeem/Lhotak/Rodriguez










 










 Set<Entry<N, Set<D>>> inc;










 synchronized (incoming) {










 addEndSummary(sP, d1, n, d2, f);










 //copy to avoid concurrent modification exceptions by other threads










 inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));










 }










 










 for (Entry<N,Set<D>> entry: inc) {










 //line 22










 N c = entry.getKey();










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 flowFunctionConstructionCount++;










 Set<D> targets = retFunction.computeTargets(d2);










 for(D d4: entry.getValue()) {










 //line 23










 for(D d5: targets) {










 EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);










 EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);










 EdgeFunction<V> fPrime;










 synchronized (summaryFunctions) {










 EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); 










 if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paper










 fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);










 if(!fPrime.equalTo(summaryFunction)) {










 summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);










 }










 }










 for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {










 EdgeFunction<V> f3 = valAndFunc.getValue();










 if(!f3.equalTo(allTop)); {










 D d3 = valAndFunc.getKey();










 propagate(d3, retSiteC, d5, f3.composeWith(fPrime));










 }










 }










 }










 }










 }










 }










 }










 }










 










 /**










	 * Lines 33-37 of the algorithm.










	 * @param edge










	 */










 private void processNormalFlow(PathEdge<N,D,M> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 EdgeFunction<V> f = jumpFunction(edge);










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 flowFunctionConstructionCount++;










 Set<D> res = flowFunction.computeTargets(d2);










 for (D d3 : res) {










 EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));










 propagate(d1, m, d3, fprime); 










 }










 }










 }










 










 private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {










 EdgeFunction<V> jumpFnE;










 synchronized (jumpFn) {










 jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);










 }










 if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)










 EdgeFunction<V> fPrime = jumpFnE.joinWith(f);










 if(!fPrime.equalTo(jumpFnE)) {










 synchronized (jumpFn) {










 jumpFn.addFunction(sourceVal, target, targetVal, fPrime);










 }










 










 PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);










 synchronized (pathWorklist) {










 pathWorklist.add(edge);










 }





















 if(DEBUG) {










 if(targetVal!=zeroValue) { 










 StringBuilder result = new StringBuilder();










 result.append("EDGE:  <");










 result.append(icfg.getMethodOf(target));










 result.append(",");










 result.append(sourceVal);










 result.append("> -> <");










 result.append(target);










 result.append(",");










 result.append(targetVal);










 result.append("> - ");










 result.append(fPrime);










 System.err.println(result.toString());










 }










 }










 }










 }










 










 private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {










 Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);










 if(map==null) return Collections.emptySet();










 return map.cellSet();










 }





















 private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {










 Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);










 if(summaries==null) {










 summaries = HashBasedTable.create();










 endSummary.put(sP, d1, summaries);










 }










 summaries.put(eP,d2,f);










 } 










 










 private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {










 Map<N, Set<D>> map = incoming.get(sP, d1);










 if(map==null) return Collections.emptySet();










 return map.entrySet(); 










 }










 










 private void addIncoming(N sP, D d3, N n, D d2) {










 Map<N, Set<D>> summaries = incoming.get(sP, d3);










 if(summaries==null) {










 summaries = new HashMap<N, Set<D>>();










 incoming.put(sP, d3, summaries);










 }










 Set<D> set = summaries.get(n);










 if(set==null) {










 set = new HashSet<D>();










 summaries.put(n,set);










 }










 set.add(d2);










 } 










 










 /**










	 * Returns the V-type result for the given value at the given statement. 










	 */










 public V resultAt(N stmt, D value) {










 return val.get(stmt, value);










 }










 










 /**










	 * Returns the resulting environment for the given statement.










	 * The artificial zero value is automatically stripped.










	 */










 public Map<D,V> resultsAt(N stmt) {










 //filter out the artificial zero-value










 return Maps.filterKeys(val.row(stmt), new Predicate<D>() {





















 public boolean apply(D val) {










 return val!=zeroValue;










 }










 });










 }





















 public void dumpResults() {










 try {










 PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));










 List<String> res = new ArrayList<String>();










 for(Cell<N, D, V> entry: val.cellSet()) {










 SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());










 PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();










 int i=0;










 for (Unit unit : units) {










 if(unit==entry.getRowKey())










 break;










 i++;










 }










 










 res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());










 }










 Collections.sort(res);










 for (String string : res) {










 out.println(string);










 }










 out.flush();










 out.close();










 } catch (FileNotFoundException e) {










 e.printStackTrace();










 }










 }





















 public void printStats() {










 if(DEBUG) {










 if(ffCache!=null)










 ffCache.printStats();










 if(efCache!=null)










 efCache.printStats();










 } else {










 System.err.println("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N, D, M> edge;





















 public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 synchronized (pathWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 pathWorklist.notify();










 }










 }










 }










 










 private class ValuePropagationTask implements Runnable {










 private final Pair<N, D> nAndD;





















 public ValuePropagationTask(Pair<N,D> nAndD) {










 this.nAndD = nAndD;










 }





















 public void run() {










 N n = nAndD.getO1();










 if(icfg.isStartPoint(n)) {










 propagateValueAtStart(nAndD, n);










 }










 if(icfg.isCallStmt(n)) {










 propagateValueAtCall(nAndD, n);










 }










 synchronized (nodeWorklist) {










 numTasks.getAndDecrement();










 //potentially wake up waiting broker thread










 //(see forwardComputeJumpFunctionsSLRPs())










 nodeWorklist.notify();










 }










 }










 }










 










 private class ValueComputationTask implements Runnable {










 private final N[] values;










 final int num;





















 public ValueComputationTask(N[] values, int num) {










 this.values = values;










 this.num = num;










 }





















 public void run() {










 int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;










 for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {










 N n = values[i];










 for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { 










 Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;










 lookupByTarget = jumpFn.lookupByTarget(n);










 for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {










 D dPrime = sourceValTargetValAndFunction.getRowKey();










 D d = sourceValTargetValAndFunction.getColumnKey();










 EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();










 synchronized (val) {










 setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));










 }










 flowFunctionApplicationCount++;










 }










 }










 }










 }










 }





















}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import java.io.FileNotFoundException;importjava.io.FileNotFoundException;import java.io.FileOutputStream;importjava.io.FileOutputStream;import java.io.PrintWriter;importjava.io.PrintWriter;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Collection;importjava.util.Collection;import java.util.Collections;importjava.util.Collections;import java.util.HashMap;importjava.util.HashMap;import java.util.HashSet;importjava.util.HashSet;import java.util.Iterator;importjava.util.Iterator;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.LinkedList;importjava.util.LinkedList;import java.util.List;importjava.util.List;import java.util.Map;importjava.util.Map;import java.util.Map.Entry;importjava.util.Map.Entry;import java.util.Set;importjava.util.Set;import java.util.concurrent.ExecutorService;importjava.util.concurrent.ExecutorService;import java.util.concurrent.Executors;importjava.util.concurrent.Executors;import java.util.concurrent.TimeUnit;importjava.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;importjava.util.concurrent.atomic.AtomicInteger;import soot.PatchingChain;importsoot.PatchingChain;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.jimple.interproc.ifds.DontSynchronize;importsoot.jimple.interproc.ifds.DontSynchronize;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.EdgeFunctionCache;importsoot.jimple.interproc.ifds.EdgeFunctionCache;import soot.jimple.interproc.ifds.EdgeFunctions;importsoot.jimple.interproc.ifds.EdgeFunctions;import soot.jimple.interproc.ifds.FlowFunction;importsoot.jimple.interproc.ifds.FlowFunction;import soot.jimple.interproc.ifds.FlowFunctionCache;importsoot.jimple.interproc.ifds.FlowFunctionCache;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.IDETabulationProblem;importsoot.jimple.interproc.ifds.IDETabulationProblem;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.JoinLattice;importsoot.jimple.interproc.ifds.JoinLattice;import soot.jimple.interproc.ifds.SynchronizedBy;importsoot.jimple.interproc.ifds.SynchronizedBy;import soot.jimple.interproc.ifds.ZeroedFlowFunctions;importsoot.jimple.interproc.ifds.ZeroedFlowFunctions;import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;importsoot.jimple.interproc.ifds.edgefunc.EdgeIdentity;import soot.toolkits.scalar.Pair;importsoot.toolkits.scalar.Pair;import com.google.common.base.Predicate;importcom.google.common.base.Predicate;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.collect.HashBasedTable;importcom.google.common.collect.HashBasedTable;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Table;importcom.google.common.collect.Table;import com.google.common.collect.Table.Cell;importcom.google.common.collect.Table.Cell;/**/** * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv, * Solves the given {@link IDETabulationProblem} as described in the 1996 paper by Sagiv, * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be * Horwitz and Reps. To solve the problem, call {@link #solve()}. Results can then be * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}. * queried by using {@link #resultAt(Object, Object)} and {@link #resultsAt(Object)}. *  *  * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s * Note that this solver and its data structures internally use mostly {@link LinkedHashSet}s * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This * instead of normal {@link HashSet}s to fix the iteration order as much as possible. This * is to produce, as much as possible, reproducible benchmarking results. We have found * is to produce, as much as possible, reproducible benchmarking results. We have found * that the iteration order can matter a lot in terms of speed. * that the iteration order can matter a lot in terms of speed. * * * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public class IDESolver<N,D,M,V,I extends InterproceduralCFG<N, M>> {publicclassIDESolver<N,D,M,V,IextendsInterproceduralCFG<N,M>>{  public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();publicstaticCacheBuilder<Object,Object>DEFAULT_CACHE_BUILDER=CacheBuilder.newBuilder().concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();  private static final boolean DEBUG = false;privatestaticfinalbooleanDEBUG=false;  private static final boolean DUMP_RESULTS = false;privatestaticfinalbooleanDUMP_RESULTS=false;  //executor for dispatching individual compute jobs (may be multi-threaded)//executor for dispatching individual compute jobs (may be multi-threaded) @DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread") private ExecutorService executor;privateExecutorServiceexecutor;  @DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread") private int numThreads;privateintnumThreads;  //the number of currently running tasks//the number of currently running tasks private final AtomicInteger numTasks = new AtomicInteger();privatefinalAtomicIntegernumTasks=newAtomicInteger(); @SynchronizedBy("consistent lock on field")@SynchronizedBy("consistent lock on field") //We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction//We are using a LinkedHashSet here to enforce FIFO semantics, which leads to a breath-first construction //of the exploded super graph. As we observed in experiments, this can speed up the construction.//of the exploded super graph. As we observed in experiments, this can speed up the construction. private final Collection<PathEdge<N,D,M>> pathWorklist = new LinkedHashSet<PathEdge<N,D,M>>();privatefinalCollection<PathEdge<N,D,M>>pathWorklist=newLinkedHashSet<PathEdge<N,D,M>>();  @SynchronizedBy("thread safe data structure, consistent locking when used")@SynchronizedBy("thread safe data structure, consistent locking when used") private final JumpFunctions<N,D,V> jumpFn;privatefinalJumpFunctions<N,D,V>jumpFn;  @SynchronizedBy("thread safe data structure, consistent locking when used")@SynchronizedBy("thread safe data structure, consistent locking when used") private final SummaryFunctions<N,D,V> summaryFunctions = new SummaryFunctions<N,D,V>();privatefinalSummaryFunctions<N,D,V>summaryFunctions=newSummaryFunctions<N,D,V>(); @SynchronizedBy("thread safe data structure, only modified internally")@SynchronizedBy("thread safe data structure, only modified internally") private final I icfg;privatefinalIicfg;  //stores summaries that were queried before they were computed//stores summaries that were queried before they were computed //see CC 2010 paper by Naeem, Lhotak and Rodriguez//see CC 2010 paper by Naeem, Lhotak and Rodriguez @SynchronizedBy("consistent lock on 'incoming'")@SynchronizedBy("consistent lock on 'incoming'") private final Table<N,D,Table<N,D,EdgeFunction<V>>> endSummary = HashBasedTable.create();privatefinalTable<N,D,Table<N,D,EdgeFunction<V>>>endSummary=HashBasedTable.create(); //edges going along calls//edges going along calls //see CC 2010 paper by Naeem, Lhotak and Rodriguez//see CC 2010 paper by Naeem, Lhotak and Rodriguez @SynchronizedBy("consistent lock on field")@SynchronizedBy("consistent lock on field") private final Table<N,D,Map<N,Set<D>>> incoming = HashBasedTable.create();privatefinalTable<N,D,Map<N,Set<D>>>incoming=HashBasedTable.create();  @DontSynchronize("stateless")@DontSynchronize("stateless") private final FlowFunctions<N, D, M> flowFunctions;privatefinalFlowFunctions<N,D,M>flowFunctions; @DontSynchronize("stateless")@DontSynchronize("stateless") private final EdgeFunctions<N,D,M,V> edgeFunctions;privatefinalEdgeFunctions<N,D,M,V>edgeFunctions; @DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread") private final Set<N> initialSeeds;privatefinalSet<N>initialSeeds; @DontSynchronize("stateless")@DontSynchronize("stateless") private final JoinLattice<V> valueLattice;privatefinalJoinLattice<V>valueLattice;  @DontSynchronize("stateless")@DontSynchronize("stateless") private final EdgeFunction<V> allTop;privatefinalEdgeFunction<V>allTop;  @DontSynchronize("only used by single thread - phase II not parallelized (yet)")@DontSynchronize("only used by single thread - phase II not parallelized (yet)") private final List<Pair<N,D>> nodeWorklist = new LinkedList<Pair<N,D>>();privatefinalList<Pair<N,D>>nodeWorklist=newLinkedList<Pair<N,D>>(); @DontSynchronize("only used by single thread - phase II not parallelized (yet)")@DontSynchronize("only used by single thread - phase II not parallelized (yet)") private final Table<N,D,V> val = HashBasedTable.create(); privatefinalTable<N,D,V>val=HashBasedTable.create();  @DontSynchronize("benign races")@DontSynchronize("benign races") public long flowFunctionApplicationCount;publiclongflowFunctionApplicationCount; @DontSynchronize("benign races")@DontSynchronize("benign races") public long flowFunctionConstructionCount;publiclongflowFunctionConstructionCount;  @DontSynchronize("benign races")@DontSynchronize("benign races") public long propagationCount;publiclongpropagationCount;  @DontSynchronize("benign races")@DontSynchronize("benign races") public long durationFlowFunctionConstruction;publiclongdurationFlowFunctionConstruction;  @DontSynchronize("benign races")@DontSynchronize("benign races") public long durationFlowFunctionApplication;publiclongdurationFlowFunctionApplication; @DontSynchronize("stateless")@DontSynchronize("stateless") private final D zeroValue;privatefinalDzeroValue;  @DontSynchronize("readOnly")@DontSynchronize("readOnly") private final FlowFunctionCache<N,D,M> ffCache; privatefinalFlowFunctionCache<N,D,M>ffCache; @DontSynchronize("readOnly")@DontSynchronize("readOnly") private final EdgeFunctionCache<N,D,M,V> efCache;privatefinalEdgeFunctionCache<N,D,M,V>efCache; /**/**	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * The solver must then be started by calling {@link #solve()}.	 * The solver must then be started by calling {@link #solve()}.	 */	 */ public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem) {publicIDESolver(IDETabulationProblem<N,D,M,V,I>tabulationProblem){ this(tabulationProblem, DEFAULT_CACHE_BUILDER, DEFAULT_CACHE_BUILDER);this(tabulationProblem,DEFAULT_CACHE_BUILDER,DEFAULT_CACHE_BUILDER); }}  /**/**	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling	 * {@link #solve()}.	 * {@link #solve()}.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 */	 */ public IDESolver(IDETabulationProblem<N,D,M,V,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder, @SuppressWarnings("rawtypes") CacheBuilder edgeFunctionCacheBuilder) {publicIDESolver(IDETabulationProblem<N,D,M,V,I>tabulationProblem,@SuppressWarnings("rawtypes")CacheBuilderflowFunctionCacheBuilder,@SuppressWarnings("rawtypes")CacheBuilderedgeFunctionCacheBuilder){ if(DEBUG) {if(DEBUG){ flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();flowFunctionCacheBuilder=flowFunctionCacheBuilder.recordStats(); edgeFunctionCacheBuilder = edgeFunctionCacheBuilder.recordStats();edgeFunctionCacheBuilder=edgeFunctionCacheBuilder.recordStats(); }} this.zeroValue = tabulationProblem.zeroValue();this.zeroValue=tabulationProblem.zeroValue(); this.icfg = tabulationProblem.interproceduralCFG();this.icfg=tabulationProblem.interproceduralCFG(); FlowFunctions<N, D, M> flowFunctions = new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), tabulationProblem.zeroValue());FlowFunctions<N,D,M>flowFunctions=newZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(),tabulationProblem.zeroValue()); EdgeFunctions<N, D, M, V> edgeFunctions = tabulationProblem.edgeFunctions();EdgeFunctions<N,D,M,V>edgeFunctions=tabulationProblem.edgeFunctions(); if(flowFunctionCacheBuilder!=null) {if(flowFunctionCacheBuilder!=null){ ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);ffCache=newFlowFunctionCache<N,D,M>(flowFunctions,flowFunctionCacheBuilder); flowFunctions = ffCache;flowFunctions=ffCache; } else {}else{ ffCache = null;ffCache=null; }} if(edgeFunctionCacheBuilder!=null) {if(edgeFunctionCacheBuilder!=null){ efCache = new EdgeFunctionCache<N,D,M,V>(edgeFunctions, edgeFunctionCacheBuilder);efCache=newEdgeFunctionCache<N,D,M,V>(edgeFunctions,edgeFunctionCacheBuilder); edgeFunctions = efCache;edgeFunctions=efCache; } else {}else{ efCache = null;efCache=null; }} this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; this.edgeFunctions = edgeFunctions;this.edgeFunctions=edgeFunctions; this.initialSeeds = tabulationProblem.initialSeeds();this.initialSeeds=tabulationProblem.initialSeeds(); this.valueLattice = tabulationProblem.joinLattice();this.valueLattice=tabulationProblem.joinLattice(); this.allTop = tabulationProblem.allTopFunction();this.allTop=tabulationProblem.allTopFunction(); this.jumpFn = new JumpFunctions<N,D,V>(allTop);this.jumpFn=newJumpFunctions<N,D,V>(allTop); }} /**/**	 * Runs the solver on the configured problem. This can take some time.	 * Runs the solver on the configured problem. This can take some time.	 * Uses a number of threads equal to the return value of	 * Uses a number of threads equal to the return value of	 * <code>Runtime.getRuntime().availableProcessors()</code>.	 * <code>Runtime.getRuntime().availableProcessors()</code>.	 */	 */ public void solve() {publicvoidsolve(){ solve(Runtime.getRuntime().availableProcessors());solve(Runtime.getRuntime().availableProcessors()); }}  /**/**	 * Runs the solver on the configured problem. This can take some time.	 * Runs the solver on the configured problem. This can take some time.	 * @param numThreads The number of threads to use.	 * @param numThreads The number of threads to use.	 */	 */ public void solve(int numThreads) {publicvoidsolve(intnumThreads){ if(numThreads<2) {if(numThreads<2){ this.executor = Executors.newSingleThreadExecutor();this.executor=Executors.newSingleThreadExecutor(); this.numThreads = 1;this.numThreads=1; } else {}else{ this.executor = Executors.newFixedThreadPool(numThreads);this.executor=Executors.newFixedThreadPool(numThreads); this.numThreads = numThreads;this.numThreads=numThreads; }}  for(N startPoint: initialSeeds) {for(NstartPoint:initialSeeds){ propagate(zeroValue, startPoint, zeroValue, allTop);propagate(zeroValue,startPoint,zeroValue,allTop); pathWorklist.add(new PathEdge<N,D,M>(zeroValue, startPoint, zeroValue));pathWorklist.add(newPathEdge<N,D,M>(zeroValue,startPoint,zeroValue)); jumpFn.addFunction(zeroValue, startPoint, zeroValue, EdgeIdentity.<V>v());jumpFn.addFunction(zeroValue,startPoint,zeroValue,EdgeIdentity.<V>v()); }} {{ final long before = System.currentTimeMillis();finallongbefore=System.currentTimeMillis(); forwardComputeJumpFunctionsSLRPs(); forwardComputeJumpFunctionsSLRPs(); durationFlowFunctionConstruction = System.currentTimeMillis() - before;durationFlowFunctionConstruction=System.currentTimeMillis()-before; }} {{ final long before = System.currentTimeMillis();finallongbefore=System.currentTimeMillis(); computeValues();computeValues(); durationFlowFunctionApplication = System.currentTimeMillis() - before;durationFlowFunctionApplication=System.currentTimeMillis()-before; }} if(DEBUG) if(DEBUG) printStats();printStats();  if(DUMP_RESULTS)if(DUMP_RESULTS) dumpResults();dumpResults();  executor.shutdown();executor.shutdown(); }} /**/**	 * Forward-tabulates the same-level realizable paths and associated functions.	 * Forward-tabulates the same-level realizable paths and associated functions.	 * Note that this is a little different from the original IFDS formulations because	 * Note that this is a little different from the original IFDS formulations because	 * we can have statements that are, for instance, both "normal" and "exit" statements.	 * we can have statements that are, for instance, both "normal" and "exit" statements.	 * This is for instance the case on a "throw" statement that may on the one hand	 * This is for instance the case on a "throw" statement that may on the one hand	 * lead to a catch block but on the other hand exit the method depending	 * lead to a catch block but on the other hand exit the method depending	 * on the exception being thrown.	 * on the exception being thrown.	 */	 */ private void forwardComputeJumpFunctionsSLRPs() {privatevoidforwardComputeJumpFunctionsSLRPs(){ while(true) {while(true){  synchronized (pathWorklist) {synchronized(pathWorklist){ if(!pathWorklist.isEmpty()) {if(!pathWorklist.isEmpty()){ //pop edge//pop edge Iterator<PathEdge<N,D,M>> iter = pathWorklist.iterator();Iterator<PathEdge<N,D,M>>iter=pathWorklist.iterator(); PathEdge<N,D,M> edge = iter.next();PathEdge<N,D,M>edge=iter.next(); iter.remove();iter.remove(); numTasks.getAndIncrement();numTasks.getAndIncrement(); //dispatch processing of edge (potentially in a different thread)//dispatch processing of edge (potentially in a different thread) executor.execute(new PathEdgeProcessingTask(edge));executor.execute(newPathEdgeProcessingTask(edge)); propagationCount++;propagationCount++; } else if(numTasks.intValue()==0){}elseif(numTasks.intValue()==0){ //path worklist is empty; no running tasks, we are done//path worklist is empty; no running tasks, we are done return;return; } else {}else{ //the path worklist is empty but we still have running tasks//the path worklist is empty but we still have running tasks //wait until woken up, then try again//wait until woken up, then try again try {try{ pathWorklist.wait();pathWorklist.wait(); } catch (InterruptedException e) {}catch(InterruptedExceptione){ throw new RuntimeException(e);thrownewRuntimeException(e); }} }} }} }} }}  /**/**	 * Computes the final values for edge functions.	 * Computes the final values for edge functions.	 */	 */ private void computeValues() { privatevoidcomputeValues(){ //Phase II(i)//Phase II(i) for(N startPoint: initialSeeds) {for(NstartPoint:initialSeeds){ setVal(startPoint, zeroValue, valueLattice.bottomElement());setVal(startPoint,zeroValue,valueLattice.bottomElement()); Pair<N, D> superGraphNode = new Pair<N,D>(startPoint, zeroValue); Pair<N,D>superGraphNode=newPair<N,D>(startPoint,zeroValue); nodeWorklist.add(superGraphNode);nodeWorklist.add(superGraphNode); }} while(true) {while(true){ synchronized (nodeWorklist) {synchronized(nodeWorklist){ if(!nodeWorklist.isEmpty()) {if(!nodeWorklist.isEmpty()){ //pop job//pop job Pair<N,D> nAndD = nodeWorklist.remove(0); Pair<N,D>nAndD=nodeWorklist.remove(0); numTasks.getAndIncrement();numTasks.getAndIncrement();  //dispatch processing of job (potentially in a different thread)//dispatch processing of job (potentially in a different thread) executor.execute(new ValuePropagationTask(nAndD));executor.execute(newValuePropagationTask(nAndD)); } else if(numTasks.intValue()==0) {}elseif(numTasks.intValue()==0){ //node worklist is empty; no running tasks, we are done//node worklist is empty; no running tasks, we are done break;break; } else {}else{ //the node worklist is empty but we still have running tasks//the node worklist is empty but we still have running tasks //wait until woken up, then try again//wait until woken up, then try again try {try{ nodeWorklist.wait();nodeWorklist.wait(); } catch (InterruptedException e) {}catch(InterruptedExceptione){ throw new RuntimeException(e);thrownewRuntimeException(e); }} }} }} }} //Phase II(ii)//Phase II(ii) //we create an array of all nodes and then dispatch fractions of this array to multiple threads//we create an array of all nodes and then dispatch fractions of this array to multiple threads Set<N> allNonCallStartNodes = icfg.allNonCallStartNodes();Set<N>allNonCallStartNodes=icfg.allNonCallStartNodes(); @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") N[] nonCallStartNodesArray = (N[]) new Object[allNonCallStartNodes.size()];N[]nonCallStartNodesArray=(N[])newObject[allNonCallStartNodes.size()]; int i=0;inti=0; for (N n : allNonCallStartNodes) {for(Nn:allNonCallStartNodes){ nonCallStartNodesArray[i] = n;nonCallStartNodesArray[i]=n; i++;i++; } } for(int t=0;t<numThreads; t++) {for(intt=0;t<numThreads;t++){ executor.execute(new ValueComputationTask(nonCallStartNodesArray, t));executor.execute(newValueComputationTask(nonCallStartNodesArray,t)); }} //wait until done//wait until done executor.shutdown();executor.shutdown(); try {try{ executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);executor.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS); } catch (InterruptedException e) {}catch(InterruptedExceptione){ throw new RuntimeException(e);thrownewRuntimeException(e); }} }} private void propagateValueAtStart(Pair<N, D> nAndD, N n) {privatevoidpropagateValueAtStart(Pair<N,D>nAndD,Nn){ D d = nAndD.getO2(); Dd=nAndD.getO2(); M p = icfg.getMethodOf(n);Mp=icfg.getMethodOf(n); for(N c: icfg.getCallsFromWithin(p)) { for(Nc:icfg.getCallsFromWithin(p)){ Set<Entry<D, EdgeFunction<V>>> entries; Set<Entry<D,EdgeFunction<V>>>entries; synchronized (jumpFn) {synchronized(jumpFn){ entries = jumpFn.forwardLookup(d,c).entrySet();entries=jumpFn.forwardLookup(d,c).entrySet(); for(Map.Entry<D,EdgeFunction<V>> dPAndFP: entries) {for(Map.Entry<D,EdgeFunction<V>>dPAndFP:entries){ D dPrime = dPAndFP.getKey();DdPrime=dPAndFP.getKey(); EdgeFunction<V> fPrime = dPAndFP.getValue();EdgeFunction<V>fPrime=dPAndFP.getValue(); N sP = n;NsP=n; propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d)));propagateValue(c,dPrime,fPrime.computeTarget(val(sP,d))); flowFunctionApplicationCount++;flowFunctionApplicationCount++; }} }} }} }}  private void propagateValueAtCall(Pair<N, D> nAndD, N n) {privatevoidpropagateValueAtCall(Pair<N,D>nAndD,Nn){ D d = nAndD.getO2();Dd=nAndD.getO2(); for(M q: icfg.getCalleesOfCallAt(n)) {for(Mq:icfg.getCalleesOfCallAt(n)){ FlowFunction<D> callFlowFunction = flowFunctions.getCallFlowFunction(n, q);FlowFunction<D>callFlowFunction=flowFunctions.getCallFlowFunction(n,q); flowFunctionConstructionCount++;flowFunctionConstructionCount++; for(D dPrime: callFlowFunction.computeTargets(d)) {for(DdPrime:callFlowFunction.computeTargets(d)){ EdgeFunction<V> edgeFn = edgeFunctions.getCallEdgeFunction(n, d, q, dPrime);EdgeFunction<V>edgeFn=edgeFunctions.getCallEdgeFunction(n,d,q,dPrime); for(N startPoint: icfg.getStartPointsOf(q)) {for(NstartPoint:icfg.getStartPointsOf(q)){ propagateValue(startPoint,dPrime, edgeFn.computeTarget(val(n,d)));propagateValue(startPoint,dPrime,edgeFn.computeTarget(val(n,d))); flowFunctionApplicationCount++;flowFunctionApplicationCount++; }} }} }} }}  private void propagateValue(N nHashN, D nHashD, V v) {privatevoidpropagateValue(NnHashN,DnHashD,Vv){ synchronized (val) {synchronized(val){ V valNHash = val(nHashN, nHashD);VvalNHash=val(nHashN,nHashD); V vPrime = valueLattice.join(valNHash,v);VvPrime=valueLattice.join(valNHash,v); if(!vPrime.equals(valNHash)) {if(!vPrime.equals(valNHash)){ setVal(nHashN, nHashD, vPrime);setVal(nHashN,nHashD,vPrime); synchronized (nodeWorklist) {synchronized(nodeWorklist){ nodeWorklist.add(new Pair<N,D>(nHashN,nHashD));nodeWorklist.add(newPair<N,D>(nHashN,nHashD)); }} }} }} }} private V val(N nHashN, D nHashD){ privateVval(NnHashN,DnHashD){ V l = val.get(nHashN, nHashD);Vl=val.get(nHashN,nHashD); if(l==null) return valueLattice.topElement(); //implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paperif(l==null)returnvalueLattice.topElement();//implicitly initialized to top; see line [1] of Fig. 7 in SRH96 paper else return l;elsereturnl; }}  private void setVal(N nHashN, D nHashD,V l){ privatevoidsetVal(NnHashN,DnHashD,Vl){ val.put(nHashN, nHashD,l);val.put(nHashN,nHashD,l); if(DEBUG)if(DEBUG) System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+ " " + l);System.err.println("VALUE: "+((SootMethod)icfg.getMethodOf(nHashN)).getSignature()+" "+nHashN+" "+nHashD+" "+l); }}  /**/**	 * Lines 13-20 of the algorithm; processing a call site in the caller's context	 * Lines 13-20 of the algorithm; processing a call site in the caller's context	 * @param edge an edge whose target node resembles a method call	 * @param edge an edge whose target node resembles a method call	 */	 */ private void processCall(PathEdge<N,D,M> edge) {privatevoidprocessCall(PathEdge<N,D,M>edge){ final D d1 = edge.factAtSource();finalDd1=edge.factAtSource(); final N n = edge.getTarget(); // a call node; line 14...finalNn=edge.getTarget();// a call node; line 14... final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();  Set<M> callees = icfg.getCalleesOfCallAt(n);Set<M>callees=icfg.getCalleesOfCallAt(n); for(M sCalledProcN: callees) { //still line 14for(MsCalledProcN:callees){//still line 14 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);FlowFunction<D>function=flowFunctions.getCallFlowFunction(n,sCalledProcN); flowFunctionConstructionCount++;flowFunctionConstructionCount++; Set<D> res = function.computeTargets(d2);Set<D>res=function.computeTargets(d2); for(N sP: icfg.getStartPointsOf(sCalledProcN)) { for(NsP:icfg.getStartPointsOf(sCalledProcN)){ for(D d3: res) {for(Dd3:res){ propagate(d3, sP, d3, EdgeIdentity.<V>v()); //line 15propagate(d3,sP,d3,EdgeIdentity.<V>v());//line 15  Set<Cell<N, D, EdgeFunction<V>>> endSumm;Set<Cell<N,D,EdgeFunction<V>>>endSumm; synchronized (incoming) {synchronized(incoming){ //line 15.1 of Naeem/Lhotak/Rodriguez//line 15.1 of Naeem/Lhotak/Rodriguez addIncoming(sP,d3,n,d2);addIncoming(sP,d3,n,d2); //line 15.2, copy to avoid concurrent modification exceptions by other threads//line 15.2, copy to avoid concurrent modification exceptions by other threads endSumm = new HashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP, d3)); endSumm=newHashSet<Table.Cell<N,D,EdgeFunction<V>>>(endSummary(sP,d3)); }}  //still line 15.2 of Naeem/Lhotak/Rodriguez//still line 15.2 of Naeem/Lhotak/Rodriguez for(Cell<N, D, EdgeFunction<V>> entry: endSumm) {for(Cell<N,D,EdgeFunction<V>>entry:endSumm){ N eP = entry.getRowKey();NeP=entry.getRowKey(); D d4 = entry.getColumnKey();Dd4=entry.getColumnKey(); EdgeFunction<V> fCalleeSummary = entry.getValue();EdgeFunction<V>fCalleeSummary=entry.getValue(); for(N retSiteN: icfg.getReturnSitesOfCallAt(n)) {for(NretSiteN:icfg.getReturnSitesOfCallAt(n)){ FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,eP,retSiteN); flowFunctionConstructionCount++;flowFunctionConstructionCount++; for(D d5: retFunction.computeTargets(d4)) {for(Dd5:retFunction.computeTargets(d4)){ EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(n, d2, sCalledProcN, d3);EdgeFunction<V>f4=edgeFunctions.getCallEdgeFunction(n,d2,sCalledProcN,d3); EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(n, sCalledProcN, eP, d4, retSiteN, d5);EdgeFunction<V>f5=edgeFunctions.getReturnEdgeFunction(n,sCalledProcN,eP,d4,retSiteN,d5); synchronized (summaryFunctions) {synchronized(summaryFunctions){ EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(n, d2, retSiteN).get(d5); EdgeFunction<V>summaryFunction=summaryFunctions.summariesFor(n,d2,retSiteN).get(d5); if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paperif(summaryFunction==null)summaryFunction=allTop;//SummaryFn initialized to all-top, see line [4] in SRH96 paper EdgeFunction<V> fPrime = f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction);EdgeFunction<V>fPrime=f4.composeWith(fCalleeSummary).composeWith(f5).joinWith(summaryFunction); if(!fPrime.equalTo(summaryFunction)) {if(!fPrime.equalTo(summaryFunction)){ summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime);summaryFunctions.insertFunction(n,d2,retSiteN,d5,fPrime); } } }} }} }} }} } } }} }} //line 17-19 of Naeem/Lhotak/Rodriguez//line 17-19 of Naeem/Lhotak/Rodriguez EdgeFunction<V> f = jumpFunction(edge);EdgeFunction<V>f=jumpFunction(edge); List<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);List<N>returnSiteNs=icfg.getReturnSitesOfCallAt(n); for (N returnSiteN : returnSiteNs) {for(NreturnSiteN:returnSiteNs){ FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);FlowFunction<D>callToReturnFlowFunction=flowFunctions.getCallToReturnFlowFunction(n,returnSiteN); flowFunctionConstructionCount++;flowFunctionConstructionCount++; for(D d3: callToReturnFlowFunction.computeTargets(d2)) {for(Dd3:callToReturnFlowFunction.computeTargets(d2)){ EdgeFunction<V> edgeFnE = edgeFunctions.getCallToReturnEdgeFunction(n, d2, returnSiteN, d3);EdgeFunction<V>edgeFnE=edgeFunctions.getCallToReturnEdgeFunction(n,d2,returnSiteN,d3); propagate(d1, returnSiteN, d3, f.composeWith(edgeFnE));propagate(d1,returnSiteN,d3,f.composeWith(edgeFnE)); }} Map<D,EdgeFunction<V>> d3sAndF3s = summaryFunctions.summariesFor(n, d2, returnSiteN);Map<D,EdgeFunction<V>>d3sAndF3s=summaryFunctions.summariesFor(n,d2,returnSiteN); for (Map.Entry<D,EdgeFunction<V>> d3AndF3 : d3sAndF3s.entrySet()) {for(Map.Entry<D,EdgeFunction<V>>d3AndF3:d3sAndF3s.entrySet()){ D d3 = d3AndF3.getKey();Dd3=d3AndF3.getKey(); EdgeFunction<V> f3 = d3AndF3.getValue();EdgeFunction<V>f3=d3AndF3.getValue(); if(f3==null) f3 = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paperif(f3==null)f3=allTop;//SummaryFn initialized to all-top, see line [4] in SRH96 paper propagate(d1, returnSiteN, d3, f.composeWith(f3));propagate(d1,returnSiteN,d3,f.composeWith(f3)); }} }} }} private EdgeFunction<V> jumpFunction(PathEdge<N, D, M> edge) {privateEdgeFunction<V>jumpFunction(PathEdge<N,D,M>edge){ synchronized (jumpFn) {synchronized(jumpFn){ EdgeFunction<V> function = jumpFn.forwardLookup(edge.factAtSource(), edge.getTarget()).get(edge.factAtTarget());EdgeFunction<V>function=jumpFn.forwardLookup(edge.factAtSource(),edge.getTarget()).get(edge.factAtTarget()); if(function==null) return allTop; //JumpFn initialized to all-top, see line [2] in SRH96 paperif(function==null)returnallTop;//JumpFn initialized to all-top, see line [2] in SRH96 paper return function;returnfunction; }} }} /**/**	 * Lines 21-32 of the algorithm.		 * Lines 21-32 of the algorithm.		 */	 */ private void processExit(PathEdge<N,D,M> edge) {privatevoidprocessExit(PathEdge<N,D,M>edge){ final N n = edge.getTarget(); // an exit node; line 21...finalNn=edge.getTarget();// an exit node; line 21... EdgeFunction<V> f = jumpFunction(edge);EdgeFunction<V>f=jumpFunction(edge); M methodThatNeedsSummary = icfg.getMethodOf(n);MmethodThatNeedsSummary=icfg.getMethodOf(n);  final D d1 = edge.factAtSource();finalDd1=edge.factAtSource(); final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();  for(N sP: icfg.getStartPointsOf(methodThatNeedsSummary)) {for(NsP:icfg.getStartPointsOf(methodThatNeedsSummary)){ //line 21.1 of Naeem/Lhotak/Rodriguez//line 21.1 of Naeem/Lhotak/Rodriguez  Set<Entry<N, Set<D>>> inc;Set<Entry<N,Set<D>>>inc; synchronized (incoming) {synchronized(incoming){ addEndSummary(sP, d1, n, d2, f);addEndSummary(sP,d1,n,d2,f); //copy to avoid concurrent modification exceptions by other threads//copy to avoid concurrent modification exceptions by other threads inc = new HashSet<Map.Entry<N,Set<D>>>(incoming(d1, sP));inc=newHashSet<Map.Entry<N,Set<D>>>(incoming(d1,sP)); }}  for (Entry<N,Set<D>> entry: inc) {for(Entry<N,Set<D>>entry:inc){ //line 22//line 22 N c = entry.getKey();Nc=entry.getKey(); for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(c)){ FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(c,methodThatNeedsSummary,n,retSiteC); flowFunctionConstructionCount++;flowFunctionConstructionCount++; Set<D> targets = retFunction.computeTargets(d2);Set<D>targets=retFunction.computeTargets(d2); for(D d4: entry.getValue()) {for(Dd4:entry.getValue()){ //line 23//line 23 for(D d5: targets) {for(Dd5:targets){ EdgeFunction<V> f4 = edgeFunctions.getCallEdgeFunction(c, d4, icfg.getMethodOf(n), d1);EdgeFunction<V>f4=edgeFunctions.getCallEdgeFunction(c,d4,icfg.getMethodOf(n),d1); EdgeFunction<V> f5 = edgeFunctions.getReturnEdgeFunction(c, icfg.getMethodOf(n), n, d2, retSiteC, d5);EdgeFunction<V>f5=edgeFunctions.getReturnEdgeFunction(c,icfg.getMethodOf(n),n,d2,retSiteC,d5); EdgeFunction<V> fPrime;EdgeFunction<V>fPrime; synchronized (summaryFunctions) {synchronized(summaryFunctions){ EdgeFunction<V> summaryFunction = summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); EdgeFunction<V>summaryFunction=summaryFunctions.summariesFor(c,d4,retSiteC).get(d5); if(summaryFunction==null) summaryFunction = allTop; //SummaryFn initialized to all-top, see line [4] in SRH96 paperif(summaryFunction==null)summaryFunction=allTop;//SummaryFn initialized to all-top, see line [4] in SRH96 paper fPrime = f4.composeWith(f).composeWith(f5).joinWith(summaryFunction);fPrime=f4.composeWith(f).composeWith(f5).joinWith(summaryFunction); if(!fPrime.equalTo(summaryFunction)) {if(!fPrime.equalTo(summaryFunction)){ summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime);summaryFunctions.insertFunction(c,d4,retSiteC,d5,fPrime); }} }} for(Map.Entry<D,EdgeFunction<V>> valAndFunc: jumpFn.reverseLookup(c,d4).entrySet()) {for(Map.Entry<D,EdgeFunction<V>>valAndFunc:jumpFn.reverseLookup(c,d4).entrySet()){ EdgeFunction<V> f3 = valAndFunc.getValue();EdgeFunction<V>f3=valAndFunc.getValue(); if(!f3.equalTo(allTop)); {if(!f3.equalTo(allTop));{ D d3 = valAndFunc.getKey();Dd3=valAndFunc.getKey(); propagate(d3, retSiteC, d5, f3.composeWith(fPrime));propagate(d3,retSiteC,d5,f3.composeWith(fPrime)); }} }} }} }} }} }} }} }}  /**/**	 * Lines 33-37 of the algorithm.	 * Lines 33-37 of the algorithm.	 * @param edge	 * @param edge	 */	 */ private void processNormalFlow(PathEdge<N,D,M> edge) {privatevoidprocessNormalFlow(PathEdge<N,D,M>edge){ final D d1 = edge.factAtSource();finalDd1=edge.factAtSource(); final N n = edge.getTarget(); finalNn=edge.getTarget(); final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget(); EdgeFunction<V> f = jumpFunction(edge);EdgeFunction<V>f=jumpFunction(edge); for (N m : icfg.getSuccsOf(n)) {for(Nm:icfg.getSuccsOf(n)){ FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);FlowFunction<D>flowFunction=flowFunctions.getNormalFlowFunction(n,m); flowFunctionConstructionCount++;flowFunctionConstructionCount++; Set<D> res = flowFunction.computeTargets(d2);Set<D>res=flowFunction.computeTargets(d2); for (D d3 : res) {for(Dd3:res){ EdgeFunction<V> fprime = f.composeWith(edgeFunctions.getNormalEdgeFunction(n, d2, m, d3));EdgeFunction<V>fprime=f.composeWith(edgeFunctions.getNormalEdgeFunction(n,d2,m,d3)); propagate(d1, m, d3, fprime); propagate(d1,m,d3,fprime); }} }} }}  private void propagate(D sourceVal, N target, D targetVal, EdgeFunction<V> f) {privatevoidpropagate(DsourceVal,Ntarget,DtargetVal,EdgeFunction<V>f){ EdgeFunction<V> jumpFnE;EdgeFunction<V>jumpFnE; synchronized (jumpFn) {synchronized(jumpFn){ jumpFnE = jumpFn.reverseLookup(target, targetVal).get(sourceVal);jumpFnE=jumpFn.reverseLookup(target,targetVal).get(sourceVal); }} if(jumpFnE==null) jumpFnE = allTop; //JumpFn is initialized to all-top (see line [2] in SRH96 paper)if(jumpFnE==null)jumpFnE=allTop;//JumpFn is initialized to all-top (see line [2] in SRH96 paper) EdgeFunction<V> fPrime = jumpFnE.joinWith(f);EdgeFunction<V>fPrime=jumpFnE.joinWith(f); if(!fPrime.equalTo(jumpFnE)) {if(!fPrime.equalTo(jumpFnE)){ synchronized (jumpFn) {synchronized(jumpFn){ jumpFn.addFunction(sourceVal, target, targetVal, fPrime);jumpFn.addFunction(sourceVal,target,targetVal,fPrime); }}  PathEdge<N,D,M> edge = new PathEdge<N,D,M>(sourceVal, target, targetVal);PathEdge<N,D,M>edge=newPathEdge<N,D,M>(sourceVal,target,targetVal); synchronized (pathWorklist) {synchronized(pathWorklist){ pathWorklist.add(edge);pathWorklist.add(edge); }} if(DEBUG) {if(DEBUG){ if(targetVal!=zeroValue) { if(targetVal!=zeroValue){ StringBuilder result = new StringBuilder();StringBuilderresult=newStringBuilder(); result.append("EDGE:  <");result.append("EDGE:  <"); result.append(icfg.getMethodOf(target));result.append(icfg.getMethodOf(target)); result.append(",");result.append(","); result.append(sourceVal);result.append(sourceVal); result.append("> -> <");result.append("> -> <"); result.append(target);result.append(target); result.append(",");result.append(","); result.append(targetVal);result.append(targetVal); result.append("> - ");result.append("> - "); result.append(fPrime);result.append(fPrime); System.err.println(result.toString());System.err.println(result.toString()); }} }} }} }}  private Set<Cell<N, D, EdgeFunction<V>>> endSummary(N sP, D d3) {privateSet<Cell<N,D,EdgeFunction<V>>>endSummary(NsP,Dd3){ Table<N, D, EdgeFunction<V>> map = endSummary.get(sP, d3);Table<N,D,EdgeFunction<V>>map=endSummary.get(sP,d3); if(map==null) return Collections.emptySet();if(map==null)returnCollections.emptySet(); return map.cellSet();returnmap.cellSet(); }} private void addEndSummary(N sP, D d1, N eP, D d2, EdgeFunction<V> f) {privatevoidaddEndSummary(NsP,Dd1,NeP,Dd2,EdgeFunction<V>f){ Table<N, D, EdgeFunction<V>> summaries = endSummary.get(sP, d1);Table<N,D,EdgeFunction<V>>summaries=endSummary.get(sP,d1); if(summaries==null) {if(summaries==null){ summaries = HashBasedTable.create();summaries=HashBasedTable.create(); endSummary.put(sP, d1, summaries);endSummary.put(sP,d1,summaries); }} summaries.put(eP,d2,f);summaries.put(eP,d2,f); } }  private Set<Entry<N, Set<D>>> incoming(D d1, N sP) {privateSet<Entry<N,Set<D>>>incoming(Dd1,NsP){ Map<N, Set<D>> map = incoming.get(sP, d1);Map<N,Set<D>>map=incoming.get(sP,d1); if(map==null) return Collections.emptySet();if(map==null)returnCollections.emptySet(); return map.entrySet(); returnmap.entrySet(); }}  private void addIncoming(N sP, D d3, N n, D d2) {privatevoidaddIncoming(NsP,Dd3,Nn,Dd2){ Map<N, Set<D>> summaries = incoming.get(sP, d3);Map<N,Set<D>>summaries=incoming.get(sP,d3); if(summaries==null) {if(summaries==null){ summaries = new HashMap<N, Set<D>>();summaries=newHashMap<N,Set<D>>(); incoming.put(sP, d3, summaries);incoming.put(sP,d3,summaries); }} Set<D> set = summaries.get(n);Set<D>set=summaries.get(n); if(set==null) {if(set==null){ set = new HashSet<D>();set=newHashSet<D>(); summaries.put(n,set);summaries.put(n,set); }} set.add(d2);set.add(d2); } }  /**/**	 * Returns the V-type result for the given value at the given statement. 	 * Returns the V-type result for the given value at the given statement. 	 */	 */ public V resultAt(N stmt, D value) {publicVresultAt(Nstmt,Dvalue){ return val.get(stmt, value);returnval.get(stmt,value); }}  /**/**	 * Returns the resulting environment for the given statement.	 * Returns the resulting environment for the given statement.	 * The artificial zero value is automatically stripped.	 * The artificial zero value is automatically stripped.	 */	 */ public Map<D,V> resultsAt(N stmt) {publicMap<D,V>resultsAt(Nstmt){ //filter out the artificial zero-value//filter out the artificial zero-value return Maps.filterKeys(val.row(stmt), new Predicate<D>() {returnMaps.filterKeys(val.row(stmt),newPredicate<D>(){ public boolean apply(D val) {publicbooleanapply(Dval){ return val!=zeroValue;returnval!=zeroValue; }} });}); }} public void dumpResults() {publicvoiddumpResults(){ try {try{ PrintWriter out = new PrintWriter(new FileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv"));PrintWriterout=newPrintWriter(newFileOutputStream("ideSolverDump"+System.currentTimeMillis()+".csv")); List<String> res = new ArrayList<String>();List<String>res=newArrayList<String>(); for(Cell<N, D, V> entry: val.cellSet()) {for(Cell<N,D,V>entry:val.cellSet()){ SootMethod methodOf = (SootMethod) icfg.getMethodOf(entry.getRowKey());SootMethodmethodOf=(SootMethod)icfg.getMethodOf(entry.getRowKey()); PatchingChain<Unit> units = methodOf.getActiveBody().getUnits();PatchingChain<Unit>units=methodOf.getActiveBody().getUnits(); int i=0;inti=0; for (Unit unit : units) {for(Unitunit:units){ if(unit==entry.getRowKey())if(unit==entry.getRowKey()) break;break; i++;i++; }}  res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue());res.add(methodOf+";"+entry.getRowKey()+"@"+i+";"+entry.getColumnKey()+";"+entry.getValue()); }} Collections.sort(res);Collections.sort(res); for (String string : res) {for(Stringstring:res){ out.println(string);out.println(string); }} out.flush();out.flush(); out.close();out.close(); } catch (FileNotFoundException e) {}catch(FileNotFoundExceptione){ e.printStackTrace();e.printStackTrace(); }} }} public void printStats() {publicvoidprintStats(){ if(DEBUG) {if(DEBUG){ if(ffCache!=null)if(ffCache!=null) ffCache.printStats();ffCache.printStats(); if(efCache!=null)if(efCache!=null) efCache.printStats();efCache.printStats(); } else {}else{ System.err.println("No statistics were collected, as DEBUG is disabled.");System.err.println("No statistics were collected, as DEBUG is disabled."); }} }}  private class PathEdgeProcessingTask implements Runnable {privateclassPathEdgeProcessingTaskimplementsRunnable{ private final PathEdge<N, D, M> edge;privatefinalPathEdge<N,D,M>edge; public PathEdgeProcessingTask(PathEdge<N, D, M> edge) {publicPathEdgeProcessingTask(PathEdge<N,D,M>edge){ this.edge = edge;this.edge=edge; }} public void run() {publicvoidrun(){ if(icfg.isCallStmt(edge.getTarget())) {if(icfg.isCallStmt(edge.getTarget())){ processCall(edge);processCall(edge); } else {}else{ //note that some statements, such as "throw" may be//note that some statements, such as "throw" may be //both an exit statement and a "normal" statement//both an exit statement and a "normal" statement if(icfg.isExitStmt(edge.getTarget())) {if(icfg.isExitStmt(edge.getTarget())){ processExit(edge);processExit(edge); }} if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()){ processNormalFlow(edge);processNormalFlow(edge); }} }} synchronized (pathWorklist) {synchronized(pathWorklist){ numTasks.getAndDecrement();numTasks.getAndDecrement(); //potentially wake up waiting broker thread//potentially wake up waiting broker thread //(see forwardComputeJumpFunctionsSLRPs())//(see forwardComputeJumpFunctionsSLRPs()) pathWorklist.notify();pathWorklist.notify(); }} }} }}  private class ValuePropagationTask implements Runnable {privateclassValuePropagationTaskimplementsRunnable{ private final Pair<N, D> nAndD;privatefinalPair<N,D>nAndD; public ValuePropagationTask(Pair<N,D> nAndD) {publicValuePropagationTask(Pair<N,D>nAndD){ this.nAndD = nAndD;this.nAndD=nAndD; }} public void run() {publicvoidrun(){ N n = nAndD.getO1();Nn=nAndD.getO1(); if(icfg.isStartPoint(n)) {if(icfg.isStartPoint(n)){ propagateValueAtStart(nAndD, n);propagateValueAtStart(nAndD,n); }} if(icfg.isCallStmt(n)) {if(icfg.isCallStmt(n)){ propagateValueAtCall(nAndD, n);propagateValueAtCall(nAndD,n); }} synchronized (nodeWorklist) {synchronized(nodeWorklist){ numTasks.getAndDecrement();numTasks.getAndDecrement(); //potentially wake up waiting broker thread//potentially wake up waiting broker thread //(see forwardComputeJumpFunctionsSLRPs())//(see forwardComputeJumpFunctionsSLRPs()) nodeWorklist.notify();nodeWorklist.notify(); }} }} }}  private class ValueComputationTask implements Runnable {privateclassValueComputationTaskimplementsRunnable{ private final N[] values;privatefinalN[]values; final int num;finalintnum; public ValueComputationTask(N[] values, int num) {publicValueComputationTask(N[]values,intnum){ this.values = values;this.values=values; this.num = num;this.num=num; }} public void run() {publicvoidrun(){ int sectionSize = (int) Math.floor(values.length / numThreads) + numThreads;intsectionSize=(int)Math.floor(values.length/numThreads)+numThreads; for(int i = sectionSize * num; i < Math.min(sectionSize * (num+1),values.length); i++) {for(inti=sectionSize*num;i<Math.min(sectionSize*(num+1),values.length);i++){ N n = values[i];Nn=values[i]; for(N sP: icfg.getStartPointsOf(icfg.getMethodOf(n))) { for(NsP:icfg.getStartPointsOf(icfg.getMethodOf(n))){ Set<Cell<D, D, EdgeFunction<V>>> lookupByTarget;Set<Cell<D,D,EdgeFunction<V>>>lookupByTarget; lookupByTarget = jumpFn.lookupByTarget(n);lookupByTarget=jumpFn.lookupByTarget(n); for(Cell<D, D, EdgeFunction<V>> sourceValTargetValAndFunction : lookupByTarget) {for(Cell<D,D,EdgeFunction<V>>sourceValTargetValAndFunction:lookupByTarget){ D dPrime = sourceValTargetValAndFunction.getRowKey();DdPrime=sourceValTargetValAndFunction.getRowKey(); D d = sourceValTargetValAndFunction.getColumnKey();Dd=sourceValTargetValAndFunction.getColumnKey(); EdgeFunction<V> fPrime = sourceValTargetValAndFunction.getValue();EdgeFunction<V>fPrime=sourceValTargetValAndFunction.getValue(); synchronized (val) {synchronized(val){ setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime))));setVal(n,d,valueLattice.join(val(n,d),fPrime.computeTarget(val(sP,dPrime)))); }} flowFunctionApplicationCount++;flowFunctionApplicationCount++; }} }} }} }} }}}}








src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}












src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/IFDSSolver.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}













package soot.jimple.interproc.ifds.solver;





















import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;










import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;





















import java.util.Set;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.FlowFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.IFDSTabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;










import soot.jimple.interproc.ifds.edgefunc.AllBottom;










import soot.jimple.interproc.ifds.edgefunc.AllTop;










import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;





















/**










 * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver}










 * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem.










 * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE










 * problem in which the environments (D to N mappings) represent the set's characteristic function.










 * 










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 * @see IFDSTabulationProblem










 */










public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {





















 static enum BinaryDomain { TOP,BOTTOM } 










 










 private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);










 










 /**










	 * Creates a solver for the given problem. The solver must then be started by calling










	 * {@link #solve()}.










	 */










 public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {










 super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {





















 public FlowFunctions<N,D,M> flowFunctions() {










 return ifdsProblem.flowFunctions();










 }





















 public I interproceduralCFG() {










 return ifdsProblem.interproceduralCFG();










 }





















 public Set<N> initialSeeds() {










 return ifdsProblem.initialSeeds();










 }





















 public D zeroValue() {










 return ifdsProblem.zeroValue();










 }





















 public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {










 return new IFDSEdgeFunctions();










 }





















 public JoinLattice<BinaryDomain> joinLattice() {










 return new JoinLattice<BinaryDomain>() {





















 public BinaryDomain topElement() {










 return BinaryDomain.TOP;










 }





















 public BinaryDomain bottomElement() {










 return BinaryDomain.BOTTOM;










 }





















 public BinaryDomain join(BinaryDomain left, BinaryDomain right) {










 if(left==TOP && right==TOP) {










 return TOP;










 } else {










 return BOTTOM;










 }










 }










 };










 }





















 @Override










 public EdgeFunction<BinaryDomain> allTopFunction() {










 return new AllTop<BinaryDomain>(TOP);










 }










 










 class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {










 










 public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {










 if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {










 if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 










 public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {










 if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;










 return EdgeIdentity.v(); 










 }










 }





















 });










 }










 










 /**










	 * Returns the set of facts that hold at the given statement.










	 */










 public Set<D> ifdsResultsAt(N statement) {










 return resultsAt(statement).keySet();










 }





















}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;importstaticsoot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.BOTTOM;import static soot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;importstaticsoot.jimple.interproc.ifds.solver.IFDSSolver.BinaryDomain.TOP;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.EdgeFunctions;importsoot.jimple.interproc.ifds.EdgeFunctions;import soot.jimple.interproc.ifds.FlowFunctions;importsoot.jimple.interproc.ifds.FlowFunctions;import soot.jimple.interproc.ifds.IDETabulationProblem;importsoot.jimple.interproc.ifds.IDETabulationProblem;import soot.jimple.interproc.ifds.IFDSTabulationProblem;importsoot.jimple.interproc.ifds.IFDSTabulationProblem;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.JoinLattice;importsoot.jimple.interproc.ifds.JoinLattice;import soot.jimple.interproc.ifds.edgefunc.AllBottom;importsoot.jimple.interproc.ifds.edgefunc.AllBottom;import soot.jimple.interproc.ifds.edgefunc.AllTop;importsoot.jimple.interproc.ifds.edgefunc.AllTop;import soot.jimple.interproc.ifds.edgefunc.EdgeIdentity;importsoot.jimple.interproc.ifds.edgefunc.EdgeIdentity;/**/** * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver} * A solver for an {@link IFDSTabulationProblem}. This solver in effect uses the {@link IDESolver} * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem. * to solve the problem, as any IFDS problem can be intepreted as a special case of an IDE problem. * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE * See Section 5.4.1 of the SRH96 paper. In effect, the IFDS problem is solved by solving an IDE * problem in which the environments (D to N mappings) represent the set's characteristic function. * problem in which the environments (D to N mappings) represent the set's characteristic function. *  *  * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. * @see IFDSTabulationProblem * @see IFDSTabulationProblem */ */public class IFDSSolver<N,D,M,I extends InterproceduralCFG<N, M>> extends IDESolver<N,D,M,IFDSSolver.BinaryDomain,I> {publicclassIFDSSolver<N,D,M,IextendsInterproceduralCFG<N,M>>extendsIDESolver<N,D,M,IFDSSolver.BinaryDomain,I>{ static enum BinaryDomain { TOP,BOTTOM } staticenumBinaryDomain{TOP,BOTTOM}  private final static EdgeFunction<BinaryDomain> ALL_BOTTOM = new AllBottom<BinaryDomain>(BOTTOM);privatefinalstaticEdgeFunction<BinaryDomain>ALL_BOTTOM=newAllBottom<BinaryDomain>(BOTTOM);  /**/**	 * Creates a solver for the given problem. The solver must then be started by calling	 * Creates a solver for the given problem. The solver must then be started by calling	 * {@link #solve()}.	 * {@link #solve()}.	 */	 */ public IFDSSolver(final IFDSTabulationProblem<N,D,M,I> ifdsProblem) {publicIFDSSolver(finalIFDSTabulationProblem<N,D,M,I>ifdsProblem){ super(new IDETabulationProblem<N,D,M,BinaryDomain,I>() {super(newIDETabulationProblem<N,D,M,BinaryDomain,I>(){ public FlowFunctions<N,D,M> flowFunctions() {publicFlowFunctions<N,D,M>flowFunctions(){ return ifdsProblem.flowFunctions();returnifdsProblem.flowFunctions(); }} public I interproceduralCFG() {publicIinterproceduralCFG(){ return ifdsProblem.interproceduralCFG();returnifdsProblem.interproceduralCFG(); }} public Set<N> initialSeeds() {publicSet<N>initialSeeds(){ return ifdsProblem.initialSeeds();returnifdsProblem.initialSeeds(); }} public D zeroValue() {publicDzeroValue(){ return ifdsProblem.zeroValue();returnifdsProblem.zeroValue(); }} public EdgeFunctions<N,D,M,BinaryDomain> edgeFunctions() {publicEdgeFunctions<N,D,M,BinaryDomain>edgeFunctions(){ return new IFDSEdgeFunctions();returnnewIFDSEdgeFunctions(); }} public JoinLattice<BinaryDomain> joinLattice() {publicJoinLattice<BinaryDomain>joinLattice(){ return new JoinLattice<BinaryDomain>() {returnnewJoinLattice<BinaryDomain>(){ public BinaryDomain topElement() {publicBinaryDomaintopElement(){ return BinaryDomain.TOP;returnBinaryDomain.TOP; }} public BinaryDomain bottomElement() {publicBinaryDomainbottomElement(){ return BinaryDomain.BOTTOM;returnBinaryDomain.BOTTOM; }} public BinaryDomain join(BinaryDomain left, BinaryDomain right) {publicBinaryDomainjoin(BinaryDomainleft,BinaryDomainright){ if(left==TOP && right==TOP) {if(left==TOP&&right==TOP){ return TOP;returnTOP; } else {}else{ return BOTTOM;returnBOTTOM; }} }} };}; }} @Override@Override public EdgeFunction<BinaryDomain> allTopFunction() {publicEdgeFunction<BinaryDomain>allTopFunction(){ return new AllTop<BinaryDomain>(TOP);returnnewAllTop<BinaryDomain>(TOP); }}  class IFDSEdgeFunctions implements EdgeFunctions<N,D,M,BinaryDomain> {classIFDSEdgeFunctionsimplementsEdgeFunctions<N,D,M,BinaryDomain>{  public EdgeFunction<BinaryDomain> getNormalEdgeFunction(N src,D srcNode,N tgt,D tgtNode) {publicEdgeFunction<BinaryDomain>getNormalEdgeFunction(Nsrc,DsrcNode,Ntgt,DtgtNode){ if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(srcNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }}  public EdgeFunction<BinaryDomain> getCallEdgeFunction(N callStmt,D srcNode,M destinationMethod,D destNode) {publicEdgeFunction<BinaryDomain>getCallEdgeFunction(NcallStmt,DsrcNode,MdestinationMethod,DdestNode){ if(srcNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(srcNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }}  public EdgeFunction<BinaryDomain> getReturnEdgeFunction(N callSite, M calleeMethod,N exitStmt,D exitNode,N returnSite,D retNode) {publicEdgeFunction<BinaryDomain>getReturnEdgeFunction(NcallSite,McalleeMethod,NexitStmt,DexitNode,NreturnSite,DretNode){ if(exitNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(exitNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }}  public EdgeFunction<BinaryDomain> getCallToReturnEdgeFunction(N callStmt,D callNode,N returnSite,D returnSideNode) {publicEdgeFunction<BinaryDomain>getCallToReturnEdgeFunction(NcallStmt,DcallNode,NreturnSite,DreturnSideNode){ if(callNode==ifdsProblem.zeroValue()) return ALL_BOTTOM;if(callNode==ifdsProblem.zeroValue())returnALL_BOTTOM; return EdgeIdentity.v(); returnEdgeIdentity.v(); }} }} });}); }}  /**/**	 * Returns the set of facts that hold at the given statement.	 * Returns the set of facts that hold at the given statement.	 */	 */ public Set<D> ifdsResultsAt(N statement) {publicSet<D>ifdsResultsAt(Nstatement){ return resultsAt(statement).keySet();returnresultsAt(statement).keySet(); }}}}








src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}












src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/JumpFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.HashMap;










import java.util.LinkedHashMap;










import java.util.Map;










import java.util.Set;





















import soot.jimple.interproc.ifds.DontSynchronize;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;










import com.google.common.collect.Table.Cell;





















/**










 * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three










 * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses










 * elements from the list through three different indices.










 */










@ThreadSafe










public class JumpFunctions<N,D,L> {










 










 //mapping from target node and value to a list of all source values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();










 










 //mapping from source value and target node to a list of all target values and associated functions










 //where the list is implemented as a mapping from the source value to the function










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();





















 //a mapping from target node to a list of triples consisting of source value,










 //target value and associated function; the triple is implemented by a table










 //we exclude empty default functions 










 @SynchronizedBy("consistent lock on this")










 protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();





















 @DontSynchronize("immutable") 










 private final EdgeFunction<L> allTop;










 










 public JumpFunctions(EdgeFunction<L> allTop) {










 this.allTop = allTop;










 }





















 /**










	 * Records a jump function. The source statement is implicit.










	 * @see PathEdge










	 */










 public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {










 assert sourceVal!=null;










 assert target!=null;










 assert targetVal!=null;










 assert function!=null;










 










 //we do not store the default function (all-top)










 if(function.equalTo(allTop)) return;










 










 Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);










 if(sourceValToFunc==null) {










 sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);










 }










 sourceValToFunc.put(sourceVal, function);










 










 Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);










 if(targetValToFunc==null) {










 targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();










 nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);










 }










 targetValToFunc.put(targetVal, function);





















 Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) {










 table = HashBasedTable.create();










 nonEmptyLookupByTargetNode.put(target,table);










 }










 table.put(sourceVal, targetVal, function);










 }










 










 /**










     * Returns, for a given target statement and value all associated










     * source values, and for each the associated edge function.










     * The return value is a mapping from source value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {










 assert target!=null;










 assert targetVal!=null;










 Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns, for a given source value and target statement all










	 * associated target values, and for each the associated edge function. 










     * The return value is a mapping from target value to function.










	 */










 public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {










 assert sourceVal!=null;










 assert target!=null;










 Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);










 if(res==null) return Collections.emptyMap();










 return res;










 }










 










 /**










	 * Returns for a given target statement all jump function records with this target.










	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).










	 */










 public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {










 assert target!=null;










 Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);










 if(table==null) return Collections.emptySet();










 Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();










 if(res==null) return Collections.emptySet();










 return res;










 }










 










}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import java.util.Collections;importjava.util.Collections;import java.util.HashMap;importjava.util.HashMap;import java.util.LinkedHashMap;importjava.util.LinkedHashMap;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.DontSynchronize;importsoot.jimple.interproc.ifds.DontSynchronize;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.SynchronizedBy;importsoot.jimple.interproc.ifds.SynchronizedBy;import soot.jimple.interproc.ifds.ThreadSafe;importsoot.jimple.interproc.ifds.ThreadSafe;import com.google.common.collect.HashBasedTable;importcom.google.common.collect.HashBasedTable;import com.google.common.collect.Table;importcom.google.common.collect.Table;import com.google.common.collect.Table.Cell;importcom.google.common.collect.Table.Cell;/**/** * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three * The IDE algorithm uses a list of jump functions. Instead of a list, we use a set of three * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses * maps that are kept in sync. This allows for efficient indexing: the algorithm accesses * elements from the list through three different indices. * elements from the list through three different indices. */ */@ThreadSafe@ThreadSafepublic class JumpFunctions<N,D,L> {publicclassJumpFunctions<N,D,L>{  //mapping from target node and value to a list of all source values and associated functions//mapping from target node and value to a list of all source values and associated functions //where the list is implemented as a mapping from the source value to the function//where the list is implemented as a mapping from the source value to the function //we exclude empty default functions//we exclude empty default functions @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Table<N,D,Map<D,EdgeFunction<L>>> nonEmptyReverseLookup = HashBasedTable.create();protectedTable<N,D,Map<D,EdgeFunction<L>>>nonEmptyReverseLookup=HashBasedTable.create();  //mapping from source value and target node to a list of all target values and associated functions//mapping from source value and target node to a list of all target values and associated functions //where the list is implemented as a mapping from the source value to the function//where the list is implemented as a mapping from the source value to the function //we exclude empty default functions //we exclude empty default functions  @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Table<D,N,Map<D,EdgeFunction<L>>> nonEmptyForwardLookup = HashBasedTable.create();protectedTable<D,N,Map<D,EdgeFunction<L>>>nonEmptyForwardLookup=HashBasedTable.create(); //a mapping from target node to a list of triples consisting of source value,//a mapping from target node to a list of triples consisting of source value, //target value and associated function; the triple is implemented by a table//target value and associated function; the triple is implemented by a table //we exclude empty default functions //we exclude empty default functions  @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Map<N,Table<D,D,EdgeFunction<L>>> nonEmptyLookupByTargetNode = new HashMap<N,Table<D,D,EdgeFunction<L>>>();protectedMap<N,Table<D,D,EdgeFunction<L>>>nonEmptyLookupByTargetNode=newHashMap<N,Table<D,D,EdgeFunction<L>>>(); @DontSynchronize("immutable") @DontSynchronize("immutable") private final EdgeFunction<L> allTop;privatefinalEdgeFunction<L>allTop;  public JumpFunctions(EdgeFunction<L> allTop) {publicJumpFunctions(EdgeFunction<L>allTop){ this.allTop = allTop;this.allTop=allTop; }} /**/**	 * Records a jump function. The source statement is implicit.	 * Records a jump function. The source statement is implicit.	 * @see PathEdge	 * @see PathEdge	 */	 */ public synchronized void addFunction(D sourceVal, N target, D targetVal, EdgeFunction<L> function) {publicsynchronizedvoidaddFunction(DsourceVal,Ntarget,DtargetVal,EdgeFunction<L>function){ assert sourceVal!=null;assertsourceVal!=null; assert target!=null;asserttarget!=null; assert targetVal!=null;asserttargetVal!=null; assert function!=null;assertfunction!=null;  //we do not store the default function (all-top)//we do not store the default function (all-top) if(function.equalTo(allTop)) return;if(function.equalTo(allTop))return;  Map<D,EdgeFunction<L>> sourceValToFunc = nonEmptyReverseLookup.get(target, targetVal);Map<D,EdgeFunction<L>>sourceValToFunc=nonEmptyReverseLookup.get(target,targetVal); if(sourceValToFunc==null) {if(sourceValToFunc==null){ sourceValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();sourceValToFunc=newLinkedHashMap<D,EdgeFunction<L>>(); nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc);nonEmptyReverseLookup.put(target,targetVal,sourceValToFunc); }} sourceValToFunc.put(sourceVal, function);sourceValToFunc.put(sourceVal,function);  Map<D, EdgeFunction<L>> targetValToFunc = nonEmptyForwardLookup.get(sourceVal, target);Map<D,EdgeFunction<L>>targetValToFunc=nonEmptyForwardLookup.get(sourceVal,target); if(targetValToFunc==null) {if(targetValToFunc==null){ targetValToFunc = new LinkedHashMap<D,EdgeFunction<L>>();targetValToFunc=newLinkedHashMap<D,EdgeFunction<L>>(); nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc);nonEmptyForwardLookup.put(sourceVal,target,targetValToFunc); }} targetValToFunc.put(targetVal, function);targetValToFunc.put(targetVal,function); Table<D,D,EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);Table<D,D,EdgeFunction<L>>table=nonEmptyLookupByTargetNode.get(target); if(table==null) {if(table==null){ table = HashBasedTable.create();table=HashBasedTable.create(); nonEmptyLookupByTargetNode.put(target,table);nonEmptyLookupByTargetNode.put(target,table); }} table.put(sourceVal, targetVal, function);table.put(sourceVal,targetVal,function); }}  /**/**     * Returns, for a given target statement and value all associated     * Returns, for a given target statement and value all associated     * source values, and for each the associated edge function.     * source values, and for each the associated edge function.     * The return value is a mapping from source value to function.     * The return value is a mapping from source value to function.	 */	 */ public synchronized Map<D,EdgeFunction<L>> reverseLookup(N target, D targetVal) {publicsynchronizedMap<D,EdgeFunction<L>>reverseLookup(Ntarget,DtargetVal){ assert target!=null;asserttarget!=null; assert targetVal!=null;asserttargetVal!=null; Map<D,EdgeFunction<L>> res = nonEmptyReverseLookup.get(target,targetVal);Map<D,EdgeFunction<L>>res=nonEmptyReverseLookup.get(target,targetVal); if(res==null) return Collections.emptyMap();if(res==null)returnCollections.emptyMap(); return res;returnres; }}  /**/**	 * Returns, for a given source value and target statement all	 * Returns, for a given source value and target statement all	 * associated target values, and for each the associated edge function. 	 * associated target values, and for each the associated edge function.      * The return value is a mapping from target value to function.     * The return value is a mapping from target value to function.	 */	 */ public synchronized Map<D,EdgeFunction<L>> forwardLookup(D sourceVal, N target) {publicsynchronizedMap<D,EdgeFunction<L>>forwardLookup(DsourceVal,Ntarget){ assert sourceVal!=null;assertsourceVal!=null; assert target!=null;asserttarget!=null; Map<D, EdgeFunction<L>> res = nonEmptyForwardLookup.get(sourceVal, target);Map<D,EdgeFunction<L>>res=nonEmptyForwardLookup.get(sourceVal,target); if(res==null) return Collections.emptyMap();if(res==null)returnCollections.emptyMap(); return res;returnres; }}  /**/**	 * Returns for a given target statement all jump function records with this target.	 * Returns for a given target statement all jump function records with this target.	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).	 * The return value is a set of records of the form (sourceVal,targetVal,edgeFunction).	 */	 */ public synchronized Set<Cell<D,D,EdgeFunction<L>>> lookupByTarget(N target) {publicsynchronizedSet<Cell<D,D,EdgeFunction<L>>>lookupByTarget(Ntarget){ assert target!=null;asserttarget!=null; Table<D, D, EdgeFunction<L>> table = nonEmptyLookupByTargetNode.get(target);Table<D,D,EdgeFunction<L>>table=nonEmptyLookupByTargetNode.get(target); if(table==null) return Collections.emptySet();if(table==null)returnCollections.emptySet(); Set<Cell<D, D, EdgeFunction<L>>> res = table.cellSet();Set<Cell<D,D,EdgeFunction<L>>>res=table.cellSet(); if(res==null) return Collections.emptySet();if(res==null)returnCollections.emptySet(); return res;returnres; }} }}








src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}












src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/PathEdge.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}













package soot.jimple.interproc.ifds.solver;





















import soot.jimple.interproc.ifds.InterproceduralCFG;





















/**










 * A path edge as described in the IFDS/IDE algorithms.










 * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}.










 * Hence, we don't store it.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 */










public class PathEdge<N,D,M> {





















 protected final N target;










 protected final D dSource, dTarget;





















 /**










	 * @param dSource The fact at the source.










	 * @param target The target statement.










	 * @param dTarget The fact at the target.










	 */










 public PathEdge(D dSource, N target, D dTarget) {










 super();










 this.target = target;










 this.dSource = dSource;










 this.dTarget = dTarget;










 }










 










 public N getTarget() {










 return target;










 }





















 public D factAtSource() {










 return dSource;










 }





















 public D factAtTarget() {










 return dTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());










 result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("rawtypes")










 PathEdge other = (PathEdge) obj;










 if (dSource == null) {










 if (other.dSource != null)










 return false;










 } else if (!dSource.equals(other.dSource))










 return false;










 if (dTarget == null) {










 if (other.dTarget != null)










 return false;










 } else if (!dTarget.equals(other.dTarget))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 StringBuffer result = new StringBuffer();










 result.append("<");










 result.append(dSource);










 result.append("> -> <");










 result.append(target.toString());










 result.append(",");










 result.append(dTarget);










 result.append(">");










 return result.toString();










 }





















}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;/**/** * A path edge as described in the IFDS/IDE algorithms. * A path edge as described in the IFDS/IDE algorithms. * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}. * The source node is implicit: it can be computed from the target by using the {@link InterproceduralCFG}. * Hence, we don't store it. * Hence, we don't store it. * * * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. */ */public class PathEdge<N,D,M> {publicclassPathEdge<N,D,M>{ protected final N target;protectedfinalNtarget; protected final D dSource, dTarget;protectedfinalDdSource,dTarget; /**/**	 * @param dSource The fact at the source.	 * @param dSource The fact at the source.	 * @param target The target statement.	 * @param target The target statement.	 * @param dTarget The fact at the target.	 * @param dTarget The fact at the target.	 */	 */ public PathEdge(D dSource, N target, D dTarget) {publicPathEdge(DdSource,Ntarget,DdTarget){ super();super(); this.target = target;this.target=target; this.dSource = dSource;this.dSource=dSource; this.dTarget = dTarget;this.dTarget=dTarget; }}  public N getTarget() {publicNgetTarget(){ return target;returntarget; }} public D factAtSource() {publicDfactAtSource(){ return dSource;returndSource; }} public D factAtTarget() {publicDfactAtTarget(){ return dTarget;returndTarget; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((dSource == null) ? 0 : dSource.hashCode());result=prime*result+((dSource==null)?0:dSource.hashCode()); result = prime * result + ((dTarget == null) ? 0 : dTarget.hashCode());result=prime*result+((dTarget==null)?0:dTarget.hashCode()); result = prime * result + ((target == null) ? 0 : target.hashCode());result=prime*result+((target==null)?0:target.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("rawtypes")@SuppressWarnings("rawtypes") PathEdge other = (PathEdge) obj;PathEdgeother=(PathEdge)obj; if (dSource == null) {if(dSource==null){ if (other.dSource != null)if(other.dSource!=null) return false;returnfalse; } else if (!dSource.equals(other.dSource))}elseif(!dSource.equals(other.dSource)) return false;returnfalse; if (dTarget == null) {if(dTarget==null){ if (other.dTarget != null)if(other.dTarget!=null) return false;returnfalse; } else if (!dTarget.equals(other.dTarget))}elseif(!dTarget.equals(other.dTarget)) return false;returnfalse; if (target == null) {if(target==null){ if (other.target != null)if(other.target!=null) return false;returnfalse; } else if (!target.equals(other.target))}elseif(!target.equals(other.target)) return false;returnfalse; return true;returntrue; }} @Override@Override public String toString() {publicStringtoString(){ StringBuffer result = new StringBuffer();StringBufferresult=newStringBuffer(); result.append("<");result.append("<"); result.append(dSource);result.append(dSource); result.append("> -> <");result.append("> -> <"); result.append(target.toString());result.append(target.toString()); result.append(",");result.append(","); result.append(dTarget);result.append(dTarget); result.append(">");result.append(">"); return result.toString();returnresult.toString(); }}}}








src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}












src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/solver/SummaryFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}













package soot.jimple.interproc.ifds.solver;





















import java.util.Collections;










import java.util.Map;





















import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.SynchronizedBy;










import soot.jimple.interproc.ifds.ThreadSafe;





















import com.google.common.collect.HashBasedTable;










import com.google.common.collect.Table;





















/**










 * A data structure to record summary functions in an indexed fashion, for fast retrieval.










 */










@ThreadSafe










public class SummaryFunctions<N,D,V> {










 










 @SynchronizedBy("consistent lock on this")










 protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();










 










 /**










	 * Inserts a summary function.










	 * @param callSite The call site with which this function is associated.










	 * @param sourceVal The source value at the call site. 










	 * @param retSite The return site (in the caller) with which this function is associated.










	 * @param targetVal The target value at the return site.










	 * @param function The edge function used to compute V-type values from the source node to the target node.  










	 */










 public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert retSite!=null;










 assert targetVal!=null;










 assert function!=null;










 










 Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);










 if(targetAndTargetValToFunction==null) {










 targetAndTargetValToFunction = HashBasedTable.create();










 table.put(callSite,sourceVal,targetAndTargetValToFunction);










 }










 targetAndTargetValToFunction.put(retSite, targetVal, function);










 }





















 /**










	 * Retrieves all summary functions for a given call site, source value and










	 * return site (in the caller).










	 * The result contains a mapping from target value to associated edge function.










	 */










 public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {










 assert callSite!=null;










 assert sourceVal!=null;










 assert returnSite!=null;





















 Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);










 if(res==null) return Collections.emptyMap();










 else {










 return res.row(returnSite);










 }










 }










}


package soot.jimple.interproc.ifds.solver;packagesoot.jimple.interproc.ifds.solver;import java.util.Collections;importjava.util.Collections;import java.util.Map;importjava.util.Map;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.SynchronizedBy;importsoot.jimple.interproc.ifds.SynchronizedBy;import soot.jimple.interproc.ifds.ThreadSafe;importsoot.jimple.interproc.ifds.ThreadSafe;import com.google.common.collect.HashBasedTable;importcom.google.common.collect.HashBasedTable;import com.google.common.collect.Table;importcom.google.common.collect.Table;/**/** * A data structure to record summary functions in an indexed fashion, for fast retrieval. * A data structure to record summary functions in an indexed fashion, for fast retrieval. */ */@ThreadSafe@ThreadSafepublic class SummaryFunctions<N,D,V> {publicclassSummaryFunctions<N,D,V>{  @SynchronizedBy("consistent lock on this")@SynchronizedBy("consistent lock on this") protected Table<N,D,Table<N,D,EdgeFunction<V>>> table = HashBasedTable.create();protectedTable<N,D,Table<N,D,EdgeFunction<V>>>table=HashBasedTable.create();  /**/**	 * Inserts a summary function.	 * Inserts a summary function.	 * @param callSite The call site with which this function is associated.	 * @param callSite The call site with which this function is associated.	 * @param sourceVal The source value at the call site. 	 * @param sourceVal The source value at the call site. 	 * @param retSite The return site (in the caller) with which this function is associated.	 * @param retSite The return site (in the caller) with which this function is associated.	 * @param targetVal The target value at the return site.	 * @param targetVal The target value at the return site.	 * @param function The edge function used to compute V-type values from the source node to the target node.  	 * @param function The edge function used to compute V-type values from the source node to the target node.  	 */	 */ public synchronized void insertFunction(N callSite,D sourceVal, N retSite, D targetVal, EdgeFunction<V> function) {publicsynchronizedvoidinsertFunction(NcallSite,DsourceVal,NretSite,DtargetVal,EdgeFunction<V>function){ assert callSite!=null;assertcallSite!=null; assert sourceVal!=null;assertsourceVal!=null; assert retSite!=null;assertretSite!=null; assert targetVal!=null;asserttargetVal!=null; assert function!=null;assertfunction!=null;  Table<N, D, EdgeFunction<V>> targetAndTargetValToFunction = table.get(callSite,sourceVal);Table<N,D,EdgeFunction<V>>targetAndTargetValToFunction=table.get(callSite,sourceVal); if(targetAndTargetValToFunction==null) {if(targetAndTargetValToFunction==null){ targetAndTargetValToFunction = HashBasedTable.create();targetAndTargetValToFunction=HashBasedTable.create(); table.put(callSite,sourceVal,targetAndTargetValToFunction);table.put(callSite,sourceVal,targetAndTargetValToFunction); }} targetAndTargetValToFunction.put(retSite, targetVal, function);targetAndTargetValToFunction.put(retSite,targetVal,function); }} /**/**	 * Retrieves all summary functions for a given call site, source value and	 * Retrieves all summary functions for a given call site, source value and	 * return site (in the caller).	 * return site (in the caller).	 * The result contains a mapping from target value to associated edge function.	 * The result contains a mapping from target value to associated edge function.	 */	 */ public synchronized Map<D,EdgeFunction<V>> summariesFor(N callSite, D sourceVal, N returnSite) {publicsynchronizedMap<D,EdgeFunction<V>>summariesFor(NcallSite,DsourceVal,NreturnSite){ assert callSite!=null;assertcallSite!=null; assert sourceVal!=null;assertsourceVal!=null; assert returnSite!=null;assertreturnSite!=null; Table<N, D, EdgeFunction<V>> res = table.get(callSite,sourceVal);Table<N,D,EdgeFunction<V>>res=table.get(callSite,sourceVal); if(res==null) return Collections.emptyMap();if(res==null)returnCollections.emptyMap(); else {else{ return res.row(returnSite);returnres.row(returnSite); }} }}}}








src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}












src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/template/BackwardsInterproceduralCFG.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}













package soot.jimple.interproc.ifds.template;





















import soot.Body;










import soot.Unit;










import soot.toolkits.graph.DirectedGraph;










import soot.toolkits.graph.InverseGraph;





















/**










 * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs.










 * This should be used for backward analyses.










 */










public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {





















 @Override










 protected DirectedGraph<Unit> makeGraph(Body body) {










 return new InverseGraph<Unit>(super.makeGraph(body));










 }










 










}


package soot.jimple.interproc.ifds.template;packagesoot.jimple.interproc.ifds.template;import soot.Body;importsoot.Body;import soot.Unit;importsoot.Unit;import soot.toolkits.graph.DirectedGraph;importsoot.toolkits.graph.DirectedGraph;import soot.toolkits.graph.InverseGraph;importsoot.toolkits.graph.InverseGraph;/**/** * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs. * Same as {@link JimpleBasedInterproceduralCFG} but based on inverted unit graphs. * This should be used for backward analyses. * This should be used for backward analyses. */ */public class BackwardsInterproceduralCFG extends JimpleBasedInterproceduralCFG {publicclassBackwardsInterproceduralCFGextendsJimpleBasedInterproceduralCFG{ @Override@Override protected DirectedGraph<Unit> makeGraph(Body body) {protectedDirectedGraph<Unit>makeGraph(Bodybody){ return new InverseGraph<Unit>(super.makeGraph(body));returnnewInverseGraph<Unit>(super.makeGraph(body)); }} }}








src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}












src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/template/DefaultIDETabulationProblem.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}













package soot.jimple.interproc.ifds.template;





















import soot.SootMethod;










import soot.Unit;










import soot.jimple.interproc.ifds.EdgeFunction;










import soot.jimple.interproc.ifds.EdgeFunctions;










import soot.jimple.interproc.ifds.IDETabulationProblem;










import soot.jimple.interproc.ifds.InterproceduralCFG;










import soot.jimple.interproc.ifds.JoinLattice;





















/**










 * This is a template for {@link IDETabulationProblem}s that automatically caches values










 * that ought to be cached. This class uses the Factory Method design pattern.










 * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently










 * reused for solving multiple different {@link IDETabulationProblem}s.










 * This class is specific to Soot. 










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>










 extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{





















 private final EdgeFunction<V> allTopFunction;










 private final JoinLattice<V> joinLattice;










 private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;










 










 public DefaultIDETabulationProblem(I icfg) {










 super(icfg);










 this.allTopFunction = createAllTopFunction();










 this.joinLattice = createJoinLattice();










 this.edgeFunctions = createEdgeFunctionsFactory();










 }





















 protected abstract EdgeFunction<V> createAllTopFunction();





















 protected abstract JoinLattice<V> createJoinLattice();





















 protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();










 










 @Override










 public final EdgeFunction<V> allTopFunction() {










 return allTopFunction;










 }










 










 @Override










 public final JoinLattice<V> joinLattice() {










 return joinLattice;










 }










 










 @Override










 public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {










 return edgeFunctions;










 }










 










}


package soot.jimple.interproc.ifds.template;packagesoot.jimple.interproc.ifds.template;import soot.SootMethod;importsoot.SootMethod;import soot.Unit;importsoot.Unit;import soot.jimple.interproc.ifds.EdgeFunction;importsoot.jimple.interproc.ifds.EdgeFunction;import soot.jimple.interproc.ifds.EdgeFunctions;importsoot.jimple.interproc.ifds.EdgeFunctions;import soot.jimple.interproc.ifds.IDETabulationProblem;importsoot.jimple.interproc.ifds.IDETabulationProblem;import soot.jimple.interproc.ifds.InterproceduralCFG;importsoot.jimple.interproc.ifds.InterproceduralCFG;import soot.jimple.interproc.ifds.JoinLattice;importsoot.jimple.interproc.ifds.JoinLattice;/**/** * This is a template for {@link IDETabulationProblem}s that automatically caches values * This is a template for {@link IDETabulationProblem}s that automatically caches values * that ought to be cached. This class uses the Factory Method design pattern. * that ought to be cached. This class uses the Factory Method design pattern. * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently * The {@link InterproceduralCFG} is passed into the constructor so that it can be conveniently * reused for solving multiple different {@link IDETabulationProblem}s. * reused for solving multiple different {@link IDETabulationProblem}s. * This class is specific to Soot.  * This class is specific to Soot.  *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public abstract class DefaultIDETabulationProblem<D,V,I extends InterproceduralCFG<Unit, SootMethod>>publicabstractclassDefaultIDETabulationProblem<D,V,IextendsInterproceduralCFG<Unit,SootMethod>> extends DefaultIFDSTabulationProblem<D,I> implements IDETabulationProblem<Unit, D, SootMethod, V, I>{extendsDefaultIFDSTabulationProblem<D,I>implementsIDETabulationProblem<Unit,D,SootMethod,V,I>{ private final EdgeFunction<V> allTopFunction;privatefinalEdgeFunction<V>allTopFunction; private final JoinLattice<V> joinLattice;privatefinalJoinLattice<V>joinLattice; private final EdgeFunctions<Unit,D,SootMethod,V> edgeFunctions;privatefinalEdgeFunctions<Unit,D,SootMethod,V>edgeFunctions;  public DefaultIDETabulationProblem(I icfg) {publicDefaultIDETabulationProblem(Iicfg){ super(icfg);super(icfg); this.allTopFunction = createAllTopFunction();this.allTopFunction=createAllTopFunction(); this.joinLattice = createJoinLattice();this.joinLattice=createJoinLattice(); this.edgeFunctions = createEdgeFunctionsFactory();this.edgeFunctions=createEdgeFunctionsFactory(); }} protected abstract EdgeFunction<V> createAllTopFunction();protectedabstractEdgeFunction<V>createAllTopFunction(); protected abstract JoinLattice<V> createJoinLattice();protectedabstractJoinLattice<V>createJoinLattice(); protected abstract EdgeFunctions<Unit, D, SootMethod, V> createEdgeFunctionsFactory();protectedabstractEdgeFunctions<Unit,D,SootMethod,V>createEdgeFunctionsFactory();  @Override@Override public final EdgeFunction<V> allTopFunction() {publicfinalEdgeFunction<V>allTopFunction(){ return allTopFunction;returnallTopFunction; }}  @Override@Override public final JoinLattice<V> joinLattice() {publicfinalJoinLattice<V>joinLattice(){ return joinLattice;returnjoinLattice; }}  @Override@Override public final EdgeFunctions<Unit, D, SootMethod, V> edgeFunctions() {publicfinalEdgeFunctions<Unit,D,SootMethod,V>edgeFunctions(){ return edgeFunctions;returnedgeFunctions; }} }}



Prev


1


2


3


Next





Prev

1

2

3

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






