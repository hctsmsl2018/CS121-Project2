



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

dea31cae















Commit
dea31cae


authored
Nov 25, 2014
by


Johannes Lerch



Browse files




edges on hold + resume







parent
9176fc7c













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ dea31cae






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......














src/heros/alias/FlowFunction.java








View file @ dea31cae






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}














src/heros/alias/IncomingEdge.java








View file @ dea31cae






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......














test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/EdgeBuilder.java








View file @ dea31cae






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......














test/heros/alias/TestHelper.java








View file @ dea31cae






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

dea31cae















Commit
dea31cae


authored
Nov 25, 2014
by


Johannes Lerch



Browse files




edges on hold + resume







parent
9176fc7c













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ dea31cae






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......














src/heros/alias/FlowFunction.java








View file @ dea31cae






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}














src/heros/alias/IncomingEdge.java








View file @ dea31cae






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......














test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/EdgeBuilder.java








View file @ dea31cae






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......














test/heros/alias/TestHelper.java








View file @ dea31cae






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

dea31cae







Open sidebar



Joshua Garcia heros
Commits

dea31cae




Open sidebar

Joshua Garcia heros
Commits

dea31cae


Joshua GarciaherosherosCommits
dea31cae








Commit
dea31cae


authored
Nov 25, 2014
by


Johannes Lerch



Browse files




edges on hold + resume







parent
9176fc7c













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ dea31cae






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......














src/heros/alias/FlowFunction.java








View file @ dea31cae






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}














src/heros/alias/IncomingEdge.java








View file @ dea31cae






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......














test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/EdgeBuilder.java








View file @ dea31cae






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......














test/heros/alias/TestHelper.java








View file @ dea31cae






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
dea31cae


authored
Nov 25, 2014
by


Johannes Lerch



Browse files




edges on hold + resume







parent
9176fc7c













Changes
8




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ dea31cae






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......














src/heros/alias/FlowFunction.java








View file @ dea31cae






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}














src/heros/alias/IncomingEdge.java








View file @ dea31cae






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......














test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/EdgeBuilder.java








View file @ dea31cae






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......














test/heros/alias/TestHelper.java








View file @ dea31cae






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
dea31cae


authored
Nov 25, 2014
by


Johannes Lerch



Browse files



Commit
dea31cae


authored
Nov 25, 2014
by


Johannes Lerch

dea31caeauthoredbyJohannes Lerch

edges on hold + resume






parent
9176fc7c
















parent
9176fc7c





parent












Changes
8
8


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPathUtil.java








View file @ dea31cae






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......














src/heros/alias/FlowFunction.java








View file @ dea31cae






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}














src/heros/alias/IncomingEdge.java








View file @ dea31cae






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......














test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/EdgeBuilder.java








View file @ dea31cae






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......














test/heros/alias/TestHelper.java








View file @ dea31cae






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......














src/heros/alias/AccessPathUtil.java








View file @ dea31cae






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}












src/heros/alias/AccessPathUtil.java








View file @ dea31cae








src/heros/alias/AccessPathUtil.java










View file @ dea31cae


dea31cae



......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}






......@@ -56,4 +56,23 @@ public class AccessPathUtil {









 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










 










 public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










}


 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);System.arraycopy(fieldRefs,0,accessPath,fact.getAccessPath().length,fieldRefs.length); return fact.cloneWithAccessPath(accessPath);returnfact.cloneWithAccessPath(accessPath); }}  public static <D extends FieldSensitiveFact<?, D>> D generalizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {publicstatic<DextendsFieldSensitiveFact<?,D>>DgeneralizeCallerSourceFact(IncomingEdge<D,?>incomingEdge,DcalleeSourceFact){ if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))if(!isPrefixOf(incomingEdge.getCalleeSourceFact(),calleeSourceFact)) throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));thrownewIllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.",incomingEdge,calleeSourceFact));  FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();FieldReference[]abstractAccessPath=incomingEdge.getCalleeSourceFact().getAccessPath(); FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();FieldReference[]concreteAccessPath=calleeSourceFact.getAccessPath(); FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();FieldReference[]targetAccessPath=incomingEdge.getCallerSourceFact().getAccessPath();  FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];FieldReference[]resultAccessPath=newFieldReference[targetAccessPath.length+concreteAccessPath.length-abstractAccessPath.length]; //copy old access path//copy old access path System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);System.arraycopy(targetAccessPath,0,resultAccessPath,0,targetAccessPath.length);  //copy delta access path that was omitted while creating the abstracted source fact//copy delta access path that was omitted while creating the abstracted source fact System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);System.arraycopy(concreteAccessPath,abstractAccessPath.length,resultAccessPath,targetAccessPath.length,concreteAccessPath.length-abstractAccessPath.length);  return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);returnincomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath); }}}}








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ dea31cae








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ dea31cae


dea31cae



......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......






......@@ -10,14 +10,22 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;





















import java.util.Collection;










import java.util.Collections;










import java.util.HashMap;










import java.util.List;










import java.util.Map;










import java.util.Set;










import java.util.Map.Entry;










import java.util.concurrent.ConcurrentHashMap;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;














......@@ -28,18 +36,6 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.ZeroedFlowFunctions;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.Pair;










import heros.solver.PathEdge;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {

























......@@ -74,6 +70,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 



......@@ -240,7 +238,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))










 continue;










 










 //TODO: Resume edges that are on hold and match this d3










 resumeEdges(sCalledProcN, d3.getFact());










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -275,6 +273,21 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute



......@@ -325,18 +338,17 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return;










 










 Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);










 










 //for each incoming call edge already processed










 //(see processCall(..))










 if (inc != null)










 for (IncomingEdge<D, N> incomingEdge : inc) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);














......@@ -346,12 +358,24 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {










 if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {



......@@ -398,27 +422,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: if reading field f










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 //always continue (d1, d2)










 










 if(d3.getReadField() instanceof SpecificFieldReference) {










 SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();










 Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());










 if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {










 //no caller interested in d3.field -> put edge on hold










 //TODO










 } else {










 //there is an incoming edge interested in d3.field










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 










 else {










 










 //TODO: if writing field f










 // create edge e = (d1, d2.*\{f})



......@@ -428,10 +450,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //		put e on hold










 // always kill (d1, d2)










 










 propagate(d1, m, d3.getFact(), null, false);










 










 propagate(d1, m, d3.getFact(), null, false);










 }










 }










 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 }










 }










 










 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();










 }










 










 /**



......@@ -521,17 +587,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;importstaticheros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;import heros.DontSynchronize;importheros.DontSynchronize;import heros.FlowFunctionCache;importheros.FlowFunctionCache;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SynchronizedBy;importheros.SynchronizedBy;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;import heros.alias.FlowFunction.AnnotatedFact;importheros.alias.FlowFunction.AnnotatedFact;import heros.solver.CountingThreadPoolExecutor;importheros.solver.CountingThreadPoolExecutor;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.solver.PathEdge;importheros.solver.PathEdge;import java.util.Collection;importjava.util.Collection;import java.util.Collections;importjava.util.Collections;import java.util.HashMap;importjava.util.HashMap;import java.util.List;importjava.util.List;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import java.util.Map.Entry;importjava.util.Map.Entry;import java.util.concurrent.ConcurrentHashMap;importjava.util.concurrent.ConcurrentHashMapconcurrent.ConcurrentHashMap;import java.util.Set;importjava.util.SetSet;import java.util.concurrent.LinkedBlockingQueue;importjava.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;importjava.util.concurrent.TimeUnit;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.DontSynchronize;importheros.DontSynchronize;import heros.FlowFunctionCache;importheros.FlowFunctionCache;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;import heros.alias.FlowFunction.AnnotatedFact;importheros.alias.FlowFunction.AnnotatedFact;import heros.alias.IFDSTabulationProblem;importheros.alias.IFDSTabulationProblem;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SynchronizedBy;importheros.SynchronizedBy;import heros.ZeroedFlowFunctions;importheros.ZeroedFlowFunctions;import heros.solver.CountingThreadPoolExecutor;importheros.solver.CountingThreadPoolExecutor;import heros.solver.Pair;importheros.solver.Pair;import heros.solver.PathEdge;importheros.solver.PathEdge;public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,DextendsFieldSensitiveFact<BaseValue,D>,M,IextendsInterproceduralCFG<N,M>>{ protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =protectedfinalMyConcurrentHashMap<M,Set<IncomingEdge<D,N>>>incoming= new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();newMyConcurrentHashMap<M,Set<IncomingEdge<D,N>>>();  protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();protectedfinalMyConcurrentHashMap<M,Set<PathEdge<N,D>>>pausedEdges=newMyConcurrentHashMap<M,Set<PathEdge<N,D>>>();  @DontSynchronize("stateless")@DontSynchronize("stateless") protected final FlowFunctions<N, D, M> flowFunctions;protectedfinalFlowFunctions<N,D,M>flowFunctions;  if (!addIncoming(sCalledProcN, new IncomingEdge<D, N>(d3.getFact(),n,d1,d2)))if(!addIncoming(sCalledProcN,newIncomingEdge<D,N>(d3.getFact(),n,d1,d2))) continue;continue;  //TODO: Resume edges that are on hold and match this d3//TODO: Resume edges that are on hold and match this d3//TODO: R e that are on hold and match this d3 resumeEdges(sCalledProcN, d3.getFact());resumeEdgesrE((sCalledProcNsCalledProcN,, d3d3..getFactgetFact());());  //line 15.2//line 15.2 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());Set<SummaryEdge<D,N>>endSumm=endSummary(sCalledProcN,d3.getFact()); }} }} private void resumeEdges(M method, D factAtMethodStartPoint) {privatevoidresumeEdges(Mmethod,DfactAtMethodStartPoint){ //TODO: Check for concurrency issues//TODO: Check for concurrency issues Set<PathEdge<N, D>> edges = pausedEdges.get(method);Set<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){ if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {if(AccessPathUtil.isPrefixOf(edge.factAtSource(),factAtMethodStartPoint)||AccessPathUtil.isPrefixOf(factAtMethodStartPoint,edge.factAtSource())){ if(edges.remove(edge)) {if(edges.remove(edge)){ logger.trace("RESUME-EDGE: {}", edge);logger.trace("RESUME-EDGE: {}",edge); propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);propagate(edge.factAtSource(),edge.getTarget(),edge.factAtTarget(),null,false); }} }} }} }} }} /**/**	 * Computes the call flow function for the given call-site abstraction	 * Computes the call flow function for the given call-site abstraction	 * @param callFlowFunction The call flow function to compute	 * @param callFlowFunction The call flow function to compute if (!addEndSummary(methodThatNeedsSummary, summaryEdge))if(!addEndSummary(methodThatNeedsSummary,summaryEdge)) return;return;  Set<IncomingEdge<D, N>> inc = incoming(methodThatNeedsSummary, d1);Set<IncomingEdge<D,N>>inc=incoming(methodThatNeedsSummary,d1);  //for each incoming call edge already processed//for each incoming call edge already processed //(see processCall(..))//(see processCall(..)) if (inc != null)if(inc!=null) for (IncomingEdge<D, N> incomingEdge : inc) {for(IncomingEdge<D,N>incomingEdge:inc){ // line 22// line 22 N callSite = incomingEdge.getCallSite();NcallSite=incomingEdge.getCallSite(); // for each return site// for each return site for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(callSite)){ // compute return-flow function// compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC); for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {for(IncomingEdge<D,N>incomingEdge:incoming(methodThatNeedsSummary)){ // line 22// line 22 N callSite = incomingEdge.getCallSite();NcallSite=incomingEdge.getCallSite(); // for each return site// for each return site for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(callSite)){ // compute return-flow function// compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC);  if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {if(AccessPathUtil.isPrefixOf(d1,incomingEdge.getCalleeSourceFact())){ D concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);DconcreteCalleeExitFact=AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(),summaryEdge); Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact, callSite);Set<AnnotatedFact<D>>callerTargetFacts=computeReturnFlowFunction(retFunction,concreteCalleeExitFact,callSite); propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);propagate(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact,callSite,false); }} }} else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {elseif(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(),d1)){ Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);Set<AnnotatedFact<D>>callerTargetFacts=computeReturnFlowFunction(retFunction,d2,callSite); // for each incoming-call value// for each incoming-call value for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {for(AnnotatedFact<D>callerTargetAnnotatedFact:callerTargetFacts){ D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact()); D callerSourceFact = AccessPathUtil.generalizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());DcallerSourceFact=AccessPathUtil.generalizeCallerSourceFact(incomingEdge,summaryEdge.getSourceFact()); propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);propagate(callerSourceFact,retSiteC,callerTargetFact,callSite,false); }} } } }} }}   //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only //be propagated into callers that have an incoming edge for this condition//be propagated into callers that have an incoming edge for this condition if(followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {if(followReturnsPastSeeds&&d1==zeroValue&&((inc ==== nullnull |||| incinc.isEmpty()))){ if(followReturnsPastSeeds && d1 == zeroValue && incoming(methodThatNeedsSummary).isEmpty()) {if(followReturnsPastSeeds&&d1==zeroValue&&incomingoming((methodThatNeedsSummarymethodThatNeedsSummary).)isEmpty()){ Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);Collection<N>callers=icfg.getCallersOf(methodThatNeedsSummary); for(N c: callers) {for(Nc:callers){ for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(c)){ FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);FlowFunction<D>flowFunction=flowFunctions.getNormalFlowFunction(n,m); Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);Set<AnnotatedFact<D>>res=computeNormalFlowFunction(flowFunction,d1,d2); for (AnnotatedFact<D> d3 : res) {for(AnnotatedFact<D>d3:res){ //TODO: if reading field f//TODO: if reading field f //TODO: double check if concurrency issues may arise//TODO: double check if concurrency issues may arise  //if reading field f//if reading field f // if d1.f element of incoming edges:// if d1.f element of incoming edges: //    create and propagate (d1.f, d2.f)//    create and propagate (d1.f, d2.f) // else // else  //	  create and set (d1.f, d2.f) on hold//	  create and set (d1.f, d2.f) on hold //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold//	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold //always continue (d1, d2)//always continue (d1, d2)  if(d3.getReadField() instanceof SpecificFieldReference) {if(d3.getReadField()instanceofSpecificFieldReference){ SpecificFieldReference fieldRef = (SpecificFieldReference) d3.getReadField();SpecificFieldReferencefieldRef=(SpecificFieldReference)d3.getReadField(); Set<IncomingEdge<D, N>> incomingEdges = incoming(icfg.getMethodOf(n), d3.getFact());Set<IncomingEdge<D,N>>incomingEdges=incoming(icfg.getMethodOf(n),d3.getFact()); if(incomingEdges.isEmpty() && !d1.equals(zeroValue)) {if(incomingEdges.isEmpty()&&!d1.equals(zeroValue)){ //no caller interested in d3.field -> put edge on hold//no caller interested in d3.field -> put edge on hold //TODO//TODO } else {}else{ //there is an incoming edge interested in d3.field//there is an incoming edge interested in d3.field D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(d1,fieldRef); D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(d1,fieldRef); if(checkForInterestedCallers(d1, n, fieldRef)) {if(checkForInterestedCallers(d1,n,fieldRef)){ propagate(concretizedSourceValue, m, d3.getFact(), null, false);propagate(concretizedSourceValue,m,d3.getFact(),null,false); } else {}else{ pauseEdge(concretizedSourceValue, m, d3.getFact());pauseEdge(concretizedSourceValue,m,d3.getFact()); }} }}  else {elseelse {{  //TODO: if writing field f//TODO: if writing field f // create edge e = (d1, d2.*\{f})// create edge e = (d1, d2.*\{f}) //		put e on hold//		put e on hold // always kill (d1, d2)// always kill (d1, d2)  propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false);  propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false); }} }} }} }}  private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {privatevoidpauseEdge(DsourceValue,NtargetStmt,DtargetValue){ M method = icfg.getMethodOf(targetStmt);Mmethod=icfg.getMethodOf(targetStmt); Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());Set<PathEdge<N,D>>edges=pausedEdges.putIfAbsentElseGet(method,newConcurrentHashSet<PathEdge<N,D>>()); edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));edges.add(newPathEdge<N,D>(sourceValue,targetStmt,targetValue)); logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);logger.trace("PAUSED: <{},{}> -> <{},{}>",method,sourceValue,targetStmt,targetValue); }} private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {privatebooleancheckForInterestedCallers(DcalleeSourceFact,NtargetStmt,SpecificFieldReferencefieldRef){ M calleeMethod = icfg.getMethodOf(targetStmt);McalleeMethod=icfg.getMethodOf(targetStmt); logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);logger.trace("Checking interest at method {} in fact {} with field access {}",calleeMethod,calleeSourceFact,fieldRef);  if(calleeSourceFact.equals(zeroValue))if(calleeSourceFact.equals(zeroValue)) return true;returntrue;  if(hasInterestedCallers(calleeSourceFact, calleeMethod, fieldRef)) {if(hasInterestedCallers(calleeSourceFact,calleeMethod,fieldRef)){ return true;returntrue; }}  Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, calleeSourceFact); Set<IncomingEdge<D,N>>inc=incomingEdgesPrefixesOf(calleeMethod,calleeSourceFact); for (IncomingEdge<D, N> incomingEdge : inc) {for(IncomingEdge<D,N>incomingEdge:inc){ if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(),incomingEdge.getCallSite(),fieldRef)){ propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? propagate(incomingEdge.getCallerSourceFact().equals(zeroValue)? incomingEdge.getCallerSourceFact() : incomingEdge.getCallerSourceFact(): cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),fieldRef), incomingEdge.getCallSite(), incomingEdge.getCallSite(), cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),fieldRef),null,false); return true;returntrue; }} else {else{ pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),fieldRef), incomingEdge.getCallSite(), incomingEdge.getCallSite(), cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),fieldRef)); }} }}  return false;returnfalse; }}  private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {privatebooleanhasInterestedCallers(DcalleeSourceFact,McalleeMethod,SpecificFieldReferencefieldRef){ D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact,fieldRef); Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);Set<IncomingEdge<D,N>>incomingEdges=incomingEdgesPrefixedWith(calleeMethod,concretizedSourceValue); return !incomingEdges.isEmpty();return!incomingEdges.isEmpty(); }}  /**/** return result;returnresult; }}  protected Set<IncomingEdge<D, N>> incoming(M m, final D abstractCalleeSourceFact) {protectedSet<IncomingEdge<D,N>>incoming(Mm,finalDabstractCalleeSourceFact){ protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {protectedSet<IncomingEdge<D,N>>incomingEdgesPrefixedWith(Mm,finalDfact){ Set<IncomingEdge<D, N>> result = incoming(m);Set<IncomingEdge<D,N>>result=incoming(m); return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {returnSets.filter(result,newPredicate<IncomingEdge<D,N>>(){ @Override@Override public boolean apply(IncomingEdge<D, N> edge) {publicbooleanapply(IncomingEdge<D,N>edge){ return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact());returnAccessPathUtil.isPrefixOf(fact,edge.getCalleeSourceFact()); }} });}); }}  protected Set<IncomingEdge<D, N>> incomingEdgesPrefixesOf(M m, final D fact) {protectedSet<IncomingEdge<D,N>>incomingEdgesPrefixesOf(Mm,finalDfact){ Set<IncomingEdge<D, N>> result = incoming(m);Set<IncomingEdge<D,N>>result=incoming(m); return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {returnSets.filter(result,newPredicate<IncomingEdge<D,N>>(){ @Override@Override public boolean apply(IncomingEdge<D, N> edge) {publicbooleanapply(IncomingEdge<D,N>edge){ return AccessPathUtil.isPrefixOf(abstractCalleeSourceFact, edge.getCalleeSourceFact());returnAccessPathUtil.isPrefixOf(abstractCalleeSourceFactabstractCalleeSourceFact,, edge.getCalleeSourceFact()); return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact);returnAccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(),, factfact); }} });}); }}  protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {protectedbooleanaddIncoming(Mm,IncomingEdge<D,N>incomingEdge){ logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);logger.trace("Incoming Edge for method {}: {}",m,incomingEdge); Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());Set<IncomingEdge<D,N>>set=incoming.putIfAbsentElseGet(m,newConcurrentHashSet<IncomingEdge<D,N>>()); return set.add(incomingEdge);returnset.add(incomingEdge); }}








src/heros/alias/FlowFunction.java








View file @ dea31cae






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}












src/heros/alias/FlowFunction.java








View file @ dea31cae








src/heros/alias/FlowFunction.java










View file @ dea31cae


dea31cae



......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}






......@@ -107,5 +107,10 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 }










 }










}


 return false;returnfalse; return true;returntrue; }}  @Override@Override public String toString() {publicStringtoString(){ return fact.toString()+"<"+readField+","+writtenField+">";returnfact.toString()+"<"+readField+","+writtenField+">"; }} }}}}








src/heros/alias/IncomingEdge.java








View file @ dea31cae






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......












src/heros/alias/IncomingEdge.java








View file @ dea31cae








src/heros/alias/IncomingEdge.java










View file @ dea31cae


dea31cae



......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......






......@@ -40,6 +40,11 @@ public class IncomingEdge<D, N> {









 public N getCallSite() {










 return callSite;










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {



......


 public N getCallSite() {publicNgetCallSite(){ return callSite;returncallSite; }}  @Override@Override public String toString() {publicStringtoString(){ return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";return"[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]"; }} @Override@Override public int hashCode() {publicinthashCode(){








test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}












test/heros/alias/AccessPathUtilTest.java








View file @ dea31cae








test/heros/alias/AccessPathUtilTest.java










View file @ dea31cae


dea31cae



......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}






......@@ -59,4 +59,19 @@ public class AccessPathUtilTest {









 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));










 }










 










 @Test










 public void testGeneralizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testGeneralizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testGeneralizeCallerSourceFactNoPrefix() {










 AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}


 public void testNonAbstractedSummary() {publicvoidtestNonAbstractedSummary(){ assertEquals(new Fact("z"), AccessPathUtil.applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))));assertEquals(newFact("z"),AccessPathUtil.applyAbstractedSummary(newFact("a"),newSummaryEdge<>(newFact("a"),null,newFact("z")))); }}  @Test@Test public void testGeneralizeCallerSourceFact() {publicvoidtestGeneralizeCallerSourceFact(){ assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));assertEquals(newFact("0.f"),AccessPathUtil.generalizeCallerSourceFact(newIncomingEdge<>(newFact("2"),null,newFact("0"),null),newFact("2.f"))); }}  @Test@Test public void testGeneralizeCallerSourceFactIdentity() {publicvoidtestGeneralizeCallerSourceFactIdentity(){ assertEquals(new Fact("0.f"), AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));assertEquals(newFact("0.f"),AccessPathUtil.generalizeCallerSourceFact(newIncomingEdge<>(newFact("2.f"),null,newFact("0.f"),null),newFact("2.f"))); }}  @Test(expected=IllegalArgumentException.class)@Test(expected=IllegalArgumentException.class) public void testGeneralizeCallerSourceFactNoPrefix() {publicvoidtestGeneralizeCallerSourceFactNoPrefix(){ AccessPathUtil.generalizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));AccessPathUtil.generalizeCallerSourceFact(newIncomingEdge<>(newFact("2.f"),null,newFact("0.f"),null),newFact("2")); }}}}








test/heros/alias/EdgeBuilder.java








View file @ dea31cae






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......












test/heros/alias/EdgeBuilder.java








View file @ dea31cae








test/heros/alias/EdgeBuilder.java










View file @ dea31cae


dea31cae



......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......






......@@ -52,17 +52,13 @@ public abstract class EdgeBuilder {









 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private FieldReference readFieldReference;










 private FieldReference writtenFieldReference;





















 public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {










 public NormalStmtBuilder(Statement stmt) {










 this.stmt = stmt;










 this.readFieldReference = readFieldReference;










 this.writtenFieldReference = writtenFieldReference;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 return this;










 }










 



......


 public static class NormalStmtBuilder extends EdgeBuilder {publicstaticclassNormalStmtBuilderextendsEdgeBuilder{ private Statement stmt;privateStatementstmt; private FieldReference readFieldReference;privateFieldReferencereadFieldReference; private FieldReference writtenFieldReference;privateFieldReferencewrittenFieldReference; public NormalStmtBuilder(Statement stmt, FieldReference readFieldReference, FieldReference writtenFieldReference) {publicNormalStmtBuilder(Statementstmt,, FieldReferenceFieldReference readFieldReferencereadFieldReference,, FieldReferenceFieldReference writtenFieldReferencewrittenFieldReference){ public NormalStmtBuilder(Statement stmt) {publicNormalStmtBuilder(Statementstmt){ this.stmt = stmt;this.stmt=stmt; this.readFieldReference = readFieldReference;this.readFieldReference=readFieldReference; this.writtenFieldReference = writtenFieldReference;this.writtenFieldReference=writtenFieldReference; }} public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {publicNormalStmtBuildersucc(Stringsucc,ExpectedFlowFunction...flows){ edges.add(new TestHelper.NormalEdge(stmt, readFieldReference, writtenFieldReference, new Statement(succ), flows));edges.add(newTestHelper.NormalEdge(stmt,readFieldReferencereadFieldReference,, writtenFieldReferencewrittenFieldReference,, newStatement(succ),flows)); edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));edges.add(newTestHelper.NormalEdge(stmt,newStatement(succ),flows)); return this;returnthis; }} 








test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......












test/heros/alias/FieldSensitiveSolverTest.java








View file @ dea31cae








test/heros/alias/FieldSensitiveSolverTest.java










View file @ dea31cae


dea31cae



......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......






......@@ -31,9 +31,9 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),










 normalStmt("c").succ("d", flow("2.3", "2.3")),










 readFieldStmt("d", "3").succ("e", flow("2.3", "4")));










 normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),










 normalStmt("c").succ("d", flow("2.f", "2.f")),










 normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));










 










 helper.runSolver(false, "a");










 }



......@@ -43,7 +43,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -57,7 +57,7 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));










 










 helper.method("foo",startPoints("d"),



......@@ -77,11 +77,12 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 helper.method("foo",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4")));










 helper.runSolver(false, "a");










 }



......@@ -91,18 +92,62 @@ public class FieldSensitiveSolverTest {









 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")));










 normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),










 callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),










 callSite("rs").calls("foo", flow("5", "3.notfield")));










 










 helper.method("foo",startPoints("d"),










 readFieldStmt("d", "notfield").succ("e", flow("3", "3")),










 normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 










 helper.method("xyz",










 startPoints("g"),










 callSite("g").calls("foo", flow("0", "3.notfield")));










 helper.runSolver(false, "a", "g");










 }





















 @Test










 public void doNotHoldIfInterestedTransitiveCallerExists() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));










 










 helper.method("xyz", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f" , kill("4")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar", 










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void happyPath() {



......


 helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), writeFieldStmt("b", "3").succ("c", flow("1", "2.3")),writeFieldStmtwriteField("b",, "3""3").succ("c",flow("1","2.3"3)), normalStmt("c").succ("d", flow("2.3", "2.3")),normalStmt("c").succ("d",flow("2.3"3,"2.3"3)), readFieldStmt("d", "3").succ("e", flow("2.3", "4")));readFieldStmtreadField("d",, "3""3").succ("e",flow("2.3"3","4"))); normalStmt("b").succ("c", flow("1", writeField("f"), "2.f")),normalStmtnormal("b").succ("c",flow("1",writeFieldwriteField(("f""f"),), "2.f"f)), normalStmt("c").succ("d", flow("2.f", "2.f")),normalStmt("c").succ("d",flow("2.f"f,"2.f"f)), normalStmt("d").succ("e", flow("2.f", readField("f"), "4")));normalStmtnormal("d").succ("e",flow("2.f"f",, readFieldreadField(("f""f"),)"4")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),writeFieldStmtwriteField("b",, "3""3").succ("c",flow("1","2.field")), normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),normalStmtnormal("b").succ("c",flow("1",writeFieldwriteField(("field""field"),), "2.field")), callSite("c").calls("foo", flow("2.field", "3.field")));callSite("c").calls("foo",flow("2.field","3.field")));  helper.method("foo",startPoints("d"),helper.method("foo",startPoints("d"), helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), writeFieldStmt("b", "3").succ("c", flow("1", "2.field")),writeFieldStmtwriteField("b",, "3""3").succ("c",flow("1","2.field")), normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),normalStmtnormal("b").succ("c",flow("1",writeFieldwriteField(("field""field"),), "2.field")), callSite("c").calls("foo", flow("2.field", "3.field")).retSite("retC", flow("2.field", "2.field")));callSite("c").calls("foo",flow("2.field","3.field")).retSite("retC",flow("2.field","2.field")));  helper.method("foo",startPoints("d"),helper.method("foo",startPoints("d"), helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),writeFieldStmtwriteFieldStmt(("b""b",, "field""field).succ("c",flow("1","2.field")), normalStmt("b").succ("c", flow("1", readField("field"), "2.field")),normalStmtnormalStmt(("b""b).succ("c",flow("1",readFieldreadField(("field""field"),), "2.field")), callSite("c").calls("foo", flow("2.field", "3.field")));callSite("c").calls("foo",flow("2.field","3.field")));  helper.method("foo",startPoints("d"),helper.method("foo",startPoints("d"), readFieldStmt("d", "notfield").succ("e", flow("3", "3")),readFieldStmt("d","notfield").succ("e",flow("3","3")), helper.method("foo",helper.method("foo", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("3", readField("notfield"), "5"), flow("3", "3")),normalStmt("d").succ("e",flow("3",readField("notfield"),"5"),flow("3","3")), normalStmt("e").succ("f", flow("3","4")));normalStmt("e").succ("f",flow("3","4"))); helper.runSolver(false, "a");helper.runSolver(false,"a"); }} helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), writeFieldStmt("b", "field").succ("c", flow("1", "2.field")),writeFieldStmt("b","field").succ("c",flow("1","2.field")), callSite("c").calls("foo", flow("2.field", "3.field")));callSite("c").calls("foo",flow("2.field","3.field"))); normalStmt("b").succ("c", flow("1", writeField("field"), "2.field")),normalStmt("b").succ("c",flow("1",writeField("field"),"2.field")), callSite("c").calls("foo", flow("2.field", "3.field")).retSite("rs", kill("2.field")),callSite("c").calls("foo",flow("2.field","3.field")).retSite("rs",kill("2.field")), callSite("rs").calls("foo", flow("5", "3.notfield")));callSite("rs").calls("foo",flow("5","3.notfield")));  helper.method("foo",startPoints("d"),helper.method("foo",startPoints("d"), readFieldStmt("d", "notfield").succ("e", flow("3", "3")),readFieldStmt("d","notfield").succ("e",flow("3","3")), normalStmt("e").succ("f", flow("3","4"), kill("3.notfield")));normalStmt("e").succ("f",flow("3","4"),kill("3.notfield"))); normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),normalStmt("d").succ("e",flow("3","3"),flow("3",readField("notfield"),"6")), normalStmt("e").succ("f", flow("3","4"), kill("6")),normalStmt("e").succ("f",flow("3","4"),kill("6")), exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));exitStmt("f").returns(over("c"),to("rs"),flow("4.field","5")));  helper.method("xyz",helper.method("xyz", startPoints("g"),startPoints("g"), callSite("g").calls("foo", flow("0", "3.notfield")));callSite("g").calls("foo",flow("0","3.notfield"))); helper.runSolver(false, "a", "g");helper.runSolver(false,"a","g"); }} @Test@Test public void doNotHoldIfInterestedTransitiveCallerExists() {publicvoiddoNotHoldIfInterestedTransitiveCallerExists(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),normalStmt("a").succ("b",flow("0",readField("f"),"1.f")), callSite("b").calls("bar", flow("1.f", "2.f")));callSite("b").calls("bar",flow("1.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), callSite("c").calls("xyz", flow("2", "3"), flow("2.f", "3.f")));callSite("c").calls("xyz",flow("2","3"),flow("2.f","3.f")));  helper.method("xyz", helper.method("xyz", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("3", readField("f"), "4")),normalStmt("d").succ("e",flow("3",readField("f"),"4")), normalStmt("e").succ("f" , kill("4")));normalStmt("e").succ("f",kill("4")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void prefixFactOfOnHoldFactIncoming() {publicvoidprefixFactOfOnHoldFactIncoming(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),callSite("b").calls("bar",flow("1","2.f")).retSite("e",kill("1")), callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));callSite("e").calls("bar",flow("2","2")).retSite("g",kill("2")));  helper.method("bar", helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),normalStmt("c").succ("d",flow("2",readField("g"),"3"),flow("2","2")), exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));exitStmt("d").returns(over("b"),to("e"),flow("2.f","2")).returns(over("e"),to("g"),kill("2"),kill("3")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void doNotPauseZeroSources() {publicvoiddoNotPauseZeroSources(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),normalStmt("a").succ("b",flow("0",readField("f"),"1.f")), normalStmt("b").succ("c", kill("1.f")));normalStmt("b").succ("c",kill("1.f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void happyPath() {publicvoidhappyPath(){








test/heros/alias/TestHelper.java








View file @ dea31cae






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......












test/heros/alias/TestHelper.java








View file @ dea31cae








test/heros/alias/TestHelper.java










View file @ dea31cae


dea31cae



......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......






......@@ -11,10 +11,11 @@









package heros.alias;





















import static org.junit.Assert.assertTrue;










import heros.FlowFunction;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Collection;










import java.util.LinkedList;



......@@ -61,15 +62,7 @@ public class TestHelper {









 }





















 public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());










 }










 










 public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));










 }










 










 public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {



......@@ -96,18 +89,34 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 public static Pair<FieldReference, FieldReference> readField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 Fact[] targetFacts = new Fact[targets.length];










 public static Pair<FieldReference, FieldReference> writeField(String fieldName) {










 return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new Fact(targets[i]);










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }










 










 public static ExpectedFlowFunction flow(String source, String... targets) {










 return flow(1, source, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);










 }










 










 public static int times(int times) {










 return times;










 }



......@@ -292,11 +301,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final Fact[] targets;










 public final AnnotatedFact<Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, Fact... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -333,14 +342,10 @@ public class TestHelper {




















 private Statement unit;










 private Statement succUnit;










 private FieldReference readFieldName;










 private FieldReference writtenFieldName;





















 public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {










 super(flowFunctions);










 this.unit = unit;










 this.readFieldName = readFieldName;










 this.writtenFieldName = writtenFieldName;










 this.succUnit = succUnit;










 }














......@@ -353,14 +358,6 @@ public class TestHelper {









 public void accept(EdgeVisitor visitor) {










 visitor.visit(this);










 }





















 public FieldReference getReadFieldReference() {










 return readFieldName;










 }





















 public FieldReference getWrittenFieldReference() {










 return writtenFieldName;










 }










 }





















 public static class CallEdge extends Edge {



......@@ -464,26 +461,6 @@ public class TestHelper {









 }










 throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));










 }










 










 @Override










 public FieldReference getReadFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getReadFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FieldReference getWrittenFieldReference(Statement curr) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr)) {










 return edge.getWrittenFieldReference();










 }










 }










 throw new AssertionError(String.format("No NormalEdge for %s", curr));










 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {



......@@ -508,17 +485,23 @@ public class TestHelper {









 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 @Override










 public Set<Fact> computeTargets(Fact source) {










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (remainingFlowFunctions.remove(ff)) {










 return Sets.newHashSet(ff.targets);










 result.addAll(Sets.newHashSet(ff.targets));










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));










 }










 }










 }










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 if(found)










 return result;










 else










 throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));










 }










 };










 }



......


package heros.alias;packageheros.alias;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import heros.FlowFunction;importheros.FlowFunction;import heros.alias.FlowFunction.AnnotatedFact;importheros.alias.FlowFunction.AnnotatedFactalias..AnnotatedFact;import heros.alias.IFDSTabulationProblem;importheros.alias.IFDSTabulationProblem;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.solver.Pair;importheros.solver.Pair;import java.util.Collection;importjava.util.Collection;import java.util.LinkedList;importjava.util.LinkedList; }} public static EdgeBuilder.NormalStmtBuilder normalStmt(String stmt) {publicstaticEdgeBuilder.NormalStmtBuildernormalStmt(Stringstmt){ return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(),new FieldReference.Any());returnnewEdgeBuilder.NormalStmtBuilder(newStatement(stmt),newFieldReference.Any(),newFieldReference.Any()); }}  public static EdgeBuilder.NormalStmtBuilder writeFieldStmt(String stmt, String fieldName) {publicstaticEdgeBuilder.NormalStmtBuilderwriteFieldStmt(Stringstmt,StringfieldName){ return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));returnnewEdgeBuilder.NormalStmtBuilder(newStatement(stmt),newFieldReference.Any(),newFieldReference.SpecificFieldReference(fieldName)); }}  public static EdgeBuilder.NormalStmtBuilder readFieldStmt(String stmt, String fieldName) {publicstaticEdgeBuilder.NormalStmtBuilderreadFieldStmt(Stringstmt,StringfieldName){ return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt), new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());returnnewEdgeBuilder.NormalStmtBuilder(newStatement(stmt),newFieldReference.SpecificFieldReference(fieldName),newFieldReference.Any()); return new EdgeBuilder.NormalStmtBuilder(new Statement(stmt));returnnewEdgeBuilder.NormalStmtBuilder(newStatement(stmt)); }}  public static EdgeBuilder.CallSiteBuilder callSite(String callSite) {publicstaticEdgeBuilder.CallSiteBuildercallSite(StringcallSite){ return new ExpectedFlowFunction(times, new Fact(source));returnnewExpectedFlowFunction(times,newFact(source)); }} public static ExpectedFlowFunction flow(String source, String... targets) {publicstaticExpectedFlowFunctionExpectedFlowFunction flowflow((StringString sourcesource,, StringString...... targetstargets){ return flow(1, source, targets);returnflowflow((11,, sourcesource,, targetstargets); public static Pair<FieldReference, FieldReference> readField(String fieldName) {publicstaticPairPair<<FieldReferenceFieldReference,, FieldReferenceFieldReference>> readFieldreadField((StringString fieldNamefieldName){ return new Pair<FieldReference, FieldReference>(new FieldReference.SpecificFieldReference(fieldName), new FieldReference.Any());returnnewnew PairPair<<FieldReferenceFieldReference,, FieldReferenceFieldReference>(>(newnew FieldReferenceFieldReference..SpecificFieldReferenceSpecificFieldReference((fieldNamefieldName),), newnew FieldReferenceFieldReference..AnyAny());() }}  public static ExpectedFlowFunction flow(int times, String source, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,String...targets){ Fact[] targetFacts = new Fact[targets.length];Fact[]targetFacts=newFact[targets.length]; public static Pair<FieldReference, FieldReference> writeField(String fieldName) {publicstaticPair<FieldReference,FieldReference>writeField(StringfieldName){ return new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.SpecificFieldReference(fieldName));returnnewPair<FieldReference,FieldReference>(newFieldReference.Any(),newFieldReference.SpecificFieldReference(fieldName)); }}  public static ExpectedFlowFunction flow(String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,Pair<FieldReference,FieldReference>fieldAccess,String...targets){ return flow(1, source, fieldAccess, targets);returnflow(1,source,fieldAccess,targets); }}  public static ExpectedFlowFunction flow(int times, String source, Pair<FieldReference, FieldReference> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,Pair<FieldReference,FieldReference>fieldAccess,String...targets){ AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];AnnotatedFact<Fact>[]targetFacts=newAnnotatedFact[targets.length]; for(int i=0; i<targets.length; i++) {for(inti=0;i<targets.length;i++){ targetFacts[i] = new Fact(targets[i]);targetFacts[i]=newFactFact((targetstargets[[ii]);] targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());targetFacts[i]=newAnnotatedFactAnnotatedFact<<FactFact>(>(newnew FactFact((targetstargets[[ii]),]), fieldAccessfieldAccess..getO1getO1(),(), fieldAccessfieldAccess..getO2getO2());() }} return new ExpectedFlowFunction(times, new Fact(source), targetFacts);returnnewExpectedFlowFunction(times,newFact(source),targetFacts); }}  public static ExpectedFlowFunction flow(String source, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,String...targets){ return flow(1, source, targets);returnflow(1,source,targets); }}  public static ExpectedFlowFunction flow(int times, String source, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,String...targets){ return flow(times, source, new Pair<FieldReference, FieldReference>(new FieldReference.Any(), new FieldReference.Any()), targets);returnflow(times,source,newPair<FieldReference,FieldReference>(newFieldReference.Any(),newFieldReference.Any()),targets); }}  public static int times(int times) {publicstaticinttimes(inttimes){ return times;returntimes; }} public static class ExpectedFlowFunction {publicstaticclassExpectedFlowFunction{ public final Fact source;publicfinalFactsource; public final Fact[] targets;publicfinalFactFact[]targets; public final AnnotatedFact<Fact>[] targets;publicfinalAnnotatedFactAnnotatedFact<<FactFact>[]>targets; public Edge edge;publicEdgeedge; private int times;privateinttimes; public ExpectedFlowFunction(int times, Fact source, Fact... targets) {publicExpectedFlowFunction(inttimes,Factsource,FactFact...targets){ public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {publicExpectedFlowFunction(inttimes,Factsource,AnnotatedFactAnnotatedFact<<FactFact>...>targets){ this.times = times;this.times=times; this.source = source;this.source=source; this.targets = targets;this.targets=targets; private Statement unit;privateStatementunit; private Statement succUnit;privateStatementsuccUnit; private FieldReference readFieldName;privateFieldReferencereadFieldName; private FieldReference writtenFieldName;privateFieldReferencewrittenFieldName; public NormalEdge(Statement unit, FieldReference readFieldName, FieldReference writtenFieldName, Statement succUnit, ExpectedFlowFunction...flowFunctions) {publicNormalEdge(Statementunit,FieldReferenceFieldReference readFieldNamereadFieldName,, FieldReferenceFieldReference writtenFieldNamewrittenFieldName,, StatementsuccUnit,ExpectedFlowFunction...flowFunctions){ public NormalEdge(Statement unit, Statement succUnit, ExpectedFlowFunction...flowFunctions) {publicNormalEdge(Statementunit,StatementsuccUnit,ExpectedFlowFunction...flowFunctions){ super(flowFunctions);super(flowFunctions); this.unit = unit;this.unit=unit; this.readFieldName = readFieldName;this.readFieldName=readFieldName; this.writtenFieldName = writtenFieldName;this.writtenFieldName=writtenFieldName; this.succUnit = succUnit;this.succUnit=succUnit; }} public void accept(EdgeVisitor visitor) {publicvoidaccept(EdgeVisitorvisitor){ visitor.visit(this);visitor.visit(this); }} public FieldReference getReadFieldReference() {publicFieldReferencegetReadFieldReference(){ return readFieldName;returnreadFieldName; }} public FieldReference getWrittenFieldReference() {publicFieldReferencegetWrittenFieldReference(){ return writtenFieldName;returnwrittenFieldName; }} }} public static class CallEdge extends Edge {publicstaticclassCallEdgeextendsEdge{ }} throw new AssertionError(String.format("No Flow Function expected for %s -> %s", curr, succ));thrownewAssertionError(String.format("No Flow Function expected for %s -> %s",curr,succ)); }}  @Override@Override public FieldReference getReadFieldReference(Statement curr) {publicFieldReferencegetReadFieldReference(Statementcurr){ for (final NormalEdge edge : normalEdges) {for(finalNormalEdgeedge:normalEdges){ if (edge.unit.equals(curr)) {if(edge.unit.equals(curr)){ return edge.getReadFieldReference();returnedge.getReadFieldReference(); }} }} throw new AssertionError(String.format("No NormalEdge for %s", curr));thrownewAssertionError(String.format("No NormalEdge for %s",curr)); }} @Override@Override public FieldReference getWrittenFieldReference(Statement curr) {publicFieldReferencegetWrittenFieldReference(Statementcurr){ for (final NormalEdge edge : normalEdges) {for(finalNormalEdgeedge:normalEdges){ if (edge.unit.equals(curr)) {if(edge.unit.equals(curr)){ return edge.getWrittenFieldReference();returnedge.getWrittenFieldReference(); }} }} throw new AssertionError(String.format("No NormalEdge for %s", curr));thrownewAssertionError(String.format("No NormalEdge for %s",curr)); }} @Override@Override public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<Fact>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ private FlowFunction<Fact> createFlowFunction(final Edge edge) {privateFlowFunction<Fact>createFlowFunction(finalEdgeedge){ return new FlowFunction<Fact>() {returnnewFlowFunction<Fact>(){ @Override@Override public Set<Fact> computeTargets(Fact source) {publicSet<Fact>computeTargets(Factsource){ public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {publicSet<AnnotatedFact<Fact>>computeTargets(Factsource){ Set<AnnotatedFact<Fact>> result = Sets.newHashSet();Set<AnnotatedFact<Fact>>result=Sets.newHashSet(); boolean found = false;booleanfound=false; for (ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ if (ff.source.equals(source)) {if(ff.source.equals(source)){ if (remainingFlowFunctions.remove(ff)) {if(remainingFlowFunctions.remove(ff)){ return Sets.newHashSet(ff.targets);returnSets.newHashSet(ff.targets); result.addAll(Sets.newHashSet(ff.targets));result.addAll(Sets.newHashSet(ff.targets)); found = true;found=true; } else {}else{ throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));thrownewAssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'",ff,edge)); }} }} }} throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));thrownewAssertionError(String.format("Fact '%s' was not expected at edge '%s'",source,edge)); if(found)if(found) return result;returnresult; elseelse throw new AssertionError(String.format("Fact '%s' was not expected at edge '%s'", source, edge));thrownewAssertionError(String.format("Fact '%s' was not expected at edge '%s'",source,edge)); }} };}; }}









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






