



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


haskell






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Yu Liu haskell
Commits

312ea5fb















Commit
312ea5fb


authored
Apr 18, 2016
by


yul13



Browse files




stack implementaion of the cybert project







parent
d4ec5fae













Changes
7




Hide whitespace changes

Inline
Side-by-side















cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb













import Distribution.Simple










main = defaultMain














cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"














cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb













import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs

























cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack














cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}














cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor














cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


haskell






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


haskell


H
H
haskell




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Yu Liu haskell
Commits

312ea5fb















Commit
312ea5fb


authored
Apr 18, 2016
by


yul13



Browse files




stack implementaion of the cybert project







parent
d4ec5fae













Changes
7




Hide whitespace changes

Inline
Side-by-side















cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb













import Distribution.Simple










main = defaultMain














cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"














cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb













import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs

























cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack














cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}














cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor














cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Yu Liu haskell
Commits

312ea5fb







Open sidebar



Yu Liu haskell
Commits

312ea5fb




Open sidebar

Yu Liu haskell
Commits

312ea5fb


Yu LiuhaskellhaskellCommits
312ea5fb








Commit
312ea5fb


authored
Apr 18, 2016
by


yul13



Browse files




stack implementaion of the cybert project







parent
d4ec5fae













Changes
7




Hide whitespace changes

Inline
Side-by-side















cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb













import Distribution.Simple










main = defaultMain














cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"














cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb













import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs

























cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack














cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}














cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor














cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
312ea5fb


authored
Apr 18, 2016
by


yul13



Browse files




stack implementaion of the cybert project







parent
d4ec5fae













Changes
7




Hide whitespace changes

Inline
Side-by-side















cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb













import Distribution.Simple










main = defaultMain














cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"














cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb













import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs

























cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack














cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}














cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor














cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
312ea5fb


authored
Apr 18, 2016
by


yul13



Browse files



Commit
312ea5fb


authored
Apr 18, 2016
by


yul13

312ea5fbauthoredbyyul13

stack implementaion of the cybert project






parent
d4ec5fae
















parent
d4ec5fae





parent












Changes
7
7


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb













import Distribution.Simple










main = defaultMain














cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"














cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb













import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs

























cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack














cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}














cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor














cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"














cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb













import Distribution.Simple










main = defaultMain












cybert-stack/Setup.hs



0 → 100644







View file @ 312ea5fb








cybert-stack/Setup.hs



0 → 100644









View file @ 312ea5fb


312ea5fb










import Distribution.Simple










main = defaultMain













import Distribution.Simple










main = defaultMain


import Distribution.SimpleimportDistribution.Simplemain = defaultMainmain=defaultMain








cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"












cybert-stack/app/cd271ex.hs



0 → 100644







View file @ 312ea5fb








cybert-stack/app/cd271ex.hs



0 → 100644









View file @ 312ea5fb


312ea5fb










-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"













-- reproduce the analysis for CD271 pvals, functional style










--










import Cybert










import Control.Monad










import Data.Maybe










import Data.Set (fromList, toList, union, empty)










extract:: Maybe [a] -> [a]










extract Nothing = []










extract (Just x) = x










pfind x = map (filter (\y -> probe y == probe x))










 -- find entries with same probeid










countln = foldr (\z acc -> acc + (length z)) 0










 -- count cross lists num










loadCybert' = loadCybert cybert_header










main = do










 all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"










 let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)










 all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)










 ; exportCybert (extract all_combined) "all_probes_refs.txt"










 ; exportCybert all_up "all_up_refs.txt"










 ; exportCybert all_down "all_down_refs.txt"










 ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"]










 ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ]










 let ones = map extract (all_combined:onesM)










 pairs = map extract (all_combined:pairsM)










 let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)










 down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)










 five_up = map (filter (\x -> countln (pfind x up) >= 5 )) up










 five_down =map (filter (\x -> countln (pfind x down) >= 5 )) down










 five_ups = foldl union empty (map cybertToSet five_up)










 five_downs = foldl union empty (map cybertToSet five_down)










 seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) up










 seven_down =map (filter (\x -> countln (pfind x down) >=7 )) down










 seven_ups = foldl union empty (map cybertToSet seven_up)










 seven_downs = foldl union empty (map cybertToSet seven_down)










 ; exportCybert (toList five_ups) "five_up_refs.txt" 










 ; exportCybert (toList five_downs) "five_down_refs.txt" 










 ; exportCybert (toList seven_ups) "seven_up_refs.txt" 










 ; exportCybert (toList seven_downs) "seven_down_refs.txt" 










 ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt"










 ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt"










 let older = extract older'










 xeno = extract xeno'










 older_ups = entriesByPval 0.05 (entriesByUpDown True older)










 older_downs = entriesByPval 0.05 (entriesByUpDown False older)










 ; exportCybert older_ups "older_patients_up.txt"










 ; exportCybert older_downs "older_patients_down.txt"










 let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xeno










 xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xeno










 ; exportCybert xeno_ups "xeno_up.txt"










 ; exportCybert xeno_downs "xeno_down.txt"


-- reproduce the analysis for CD271 pvals, functional style-- reproduce the analysis for CD271 pvals, functional style----import CybertimportCybertimport Control.MonadimportControl.Monadimport Data.MaybeimportData.Maybeimport Data.Set (fromList, toList, union, empty)importData.Set(fromList,toList,union,empty)extract:: Maybe [a] -> [a]extract::Maybe[a]->[a]extract Nothing = []extractNothing=[]extract (Just x) = xextract(Justx)=xpfind x = map (filter (\y -> probe y == probe x))pfindx=map(filter(\y->probey==probex)) -- find entries with same probeid-- find entries with same probeidcountln = foldr (\z acc -> acc + (length z)) 0countln=foldr(\zacc->acc+(lengthz))0 -- count cross lists num-- count cross lists numloadCybert' = loadCybert cybert_headerloadCybert'=loadCybertcybert_headermain = domain=do all_combined <- loadCybert' "./CyberT_Output/paired_2/CD271_all_together0.txt"all_combined<-loadCybert'"./CyberT_Output/paired_2/CD271_all_together0.txt" let all_up = (entriesByPval 0.05) $ (entriesByUpDown True) (extract all_combined)letall_up=(entriesByPval0.05)$(entriesByUpDownTrue)(extractall_combined) all_down = (entriesByPval 0.05) $ (entriesByUpDown False) (extract all_combined)all_down=(entriesByPval0.05)$(entriesByUpDownFalse)(extractall_combined) ; exportCybert (extract all_combined) "all_probes_refs.txt";exportCybert(extractall_combined)"all_probes_refs.txt" ; exportCybert all_up "all_up_refs.txt";exportCybertall_up"all_up_refs.txt" ; exportCybert all_down "all_down_refs.txt";exportCybertall_down"all_down_refs.txt" ; onesM <- mapM loadCybert' $ map ("./CyberT_Output/paired_2/CD271_one_one" ++ ) ["0.txt","1.txt","2.txt","3.txt"];onesM<-mapMloadCybert'$map("./CyberT_Output/paired_2/CD271_one_one"++)["0.txt","1.txt","2.txt","3.txt"] ; pairsM <- mapM loadCybert' ["./CyberT_Output/paired_2/CD271_two_two_" ++i ++ j ++ ".txt" | i <- ["1","2","3"], j<-["0","1"] ];pairsM<-mapMloadCybert'["./CyberT_Output/paired_2/CD271_two_two_"++i++j++".txt"|i<-["1","2","3"],j<-["0","1"]] let ones = map extract (all_combined:onesM)letones=mapextract(all_combined:onesM) pairs = map extract (all_combined:pairsM)pairs=mapextract(all_combined:pairsM) let up = map (entriesByPval 0.05) (map (entriesByUpDown True) pairs)letup=map(entriesByPval0.05)(map(entriesByUpDownTrue)pairs) down = map (entriesByPval 0.05) (map (entriesByUpDown False) pairs)down=map(entriesByPval0.05)(map(entriesByUpDownFalse)pairs) five_up = map (filter (\x -> countln (pfind x up) >= 5 )) upfive_up=map(filter(\x->countln(pfindxup)>=5))up five_down =map (filter (\x -> countln (pfind x down) >= 5 )) downfive_down=map(filter(\x->countln(pfindxdown)>=5))down five_ups = foldl union empty (map cybertToSet five_up)five_ups=foldlunionempty(mapcybertToSetfive_up) five_downs = foldl union empty (map cybertToSet five_down)five_downs=foldlunionempty(mapcybertToSetfive_down) seven_up = map (filter (\x -> countln (pfind x up) >= 7 )) upseven_up=map(filter(\x->countln(pfindxup)>=7))up seven_down =map (filter (\x -> countln (pfind x down) >=7 )) downseven_down=map(filter(\x->countln(pfindxdown)>=7))down seven_ups = foldl union empty (map cybertToSet seven_up)seven_ups=foldlunionempty(mapcybertToSetseven_up) seven_downs = foldl union empty (map cybertToSet seven_down)seven_downs=foldlunionempty(mapcybertToSetseven_down) ; exportCybert (toList five_ups) "five_up_refs.txt" ;exportCybert(toListfive_ups)"five_up_refs.txt" ; exportCybert (toList five_downs) "five_down_refs.txt" ;exportCybert(toListfive_downs)"five_down_refs.txt" ; exportCybert (toList seven_ups) "seven_up_refs.txt" ;exportCybert(toListseven_ups)"seven_up_refs.txt" ; exportCybert (toList seven_downs) "seven_down_refs.txt" ;exportCybert(toListseven_downs)"seven_down_refs.txt" ; older' <- loadCybert' "./CyberT_Output/paired_2/CD271_two_two_13.txt";older'<-loadCybert'"./CyberT_Output/paired_2/CD271_two_two_13.txt" ; xeno' <- loadCybert' "./CyberT_Output/paired_2/CD271_one_one4.txt";xeno'<-loadCybert'"./CyberT_Output/paired_2/CD271_one_one4.txt" let older = extract older'letolder=extractolder' xeno = extract xeno'xeno=extractxeno' older_ups = entriesByPval 0.05 (entriesByUpDown True older)older_ups=entriesByPval0.05(entriesByUpDownTrueolder) older_downs = entriesByPval 0.05 (entriesByUpDown False older)older_downs=entriesByPval0.05(entriesByUpDownFalseolder) ; exportCybert older_ups "older_patients_up.txt";exportCybertolder_ups"older_patients_up.txt" ; exportCybert older_downs "older_patients_down.txt";exportCybertolder_downs"older_patients_down.txt" let xeno_ups = entriesByFold 1 $ entriesByUpDown (True) xenoletxeno_ups=entriesByFold1$entriesByUpDown(True)xeno xeno_downs = entriesByFold 1 $ entriesByUpDown (False) xenoxeno_downs=entriesByFold1$entriesByUpDown(False)xeno ; exportCybert xeno_ups "xeno_up.txt";exportCybertxeno_ups"xeno_up.txt" ; exportCybert xeno_downs "xeno_down.txt";exportCybertxeno_downs"xeno_down.txt"








cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb













import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs























cybert-stack/app/huanganalysis.hs



0 → 100644







View file @ 312ea5fb








cybert-stack/app/huanganalysis.hs



0 → 100644









View file @ 312ea5fb


312ea5fb










import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs
























import Cybert










import Data.Maybe










import Data.List










import qualified Data.Map as M










import Control.Monad










import qualified Control.Exception as E










import System.Directory










import System.IO










import qualified Control.Monad.Parallel as P










{-import Data.Set(fromList, toList, union, empty)-}





















cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]










cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)










loadCybert' = loadCybert cheader










targetDirs= ["NatData_runs","XlinkData_runs"]





















{-utility fctns for writing to file -}










stringify sep xs = foldl1 (\x y ->x++sep++ y) xs





















writeString fname content = do










 withFile fname WriteMode (\handle -> do










 hPutStr handle content)





















mvroot :: FilePath -> FilePath -> IO Bool










mvroot root cur = do










 E.catch










 (










 do










 createDirectoryIfMissing True (cur ++"/ontargets")










 createDirectoryIfMissing True (cur ++"/scatters")










 createDirectoryIfMissing True (cur ++"/avgs")










 setCurrentDirectory (cur++"/runs")










 return True










 )










 (\e-> do










 let err = show (e::E.IOException)










 putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,










 "Err:", err]










 return False










 );





















{-extractTargets :: [Cybert_entry] -> IO()-}





















exportScatter fname xs = do










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xs










 (writeString ("../scatters/"++ fname)) (stringify "\n" ss)





















exportTargets fname xs = do










 exportProbes xs ("../ontargets/" ++ fname)










 let ss = map (\x-> let d = secondaryData x










 in stringify "\t"










 [probe x, showEitherF (mean x), show (d M.! "pval1"),










 show (d M.! "fpr"), show (d M.! "fdr")]) xs










 writeString ("../targetdetails/"++ fname) $ 










 stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)










exportAVG fn xs = do










 let xxs = map fn xs










 let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))










 else 1.0










 let gname = if length xs == 0 then "Unknown"










 else fromMaybe "Unknown" (collection $ (xs !! 0))










 let ss = gname ++ "\t" ++ (show avg) ++ "\n"










 return ss










subroutine:: (Maybe [Cybert_entry]) -> IO ([String])










subroutine xs = do










 let xxs'= fromMaybe [] xs










 let fname = if length xxs' == 0 then "Nill.dummy"










 else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)










 ; exportScatter fname xxs'










 {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}










 let xxs = filter (\x -> let d = (secondaryData x)










 in if (d M.! "fdr") < 0.0 then (pval x) < 0.05










 {-in case where beta fitting fails-}










 else (d M.! "pval1") <0.05 










 {-&& (d M.! "fdr") < 0.1-}










 ) (entriesByUpDown True xxs')










 ; putStrLn (fname ++" , "++(show $ length xxs))










 ; exportTargets fname xxs










 ; tot_p <- exportAVG pval xxs'










 ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs'










 ; tar_p <- exportAVG pval xxs










 ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs










 return [tot_p,tot_f,tar_p,tar_f]










 {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}





















routine :: FilePath -> FilePath -> IO()










routine root cur = do










 flag<-mvroot root cur;










 if flag then do










 filenames' <- getDirectoryContents "."










 let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'










 collections <- mapM loadCybert' filenames










 putStrLn $ show filenames










 {-acquire cybert entries -}










 avgs <- P.mapM subroutine collections










 writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))










 writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))










 writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))










 writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))










 {-E.evaluate $ runEval $ do-}










 {-parMap (rpar.subroutine) collections-}










 {-parMap rseq parTasks-}










 {-use pval of 0.05 and fpr of 0.1 to filter-}










 putStr $ "\nHandled" ++ cur ++"\n"










 setCurrentDirectory root










 else do










 putStr "\nNothing is done\n"










 setCurrentDirectory root





















main = do










{-first get stuff from the "runs" folder-}










 curdir <- getCurrentDirectory;










 mapM (routine curdir) targetDirs













import CybertimportCybertimport Data.MaybeimportData.Maybeimport Data.ListimportData.Listimport qualified Data.Map as MimportqualifiedData.MapasMimport Control.MonadimportControl.Monadimport qualified Control.Exception as EimportqualifiedControl.ExceptionasEimport System.DirectoryimportSystem.Directoryimport System.IOimportSystem.IOimport qualified Control.Monad.Parallel as PimportqualifiedControl.Monad.ParallelasP{-import Data.Set(fromList, toList, union, empty)-}{-import Data.Set(fromList, toList, union, empty)-}cheader' = M.fromList [("Secondary_Data_FDR","fdr"), ("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]cheader'=M.fromList[("Secondary_Data_FDR","fdr"),("Secondary_Data_FPR","fpr"),("Secondary_Data_Pval1","pval1")]cheader = M.union (cheader') (M.adjust (\x->"accession") "probe" cybert_header)cheader=M.union(cheader')(M.adjust(\x->"accession")"probe"cybert_header)loadCybert' = loadCybert cheaderloadCybert'=loadCybertcheadertargetDirs= ["NatData_runs","XlinkData_runs"]targetDirs=["NatData_runs","XlinkData_runs"]{-utility fctns for writing to file -}{-utility fctns for writing to file -}stringify sep xs = foldl1 (\x y ->x++sep++ y) xsstringifysepxs=foldl1(\xy->x++sep++y)xswriteString fname content = dowriteStringfnamecontent=do withFile fname WriteMode (\handle -> dowithFilefnameWriteMode(\handle->do hPutStr handle content)hPutStrhandlecontent)mvroot :: FilePath -> FilePath -> IO Boolmvroot::FilePath->FilePath->IOBoolmvroot root cur = domvrootrootcur=do E.catchE.catch (( dodo createDirectoryIfMissing True (cur ++"/ontargets")createDirectoryIfMissingTrue(cur++"/ontargets") createDirectoryIfMissing True (cur ++"/scatters")createDirectoryIfMissingTrue(cur++"/scatters") createDirectoryIfMissing True (cur ++"/avgs")createDirectoryIfMissingTrue(cur++"/avgs") setCurrentDirectory (cur++"/runs")setCurrentDirectory(cur++"/runs") return TruereturnTrue )) (\e-> do(\e->do let err = show (e::E.IOException)leterr=show(e::E.IOException) putStr $ stringify "\n" ["Error Chaging to directory\n" , cur,putStr$stringify"\n"["Error Chaging to directory\n",cur, "Err:", err]"Err:",err] return FalsereturnFalse ););{-extractTargets :: [Cybert_entry] -> IO()-}{-extractTargets :: [Cybert_entry] -> IO()-}exportScatter fname xs = doexportScatterfnamexs=do let ss = map (\x-> let d = secondaryData xletss=map(\x->letd=secondaryDatax in stringify "\t" [probe x, show (d M.! "pval1"),show (d M.! "fdr")]) xsinstringify"\t"[probex,show(dM.!"pval1"),show(dM.!"fdr")])xs (writeString ("../scatters/"++ fname)) (stringify "\n" ss)(writeString("../scatters/"++fname))(stringify"\n"ss)exportTargets fname xs = doexportTargetsfnamexs=do exportProbes xs ("../ontargets/" ++ fname)exportProbesxs("../ontargets/"++fname) let ss = map (\x-> let d = secondaryData xletss=map(\x->letd=secondaryDatax in stringify "\t"instringify"\t" [probe x, showEitherF (mean x), show (d M.! "pval1"),[probex,showEitherF(meanx),show(dM.!"pval1"), show (d M.! "fpr"), show (d M.! "fdr")]) xsshow(dM.!"fpr"),show(dM.!"fdr")])xs writeString ("../targetdetails/"++ fname) $ writeString("../targetdetails/"++fname)$ stringify "\n" (["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)stringify"\n"(["accession\tmean\tpvalue(one-tail)\tFPR\tFDR"]++ss)exportAVG fn xs = doexportAVGfnxs=do let xxs = map fn xsletxxs=mapfnxs let avg = if length xs >=2 then (foldl1 (+) xxs) / (fromIntegral (length xxs))letavg=iflengthxs>=2then(foldl1(+)xxs)/(fromIntegral(lengthxxs)) else 1.0else1.0 let gname = if length xs == 0 then "Unknown"letgname=iflengthxs==0then"Unknown" else fromMaybe "Unknown" (collection $ (xs !! 0))elsefromMaybe"Unknown"(collection$(xs!!0)) let ss = gname ++ "\t" ++ (show avg) ++ "\n"letss=gname++"\t"++(showavg)++"\n" return ssreturnsssubroutine:: (Maybe [Cybert_entry]) -> IO ([String])subroutine::(Maybe[Cybert_entry])->IO([String])subroutine xs = dosubroutinexs=do let xxs'= fromMaybe [] xsletxxs'=fromMaybe[]xs let fname = if length xxs' == 0 then "Nill.dummy"letfname=iflengthxxs'==0then"Nill.dummy" else fromMaybe "Nill.dummy" (collection $ xxs' !! 0)elsefromMaybe"Nill.dummy"(collection$xxs'!!0) ; exportScatter fname xxs';exportScatterfnamexxs' {-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-}{-; exportAVG "../avgs/Total_AVG_mean.tsv" mean xxs'-} let xxs = filter (\x -> let d = (secondaryData x)letxxs=filter(\x->letd=(secondaryDatax) in if (d M.! "fdr") < 0.0 then (pval x) < 0.05inif(dM.!"fdr")<0.0then(pvalx)<0.05 {-in case where beta fitting fails-}{-in case where beta fitting fails-} else (d M.! "pval1") <0.05 else(dM.!"pval1")<0.05 {-&& (d M.! "fdr") < 0.1-}{-&& (d M.! "fdr") < 0.1-} ) (entriesByUpDown True xxs'))(entriesByUpDownTruexxs') ; putStrLn (fname ++" , "++(show $ length xxs));putStrLn(fname++" , "++(show$lengthxxs)) ; exportTargets fname xxs;exportTargetsfnamexxs ; tot_p <- exportAVG pval xxs';tot_p<-exportAVGpvalxxs' ; tot_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs';tot_f<-exportAVG(\x->letd=secondaryDataxindM.!"fdr")xxs' ; tar_p <- exportAVG pval xxs;tar_p<-exportAVGpvalxxs ; tar_f <- exportAVG (\x->let d = secondaryData x in d M.! "fdr") xxs;tar_f<-exportAVG(\x->letd=secondaryDataxindM.!"fdr")xxs return [tot_p,tot_f,tar_p,tar_f]return[tot_p,tot_f,tar_p,tar_f] {-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}{-; exportAVG "../avgs/Targets_AVG_mean.tsv"  xxs'-}routine :: FilePath -> FilePath -> IO()routine::FilePath->FilePath->IO()routine root cur = doroutinerootcur=do flag<-mvroot root cur;flag<-mvrootrootcur; if flag then doifflagthendo filenames' <- getDirectoryContents "."filenames'<-getDirectoryContents"." let filenames = filter (\x -> "_cybert_result.tsv" `isInfixOf` x) filenames'letfilenames=filter(\x->"_cybert_result.tsv"`isInfixOf`x)filenames' collections <- mapM loadCybert' filenamescollections<-mapMloadCybert'filenames putStrLn $ show filenamesputStrLn$showfilenames {-acquire cybert entries -}{-acquire cybert entries -} avgs <- P.mapM subroutine collectionsavgs<-P.mapMsubroutinecollections writeString "../avgs/Total_AVG_pval.tsv" (stringify "\n" (map (\x->x!!0) avgs))writeString"../avgs/Total_AVG_pval.tsv"(stringify"\n"(map(\x->x!!0)avgs)) writeString "../avgs/Total_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!1) avgs))writeString"../avgs/Total_AVG_fdr.tsv"(stringify"\n"(map(\x->x!!1)avgs)) writeString "../avgs/Targets_AVG_pval.tsv" (stringify "\n" (map (\x->x!!2) avgs))writeString"../avgs/Targets_AVG_pval.tsv"(stringify"\n"(map(\x->x!!2)avgs)) writeString "../avgs/Targets_AVG_fdr.tsv" (stringify "\n" (map (\x->x!!3) avgs))writeString"../avgs/Targets_AVG_fdr.tsv"(stringify"\n"(map(\x->x!!3)avgs)) {-E.evaluate $ runEval $ do-}{-E.evaluate $ runEval $ do-} {-parMap (rpar.subroutine) collections-}{-parMap (rpar.subroutine) collections-} {-parMap rseq parTasks-}{-parMap rseq parTasks-} {-use pval of 0.05 and fpr of 0.1 to filter-}{-use pval of 0.05 and fpr of 0.1 to filter-} putStr $ "\nHandled" ++ cur ++"\n"putStr$"\nHandled"++cur++"\n" setCurrentDirectory rootsetCurrentDirectoryroot else doelsedo putStr "\nNothing is done\n"putStr"\nNothing is done\n" setCurrentDirectory rootsetCurrentDirectoryrootmain = domain=do{-first get stuff from the "runs" folder-}{-first get stuff from the "runs" folder-} curdir <- getCurrentDirectory;curdir<-getCurrentDirectory; mapM (routine curdir) targetDirsmapM(routinecurdir)targetDirs








cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack












cybert-stack/cybert-stack.cabal



0 → 100644







View file @ 312ea5fb








cybert-stack/cybert-stack.cabal



0 → 100644









View file @ 312ea5fb


312ea5fb










name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack













name:                cybert-stack










version:             0.1.0.0










synopsis:            Initial project template from stack










description:         Please see README.md










homepage:            https://github.com/darlliu/cybert-stack#readme










license:             BSD3










license-file:        LICENSE










author:              Yu Liu










maintainer:          yul13@uci.edu










copyright:           NA










category:            research










build-type:          Simple










-- extra-source-files:










cabal-version:       >=1.10





















library










  hs-source-dirs:      src










  exposed-modules:     Cybert










  build-depends:       base >= 4.7 && < 5










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-cd271










  hs-source-dirs:      app










  main-is:             cd271ex.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










  default-language:    Haskell2010





















executable cybert-stack-huanganalysis










  hs-source-dirs:      app










  main-is:             huanganalysis.hs










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  build-depends:       base










                    ,  cybert-stack










                    ,  directory >= 1.2










                    ,  containers >= 0.5










                    ,  bytestring >= 0.1










                    ,  monad-parallel>=0.7.2










  default-language:    Haskell2010





















test-suite cybert-stack-test










  type:                exitcode-stdio-1.0










  hs-source-dirs:      test










  main-is:             test_cybert.hs










  build-depends:       base










                     , cybert-stack










  ghc-options:         -threaded -rtsopts -with-rtsopts=-N










  default-language:    Haskell2010





















source-repository head










  type:     git










  location: https://github.com/darlliu/cybert-stack


name:                cybert-stackversion:             0.1.0.0synopsis:            Initial project template from stackdescription:         Please see README.mdhomepage:            https://github.com/darlliu/cybert-stack#readmelicense:             BSD3license-file:        LICENSEauthor:              Yu Liumaintainer:          yul13@uci.educopyright:           NAcategory:            researchbuild-type:          Simple-- extra-source-files:cabal-version:       >=1.10library  hs-source-dirs:      src  exposed-modules:     Cybert  build-depends:       base >= 4.7 && < 5                    ,  containers >= 0.5                    ,  bytestring >= 0.1  default-language:    Haskell2010executable cybert-stack-cd271  hs-source-dirs:      app  main-is:             cd271ex.hs  ghc-options:         -threaded -rtsopts -with-rtsopts=-N  build-depends:       base                    ,  cybert-stack                    ,  containers >= 0.5                    ,  bytestring >= 0.1  default-language:    Haskell2010executable cybert-stack-huanganalysis  hs-source-dirs:      app  main-is:             huanganalysis.hs  ghc-options:         -threaded -rtsopts -with-rtsopts=-N  build-depends:       base                    ,  cybert-stack                    ,  directory >= 1.2                    ,  containers >= 0.5                    ,  bytestring >= 0.1                    ,  monad-parallel>=0.7.2  default-language:    Haskell2010test-suite cybert-stack-test  type:                exitcode-stdio-1.0  hs-source-dirs:      test  main-is:             test_cybert.hs  build-depends:       base                     , cybert-stack  ghc-options:         -threaded -rtsopts -with-rtsopts=-N  default-language:    Haskell2010source-repository head  type:     git  location: https://github.com/darlliu/cybert-stack








cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}












cybert-stack/src/Cybert.hs



0 → 100644







View file @ 312ea5fb








cybert-stack/src/Cybert.hs



0 → 100644









View file @ 312ea5fb


312ea5fb










--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}













--a simple loader for cybert data










--generates cybert reports and tables










--










--has the following:










--1, a polymorphic and flexible data structure indexed by multiple










--keys.










--2, ability to do set operation, selection filtering and mapping 










--on entries










--3, IO for both human readable format and message passing to other python










--code










--










{-module definitions -}










module Cybert










(










 Cybert_entry(NA, Cybert,probe,genesym,










 sample, collection, mean, bf, bh, sds, 










 pval,ratio,secondaryRefs,secondaryData),










 cybert_entry,










 cybert_header,










 showCybertEntries,










 entriesByFold,










 entriesByPval,










 entriesBySym,










 entriesByUpDown,










 entriesBySecondaryRef,










 showEitherF,










 cybertToSet,










 loadCybert,










 exportCybert,










 exportGeneSyms,










 exportProbes










) where










{-end module definitions -}










import Data.Bits










import Data.List










import Data.Maybe










import Data.Char










import System.IO










import System.IO.Error










import Control.Exception as E










import qualified Data.Set as S










import qualified Data.Map as M










import qualified Data.ByteString.Char8 as B





















{-basic data types-}










data Cybert_entry = NA | Cybert {










 probe :: String ,










 genesym :: Maybe String ,










 sample :: [String] ,










 collection :: Maybe String , --which dataset










 mean :: Either Float [Float] , --multiple means










 sds :: Either Float [Float],










 pval :: Float, --the pairwise or ANOVA pval










 bf :: Float,










 bh :: Float,










 ratio :: Either Float [Float], --pairwise ratio or numerous ratios










 secondaryRefs :: M.Map String String , --optional secondary refs










 secondaryData :: M.Map String Float , --optional secondary data










 raw :: B.ByteString










}










cybert_entry = Cybert{










 -- default constructor










 probe = "NONE",










 genesym = Nothing,










 sample = [],










 collection = Nothing,










 mean = Right [],










 sds = Right [],










 pval = -1,










 bf = -1,










 bh = -1,










 ratio = Left (-1),










 secondaryRefs = M.fromList [("","")],










 secondaryData = M.fromList [("",0)],










 raw = B.empty










}










cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),










 ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),










 ("sds","std")])










hasher :: String -> Int










hasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381










cybertHash :: Cybert_entry -> Int










cybertHash NA = 0










cybertHash Cybert{probe=p} = hasher p










{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}





















instance Eq Cybert_entry where










 a == b = (cybertHash a) == (cybertHash b)










instance Ord Cybert_entry where










 compare a b = compare (cybertHash a) (cybertHash b)










--hashing










{-end basic data types-}










{-format and show routines-}










showJustS::Maybe String -> String










showJustS Nothing = "N/A"










showJustS (Just x) = x





















showEitherF::(Either Float [Float]) -> String










showEitherF (Left x) = show x










showEitherF (Right xxs@(x:[])) = show x










showEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))





















showCybertEntries::[Cybert_entry]->String










showCybertEntries (x:[])= show x










showCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)





















instance Show Cybert_entry where










 showsPrec _ a s = show a ++ s










 show NA = "NA"










 show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,










 pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++










 (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)










 -- for each sample










{-end format and show routines-}










{-set operation and filtering routines-}










entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]










entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xs





















entryByProbe :: String -> [Cybert_entry] -> Cybert_entry










entryByProbe p xs = head $ filter (\x -> probe x == p) xs





















entriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]










entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xs










--lookup










entriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]










--shows fold CHANGE, i.e. the change in fold from the larger to the smaller










entriesByFold threshold xs = filter (\x ->pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b)= if length b < 2 then False










 else let larger = foldl1 max b










 smaller = foldl1 min b










 in larger - smaller > threshold










entriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]










entriesByPval threshold xs = filter (\x -> pval x < threshold) xs





















entriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]










entriesByUpDown val xs = filter (\x -> pred $ mean x) xs where










 pred (Left a) = False










 pred (Right b) = if length b < 2 then False










 else let bigger = (b!!1-b!!0>0)










 in bigger==val










--filtering





















cybertToSet :: [Cybert_entry] -> S.Set Cybert_entry










cybertToSet xs = S.fromList xs










--set operations










{-end set operation and filtering routines-}










{-IO routines-}










buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]










buildHeaderPrec s = let ss = B.split '\t' s










 in map (\x -> (stripQuote $ B.unpack x, x)) ss where










 stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xs










 stripQuote xs = map toLower xs





















buildHeader :: B.ByteString -> (M.Map String (Maybe Int) )










buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' s










 in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ss










maybeGet :: [B.ByteString] -> Maybe Int -> B.ByteString










[] `maybeGet` _ = B.pack ""










x `maybeGet` Nothing = B.pack ""










x `maybeGet` (Just s)= if length x > s then x !! s










 else B.pack ""





















getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe String










getText header ss id = if id `M.notMember` header










 then Nothing










 else let idx = header M.! id










 in Just (B.unpack $ ss `maybeGet` idx)










getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Float










getNum header ss id = if id `M.notMember` header










 then -1 :: Float










 else let idx = header M.! id










 in read (B.unpack $ ss `maybeGet` idx) :: Float










getNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]










getNums header ss ids = let nums = map (getNum header ss) ids










 in if length nums == 1 then Left (nums !! 0)










 else Right $ filter (not . (== -1)) nums










getSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)










getSecondaryData cheader header ss =










 let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getNum header ss) keys










 in M.fromList (zip keys vals)










getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)










getSecondaryRefs cheader header ss =










 let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)










 keys = map (cheader M.!) pfxs










 vals = map (getText header ss) keys










 in M.fromList (zip keys (map (fromMaybe "") vals))










lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entry










lineToCybert cheader header fname line = readLine line where










 readLine s = let ss = B.split '\t' s 










 in if length ss /= M.size header then cybert_entry










 else let cybt= cybert_entry {










 probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),










 --this is a must










 collection = Just fname,










 genesym = getText header ss $ cheader M.! "genesym",










 --this is of maybe type










 pval = getNum header ss $ cheader M.! "pval",










 bf = getNum header ss $ cheader M.! "bf",










 bh = getNum header ss $ cheader M.! "bh",










 --these are -1 defaulted










 mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],










 sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],










 --these are one or many










 raw = s,










 --raw info










 secondaryRefs = getSecondaryRefs cheader header ss,










 secondaryData = getSecondaryData cheader header ss










 } in cybt





















loadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])










loadCybert cheader fname = E.catch










 (withFile fname ReadMode (\handle -> do










 contents <- B.hGetContents handle










 let mylines = B.split '\n' contents










 if length mylines <= 1 then return Nothing










 else let header = buildHeader (head mylines);










 output = Just (filter (not.isNothing.collection)










 $ map (lineToCybert cheader header fname) (drop 1 mylines))










 in if output == (Just []) then return Nothing










 else return output










 ))










 (\err -> do










 if isEOFError err










 then do










 putStrLn "File is empty or truncated."










 return Nothing










 else do










 putStrLn $ "Unexpected Error at opening file: "++ (show err)










 return Nothing










 )










-- Loads a cybert table from fname










exportCybert :: [Cybert_entry] -> String -> IO()










exportCybert xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = showCybertEntries xs










 hPutStr handle contents










 )





















exportGeneSyms :: [Cybert_entry] -> String -> IO()










exportGeneSyms xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map showJustS (map genesym xs))










 hPutStr handle contents










 )





















exportProbes :: [Cybert_entry] -> String -> IO()










exportProbes xs fname = do










 withFile fname WriteMode (\handle -> do










 let contents = unlines (map probe xs)










 hPutStr handle contents










 )










{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}










{-end IO routines-}


--a simple loader for cybert data--a simple loader for cybert data--generates cybert reports and tables--generates cybert reports and tables------has the following:--has the following:--1, a polymorphic and flexible data structure indexed by multiple--1, a polymorphic and flexible data structure indexed by multiple--keys.--keys.--2, ability to do set operation, selection filtering and mapping --2, ability to do set operation, selection filtering and mapping --on entries--on entries--3, IO for both human readable format and message passing to other python--3, IO for both human readable format and message passing to other python--code--code----{-module definitions -}{-module definitions -}module CybertmoduleCybert(( Cybert_entry(NA, Cybert,probe,genesym,Cybert_entry(NA,Cybert,probe,genesym, sample, collection, mean, bf, bh, sds, sample,collection,mean,bf,bh,sds, pval,ratio,secondaryRefs,secondaryData),pval,ratio,secondaryRefs,secondaryData), cybert_entry,cybert_entry, cybert_header,cybert_header, showCybertEntries,showCybertEntries, entriesByFold,entriesByFold, entriesByPval,entriesByPval, entriesBySym,entriesBySym, entriesByUpDown,entriesByUpDown, entriesBySecondaryRef,entriesBySecondaryRef, showEitherF,showEitherF, cybertToSet,cybertToSet, loadCybert,loadCybert, exportCybert,exportCybert, exportGeneSyms,exportGeneSyms, exportProbesexportProbes) where)where{-end module definitions -}{-end module definitions -}import Data.BitsimportData.Bitsimport Data.ListimportData.Listimport Data.MaybeimportData.Maybeimport Data.CharimportData.Charimport System.IOimportSystem.IOimport System.IO.ErrorimportSystem.IO.Errorimport Control.Exception as EimportControl.ExceptionasEimport qualified Data.Set as SimportqualifiedData.SetasSimport qualified Data.Map as MimportqualifiedData.MapasMimport qualified Data.ByteString.Char8 as BimportqualifiedData.ByteString.Char8asB{-basic data types-}{-basic data types-}data Cybert_entry = NA | Cybert {dataCybert_entry=NA|Cybert{ probe :: String ,probe::String, genesym :: Maybe String ,genesym::MaybeString, sample :: [String] ,sample::[String], collection :: Maybe String , --which datasetcollection::MaybeString,--which dataset mean :: Either Float [Float] , --multiple meansmean::EitherFloat[Float],--multiple means sds :: Either Float [Float],sds::EitherFloat[Float], pval :: Float, --the pairwise or ANOVA pvalpval::Float,--the pairwise or ANOVA pval bf :: Float,bf::Float, bh :: Float,bh::Float, ratio :: Either Float [Float], --pairwise ratio or numerous ratiosratio::EitherFloat[Float],--pairwise ratio or numerous ratios secondaryRefs :: M.Map String String , --optional secondary refssecondaryRefs::M.MapStringString,--optional secondary refs secondaryData :: M.Map String Float , --optional secondary datasecondaryData::M.MapStringFloat,--optional secondary data raw :: B.ByteStringraw::B.ByteString}}cybert_entry = Cybert{cybert_entry=Cybert{ -- default constructor-- default constructor probe = "NONE",probe="NONE", genesym = Nothing,genesym=Nothing, sample = [],sample=[], collection = Nothing,collection=Nothing, mean = Right [],mean=Right[], sds = Right [],sds=Right[], pval = -1,pval=-1, bf = -1,bf=-1, bh = -1,bh=-1, ratio = Left (-1),ratio=Left(-1), secondaryRefs = M.fromList [("","")],secondaryRefs=M.fromList[("","")], secondaryData = M.fromList [("",0)],secondaryData=M.fromList[("",0)], raw = B.emptyraw=B.empty}}cybert_header = (M.fromList [("probe", "probe_id"), ("genesym","gene_sym"),cybert_header=(M.fromList[("probe","probe_id"),("genesym","gene_sym"), ("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"),("pval","pval"),("bf","bonferroni"),("bh","bh"),("ratio","ratiomean"),("mean","mean"), ("sds","std")])("sds","std")])hasher :: String -> Inthasher::String->Inthasher = foldl (\h c -> 33*h `xor` fromEnum c) 5381hasher=foldl(\hc->33*h`xor`fromEnumc)5381cybertHash :: Cybert_entry -> IntcybertHash::Cybert_entry->IntcybertHash NA = 0cybertHashNA=0cybertHash Cybert{probe=p} = hasher pcybertHashCybert{probe=p}=hasherp{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}{-cybertHash Cybert{probe=p, collection=(Just s)} = hasher $ s++p-}instance Eq Cybert_entry whereinstanceEqCybert_entrywhere a == b = (cybertHash a) == (cybertHash b)a==b=(cybertHasha)==(cybertHashb)instance Ord Cybert_entry whereinstanceOrdCybert_entrywhere compare a b = compare (cybertHash a) (cybertHash b)compareab=compare(cybertHasha)(cybertHashb)--hashing--hashing{-end basic data types-}{-end basic data types-}{-format and show routines-}{-format and show routines-}showJustS::Maybe String -> StringshowJustS::MaybeString->StringshowJustS Nothing = "N/A"showJustSNothing="N/A"showJustS (Just x) = xshowJustS(Justx)=xshowEitherF::(Either Float [Float]) -> StringshowEitherF::(EitherFloat[Float])->StringshowEitherF (Left x) = show xshowEitherF(Leftx)=showxshowEitherF (Right xxs@(x:[])) = show xshowEitherF(Rightxxs@(x:[]))=showxshowEitherF (Right xxs@(x:xs)) = (show x) ++"\t"++ (showEitherF (Right xs))showEitherF(Rightxxs@(x:xs))=(showx)++"\t"++(showEitherF(Rightxs))showCybertEntries::[Cybert_entry]->StringshowCybertEntries::[Cybert_entry]->StringshowCybertEntries (x:[])= show xshowCybertEntries(x:[])=showxshowCybertEntries (x:xs)= (show x) ++ "\n" ++ (showCybertEntries xs)showCybertEntries(x:xs)=(showx)++"\n"++(showCybertEntriesxs)instance Show Cybert_entry whereinstanceShowCybert_entrywhere showsPrec _ a s = show a ++ sshowsPrec_as=showa++s show NA = "NA"showNA="NA" show Cybert {probe=p, genesym=sym, sample=ss, collection=col, mean=m,showCybert{probe=p,genesym=sym,sample=ss,collection=col,mean=m, pval=pv, ratio=r, secondaryRefs=_, secondaryData=_,raw=_} = p++"\t"++pval=pv,ratio=r,secondaryRefs=_,secondaryData=_,raw=_}=p++"\t"++ (showJustS sym)++"\t"++(showJustS col) ++"\t" ++(showEitherF m)++"\t"++(show pv)(showJustSsym)++"\t"++(showJustScol)++"\t"++(showEitherFm)++"\t"++(showpv) -- for each sample-- for each sample{-end format and show routines-}{-end format and show routines-}{-set operation and filtering routines-}{-set operation and filtering routines-}entriesBySym :: String -> [Cybert_entry] -> [Cybert_entry]entriesBySym::String->[Cybert_entry]->[Cybert_entry]entriesBySym sym xs = filter (\x -> genesym x == (Just sym)) xsentriesBySymsymxs=filter(\x->genesymx==(Justsym))xsentryByProbe :: String -> [Cybert_entry] -> Cybert_entryentryByProbe::String->[Cybert_entry]->Cybert_entryentryByProbe p xs = head $ filter (\x -> probe x == p) xsentryByProbepxs=head$filter(\x->probex==p)xsentriesBySecondaryRef :: String -> String -> [Cybert_entry] -> [Cybert_entry]entriesBySecondaryRef::String->String->[Cybert_entry]->[Cybert_entry]entriesBySecondaryRef tref ref xs = filter (\x -> (secondaryRefs x) M.! tref == ref) xsentriesBySecondaryReftrefrefxs=filter(\x->(secondaryRefsx)M.!tref==ref)xs--lookup--lookupentriesByFold :: Float -> [Cybert_entry] -> [Cybert_entry]entriesByFold::Float->[Cybert_entry]->[Cybert_entry]--shows fold CHANGE, i.e. the change in fold from the larger to the smaller--shows fold CHANGE, i.e. the change in fold from the larger to the smallerentriesByFold threshold xs = filter (\x ->pred $ mean x) xs whereentriesByFoldthresholdxs=filter(\x->pred$meanx)xswhere pred (Left a) = Falsepred(Lefta)=False pred (Right b)= if length b < 2 then Falsepred(Rightb)=iflengthb<2thenFalse else let larger = foldl1 max belseletlarger=foldl1maxb smaller = foldl1 min bsmaller=foldl1minb in larger - smaller > thresholdinlarger-smaller>thresholdentriesByPval :: Float -> [Cybert_entry] -> [Cybert_entry]entriesByPval::Float->[Cybert_entry]->[Cybert_entry]entriesByPval threshold xs = filter (\x -> pval x < threshold) xsentriesByPvalthresholdxs=filter(\x->pvalx<threshold)xsentriesByUpDown :: Bool -> [Cybert_entry] -> [Cybert_entry]entriesByUpDown::Bool->[Cybert_entry]->[Cybert_entry]entriesByUpDown val xs = filter (\x -> pred $ mean x) xs whereentriesByUpDownvalxs=filter(\x->pred$meanx)xswhere pred (Left a) = Falsepred(Lefta)=False pred (Right b) = if length b < 2 then Falsepred(Rightb)=iflengthb<2thenFalse else let bigger = (b!!1-b!!0>0)elseletbigger=(b!!1-b!!0>0) in bigger==valinbigger==val--filtering--filteringcybertToSet :: [Cybert_entry] -> S.Set Cybert_entrycybertToSet::[Cybert_entry]->S.SetCybert_entrycybertToSet xs = S.fromList xscybertToSetxs=S.fromListxs--set operations--set operations{-end set operation and filtering routines-}{-end set operation and filtering routines-}{-IO routines-}{-IO routines-}buildHeaderPrec :: B.ByteString -> [(String , B.ByteString)]buildHeaderPrec::B.ByteString->[(String,B.ByteString)]buildHeaderPrec s = let ss = B.split '\t' sbuildHeaderPrecs=letss=B.split'\t's in map (\x -> (stripQuote $ B.unpack x, x)) ss whereinmap(\x->(stripQuote$B.unpackx,x))sswhere stripQuote ('\"':xs) = map toLower $ take ((length xs) - 1) xsstripQuote('\"':xs)=maptoLower$take((lengthxs)-1)xs stripQuote xs = map toLower xsstripQuotexs=maptoLowerxsbuildHeader :: B.ByteString -> (M.Map String (Maybe Int) )buildHeader::B.ByteString->(M.MapString(MaybeInt))buildHeader s = let ss = buildHeaderPrec s; sl = B.split '\t' sbuildHeaders=letss=buildHeaderPrecs;sl=B.split'\t's in M.fromList $ map (\x -> (fst x , (snd x) `elemIndex` sl)) ssinM.fromList$map(\x->(fstx,(sndx)`elemIndex`sl))ssmaybeGet :: [B.ByteString] -> Maybe Int -> B.ByteStringmaybeGet::[B.ByteString]->MaybeInt->B.ByteString[] `maybeGet` _ = B.pack ""[]`maybeGet`_=B.pack""x `maybeGet` Nothing = B.pack ""x`maybeGet`Nothing=B.pack""x `maybeGet` (Just s)= if length x > s then x !! sx`maybeGet`(Justs)=iflengthx>sthenx!!s else B.pack ""elseB.pack""getText :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> Maybe StringgetText::(M.MapString(MaybeInt))->[B.ByteString]->String->MaybeStringgetText header ss id = if id `M.notMember` headergetTextheaderssid=ifid`M.notMember`header then NothingthenNothing else let idx = header M.! idelseletidx=headerM.!id in Just (B.unpack $ ss `maybeGet` idx)inJust(B.unpack$ss`maybeGet`idx)getNum :: (M.Map String (Maybe Int))-> [B.ByteString] -> String -> FloatgetNum::(M.MapString(MaybeInt))->[B.ByteString]->String->FloatgetNum header ss id = if id `M.notMember` headergetNumheaderssid=ifid`M.notMember`header then -1 :: Floatthen-1::Float else let idx = header M.! idelseletidx=headerM.!id in read (B.unpack $ ss `maybeGet` idx) :: Floatinread(B.unpack$ss`maybeGet`idx)::FloatgetNums :: (M.Map String (Maybe Int))-> [B.ByteString] -> [String] -> Either Float [Float]getNums::(M.MapString(MaybeInt))->[B.ByteString]->[String]->EitherFloat[Float]getNums header ss ids = let nums = map (getNum header ss) idsgetNumsheaderssids=letnums=map(getNumheaderss)ids in if length nums == 1 then Left (nums !! 0)iniflengthnums==1thenLeft(nums!!0) else Right $ filter (not . (== -1)) numselseRight$filter(not.(==-1))numsgetSecondaryData::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String Float)getSecondaryData::(M.MapStringString)->(M.MapString(MaybeInt))->[B.ByteString]->(M.MapStringFloat)getSecondaryData cheader header ss =getSecondaryDatacheaderheaderss= let pfxs = filter (\x->"Secondary_Data_" `isInfixOf` x) (M.keys cheader)letpfxs=filter(\x->"Secondary_Data_"`isInfixOf`x)(M.keyscheader) keys = map (cheader M.!) pfxskeys=map(cheaderM.!)pfxs vals = map (getNum header ss) keysvals=map(getNumheaderss)keys in M.fromList (zip keys vals)inM.fromList(zipkeysvals)getSecondaryRefs::(M.Map String String) ->(M.Map String (Maybe Int))-> [B.ByteString] -> (M.Map String String)getSecondaryRefs::(M.MapStringString)->(M.MapString(MaybeInt))->[B.ByteString]->(M.MapStringString)getSecondaryRefs cheader header ss =getSecondaryRefscheaderheaderss= let pfxs = filter (\x->"Secondary_Refs_" `isInfixOf` x) (M.keys cheader)letpfxs=filter(\x->"Secondary_Refs_"`isInfixOf`x)(M.keyscheader) keys = map (cheader M.!) pfxskeys=map(cheaderM.!)pfxs vals = map (getText header ss) keysvals=map(getTextheaderss)keys in M.fromList (zip keys (map (fromMaybe "") vals))inM.fromList(zipkeys(map(fromMaybe"")vals))lineToCybert :: (M.Map String String) -> (M.Map String (Maybe Int))-> String ->B.ByteString -> Cybert_entrylineToCybert::(M.MapStringString)->(M.MapString(MaybeInt))->String->B.ByteString->Cybert_entrylineToCybert cheader header fname line = readLine line wherelineToCybertcheaderheaderfnameline=readLinelinewhere readLine s = let ss = B.split '\t' s readLines=letss=B.split'\t's in if length ss /= M.size header then cybert_entryiniflengthss/=M.sizeheaderthencybert_entry else let cybt= cybert_entry {elseletcybt=cybert_entry{ probe = B.unpack $ ss `maybeGet` (header M.! (cheader M.! "probe")),probe=B.unpack$ss`maybeGet`(headerM.!(cheaderM.!"probe")), --this is a must--this is a must collection = Just fname,collection=Justfname, genesym = getText header ss $ cheader M.! "genesym",genesym=getTextheaderss$cheaderM.!"genesym", --this is of maybe type--this is of maybe type pval = getNum header ss $ cheader M.! "pval",pval=getNumheaderss$cheaderM.!"pval", bf = getNum header ss $ cheader M.! "bf",bf=getNumheaderss$cheaderM.!"bf", bh = getNum header ss $ cheader M.! "bh",bh=getNumheaderss$cheaderM.!"bh", --these are -1 defaulted--these are -1 defaulted mean = getNums header ss $ map ( cheader M.! "mean" ++ ) ["c","e","1","2","3","4","5","6","7"],mean=getNumsheaderss$map(cheaderM.!"mean"++)["c","e","1","2","3","4","5","6","7"], sds = getNums header ss $ map ( cheader M.! "sds" ++ ) ["c","e","1","2","3","4","5","6","7"],sds=getNumsheaderss$map(cheaderM.!"sds"++)["c","e","1","2","3","4","5","6","7"], --these are one or many--these are one or many raw = s,raw=s, --raw info--raw info secondaryRefs = getSecondaryRefs cheader header ss,secondaryRefs=getSecondaryRefscheaderheaderss, secondaryData = getSecondaryData cheader header sssecondaryData=getSecondaryDatacheaderheaderss } in cybt}incybtloadCybert :: (M.Map String String)->String -> IO (Maybe [Cybert_entry])loadCybert::(M.MapStringString)->String->IO(Maybe[Cybert_entry])loadCybert cheader fname = E.catchloadCybertcheaderfname=E.catch (withFile fname ReadMode (\handle -> do(withFilefnameReadMode(\handle->do contents <- B.hGetContents handlecontents<-B.hGetContentshandle let mylines = B.split '\n' contentsletmylines=B.split'\n'contents if length mylines <= 1 then return Nothingiflengthmylines<=1thenreturnNothing else let header = buildHeader (head mylines);elseletheader=buildHeader(headmylines); output = Just (filter (not.isNothing.collection)output=Just(filter(not.isNothing.collection) $ map (lineToCybert cheader header fname) (drop 1 mylines))$map(lineToCybertcheaderheaderfname)(drop1mylines)) in if output == (Just []) then return Nothinginifoutput==(Just[])thenreturnNothing else return outputelsereturnoutput )))) (\err -> do(\err->do if isEOFError errifisEOFErrorerr then dothendo putStrLn "File is empty or truncated."putStrLn"File is empty or truncated." return NothingreturnNothing else doelsedo putStrLn $ "Unexpected Error at opening file: "++ (show err)putStrLn$"Unexpected Error at opening file: "++(showerr) return NothingreturnNothing ))-- Loads a cybert table from fname-- Loads a cybert table from fnameexportCybert :: [Cybert_entry] -> String -> IO()exportCybert::[Cybert_entry]->String->IO()exportCybert xs fname = doexportCybertxsfname=do withFile fname WriteMode (\handle -> dowithFilefnameWriteMode(\handle->do let contents = showCybertEntries xsletcontents=showCybertEntriesxs hPutStr handle contentshPutStrhandlecontents ))exportGeneSyms :: [Cybert_entry] -> String -> IO()exportGeneSyms::[Cybert_entry]->String->IO()exportGeneSyms xs fname = doexportGeneSymsxsfname=do withFile fname WriteMode (\handle -> dowithFilefnameWriteMode(\handle->do let contents = unlines (map showJustS (map genesym xs))letcontents=unlines(mapshowJustS(mapgenesymxs)) hPutStr handle contentshPutStrhandlecontents ))exportProbes :: [Cybert_entry] -> String -> IO()exportProbes::[Cybert_entry]->String->IO()exportProbes xs fname = doexportProbesxsfname=do withFile fname WriteMode (\handle -> dowithFilefnameWriteMode(\handle->do let contents = unlines (map probe xs)letcontents=unlines(mapprobexs) hPutStr handle contentshPutStrhandlecontents )){-exportRef :: [Cybert_entry] -> String -> String -> IO()-}{-exportRef :: [Cybert_entry] -> String -> String -> IO()-}{-end IO routines-}{-end IO routines-}








cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor












cybert-stack/stack.yaml



0 → 100644







View file @ 312ea5fb








cybert-stack/stack.yaml



0 → 100644









View file @ 312ea5fb


312ea5fb










# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor













# This file was automatically generated by stack init










# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/





















# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)










resolver: lts-5.13





















# Local packages, usually specified by relative directory name










packages:










- '.'










# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)










extra-deps: []





















# Override default flag values for local packages and extra-deps










flags: {}





















# Extra package databases containing global packages










extra-package-dbs: []





















# Control whether we use the GHC we find on the path










# system-ghc: true





















# Require a specific version of stack, using version ranges










# require-stack-version: -any # Default










# require-stack-version: >= 1.0.0





















# Override the architecture used by stack, especially useful on Windows










# arch: i386










# arch: x86_64





















# Extra directories used by stack for building










# extra-include-dirs: [/path/to/dir]










# extra-lib-dirs: [/path/to/dir]





















# Allow a newer minor version of GHC than the snapshot specifies










# compiler-check: newer-minor


# This file was automatically generated by stack init# This file was automatically generated by stack init# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/# For more information, see: http://docs.haskellstack.org/en/stable/yaml_configuration/# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)resolver: lts-5.13resolver:lts-5.13# Local packages, usually specified by relative directory name# Local packages, usually specified by relative directory namepackages:packages:- '.'-'.'# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)extra-deps: []extra-deps:[]# Override default flag values for local packages and extra-deps# Override default flag values for local packages and extra-depsflags: {}flags:{}# Extra package databases containing global packages# Extra package databases containing global packagesextra-package-dbs: []extra-package-dbs:[]# Control whether we use the GHC we find on the path# Control whether we use the GHC we find on the path# system-ghc: true# system-ghc: true# Require a specific version of stack, using version ranges# Require a specific version of stack, using version ranges# require-stack-version: -any # Default# require-stack-version: -any # Default# require-stack-version: >= 1.0.0# require-stack-version: >= 1.0.0# Override the architecture used by stack, especially useful on Windows# Override the architecture used by stack, especially useful on Windows# arch: i386# arch: i386# arch: x86_64# arch: x86_64# Extra directories used by stack for building# Extra directories used by stack for building# extra-include-dirs: [/path/to/dir]# extra-include-dirs: [/path/to/dir]# extra-lib-dirs: [/path/to/dir]# extra-lib-dirs: [/path/to/dir]# Allow a newer minor version of GHC than the snapshot specifies# Allow a newer minor version of GHC than the snapshot specifies# compiler-check: newer-minor# compiler-check: newer-minor








cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"












cybert-stack/test/test_cybert.hs



0 → 100644







View file @ 312ea5fb








cybert-stack/test/test_cybert.hs



0 → 100644









View file @ 312ea5fb


312ea5fb










import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"













import Cybert





















main = do










 let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}










 let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}










 ssome@(Just some)<- loadCybert cybert_header "test.txt"










 exportGeneSyms some "tested.txt"


import CybertimportCybertmain = domain=do let c = cybert_entry{genesym=(Just "Sym"), mean = (Right [1,2,3])}letc=cybert_entry{genesym=(Just"Sym"),mean=(Right[1,2,3])} let d = cybert_entry{genesym=(Just "Sym2"), mean = (Right [1,2,3])}letd=cybert_entry{genesym=(Just"Sym2"),mean=(Right[1,2,3])} ssome@(Just some)<- loadCybert cybert_header "test.txt"ssome@(Justsome)<-loadCybertcybert_header"test.txt" exportGeneSyms some "tested.txt"exportGeneSymssome"tested.txt"









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






