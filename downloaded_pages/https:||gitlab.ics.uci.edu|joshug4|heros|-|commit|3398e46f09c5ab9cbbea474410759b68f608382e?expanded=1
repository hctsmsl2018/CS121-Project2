



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

3398e46f















Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}














src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

3398e46f















Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}














src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

3398e46f







Open sidebar



Joshua Garcia heros
Commits

3398e46f




Open sidebar

Joshua Garcia heros
Commits

3398e46f


Joshua GarciaherosherosCommits
3398e46f








Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}














src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Hide whitespace changes

Inline
Side-by-side















mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}














src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files



Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch

3398e46fauthoredbyJohannes Lerch

rewrite of ifds solver






parent
55cdd2d8
















parent
55cdd2d8





parent












Changes
45
45


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f





File added













src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......














src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......














src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}














src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......














src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}














src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file














src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}














src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}














src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file














src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}














src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}














src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}














src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......














src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}














src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}














src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......









Prev


1


2


3


Next













mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f





File added











mockito-all-1.9.5.jar



0 â†’ 100644




View file @ 3398e46f








mockito-all-1.9.5.jar



0 â†’ 100644






View file @ 3398e46f
3398e46f


File added




File added


File added









src/heros/InterproceduralCFG.java








View file @ 3398e46f






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......












src/heros/InterproceduralCFG.java








View file @ 3398e46f








src/heros/InterproceduralCFG.java










View file @ 3398e46f


3398e46f



......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......






......@@ -28,6 +28,8 @@ public interface InterproceduralCFG<N,M>  {









	 */










 public M getMethodOf(N n);





















 public List<N> getPredsOf(N u);










 










 /**










	 * Returns the successor nodes.










	 */



......


	 */	 */ public M getMethodOf(N n);publicMgetMethodOf(Nn); public List<N> getPredsOf(N u);publicList<N>getPredsOf(Nu);  /**/**	 * Returns the successor nodes.	 * Returns the successor nodes.	 */	 */








src/heros/alias/AccessPath.java








View file @ 3398e46f






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......












src/heros/alias/AccessPath.java








View file @ 3398e46f








src/heros/alias/AccessPath.java










View file @ 3398e46f


3398e46f



......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......






......@@ -39,20 +39,21 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(T fieldReferences) {










 return exclusions.contains(fieldReferences);










 }










 










 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {










 if(fieldReferences.length > 0) {










 for(T field : fieldReferences[0].elements()) {



......@@ -76,22 +77,23 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 if(merge) {










 for(int i=fieldReferences.length-1; i>=0; i--) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].shouldBeMerged(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 builder.removeExclusions();










 return builder.build();










 }










 }










 }










 }










 //FIXME do we need to not merge sometimes?










//		if(merge) {










//			for(int i=fieldReferences.length-1; i>=0; i--) {










//				for(int j=0; j<accesses.length; j++) {










//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {










//						// [..., {j-i}, ...]










//						










//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










//						builder.keep(0, j);










//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










//						builder.append(fieldReferences, i+1, fieldReferences.length);










//						builder.removeExclusions();










//						return builder.build();










//					}










//				}










//			}










//		}










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);



......@@ -121,7 +123,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions() {



......@@ -139,7 +141,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {



......@@ -166,16 +168,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> prepend(T fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










//		for(int j=0; j<accesses.length; j++) {










//			if(accesses[j].contains(fieldRef)) {










//				// [{0-j}, ...]










// 










//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










//				builder.merge(0, j+1);










//				builder.keep(j+1, accesses.length);










//				return builder.build();










//			}










//		}










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);



......@@ -186,7 +188,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }



......@@ -200,13 +202,13 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -283,6 +285,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -305,41 +308,44 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 break;










 }










 










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);










//		exclusions.removeAll(this.exclusions);










 Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);










 assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) 










 || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));










 return delta;










 }










 










 public boolean contains(AccessPath<T> accPath) {










 assert accPath.accesses.length <= 1;










 if(accPath.accesses.length == 1) {










 for(SubAccessPath<T> sub : accesses) {










 if(sub.elements().equals(accPath.accesses[0].elements())) {










 return true;










 }










 }










 return false;










 }










 else










 return exclusions.containsAll(accPath.exclusions);










 }










 










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 }










 










 @Override



......@@ -347,24 +353,67 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Delta other = (Delta) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (exclusions == null) {










 if (other.exclusions != null)










 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 return true;










 }





















 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 return new AccessPath<>(accesses, newExclusions);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 for(SubAccessPath<T> subAcc : accesses)










 if(subAcc instanceof SpecificFieldAccess)










 return false;










 return true;










 }










 










 public boolean canRead(T field) {










 for(SubAccessPath<T> acc : accesses) {










 if(acc.contains(field))










 return true;










 if(acc instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 return exclusions.isEmpty() && accesses.length == 0;










 }










 










 @Override



......@@ -373,7 +422,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -393,11 +441,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -406,8 +449,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -419,12 +460,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 return new AccessPath<U>(newAccesses, newExclusions);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 else










 return this;










 }



......@@ -437,15 +478,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);










 Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);



......@@ -496,7 +528,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -509,32 +541,16 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 



......@@ -572,13 +588,6 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {



......


  private final SubAccessPath<T>[] accesses;privatefinalSubAccessPath<T>[]accesses; private final Set<T> exclusions;privatefinalSet<T>exclusions; private final SubPathResolver<T> resolver;privatefinalSubPathResolver<T>resolver;  public AccessPath() {publicAccessPath(){ accesses = new SubAccessPath[0];accesses=newSubAccessPath[0]; exclusions = Sets.newHashSet();exclusions=Sets.newHashSet(); resolver = null;resolver=null; }}  AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {AccessPath(SubAccessPath<T>[]accesses,Set<T>exclusions,, SubPathResolverSubPathResolver<<TT>> resolverresolver){ AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {AccessPath(SubAccessPath<T>[]accesses,Set<T>exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; this.resolver = resolver;this.resolver=resolver; }} public boolean isAccessInExclusions(T fieldReferences) {publicbooleanisAccessInExclusions(TfieldReferences){ return exclusions.contains(fieldReferences);returnexclusions.contains(fieldReferences); }}  public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<T>...fieldReferences){ if(fieldReferences.length > 0) {if(fieldReferences.length>0){ for(T field : fieldReferences[0].elements()) {for(Tfield:fieldReferences[0].elements()){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString()); if(merge) {if(merge){ for(int i=fieldReferences.length-1; i>=0; i--) {for(inti=fieldReferences.length-1;i>=0;i--){ for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].shouldBeMerged(fieldReferences[i])) {if(accesses[j].shouldBeMerged(fieldReferences[i])){ // [..., {j-i}, ...]// [..., {j-i}, ...]  AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);AccessPathBuilderbuilder=newAccessPathBuilder(j+fieldReferences.length-i); builder.keep(0, j);builder.keep(0,j); builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);builder.merge(j,accesses.length).mergeWithLast(fieldReferences,0,i); builder.append(fieldReferences, i+1, fieldReferences.length);builder.append(fieldReferences,i+1,fieldReferences.length); builder.removeExclusions();builder.removeExclusions(); return builder.build();returnbuilder.build(); }} }} }} }} //FIXME do we need to not merge sometimes?//FIXME do we need to not merge sometimes?//		if(merge) {//		if(merge) {//			for(int i=fieldReferences.length-1; i>=0; i--) {//			for(int i=fieldReferences.length-1; i>=0; i--) {//				for(int j=0; j<accesses.length; j++) {//				for(int j=0; j<accesses.length; j++) {//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {//					if(accesses[j].shouldBeMerged(fieldReferences[i])) {//						// [..., {j-i}, ...]//						// [..., {j-i}, ...]//						//						//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);//						AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);//						builder.keep(0, j);//						builder.keep(0, j);//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);//						builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);//						builder.append(fieldReferences, i+1, fieldReferences.length);//						builder.append(fieldReferences, i+1, fieldReferences.length);//						builder.removeExclusions();//						builder.removeExclusions();//						return builder.build();//						return builder.build();//					}//					}//				}//				}//			}//			}//		}//		}  AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+fieldReferences.length); builder.keep(0, accesses.length);builder.keep(0,accesses.length); }}  public AccessPath<T> build() {publicAccessPath<T>build(){ return new AccessPath<>(newAccesses, newExclusions, resolver);returnnewAccessPath<>(newAccesses,newExclusions,, resolverresolver); return new AccessPath<>(newAccesses, newExclusions);returnnewAccessPath<>(newAccesses,newExclusions); }} public void removeExclusions() {publicvoidremoveExclusions(){ }} public void mergeWithLast(SubAccessPath<T>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<T>[]fieldReferences,intstart,intendExcl){ newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); newAccesses[currentIndex-1] = newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccessesnewAccesses[[currentIndexcurrentIndex--11]] == newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); }} public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {publicAccessPathBuildermerge(intsrcIndex,intdestIndexExcl){ }} public AccessPath<T> prepend(T fieldRef) {publicAccessPath<T>prepend(TfieldRef){ for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].contains(fieldRef)) {if(accesses[j].contains(fieldRef)){ // [{0-j}, ...]// [{0-j}, ...]  AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length-j); builder.merge(0, j+1);builder.merge(0,j+1); builder.keep(j+1, accesses.length);builder.keep(j+1,accesses.length); return builder.build();returnbuilder.build(); }} }}//		for(int j=0; j<accesses.length; j++) {//		for(int j=0; j<accesses.length; j++) {////			if(accesses[j].contains(fieldRef)) {//			if(accesses[j].contains(fieldRef)) {////				// [{0-j}, ...]//				// [{0-j}, ...]//// // ////				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);//				AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);////				builder.merge(0, j+1);//				builder.merge(0, j+1);////				builder.keep(j+1, accesses.length);//				builder.keep(j+1, accesses.length);////				return builder.build();//				return builder.build();////			}//			}////		}//		}// AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+1); builder.append(fieldRef);builder.append(fieldRef); builder.keep(0, accesses.length);builder.keep(0,accesses.length); for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i].contains(field)) {if(accesses[i].contains(field)){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions,, resolverresolver); return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); elseelse return this;returnthis; }} public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(T...fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }} public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(Collection<T>fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }} public static enum PrefixTestResult {publicstaticenumPrefixTestResult{ }}  public Delta<T> getDeltaTo(AccessPath<T> accPath) {publicDelta<T>getDeltaTo(AccessPath<T>accPath){ assert isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX);assertisPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX); int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  }} break;break; }}  return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);returnnewDelta<T>(Arrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length),accPath.exclusions,accPath.resolver);//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);//		Set<T> exclusions = Sets.newHashSet(accPath.exclusions);//		exclusions.removeAll(this.exclusions);//		exclusions.removeAll(this.exclusions); Delta<T> delta = new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions);Delta<T>delta=newDelta<T>(Arrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length),accPath.exclusions); assert (isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX) && accPath.isPrefixOf(delta.applyTo(this, true)) == PrefixTestResult.GUARANTEED_PREFIX) assert(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)&&accPath.isPrefixOf(delta.applyTo(this,true))==PrefixTestResult.GUARANTEED_PREFIX) || (isPrefixOf(accPath) == PrefixTestResult.GUARANTEED_PREFIX && accPath.equals(delta.applyTo(this, true)));||(isPrefixOf(accPath)==PrefixTestResult.GUARANTEED_PREFIX&&accPath.equals(delta.applyTo(this,true))); return delta;returndelta; }}  public boolean contains(AccessPath<T> accPath) {publicbooleancontains(AccessPath<T>accPath){ assert accPath.accesses.length <= 1;assertaccPath.accesses.length<=1; if(accPath.accesses.length == 1) {if(accPath.accesses.length==1){ for(SubAccessPath<T> sub : accesses) {for(SubAccessPath<T>sub:accesses){ if(sub.elements().equals(accPath.accesses[0].elements())) {if(sub.elements().equals(accPath.accesses[0].elements())){ return true;returntrue; }} }} return false;returnfalse; }} elseelse return exclusions.containsAll(accPath.exclusions);returnexclusions.containsAll(accPath.exclusions); }}   public static class Delta<T extends FieldRef<T>> {publicstaticclassDelta<TextendsFieldRef<T>>{ final SubAccessPath<T>[] accesses;finalSubAccessPath<T>[]accesses; final Set<T> exclusions;finalSet<T>exclusions; final SubPathResolver<T> resolver;finalSubPathResolver<T>resolver; protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {protectedDelta(SubAccessPath<T>[]accesses,Set<T>exclusions,, SubPathResolverSubPathResolver<<TT>> resolverresolver){ protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions) {protectedDelta(SubAccessPath<T>[]accesses,Set<T>exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; this.resolver = resolver;this.resolver=resolver; }}  public boolean canBeAppliedTo(AccessPath<T> accPath) {publicbooleancanBeAppliedTo(AccessPath<T>accPath){ return !accPath.isAccessInExclusions(accesses);return!accPath.isAccessInExclusions(accesses); }}  public AccessPath<T> applyTo(AccessPath<T> accPath) {publicAccessPath<T>applyTo(AccessPath<T>accPath){ return applyTo(accPath, true);returnapplyTo(accPath,true); }}  public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {publicAccessPath<T>applyTo(AccessPath<T>accPath,booleanmerge){ AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);AccessPath<T>result=accPath.addFieldReference(merge,accesses).appendExcludedFieldReference(exclusions); if(resolver != null) {if(resolver!=null){ if(result.hasResolver())if(result.hasResolver()) throw new AssertionError();thrownewAssertionError(); result = result.setResolver(resolver);result=result.setResolver(resolver); }} return result;returnresult; }}  public static <T extends FieldRef<T>> Delta<T> empty() {publicstatic<TextendsFieldRef<T>>Delta<T>empty(){ return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);returnnewDelta<T>(newSubAccessPath[0],Sets.<T>newHashSet(),null); return accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);returnaccPath.addFieldReference(merge,accesses).appendExcludedFieldReference(exclusions); }}  @Override@Override String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result += "^" + Joiner.on(",").join(exclusions);result+="^"+Joiner.on(",").join(exclusions); if(resolver != null)if(resolver!=null) result+="["+resolver+"]";result+="["+resolver+"]"; return result;returnresult; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses); result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());result=prime*result+((exclusions==null)?0:exclusions.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; Delta other = (Delta) obj;Deltaother=(Delta)obj; if (!Arrays.equals(accesses, other.accesses))if(!Arrays.equals(accesses,other.accesses)) return false;returnfalse; if (exclusions == null) {if(exclusions==null){ if (other.exclusions != null)if(other.exclusions!=null) return false;returnfalse; } else if (!exclusions.equals(other.exclusions))}elseif(!exclusions.equals(other.exclusions)) return false;returnfalse; return true;returntrue; }} public static <T extends FieldRef<T>> Delta<T> empty() {publicstatic<TextendsFieldRef<T>>Delta<T>empty(){ return new Delta<T>(new SubAccessPath[0], Sets.<T>newHashSet());returnnewDelta<T>(newSubAccessPath[0],Sets.<T>newHashSet()); }} }}  public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {publicAccessPath<T>mergeExcludedFieldReferences(AccessPath<T>accPath){ HashSet<T> newExclusions = Sets.newHashSet(exclusions);HashSet<T>newExclusions=Sets.newHashSet(exclusions); newExclusions.addAll(accPath.exclusions);newExclusions.addAll(accPath.exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); }}  public boolean mayHaveEmptyAccessPath() {publicbooleanmayHaveEmptyAccessPath(){ return finalIndex() == 0;returnfinalIndex()==0; for(SubAccessPath<T> subAcc : accesses)for(SubAccessPath<T>subAcc:accesses) if(subAcc instanceof SpecificFieldAccess)if(subAccinstanceofSpecificFieldAccess) return false;returnfalse; return true;returntrue; }}  public boolean canRead(T field) {publicbooleancanRead(Tfield){ for(SubAccessPath<T> acc : accesses) {for(SubAccessPath<T>acc:accesses){ if(acc.contains(field))if(acc.contains(field)) return true;returntrue; if(acc instanceof SpecificFieldAccess)if(accinstanceofSpecificFieldAccess) return false;returnfalse; }} return false;returnfalse; }}  public boolean isEmpty() {publicbooleanisEmpty(){ return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();returnexclusions.isEmpty()&&accesses.length==0 &&&& !!hasResolverhasResolver();() return exclusions.isEmpty() && accesses.length == 0;returnexclusions.isEmpty()&&accesses.length==0; }}  @Override@Override int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses); result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());result=prime*result+((exclusions==null)?0:exclusions.hashCode()); result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());result=prime*result+((resolver==null)?0:resolver.hashCode()); return result;returnresult; }} return false;returnfalse; } else if (!exclusions.equals(other.exclusions))}elseif(!exclusions.equals(other.exclusions)) return false;returnfalse; if (resolver == null) {if(resolver==null){ if (other.resolver != null)if(other.resolver!=null) return false;returnfalse; } else if (!resolver.equals(other.resolver))}elseif(!resolver.equals(other.resolver)) return false;returnfalse; return true;returntrue; }} String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result += "^" + Joiner.on(",").join(exclusions);result+="^"+Joiner.on(",").join(exclusions); if(resolver != null)if(resolver!=null) result+="["+resolver+"]";result+="["+resolver+"]"; return result;returnresult; }}  Set<U> newExclusions = Sets.newHashSet();Set<U>newExclusions=Sets.newHashSet(); for(T f : exclusions)for(Tf:exclusions) newExclusions.add(function.apply(f));newExclusions.add(function.apply(f)); return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);returnnewAccessPath<U>(newAccesses,newExclusions,, nullnull /*FIXME*//*FIXME*/); return new AccessPath<U>(newAccesses, newExclusions);returnnewAccessPath<U>(newAccesses,newExclusions); }}  public AccessPath<T> removeAnyAccess() {publicAccessPath<T>removeAnyAccess(){ if(accesses.length > 0)if(accesses.length>0) return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);returnnewAccessPath<T>(newSubAccessPath[0],exclusions,, resolverresolver); return new AccessPath<T>(new SubAccessPath[0], exclusions);returnnewAccessPath<T>(newSubAccessPath[0],exclusions); elseelse return this;returnthis; }} int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  if(resolver != null) {if(resolver!=null){ if(!resolver.equals(accPath.resolver)) {if(!resolver.equals(accPath.resolver)){ return false;returnfalse; }} }} else if(accPath.resolver != null)elseif(accPath.resolver!=null) return false;returnfalse;   outer: while(true) {outer:while(true){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);Collection<Transition<T>>transitions=possibleTransitions(currIndex,false); Collection<Transition<T>> otherTransitions = accPath.possibleTransitions(otherIndex, false);Collection<Transition<T>>otherTransitions=accPath.possibleTransitions(otherIndex,false); }} public AccessPath<T> removeExclusions() {publicAccessPath<T>removeExclusions(){ return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);returnnewAccessPath<T>(accesses,Sets.<T>newHashSet(),, resolverresolver); return new AccessPath<T>(accesses, Sets.<T>newHashSet());returnnewAccessPath<T>(accesses,Sets.<T>newHashSet()); }} public SubAccessPath<T> getFirstAccess() {publicSubAccessPath<T>getFirstAccess(){ throw new IllegalArgumentException();thrownewIllegalArgumentException();  if(elements.size() == 1) {if(elements.size()==1){ return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions,, resolverresolver); return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions); }}  HashSet<T> newSet = Sets.newHashSet(elements);HashSet<T>newSet=Sets.newHashSet(elements); newSet.remove(field);newSet.remove(field); SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);SubAccessPath<T>[]newAccesses=Arrays.copyOf(accesses,accesses.length); newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);newAccesses[0]=newSetOfPossibleFieldAccesses<>(newSet); return new AccessPath<T>(newAccesses, exclusions, resolver);returnnewAccessPath<T>(newAccesses,exclusions,, resolverresolver); return new AccessPath<T>(newAccesses, exclusions);returnnewAccessPath<T>(newAccesses,exclusions); }} public AccessPath<T> setResolver(SubPathResolver<T> resolver) {publicAccessPath<T>setResolver(SubPathResolver<T>resolver){ return new AccessPath<T>(accesses, exclusions, resolver);returnnewAccessPath<T>(accesses,exclusions,resolver); }}  public SubPathResolver<T> getResolver() {publicSubPathResolver<T>getResolver(){ return resolver;returnresolver; }}  public boolean hasResolver() {publicbooleanhasResolver(){ return resolver != null;returnresolver!=null; }}  public AccessPath<T> decorateResolver(Constraint<T> constraint) {publicAccessPath<T>decorateResolver(Constraint<T>constraint){ return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));returnnewAccessPath<T>(accesses,exclusions,resolver.decorate(constraint)); }}  public class Iterator {publicclassIterator{ private int currentIndex = 0;privateintcurrentIndex=0;  return exclusions.contains(field);returnexclusions.contains(field); }}  public boolean hasResolver() {publicbooleanhasResolver(){ return resolver != null;returnresolver!=null; }} public Object getResolver() {publicObjectgetResolver(){ return resolver;returnresolver; }} }} public AccessPath<T>.Iterator iterator() {publicAccessPath<T>.Iteratoriterator(){








src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}












src/heros/alias/AccessPathHandler.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/AccessPathHandler.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.ReadFieldConstraint;










import heros.alias.FlowFunction.WriteFieldConstraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;





















public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private AccessPath<Field> accessPath;










 private Resolver<Field, Fact, Stmt, Method> resolver;





















 public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 this.accessPath = accessPath;










 this.resolver = resolver;










 }





















 public boolean canRead(Field field) {










 return accessPath.canRead(field);










 }










 










 public boolean mayCanRead(Field field) {










 return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));










 }










 










 public boolean mayBeEmpty() {










 return accessPath.mayHaveEmptyAccessPath();










 }





















 public boolean canOverwrite(Field fieldRef) {










 if(accessPath.hasEmptyAccessPath())










 return true;










 if(accessPath.getFirstAccess().contains(fieldRef))










 return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;










 return false;










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 }










 };










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {










 if(mayCanRead(field)) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 }










 };










 }










 else










 throw new IllegalArgumentException("Cannot read field "+field);










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {










 if(canOverwrite(field))










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 }










 };










 else










 throw new IllegalArgumentException("Cannot write field "+field);










 }










 










 public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {










 public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);










 }





















}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import heros.alias.FlowFunction.ReadFieldConstraint;importheros.alias.FlowFunction.ReadFieldConstraint;import heros.alias.FlowFunction.WriteFieldConstraint;importheros.alias.FlowFunction.WriteFieldConstraint;import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;importheros.alias.SubAccessPath.SetOfPossibleFieldAccesses;public class AccessPathHandler<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassAccessPathHandler<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ private AccessPath<Field> accessPath;privateAccessPath<Field>accessPath; private Resolver<Field, Fact, Stmt, Method> resolver;privateResolver<Field,Fact,Stmt,Method>resolver; public AccessPathHandler(AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {publicAccessPathHandler(AccessPath<Field>accessPath,Resolver<Field,Fact,Stmt,Method>resolver){ this.accessPath = accessPath;this.accessPath=accessPath; this.resolver = resolver;this.resolver=resolver; }} public boolean canRead(Field field) {publicbooleancanRead(Fieldfield){ return accessPath.canRead(field);returnaccessPath.canRead(field); }}  public boolean mayCanRead(Field field) {publicbooleanmayCanRead(Fieldfield){ return accessPath.canRead(field) || (accessPath.mayHaveEmptyAccessPath() && !accessPath.isAccessInExclusions(field));returnaccessPath.canRead(field)||(accessPath.mayHaveEmptyAccessPath()&&!accessPath.isAccessInExclusions(field)); }}  public boolean mayBeEmpty() {publicbooleanmayBeEmpty(){ return accessPath.mayHaveEmptyAccessPath();returnaccessPath.mayHaveEmptyAccessPath(); }} public boolean canOverwrite(Field fieldRef) {publicbooleancanOverwrite(FieldfieldRef){ if(accessPath.hasEmptyAccessPath())if(accessPath.hasEmptyAccessPath()) return true;returntrue; if(accessPath.getFirstAccess().contains(fieldRef))if(accessPath.getFirstAccess().contains(fieldRef)) return accessPath.getFirstAccess() instanceof SetOfPossibleFieldAccesses;returnaccessPath.getFirstAccess()instanceofSetOfPossibleFieldAccesses; return false;returnfalse; }}  public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));returnnewConstrainedFact<>(newWrappedFact<Field,Fact,Stmt,Method>(fact,accessPath,resolver)); }}  public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {publicConstrainedFact<Field,Fact,Stmt,Method>generateWithEmptyAccessPath(Factfact,ZeroHandler<Field>zeroHandler){ return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));returnnewConstrainedFact<>(newWrappedFact<>(fact,newAccessPath<Field>(),newZeroCallEdgeResolver<>(resolver.analyzer,zeroHandler))); }}  public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>prepend(finalFieldfield){ return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.prepend(field),resolver)); }} };}; }}  public ResultBuilder<Field, Fact, Stmt, Method> read(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>read(finalFieldfield){ if(mayCanRead(field)) {if(mayCanRead(field)){ return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(canRead(field))if(canRead(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.removeFirst(field),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));returnnewConstrainedFact<>(newWrappedFact<>(fact,newAccessPath<Field>(),resolver),newReadFieldConstraint<>(field)); }} };}; }} elseelse throw new IllegalArgumentException("Cannot read field "+field);thrownewIllegalArgumentException("Cannot read field "+field); }}  public ResultBuilder<Field, Fact, Stmt, Method> overwrite(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>overwrite(finalFieldfield){ if(canOverwrite(field))if(canOverwrite(field)) return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(accessPath.canRead(field)) {if(accessPath.canRead(field)){ AccessPath<Field> tempAccPath = accessPath.removeRepeatableFirstAccess(field);AccessPath<Field>tempAccPath=accessPath.removeRepeatableFirstAccess(field); if(tempAccPath.hasEmptyAccessPath())if(tempAccPath.hasEmptyAccessPath()) return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,tempAccPath.appendExcludedFieldReference(field),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,tempAccPath,resolver)); } else if(accessPath.isAccessInExclusions(field))}elseif(accessPath.isAccessInExclusions(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath,resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));returnnewConstrainedFact<>(newWrappedFact<>(fact,accessPath.appendExcludedFieldReference(field),resolver),newWriteFieldConstraint<>(field)); }} };}; elseelse throw new IllegalArgumentException("Cannot write field "+field);thrownewIllegalArgumentException("Cannot write field "+field); }}  public static interface ResultBuilder<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Stmt, Method> {publicstaticinterfaceResultBuilder<FieldRefextendsAccessPath.FieldRef<FieldRef>,FactAbstraction,Stmt,Method>{ public ConstrainedFact<FieldRef, FactAbstraction, Stmt, Method> generate(FactAbstraction fact);publicConstrainedFact<FieldRef,FactAbstraction,Stmt,Method>generate(FactAbstractionfact); }}}}








src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}












src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0







View file @ 55cdd2d8








src/heros/alias/AccessPathUtil.java

deleted


100644 â†’ 0









View file @ 55cdd2d8


55cdd2d8










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {










 if(prefixCandidate.getBaseValue() == null) {










 if(fact.getBaseValue() != null)










 return PrefixTestResult.NO_PREFIX;










 } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return PrefixTestResult.NO_PREFIX;










 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();





















 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {










 if(fact.getAccessPath().equals(accPath))










 return fact;










 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Set;importjava.util.Set;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class AccessPathUtil {publicclassAccessPathUtil{ public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> PrefixTestResult isPrefixOf(D prefixCandidate, D fact) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>PrefixTestResultisPrefixOf(DprefixCandidate,Dfact){ if(prefixCandidate.getBaseValue() == null) {if(prefixCandidate.getBaseValue()==null){ if(fact.getBaseValue() != null)if(fact.getBaseValue()!=null) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; } else if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))}elseif(!prefixCandidate.getBaseValue().equals(fact.getBaseValue())) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX;  return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());returnprefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath()); }} public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<Delta<FieldRef>>getDelta(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();AccessPath<FieldRef>concreteAccessPath=sourceFact.getAccessPath(); AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();AccessPath<FieldRef>abstractAccessPath=summary.getSourceFact().getAccessPath(); AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();AccessPath<FieldRef>targetAccessPath=summary.getTargetFact().getAccessPath();  if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(AccessPath.Delta.<FieldRef> empty());returnOptional.of(AccessPath.Delta.<FieldRef>empty()); Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);Delta<FieldRef>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(!delta.canBeAppliedTo(targetAccessPath))if(!delta.canBeAppliedTo(targetAccessPath)) return Optional.absent();returnOptional.absent(); elseelse return Optional.of(delta);returnOptional.of(delta); }}  public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();AccessPath<FieldRef>concreteAccessPath=sourceFact.getAccessPath(); AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();AccessPath<FieldRef>abstractAccessPath=summary.getSourceFact().getAccessPath(); AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();AccessPath<FieldRef>targetAccessPath=summary.getTargetFact().getAccessPath(); if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(summary.getTargetFact());returnOptional.of(summary.getTargetFact());  Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);Delta<FieldRef>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(!delta.canBeAppliedTo(targetAccessPath))if(!delta.canBeAppliedTo(targetAccessPath)) return Optional.absent();returnOptional.absent();  AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);AccessPath<FieldRef>result=delta.applyTo(targetAccessPath); return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result)); }} public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithAccessPath(D fact, AccessPath<FieldRef> accPath) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>DcloneWithAccessPath(Dfact,AccessPath<FieldRef>accPath){ if(fact.getAccessPath().equals(accPath))if(fact.getAccessPath().equals(accPath)) return fact;returnfact; elseelse return fact.cloneWithAccessPath(accPath);returnfact.cloneWithAccessPath(accPath); }} }}








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......












src/heros/alias/BiDiFieldSensitiveIFDSSolver.java








View file @ 3398e46f








src/heros/alias/BiDiFieldSensitiveIFDSSolver.java










View file @ 3398e46f


3398e46f



......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......






......@@ -48,7 +48,7 @@ import com.google.common.collect.Sets;









 * @param <M> see {@link IFDSSolver}










 * @param <I> see {@link IFDSSolver}










 */










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {










public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;










 private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;



......


 * @param <M> see {@link IFDSSolver} * @param <M> see {@link IFDSSolver} * @param <I> see {@link IFDSSolver} * @param <I> see {@link IFDSSolver} */ */public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassBiDiFieldSensitiveIFDSSolver<N,BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,D extendsextends FieldSensitiveFactFieldSensitiveFact<<BaseValueBaseValue,, FieldRefFieldRef,, DD>,>M,IextendsInterproceduralCFG<N,M>>{public class BiDiFieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {publicclassBiDiFieldSensitiveIFDSSolver<N,BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,D,M,IextendsInterproceduralCFG<N,M>>{ private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> forwardProblem;privatefinalIFDSTabulationProblem<N,FieldRef,AbstractionWithSourceStmt,M,I>forwardProblem; private final IFDSTabulationProblem<N, FieldRef, AbstractionWithSourceStmt, M, I> backwardProblem;privatefinalIFDSTabulationProblem<N,FieldRef,AbstractionWithSourceStmt,M,I>backwardProblem;








src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}












src/heros/alias/CacheMap.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/CacheMap.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}













package heros.alias;





















import java.util.Collection;










import java.util.HashMap;










import java.util.Map;










import java.util.Set;





















public abstract class CacheMap<K, V> implements Map<K, V> {





















 private HashMap<K, V> map;





















 public CacheMap() {










 map = new HashMap<K, V>();










 }





















 @Override










 public int size() {










 return map.size();










 }





















 @Override










 public boolean isEmpty() {










 return map.isEmpty();










 }





















 @Override










 public boolean containsKey(Object key) {










 return map.containsKey(key);










 }





















 @Override










 public boolean containsValue(Object value) {










 return map.containsValue(value);










 }





















 protected abstract V createItem(K key);





















 public V getOrCreate(K key) {










 if (!map.containsKey(key)) {










 V value = createItem((K) key);










 map.put((K) key, value);










 return value;










 }





















 return map.get(key);










 }





















 @Override










 public V get(Object key) {










 return map.get(key);










 }





















 @Override










 public V put(K key, V value) {










 return map.put(key, value);










 }





















 @Override










 public V remove(Object key) {










 return map.remove(key);










 }





















 @Override










 public void putAll(Map<? extends K, ? extends V> m) {










 map.putAll(m);










 }





















 @Override










 public void clear() {










 map.clear();










 }





















 @Override










 public Set<K> keySet() {










 return map.keySet();










 }





















 @Override










 public Collection<V> values() {










 return map.values();










 }





















 @Override










 public Set<java.util.Map.Entry<K, V>> entrySet() {










 return map.entrySet();










 }





















}


package heros.alias;packageheros.alias;import java.util.Collection;importjava.util.Collection;import java.util.HashMap;importjava.util.HashMap;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;public abstract class CacheMap<K, V> implements Map<K, V> {publicabstractclassCacheMap<K,V>implementsMap<K,V>{ private HashMap<K, V> map;privateHashMap<K,V>map; public CacheMap() {publicCacheMap(){ map = new HashMap<K, V>();map=newHashMap<K,V>(); }} @Override@Override public int size() {publicintsize(){ return map.size();returnmap.size(); }} @Override@Override public boolean isEmpty() {publicbooleanisEmpty(){ return map.isEmpty();returnmap.isEmpty(); }} @Override@Override public boolean containsKey(Object key) {publicbooleancontainsKey(Objectkey){ return map.containsKey(key);returnmap.containsKey(key); }} @Override@Override public boolean containsValue(Object value) {publicbooleancontainsValue(Objectvalue){ return map.containsValue(value);returnmap.containsValue(value); }} protected abstract V createItem(K key);protectedabstractVcreateItem(Kkey); public V getOrCreate(K key) {publicVgetOrCreate(Kkey){ if (!map.containsKey(key)) {if(!map.containsKey(key)){ V value = createItem((K) key);Vvalue=createItem((K)key); map.put((K) key, value);map.put((K)key,value); return value;returnvalue; }} return map.get(key);returnmap.get(key); }} @Override@Override public V get(Object key) {publicVget(Objectkey){ return map.get(key);returnmap.get(key); }} @Override@Override public V put(K key, V value) {publicVput(Kkey,Vvalue){ return map.put(key, value);returnmap.put(key,value); }} @Override@Override public V remove(Object key) {publicVremove(Objectkey){ return map.remove(key);returnmap.remove(key); }} @Override@Override public void putAll(Map<? extends K, ? extends V> m) {publicvoidputAll(Map<?extendsK,?extendsV>m){ map.putAll(m);map.putAll(m); }} @Override@Override public void clear() {publicvoidclear(){ map.clear();map.clear(); }} @Override@Override public Set<K> keySet() {publicSet<K>keySet(){ return map.keySet();returnmap.keySet(); }} @Override@Override public Collection<V> values() {publicCollection<V>values(){ return map.values();returnmap.values(); }} @Override@Override public Set<java.util.Map.Entry<K, V>> entrySet() {publicSet<java.util.Map.Entry<K,V>>entrySet(){ return map.entrySet();returnmap.entrySet(); }}}}








src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file












src/heros/alias/CallEdgeResolver.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/CallEdgeResolver.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;
































class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 super(analyzer);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { 










 log("Resolve: "+constraint);










 if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {










 AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);










 PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);










 nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);










 }










 }










 










 //FIXME: this is a dirty hack (and unsound?!)










 private boolean doesContain(Constraint<Field> constraint) {










 AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);










 return analyzer.getAccessPath().contains(accPath);










 }





















 @Override










 public String toString() {










 return "";










 }










 










 @Override










 protected void log(String message) {










 analyzer.log(message);










 }
































}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;class CallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {classCallEdgeResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ public CallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {publicCallEdgeResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer){ super(analyzer);super(analyzer); }} @Override@Override public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) { publicvoidresolve(Constraint<Field>constraint,InterestCallback<Field,Fact,Stmt,Method>callback){ log("Resolve: "+constraint);log("Resolve: "+constraint); if(constraint.canBeAppliedTo(analyzer.getAccessPath()) && !analyzer.isLocked() && !doesContain(constraint)) {if(constraint.canBeAppliedTo(analyzer.getAccessPath())&&!analyzer.isLocked()&&!doesContain(constraint)){ AccessPath<Field> newAccPath = constraint.applyToAccessPath(analyzer.getAccessPath(), true);AccessPath<Field>newAccPath=constraint.applyToAccessPath(analyzer.getAccessPath(),true); PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method> nestedAnalyzer = analyzer.getOrCreateNestedAnalyzer(newAccPath);PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>nestedAnalyzer=analyzer.getOrCreateNestedAnalyzer(newAccPath); nestedAnalyzer.getCallEdgeResolver().registerCallback(callback);nestedAnalyzer.getCallEdgeResolver().registerCallback(callback); }} }}  //FIXME: this is a dirty hack (and unsound?!)//FIXME: this is a dirty hack (and unsound?!) private boolean doesContain(Constraint<Field> constraint) {privatebooleandoesContain(Constraint<Field>constraint){ AccessPath<Field> accPath = constraint.applyToAccessPath(new AccessPath<Field>(), true);AccessPath<Field>accPath=constraint.applyToAccessPath(newAccessPath<Field>(),true); return analyzer.getAccessPath().contains(accPath);returnanalyzer.getAccessPath().contains(accPath); }} @Override@Override public String toString() {publicStringtoString(){ return "";return""; }}  @Override@Override protected void log(String message) {protectedvoidlog(Stringmessage){ analyzer.log(message);analyzer.log(message); }}}}








src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}












src/heros/alias/Context.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/Context.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {





















 public final InterproceduralCFG<Statement, Method> icfg;










 public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;










 public final Scheduler scheduler;










 public final FactAbstraction zeroValue;










 public final boolean followReturnsPastSeeds;










 public final FactMergeHandler<FactAbstraction> factHandler;










 public final ZeroHandler<FieldRef> zeroHandler;










 










 Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, 










 Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {










 this.icfg = icfg;










 this.flowProcessor = flowProcessor;










 this.scheduler = scheduler;










 this.zeroValue = zeroValue;










 this.followReturnsPastSeeds = followReturnsPastSeeds;










 this.factHandler = factHandler;










 this.zeroHandler = zeroHandler;










 }










 










 public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.InterproceduralCFG;importheros.InterproceduralCFG;public abstract class Context<FieldRef extends AccessPath.FieldRef<FieldRef>, FactAbstraction, Statement, Method> {publicabstractclassContext<FieldRefextendsAccessPath.FieldRef<FieldRef>,FactAbstraction,Statement,Method>{ public final InterproceduralCFG<Statement, Method> icfg;publicfinalInterproceduralCFG<Statement,Method>icfg; public final FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor;publicfinalFlowFunctionProcessor<FactAbstraction,Statement,Method,FieldRef>flowProcessor; public final Scheduler scheduler;publicfinalSchedulerscheduler; public final FactAbstraction zeroValue;publicfinalFactAbstractionzeroValue; public final boolean followReturnsPastSeeds;publicfinalbooleanfollowReturnsPastSeeds; public final FactMergeHandler<FactAbstraction> factHandler;publicfinalFactMergeHandler<FactAbstraction>factHandler; public final ZeroHandler<FieldRef> zeroHandler;publicfinalZeroHandler<FieldRef>zeroHandler;  Context(InterproceduralCFG<Statement, Method> icfg, FlowFunctionProcessor<FactAbstraction, Statement, Method, FieldRef> flowProcessor, Context(InterproceduralCFG<Statement,Method>icfg,FlowFunctionProcessor<FactAbstraction,Statement,Method,FieldRef>flowProcessor, Scheduler scheduler, FactAbstraction zeroValue, boolean followReturnsPastSeeds, FactMergeHandler<FactAbstraction> factHandler, ZeroHandler<FieldRef> zeroHandler) {Schedulerscheduler,FactAbstractionzeroValue,booleanfollowReturnsPastSeeds,FactMergeHandler<FactAbstraction>factHandler,ZeroHandler<FieldRef>zeroHandler){ this.icfg = icfg;this.icfg=icfg; this.flowProcessor = flowProcessor;this.flowProcessor=flowProcessor; this.scheduler = scheduler;this.scheduler=scheduler; this.zeroValue = zeroValue;this.zeroValue=zeroValue; this.followReturnsPastSeeds = followReturnsPastSeeds;this.followReturnsPastSeeds=followReturnsPastSeeds; this.factHandler = factHandler;this.factHandler=factHandler; this.zeroHandler = zeroHandler;this.zeroHandler=zeroHandler; }}  public abstract MethodAnalyzer<FieldRef, FactAbstraction, Statement, Method> getAnalyzer(Method method);publicabstractMethodAnalyzer<FieldRef,FactAbstraction,Statement,Method>getAnalyzer(Methodmethod);}}








src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}












src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/ControlFlowJoinResolver.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private boolean recursiveLock = false;










 private Stmt joinStmt;










 private AccessPath<Field> resolvedAccPath;










 private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();










 private boolean propagated = false;










 private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;





















 public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {










 this(analyzer, joinStmt, new AccessPath<Field>(), null);










 }










 










 private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.joinStmt = joinStmt;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 }





















 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {










 if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Fact "+fact);










 if(!incomingFacts.add(fact))










 return;










 










 interest(analyzer, this);










 for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(fact);










 










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 }










 else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {










 ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);










 }





















 @Override










 public void canBeResolvedEmpty() {










 ControlFlowJoinResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 










 private boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 recursiveLock = true;










 ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 recursiveLock = false;










 }










 










 private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 










 final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {










 nestedResolver.addIncoming(incFact);










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }





















 @Override










 protected void log(String message) {










 analyzer.log("Join Stmt "+toString()+": "+message);










 }





















 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+joinStmt+">";










 }





















 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }





















 public Stmt getJoinStmt() {










 return joinStmt;










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class ControlFlowJoinResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassControlFlowJoinResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ private boolean recursiveLock = false;privatebooleanrecursiveLock=false; private Stmt joinStmt;privateStmtjoinStmt; private AccessPath<Field> resolvedAccPath;privateAccessPath<Field>resolvedAccPath; private Set<WrappedFact<Field, Fact, Stmt, Method>> incomingFacts = Sets.newHashSet();privateSet<WrappedFact<Field,Fact,Stmt,Method>>incomingFacts=Sets.newHashSet(); private boolean propagated = false;privatebooleanpropagated=false; private Map<AccessPath<Field>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();privateMap<AccessPath<Field>,ControlFlowJoinResolver<Field,Fact,Stmt,Method>>nestedResolvers=Maps.newHashMap(); private ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent;privateControlFlowJoinResolver<Field,Fact,Stmt,Method>parent; public ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt) {publicControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,StmtjoinStmt){ this(analyzer, joinStmt, new AccessPath<Field>(), null);this(analyzer,joinStmt,newAccessPath<Field>(),null); }}  private ControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt joinStmt, AccessPath<Field> resolvedAccPath, ControlFlowJoinResolver<Field, Fact, Stmt, Method> parent) {privateControlFlowJoinResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,StmtjoinStmt,AccessPath<Field>resolvedAccPath,ControlFlowJoinResolver<Field,Fact,Stmt,Method>parent){ super(analyzer);super(analyzer); this.joinStmt = joinStmt;this.joinStmt=joinStmt; this.resolvedAccPath = resolvedAccPath;this.resolvedAccPath=resolvedAccPath; this.parent = parent;this.parent=parent; }} public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact) {publicvoidaddIncoming(finalWrappedFact<Field,Fact,Stmt,Method>fact){ if(resolvedAccPath.isPrefixOf(fact.getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {if(resolvedAccPath.isPrefixOf(fact.getAccessPath())==PrefixTestResult.GUARANTEED_PREFIX){ log("Incoming Fact "+fact);log("Incoming Fact "+fact); if(!incomingFacts.add(fact))if(!incomingFacts.add(fact)) return;return;  interest(analyzer, this);interest(analyzer,this); for(ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())for(ControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver:nestedResolvers.values()) nestedResolver.addIncoming(fact);nestedResolver.addIncoming(fact);  if(!propagated) {if(!propagated){ propagated=true;propagated=true; analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(analyzer.processFlowFromJoinStmt(newWrappedFactAtStatement<>(joinStmt,newWrappedFact<>( fact.getFact(), new AccessPath<Field>(), this)));fact.getFact(),newAccessPath<Field>(),this))); }} }} else if(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {elseif(fact.getAccessPath().isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);Delta<Field>delta=fact.getAccessPath().getDeltaTo(resolvedAccPath); fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {fact.getResolver().resolve(newDeltaConstraint<>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {Resolver<Field,Fact,Stmt,Method>resolver){ ControlFlowJoinResolver.this.interest(analyzer, ControlFlowJoinResolver.this);ControlFlowJoinResolver.this.interest(analyzer,ControlFlowJoinResolver.this); }} @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ ControlFlowJoinResolver.this.canBeResolvedEmpty();ControlFlowJoinResolver.this.canBeResolvedEmpty(); }} });}); }} }}  private boolean isLocked() {privatebooleanisLocked(){ if(recursiveLock)if(recursiveLock) return true;returntrue; if(parent == null)if(parent==null) return false;returnfalse; return parent.isLocked();returnparent.isLocked(); }}  @Override@Override public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {publicvoidresolve(Constraint<Field>constraint,finalInterestCallback<Field,Fact,Stmt,Method>callback){ log("Resolve: "+constraint);log("Resolve: "+constraint); if(!constraint.canBeAppliedTo(resolvedAccPath) || isLocked())if(!constraint.canBeAppliedTo(resolvedAccPath)||isLocked()) return;return;  AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath,false); recursiveLock = true;recursiveLock=true; ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);ControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver=getOrCreateNestedResolver(candidateAccPath); if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath,false))) throw new AssertionError();thrownewAssertionError();  nestedResolver.registerCallback(callback);nestedResolver.registerCallback(callback); recursiveLock = false;recursiveLock=false; }}  private ControlFlowJoinResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {privateControlFlowJoinResolver<Field,Fact,Stmt,Method>getOrCreateNestedResolver(AccessPath<Field>candidateAccPath){ if(resolvedAccPath.equals(candidateAccPath))if(resolvedAccPath.equals(candidateAccPath)) return this;returnthis;  if(!nestedResolvers.containsKey(candidateAccPath)) {if(!nestedResolvers.containsKey(candidateAccPath)){ assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;assertresolvedAccPath.getDeltaTo(candidateAccPath).accesses.length<=1;  final ControlFlowJoinResolver<Field, Fact, Stmt, Method> nestedResolver = new ControlFlowJoinResolver<>(analyzer, joinStmt, candidateAccPath, this);finalControlFlowJoinResolver<Field,Fact,Stmt,Method>nestedResolver=newControlFlowJoinResolver<>(analyzer,joinStmt,candidateAccPath,this); nestedResolver.propagated = true;nestedResolver.propagated=true; nestedResolvers.put(candidateAccPath, nestedResolver);nestedResolvers.put(candidateAccPath,nestedResolver); for(WrappedFact<Field, Fact, Stmt, Method> incFact: incomingFacts) {for(WrappedFact<Field,Fact,Stmt,Method>incFact:incomingFacts){ nestedResolver.addIncoming(incFact);nestedResolver.addIncoming(incFact); } } }} return nestedResolvers.get(candidateAccPath);returnnestedResolvers.get(candidateAccPath); }} @Override@Override protected void log(String message) {protectedvoidlog(Stringmessage){ analyzer.log("Join Stmt "+toString()+": "+message);analyzer.log("Join Stmt "+toString()+": "+message); }} @Override@Override public String toString() {publicStringtoString(){ return "<"+resolvedAccPath+":"+joinStmt+">";return"<"+resolvedAccPath+":"+joinStmt+">"; }} public AccessPath<Field> getResolvedAccessPath() {publicAccessPath<Field>getResolvedAccessPath(){ return resolvedAccPath;returnresolvedAccPath; }} public Stmt getJoinStmt() {publicStmtgetJoinStmt(){ return joinStmt;returnjoinStmt; }}}}








src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file












src/heros/alias/Debugger.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/Debugger.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.InterproceduralCFG;





















public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {





















 public abstract void setICFG(I icfg);





















 public abstract void initialSeed(Stmt stmt);





















 










 public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 @Override










 public void setICFG(I icfg) {










 










 }





















 @Override










 public void initialSeed(Stmt stmt) {










 










 }










 










 }










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.InterproceduralCFG;importheros.InterproceduralCFG;public interface Debugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> {publicinterfaceDebugger<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>{ public abstract void setICFG(I icfg);publicabstractvoidsetICFG(Iicfg); public abstract void initialSeed(Stmt stmt);publicabstractvoidinitialSeed(Stmtstmt);  public static class NullDebugger <Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicstaticclassNullDebugger<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ @Override@Override public void setICFG(I icfg) {publicvoidsetICFG(Iicfg){  }} @Override@Override public void initialSeed(Stmt stmt) {publicvoidinitialSeed(Stmtstmt){  }}  }}}}








src/heros/alias/DeltaConstraint.java








View file @ 3398e46f






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}












src/heros/alias/DeltaConstraint.java








View file @ 3398e46f








src/heros/alias/DeltaConstraint.java










View file @ 3398e46f


3398e46f



......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}






......@@ -21,13 +21,13 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 public DeltaConstraint(Delta<FieldRef> delta) {










 this.delta = delta;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 return delta.applyTo(accPath, !sourceFact);










 }





















 @Override



......@@ -35,4 +35,35 @@ public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> imp









 return delta.canBeAppliedTo(accPath);










 }





















 @Override










 public String toString() {










 return delta.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DeltaConstraint other = (DeltaConstraint) obj;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 return true;










 }










 










 










}


 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);delta=accPathAtCaller.getDeltaTo(accPathAtCallee); }} public DeltaConstraint(Delta<FieldRef> delta) {publicDeltaConstraint(Delta<FieldRef>delta){ this.delta = delta;this.delta=delta; }}  @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,booleansourceFact){ if(accPath.hasResolver()) {if(accPath.hasResolver()){ return delta.applyTo(accPath, sourceFact).decorateResolver(this);returndelta.applyTo(accPath,sourceFact).decorateResolver(this); }} elseelse return delta.applyTo(accPath, sourceFact);returndelta.applyTo(accPath,sourceFact); return delta.applyTo(accPath, !sourceFact);returndelta.applyTo(accPath,!sourceFact); }} @Override@Override return delta.canBeAppliedTo(accPath);returndelta.canBeAppliedTo(accPath); }} @Override@Override public String toString() {publicStringtoString(){ return delta.toString();returndelta.toString(); }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((delta == null) ? 0 : delta.hashCode());result=prime*result+((delta==null)?0:delta.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; DeltaConstraint other = (DeltaConstraint) obj;DeltaConstraintother=(DeltaConstraint)obj; if (delta == null) {if(delta==null){ if (other.delta != null)if(other.delta!=null) return false;returnfalse; } else if (!delta.equals(other.delta))}elseif(!delta.equals(other.delta)) return false;returnfalse; return true;returntrue; }}  }}








src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}












src/heros/alias/FactAtStatement.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/FactAtStatement.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















public class FactAtStatement<Fact, Stmt> {





















 public final Fact fact;










 public final Stmt stmt;





















 public FactAtStatement(Fact fact, Stmt stmt) {










 this.fact = fact;










 this.stmt = stmt;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 FactAtStatement other = (FactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class FactAtStatement<Fact, Stmt> {publicclassFactAtStatement<Fact,Stmt>{ public final Fact fact;publicfinalFactfact; public final Stmt stmt;publicfinalStmtstmt; public FactAtStatement(Fact fact, Stmt stmt) {publicFactAtStatement(Factfact,Stmtstmt){ this.fact = fact;this.fact=fact; this.stmt = stmt;this.stmt=stmt; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode()); result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());result=prime*result+((stmt==null)?0:stmt.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; FactAtStatement other = (FactAtStatement) obj;FactAtStatementother=(FactAtStatement)obj; if (fact == null) {if(fact==null){ if (other.fact != null)if(other.fact!=null) return false;returnfalse; } else if (!fact.equals(other.fact))}elseif(!fact.equals(other.fact)) return false;returnfalse; if (stmt == null) {if(stmt==null){ if (other.stmt != null)if(other.stmt!=null) return false;returnfalse; } else if (!stmt.equals(other.stmt))}elseif(!stmt.equals(other.stmt)) return false;returnfalse; return true;returntrue; }}}}








src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}












src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java








View file @ 3398e46f








src/heros/alias/SubPathResolver.java

â†’

src/heros/alias/FactMergeHandler.java





SubPathResolvFactMergeHandl




View file @ 3398e46f


3398e46f



......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}






......@@ -10,9 +10,9 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










public interface FactMergeHandler<Fact> {





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










 void merge(Fact previousFact, Fact currentFact);










 










 void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.Constraint;importimport heros.alias.FlowFunction.Constraintheros.alias.FlowFunction.Constraint;;public interface FactMergeHandler<Fact> {publicpublic interfaceinterface FactMergeHandlerFactMergeHandler<<FactFact>> {{public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {publicpublic interfaceinterface SubPathResolverSubPathResolver<<TT extendsextends AccessPathAccessPath..FieldRefFieldRef<<TT>>>> {{ SubPathResolver<T> decorate(Constraint<T> constraint);SubPathResolverSubPathResolver<<TT>> decoratedecorate((ConstraintConstraint<<TT>> constraintconstraint); void merge(Fact previousFact, Fact currentFact); voidvoid mergemerge((FactFact previousFactpreviousFact,, FactFact currentFactcurrentFact););  void restoreCallingContext(Fact factAtReturnSite, Fact factAtCallSite);voidvoid restoreCallingContextrestoreCallingContext((FactFact factAtReturnSitefactAtReturnSite,, FactFact factAtCallSitefactAtCallSite);}}








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 3398e46f








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ 3398e46f


3398e46f



......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}






......@@ -10,146 +10,41 @@









 ******************************************************************************/










package heros.alias;





















import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;










import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.Pair;










import heros.solver.PathEdge;





















import java.io.BufferedOutputStream;










import java.io.FileNotFoundException;










import java.io.FileOutputStream;










import java.io.FileWriter;










import java.io.IOException;










import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.Comparator;










import java.util.Enumeration;










import java.util.HashMap;










import java.util.Iterator;










import java.util.LinkedList;










import java.util.List;










import java.util.Map;










import java.util.Map.Entry;










import java.util.PriorityQueue;










import java.util.Set;










import java.util.concurrent.LinkedBlockingQueue;










import java.util.concurrent.TimeUnit;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;










public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {





















import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Iterators;










import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;










import com.sun.org.apache.xpath.internal.axes.IteratorPool;





















public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel










 (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();










 










 protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);





















 //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace










 public static final boolean DEBUG = logger.isDebugEnabled();





















 protected CountingThreadPoolExecutor executor;










 










 @DontSynchronize("only used by single thread")










 protected int numThreads;










 










 @SynchronizedBy("thread safe data structure, consistent locking when used")










 protected final JumpFunctions<N,D> jumpFn;










 










 @SynchronizedBy("thread safe data structure, only modified internally")










 protected final I icfg;










 










 //stores summaries that were queried before they were computed










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on 'incoming'")










 protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =










 new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();










 










 //edges going along calls










 //see CC 2010 paper by Naeem, Lhotak and Rodriguez










 @SynchronizedBy("consistent lock on field")










 protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =










 new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();










 










 protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;










 










 @DontSynchronize("benign races")










 public long propagationCount;










 










 @DontSynchronize("stateless")










 protected final D zeroValue;










 private Scheduler scheduler = new Scheduler();










 private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;










 










 @DontSynchronize("readOnly")










 protected final FlowFunctionCache<N,D,M> ffCache = null; 










 










 @DontSynchronize("readOnly")










 protected final boolean followReturnsPastSeeds;





















 private LinkedList<PathEdgeProcessingTask> worklist;










 










 










 /**










	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }





















 /**










	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling










	 * {@link #solve()}.










	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;










		} else {










			ffCache = null;










		}*/










 this.flowFunctions = flowFunctions;










 this.initialSeeds = tabulationProblem.initialSeeds();










 this.jumpFn = new JumpFunctions<N,D>();










 this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();










 this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe










 this.executor = getExecutor();










 this.worklist = Lists.newLinkedList();










 private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {










 @Override










 protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {










 return new MethodAnalyzer<>(key, context);










 }










 };





















 private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;










 private Context<FieldRef, D, N,M> context;










 private Debugger<FieldRef, D, N, M, I> debugger;





















 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {










 this.tabulationProblem = tabulationProblem;










 this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;










 this.debugger.setICFG(tabulationProblem.interproceduralCFG());










 flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());










 context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), 










 tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {










 @Override










 public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 return methodAnalyzers.getOrCreate(method);










 }










 };










 }





















 /**



......@@ -157,8 +52,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 */










 public void solve() { 










 submitInitialSeeds();










 awaitCompletionComputeValuesAndShutdown();










 writeDebugFile();










 scheduler.runAndAwaitCompletion();










 }





















 /**



......@@ -167,1110 +61,13 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.









	 * their own. Normally, {@link #solve()} should be called instead.










	 */










 protected void submitInitialSeeds() {










 for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {










 for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {










 N startPoint = seed.getKey();










 for(D val: seed.getValue())










 propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);










 jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));










 }










 }





















 /**










	 * Awaits the completion of the exploded super graph. When complete, computes result values,










	 * shuts down the executor and returns.










	 */










 protected void awaitCompletionComputeValuesAndShutdown() {










//		{










//			//run executor and await termination of tasks










//			runExecutorAndAwaitCompletion();










//		}










 if(logger.isDebugEnabled())










 printStats();





















 //ask executor to shut down;










 //this will cause new submissions to the executor to be rejected,










 //but at this point all tasks should have completed anyway










//		executor.shutdown();










 //similarly here: we await termination, but this should happen instantaneously,










 //as all tasks should have completed










 runExecutorAndAwaitCompletion();










 }





















 protected boolean hasWork() {










 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */










 private void runExecutorAndAwaitCompletion() {










//		try {










//			executor.awaitCompletion();










//		} catch (InterruptedException e) {










//			e.printStackTrace();










//		}










//		Throwable exception = executor.getException();










//		if(exception!=null) {










//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }





















 /**










     * Dispatch the processing of a given edge. It may be executed in a different thread.










     * @param edge the edge to process










     */










 protected void scheduleEdgeProcessing(PathEdge<N,D> edge){










 // If the executor has been killed, there is little point










 // in submitting new tasks










//    	if (executor.isTerminating())










//    		return;










//    	executor.execute(new PathEdgeProcessingTask(edge));










 worklist.add(new PathEdgeProcessingTask(edge));










 propagationCount++;










 }










 










 /**










	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.










	 * 










	 * For each possible callee, registers incoming call edges.










	 * Also propagates call-to-return flows and summarized callee flows within the caller. 










	 * 










	 * @param edge an edge whose target node resembles a method call










	 */










 private void processCall(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); // a call node; line 14...





















 logger.trace("Processing call to {}", n);





















 final D d2 = edge.factAtTarget();










 assert d2 != null;










 Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);










 










 //for each possible callee










 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(ConstrainedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());










 propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15










 }










 










 //register the fact that <sp,d3> has an incoming edge from <n,d2>










 //line 15.1 of Naeem/Lhotak/Rodriguez










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);










 if (!addIncoming(sCalledProcN, incomingEdge))










 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());










 










 //still line 15.2 of Naeem/Lhotak/Rodriguez










 //for each already-queried exit value <eP,d4> reachable from <sP,d3>,










 //create new caller-side jump functions to the return sites










 //because we have observed a potentially new incoming edge into <sP,d3>










 if (endSumm != null)










 for(SummaryEdge<D, N> summary: endSumm) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);










 if(delta.isPresent()) {










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);










 resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());










 










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);










 propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);










 }










 }










 }










 }










 }










 }










 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);










 }










 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);










 }










 }










 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 if(edges.size() > 100)










 System.out.println("Paused edges for method "+method+": "+edges.size());










 










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && 










 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();










 decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 else {










 propagateConstrained(new CallConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction










	 * @param callFlowFunction The call flow function to compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }





















 /**










	 * Computes the call-to-return flow function for the given call-site










	 * abstraction










	 * @param callToReturnFlowFunction The call-to-return flow function to










	 * compute










	 * @param d1 The abstraction at the current method's start node.










	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 










 /**










	 * Lines 21-32 of the algorithm.










	 * 










	 * Stores callee-side summaries.










	 * Also, at the side of the caller, propagates intra-procedural flows to return sites










	 * using those newly computed summaries.










	 * 










	 * @param edge an edge whose target node resembles a method exits










	 */










 protected void processExit(PathEdge<N,D> edge) {










 final N n = edge.getTarget(); // an exit node; line 21...










 M methodThatNeedsSummary = icfg.getMethodOf(n);










 










 final D d1 = edge.factAtSource();










 final D d2 = edge.factAtTarget();










 










 //for each of the method's start points, determine incoming calls










 










 //line 21.1 of Naeem/Lhotak/Rodriguez










 //register end-summary










 SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);










 if (!addEndSummary(methodThatNeedsSummary, summaryEdge))










 return; //FIXME: should never be reached?! -> assert ?










 










 //for each incoming call edge already processed










 //(see processCall(..))










 for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {










 // line 22










 N callSite = incomingEdge.getCallSite();










 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(delta.isPresent()) {










 Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);










 










 // for each incoming-call value










 for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);










 }










 }










 }










 }










 }










 










 










 //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow










 //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only










 //be propagated into callers that have an incoming edge for this condition










 if(followReturnsPastSeeds && d1 == zeroValue) {










 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(ConstrainedFact<FieldRef, D> d5: targets) {










 










 Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);










 resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());










 AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));










 propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }










 }










 










 private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();










 










 private Resolver getResolver(D sourceFact, D targetFact, N stmt) {










 HashKey key = new HashKey(sourceFact, targetFact, stmt);










 if(!returnSiteIncomingEdges.containsKey(key))










 returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));










 return returnSiteIncomingEdges.get(key);










 }










 










 private class PausedReturnSiteEdge {





















 private Constraint<FieldRef> constraint;










 private PathEdge<N, D> pathEdge;










 private AccessPath<FieldRef> alreadyResolvedAccPath;










 private D concretizedStmtFact;





















 public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {










 this.constraint = constraint;










 this.pathEdge = pathEdge;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 this.concretizedStmtFact = concretizedStmtFact;










 }










 }










 










 class Resolver {





















 private D sourceFact;










 private N stmt;










 private Set<IncomingFact> incomingFacts = Sets.newHashSet();










 private D targetFact;










 private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();





















 public Resolver(D sourceFact, D targetFact, N stmt) {










 this.sourceFact = sourceFact;










 this.targetFact = targetFact;










 this.stmt = stmt;










 }





















 public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {










 if(!fact.getAccessPath().hasResolver())










 throw new AssertionError();










 if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))










 throw new AssertionError();










 }










 










 logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);










 IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);










 incomingFacts.add(incFact);










 










 for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {










 if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {










 propagate(edge.pathEdge, null, false);










 paused.remove(edge);










 }










 }










 }





















 private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {










 if(!visited.resolver.add(this))










 return false;










 










 alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);










 D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);










 










 logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());










 










 boolean resolved = false;










 for(final IncomingFact incFact : incomingFacts) {










 resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);










 if(resolved)










 break;










 }










 if(resolved) {










 propagate(pathEdge, null, false);










 } else {










 logger.trace("Pause {} at {}", pathEdge, stmt);










 paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));










 }










 return resolved;










 }





















 protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,










 final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {










 










 










 logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);










 










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {}", incFact.fact);










 return true;










 } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(incFact.fact.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(










 incFact.summaryEdge.getSourceFact(), 










 incFact.summaryEdge.getTargetStmt(), 










 applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {





















 @Override










 public void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);










 }










 }, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 propagate(pathEdge, null, false);










 return true;










 }










 }










 }










 else {










 D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));










 if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {










 logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);










 return true;










 } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 if(factWithDelta.getAccessPath().hasResolver()) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();










 logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);










 










 final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);










 if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {










 D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);










 target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));










 PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);










 }










 };










 










 boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);










 if(resolved) {










 return true;










 }










 }










 }










 else {










 final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));










 AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);










 boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(










 applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), 










 pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {










 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);










 }










 }, visited);










 if(resolved)










 return true;










 }










 }










 }










 }










 return false;










 }










 










 @Override










 public String toString() {










 return stmt.toString();










 }










 }





















 private class Visited {










 Set<Resolver> resolver = Sets.newHashSet();










 Map<N, Boolean> visitedCallSites = Maps.newHashMap();










 }










 










 class DecoratingResolver implements SubPathResolver<FieldRef> {










 










 private Resolver resolver;










 private AccessPath<FieldRef> alreadyResolvedAccPath;





















 public DecoratingResolver(Resolver resolver) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = new AccessPath<FieldRef>();










 }










 










 public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {










 this.resolver = resolver;










 this.alreadyResolvedAccPath = alreadyResolvedAccPath;










 }










 










 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 return resolve(constraint, pathEdge, new Visited());










 }





















 public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {










 return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 DecoratingResolver other = (DecoratingResolver) obj;










 if (alreadyResolvedAccPath == null) {










 if (other.alreadyResolvedAccPath != null)










 return false;










 } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return alreadyResolvedAccPath+ ":"+resolver.toString();










 }





















 @Override










 public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {










 return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));










 }










 }










 










 private class IncomingFact {





















 private D fact;










 private Delta<FieldRef> delta;










 private SummaryEdge<D, N> summaryEdge;





















 public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {










 this.summaryEdge = summaryEdge;










 this.fact = fact;










 this.delta = delta;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + getOuterType().hashCode();










 result = prime * result + ((delta == null) ? 0 : delta.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 IncomingFact other = (IncomingFact) obj;










 if (!getOuterType().equals(other.getOuterType()))










 return false;










 if (delta == null) {










 if (other.delta != null)










 return false;










 } else if (!delta.equals(other.delta))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (summaryEdge == null) {










 if (other.summaryEdge != null)










 return false;










 } else if (!summaryEdge.equals(other.summaryEdge))










 return false;










 return true;










 }





















 private FieldSensitiveIFDSSolver getOuterType() {










 return FieldSensitiveIFDSSolver.this;










 }










 










 }










 










 /**










	 * Computes the return flow function for the given set of caller-side










	 * abstractions.










	 * @param retFunction The return flow function to compute










	 * @param d2 The abstraction at the exit node in the callee










	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }





















 /**










	 * Lines 33-37 of the algorithm.










	 * Simply propagate normal, intra-procedural flows.










	 * @param edge










	 */










 @SuppressWarnings("unchecked")










 private void processNormalFlow(PathEdge<N,D> edge) {










 final D d1 = edge.factAtSource();










 final N n = edge.getTarget(); 










 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 if(d3.getFact().getAccessPath().hasResolver()) {










 AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());










 ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));










 } else










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);










 }










 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {










 return propagateConstrained(pathEdge, new Visited());










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);





















 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else if(hasPausedEdges(calleeMethod, pathEdge))










 propagate = false;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteed










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 propagate = !callSitesWithInterest.isEmpty();










 










 Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());










 Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);










 










 for(IncomingEdge<D, N> incEdge : candidates) { //potential










 if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {










 if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)










 propagate |= visited.visitedCallSites.get(incEdge.getCallSite());










 }










 else {










 if(!callSitesWithInterest.contains(incEdge.getCallSite())) {










 if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();










 D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);










 calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(










 incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));










 boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), 










 calleeMethod,










 calleeSourceFact), visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 else {










 Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());










 if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && 










 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.visitedCallSites.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.visitedCallSites.put(incEdge.getCallSite(), result);










 propagate |= result;










 }










 }










 }










 }










 }










 }










 










 if(propagate) {










 propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }





















 private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {










 Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();










 for(IncomingEdge<D, N> incEdge : candidates) {










 if(result.containsKey(incEdge.getCallSite())) {










 IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());










 if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {










 result.put(incEdge.getCallSite(), incEdge);










 }










 }










 else










 result.put(incEdge.getCallSite(), incEdge);










 }










 return result.values();










 }





















 private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {










 ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);










 if(pe != null) {










 for(PathEdge<N, D> edge : pe) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)










 return true;










 }










 }










 return false;










 }





















 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**










	 * Computes the normal flow function for the given set of start and end










	 * abstractions.










	 * @param flowFunction The normal flow function to compute










	 * @param d1 The abstraction at the method's start node










	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 










 /**










	 * This method will be called for each incoming edge and can be used to










	 * transfer knowledge from the calling edge to the returning edge, without










	 * affecting the summary edges at the callee.










	 * 










	 * @param d4










	 *            Fact stored with the incoming edge, i.e., present at the










	 *            caller side










	 * @param d5










	 *            Fact that originally should be propagated to the caller.










	 * @return Fact that will be propagated to the caller.










	 */










 protected D restoreContextOnReturnedFact(D d4, D d5) {










 d5.setCallingContext(d4);










 return d5;










 }










 










 protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite) {










 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 private int cacheSourceBaseValue = 0;










 private int concretizationEdges = 0;










 private int cacheEquals = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated










	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 










	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return










	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})










	 */










 protected void propagate(PathEdge<N,D> edge,










 /* deliberately exposed to clients */ N relatedCallSite,










 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 










 final D existingVal = jumpFn.addFunction(edge);










 










 










 if(!edge.factAtTarget().getAccessPath().hasResolver()) {










 if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {










 throw new AssertionError();










 }










 }










 










 if(edge instanceof CallConcretizationPathEdge) {










 concretizationEdges++;










 CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;










 IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), 










 concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());










 if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))










 return;










 










 resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());










 registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);










 } else if(edge instanceof ReturnConcretizationPathEdge) {










 ((ReturnConcretizationPathEdge<N,D>) edge).propagate();










 } else {










//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {










//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",










//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));










//			}










 










 










 if (existingVal != null) {










 cacheEquals++;










 if (existingVal != edge.factAtTarget())










 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());










 










 if(sourceBaseValueCache.containsKey(sourceValueKey)) {










 cacheSourceBaseValue++;










 }










 sourceBaseValueCache.put(sourceValueKey, edge);










 










 










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










//					if(cacheHits % 10_000 == 0) {










//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));










//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










//						System.out.println(edge);










//						System.out.println(icfg.getMethodOf(edge.getTarget()));










//						System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










//						System.out.println("---");










//					}










 cacheHits++;










 boolean opposite = false;










 for(PathEdge<N,D> cachedEdge : cache.get(key)) {










 if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {










 cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










 cacheMerges++;










 logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










 return;










 }










//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))










//							opposite=true;





















 }










//					if(opposite)










//						cacheOppositePrefix++;










//					else if(cache.get(key).size() > 500) {










//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");










//						System.out.println(edge.factAtTarget());










//					}










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));










 for(D val: seed.getValue()) {










 analyzer.addInitialSeed(startPoint, val);










 debugger.initialSeed(startPoint);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private Object[] values;





















 public CacheKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);










 if(map == null)










 return null;










 










 return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {










 @Override










 public boolean apply(SummaryEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }





















 private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {










 Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGet










 (m, new ConcurrentHashSet<SummaryEdge<D, N>>());










 return summaries.add(summaryEdge);










 } 





















 protected Set<IncomingEdge<D, N>> incoming(M m) {










 Set<IncomingEdge<D, N>> result = incoming.get(m);










 if(result == null)










 return Collections.emptySet();










 else










 return result;










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;










 }










 });










 }










 










 protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {










 Set<IncomingEdge<D, N>> result = incoming(m);










 return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {










 @Override










 public boolean apply(IncomingEdge<D, N> edge) {










 return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);










 }










 });










 }










 










 protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {










 logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);










 Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());










 return set.add(incomingEdge);










 }










 










 /**










	 * Factory method for this solver's thread-pool executor.










	 */










 protected CountingThreadPoolExecutor getExecutor() {










 return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());










 }










 










 /**










	 * Returns a String used to identify the output of this solver in debug mode.










	 * Subclasses can overwrite this string to distinguish the output from different solvers.










	 */










 protected String getDebugName() {










 return "FAST IFDS SOLVER";










 }





















 public void printStats() {










 if(logger.isDebugEnabled()) {










 if(ffCache!=null)










 ffCache.printStats();










 } else {










 logger.info("No statistics were collected, as DEBUG is disabled.");










 }










 }










 










 private class PathEdgeProcessingTask implements Runnable {










 private final PathEdge<N,D> edge;





















 public PathEdgeProcessingTask(PathEdge<N,D> edge) {










 this.edge = edge;










 }





















 public void run() {










 if(icfg.isCallStmt(edge.getTarget())) {










 processCall(edge);










 } else {










 //note that some statements, such as "throw" may be










 //both an exit statement and a "normal" statement










 if(icfg.isExitStmt(edge.getTarget())) {










 processExit(edge);










 }










 if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {










 processNormalFlow(edge);










 }










 }










 }










 }










 





















 public void writeDebugFile() {










 try {










 FileWriter writer = new FileWriter("debug-solver-dump.json");










 writer.write("var methods= {\n\t");










 Enumeration<M> summaryEnumerable = endSummary.keys();










 










 while(summaryEnumerable.hasMoreElements()) {










 M m = summaryEnumerable.nextElement();










 writer.write("\""+m.toString()+"\"");










 writer.write(": { \n\t\tsummaries: [\n");










 for(SummaryEdge<D,N> summary : endSummary.get(m)) {










 writer.write("\t\t\t{ \n\t\t\t\tsource: ");










 writeFact(writer, summary.getSourceFact());










 writer.write(",\n\t\t\t\ttarget: ");










 writeFact(writer, summary.getTargetFact());










 writer.write("\n\t\t\t},");










 }










 writer.write("\n\t\t],");










 writer.write("\n\t\tincoming: [\n");










 Set<IncomingEdge<D, N>> incEdges = incoming.get(m);










 if(incEdges!=null)










 for(IncomingEdge<D,N> incEdge : incEdges) {










 writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");










 writeFact(writer, incEdge.getCalleeSourceFact());










 writer.write(",\n\t\t\t\tcalling_method: ");










 writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");










 writer.write("\n\t\t\t},");










 }










 










 writer.write("\n\t\t]");










 writer.write("\n\t},\n");










 }










 










 writer.write("}");










 writer.flush();










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void writeFact(FileWriter writer, D sourceFact) throws IOException {










 writer.write("{");










//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");










 writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");










 writer.write("accPath: [");










 for(String s :sourceFact.getAccessPath().tokenize()) {










 writer.write("\""+s+"\",");










 }










 writer.write("]}");










 }










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.DontSynchronize;importheros.DontSynchronize;import heros.FlowFunctionCache;importheros.FlowFunctionCache;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SynchronizedBy;importheros.SynchronizedBy;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;importheros.alias.BiDiFieldSensitiveIFDSSolver.AbstractionWithSourceStmt;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import heros.solver.CountingThreadPoolExecutor;importheros.solver.CountingThreadPoolExecutor;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.solver.Pair;importheros.solver.Pair;import heros.solver.PathEdge;importheros.solver.PathEdge;import java.io.BufferedOutputStream;importjava.io.BufferedOutputStream;import java.io.FileNotFoundException;importjava.io.FileNotFoundException;import java.io.FileOutputStream;importjava.io.FileOutputStream;import java.io.FileWriter;importjava.io.FileWriter;import java.io.IOException;importjava.io.IOException;import java.util.Arrays;importjava.util.Arrays;import java.util.Collection;importjava.util.Collection;import java.util.Collections;importjava.util.Collections;import java.util.Comparator;importjava.util.Comparator;import java.util.Enumeration;importjava.util.Enumeration;import java.util.HashMap;importjava.util.HashMap;import java.util.Iterator;importjava.util.Iterator;import java.util.LinkedList;importjava.util.LinkedList;import java.util.List;importjava.util.List;import java.util.Map;importjava.util.Map;import java.util.Map.Entry;importjava.util.Map.Entry;import java.util.PriorityQueue;importjava.util.PriorityQueue;import java.util.Set;importjava.util.Set;import java.util.concurrent.LinkedBlockingQueue;importjava.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;importjava.util.concurrent.TimeUnit;import org.slf4j.Logger;importorg.slf4j.Logger;import org.slf4j.LoggerFactory;importorg.slf4j.LoggerFactory;public class FieldSensitiveIFDSSolver<N, FieldRef extends AccessPath.FieldRef<FieldRef>, D, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,FieldRefextendsAccessPath.FieldRef<FieldRef>,D,M,IextendsInterproceduralCFG<N,M>>{import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.base.Predicate;importcom.google.common.base.Predicate;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.collect.HashMultimap;importcom.google.common.collect.HashMultimap;import com.google.common.collect.Iterators;importcom.google.common.collect.Iterators;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import com.sun.org.apache.xpath.internal.axes.IteratorPool;importcom.sun.org.apache.xpath.internal.axes.IteratorPool;public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<BaseValue,FieldRef,D>,M,IextendsInterproceduralCFG<N,M>>{ public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevelpublicstaticCacheBuilder<Object,Object>DEFAULT_CACHE_BUILDER=CacheBuilder.newBuilder().concurrencyLevel (Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();  protected static final Logger logger = LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class);protectedstaticfinalLoggerlogger=LoggerFactory.getLogger(FieldSensitiveIFDSSolver.class); //enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace//enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace public static final boolean DEBUG = logger.isDebugEnabled();publicstaticfinalbooleanDEBUG=logger.isDebugEnabled(); protected CountingThreadPoolExecutor executor;protectedCountingThreadPoolExecutorexecutor;  @DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread") protected int numThreads;protectedintnumThreads;  @SynchronizedBy("thread safe data structure, consistent locking when used")@SynchronizedBy("thread safe data structure, consistent locking when used") protected final JumpFunctions<N,D> jumpFn;protectedfinalJumpFunctions<N,D>jumpFn;  @SynchronizedBy("thread safe data structure, only modified internally")@SynchronizedBy("thread safe data structure, only modified internally") protected final I icfg;protectedfinalIicfg;  //stores summaries that were queried before they were computed//stores summaries that were queried before they were computed //see CC 2010 paper by Naeem, Lhotak and Rodriguez//see CC 2010 paper by Naeem, Lhotak and Rodriguez @SynchronizedBy("consistent lock on 'incoming'")@SynchronizedBy("consistent lock on 'incoming'") protected final MyConcurrentHashMap<M,Set<SummaryEdge<D, N>>> endSummary =protectedfinalMyConcurrentHashMap<M,Set<SummaryEdge<D,N>>>endSummary= new MyConcurrentHashMap<M, Set<SummaryEdge<D, N>>>();newMyConcurrentHashMap<M,Set<SummaryEdge<D,N>>>();  //edges going along calls//edges going along calls //see CC 2010 paper by Naeem, Lhotak and Rodriguez//see CC 2010 paper by Naeem, Lhotak and Rodriguez @SynchronizedBy("consistent lock on field")@SynchronizedBy("consistent lock on field") protected final MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>> incoming =protectedfinalMyConcurrentHashMap<M,Set<IncomingEdge<D,N>>>incoming= new MyConcurrentHashMap<M, Set<IncomingEdge<D, N>>>();newMyConcurrentHashMap<M,Set<IncomingEdge<D,N>>>();  protected final MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, ConcurrentHashSet<PathEdge<N,D>>>();protectedfinalMyConcurrentHashMap<M,ConcurrentHashSet<PathEdge<N,D>>>pausedEdges=newMyConcurrentHashMap<M,ConcurrentHashSet<PathEdge<N,D>>>();  @DontSynchronize("stateless")@DontSynchronize("stateless") protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;protectedfinalFlowFunctions<N,FieldRef,D,M>flowFunctions;  @DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread") protected final Map<N,Set<D>> initialSeeds;protectedfinalMap<N,Set<D>>initialSeeds;  @DontSynchronize("benign races")@DontSynchronize("benign races") public long propagationCount;publiclongpropagationCount;  @DontSynchronize("stateless")@DontSynchronize("stateless") protected final D zeroValue;protectedfinalDzeroValue; private Scheduler scheduler = new Scheduler();privateSchedulerscheduler=newScheduler(); private FlowFunctionProcessor<D, N, M, FieldRef> flowProcessor;privateFlowFunctionProcessor<D,N,M,FieldRef>flowProcessor;  @DontSynchronize("readOnly")@DontSynchronize("readOnly") protected final FlowFunctionCache<N,D,M> ffCache = null; protectedfinalFlowFunctionCache<N,D,M>ffCache=null;  @DontSynchronize("readOnly")@DontSynchronize("readOnly") protected final boolean followReturnsPastSeeds;protectedfinalbooleanfollowReturnsPastSeeds; private LinkedList<PathEdgeProcessingTask> worklist;privateLinkedList<PathEdgeProcessingTask>worklist;   /**/**	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * The solver must then be started by calling {@link #solve()}.	 * The solver must then be started by calling {@link #solve()}.	 */	 */ public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I>tabulationProblem){ this(tabulationProblem, DEFAULT_CACHE_BUILDER);this(tabulationProblem,DEFAULT_CACHE_BUILDER); }} /**/**	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling	 * Creates a solver for the given problem, constructing caches with the given {@link CacheBuilder}. The solver must then be started by calling	 * {@link #solve()}.	 * {@link #solve()}.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 */	 */ public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I>tabulationProblem,@SuppressWarnings("rawtypes")CacheBuilderflowFunctionCacheBuilder){ if(logger.isDebugEnabled())if(logger.isDebugEnabled()) flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();flowFunctionCacheBuilder=flowFunctionCacheBuilder.recordStats(); this.zeroValue = tabulationProblem.zeroValue();this.zeroValue=tabulationProblem.zeroValue(); this.icfg = tabulationProblem.interproceduralCFG(); this.icfg=tabulationProblem.interproceduralCFG(); /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); FlowFunctions<N,FieldRef,D,M>flowFunctions=tabulationProblem.flowFunctions(); /*if(flowFunctionCacheBuilder!=null) {/*if(flowFunctionCacheBuilder!=null) {			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);			flowFunctions = ffCache;			flowFunctions = ffCache;		} else {		} else {			ffCache = null;			ffCache = null;		}*/		}*/ this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; this.initialSeeds = tabulationProblem.initialSeeds();this.initialSeeds=tabulationProblem.initialSeeds(); this.jumpFn = new JumpFunctions<N,D>();this.jumpFn=newJumpFunctions<N,D>(); this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();this.followReturnsPastSeeds=tabulationProblem.followReturnsPastSeeds(); this.numThreads = 1; //Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safethis.numThreads=1;//Math.max(1,tabulationProblem.numThreads()); //solution is in the current state not thread safe this.executor = getExecutor();this.executor=getExecutor(); this.worklist = Lists.newLinkedList();this.worklist=Lists.newLinkedList(); private CacheMap<M, MethodAnalyzer<FieldRef, D, N, M>> methodAnalyzers = new CacheMap<M, MethodAnalyzer<FieldRef, D,N, M>>() {privateCacheMap<M,MethodAnalyzer<FieldRef,D,N,M>>methodAnalyzers=newCacheMap<M,MethodAnalyzer<FieldRef,D,N,M>>(){ @Override@Override protected MethodAnalyzer<FieldRef, D, N, M> createItem(M key) {protectedMethodAnalyzer<FieldRef,D,N,M>createItem(Mkey){ return new MethodAnalyzer<>(key, context);returnnewMethodAnalyzer<>(key,context); }} };}; private IFDSTabulationProblem<N, FieldRef, D, M, I> tabulationProblem;privateIFDSTabulationProblem<N,FieldRef,D,M,I>tabulationProblem; private Context<FieldRef, D, N,M> context;privateContext<FieldRef,D,N,M>context; private Debugger<FieldRef, D, N, M, I> debugger;privateDebugger<FieldRef,D,N,M,I>debugger; public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, FactMergeHandler<D> factHandler, Debugger<FieldRef, D, N, M, I> debugger) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I>tabulationProblem,FactMergeHandler<D>factHandler,Debugger<FieldRef,D,N,M,I>debugger){ this.tabulationProblem = tabulationProblem;this.tabulationProblem=tabulationProblem; this.debugger = debugger == null ? new Debugger.NullDebugger<FieldRef, D, N, M, I>() : debugger;this.debugger=debugger==null?newDebugger.NullDebugger<FieldRef,D,N,M,I>():debugger; this.debugger.setICFG(tabulationProblem.interproceduralCFG());this.debugger.setICFG(tabulationProblem.interproceduralCFG()); flowProcessor = new FlowFunctionProcessor<>(tabulationProblem.flowFunctions());flowProcessor=newFlowFunctionProcessor<>(tabulationProblem.flowFunctions()); context = new Context<FieldRef, D, N, M>(tabulationProblem.interproceduralCFG(), flowProcessor, scheduler, tabulationProblem.zeroValue(), context=newContext<FieldRef,D,N,M>(tabulationProblem.interproceduralCFG(),flowProcessor,scheduler,tabulationProblem.zeroValue(), tabulationProblem.followReturnsPastSeeds(), factHandler, tabulationProblem.zeroHandler()) {tabulationProblem.followReturnsPastSeeds(),factHandler,tabulationProblem.zeroHandler()){ @Override@Override public MethodAnalyzer<FieldRef, D, N, M> getAnalyzer(M method) {publicMethodAnalyzer<FieldRef,D,N,M>getAnalyzer(Mmethod){ if(method == null)if(method==null) throw new IllegalArgumentException("Method must be not null");thrownewIllegalArgumentException("Method must be not null"); return methodAnalyzers.getOrCreate(method);returnmethodAnalyzers.getOrCreate(method); }} };}; }} /**/**	 */	 */ public void solve() { publicvoidsolve(){ submitInitialSeeds();submitInitialSeeds(); awaitCompletionComputeValuesAndShutdown();awaitCompletionComputeValuesAndShutdown(); writeDebugFile();writeDebugFile(); scheduler.runAndAwaitCompletion();scheduler.runAndAwaitCompletion(); }} /**/**	 * their own. Normally, {@link #solve()} should be called instead.	 * their own. Normally, {@link #solve()} should be called instead.	 */	 */ protected void submitInitialSeeds() {protectedvoidsubmitInitialSeeds(){ for(Entry<N, Set<D>> seed: initialSeeds.entrySet()) {for(Entry<N,Set<D>>seed:initialSeeds.entrySet()){ for(Entry<N, Set<D>> seed: tabulationProblem.initialSeeds().entrySet()) {for(Entry<N,Set<D>>seed:tabulationProblemtabulationProblem..initialSeeds().()entrySet()){ N startPoint = seed.getKey();NstartPoint=seed.getKey(); for(D val: seed.getValue())for(Dval:seed.getValue()) propagate(new PathEdge<>(zeroValue, startPoint, val), null, false);propagate(newPathEdge<>(zeroValue,startPoint,val),null,false); jumpFn.addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));jumpFn.addFunction(newPathEdge<N,D>(zeroValue,startPoint,zeroValue)); }} }} /**/**	 * Awaits the completion of the exploded super graph. When complete, computes result values,	 * Awaits the completion of the exploded super graph. When complete, computes result values,	 * shuts down the executor and returns.	 * shuts down the executor and returns.	 */	 */ protected void awaitCompletionComputeValuesAndShutdown() {protectedvoidawaitCompletionComputeValuesAndShutdown(){//		{//		{//			//run executor and await termination of tasks//			//run executor and await termination of tasks//			runExecutorAndAwaitCompletion();//			runExecutorAndAwaitCompletion();//		}//		} if(logger.isDebugEnabled())if(logger.isDebugEnabled()) printStats();printStats(); //ask executor to shut down;//ask executor to shut down; //this will cause new submissions to the executor to be rejected,//this will cause new submissions to the executor to be rejected, //but at this point all tasks should have completed anyway//but at this point all tasks should have completed anyway//		executor.shutdown();//		executor.shutdown(); //similarly here: we await termination, but this should happen instantaneously,//similarly here: we await termination, but this should happen instantaneously, //as all tasks should have completed//as all tasks should have completed runExecutorAndAwaitCompletion();runExecutorAndAwaitCompletion(); }} protected boolean hasWork() {protectedbooleanhasWork(){ return !worklist.isEmpty();return!worklist.isEmpty(); }}  private int jobCounter = 0;privateintjobCounter=0; private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();privateHashMultimap<M,PathEdge<N,D>>edgesPerMethod=HashMultimap.create(); /**/**	 * Runs execution, re-throwing exceptions that might be thrown during its execution.	 * Runs execution, re-throwing exceptions that might be thrown during its execution.	 */	 */ private void runExecutorAndAwaitCompletion() {privatevoidrunExecutorAndAwaitCompletion(){//		try {//		try {//			executor.awaitCompletion();//			executor.awaitCompletion();//		} catch (InterruptedException e) {//		} catch (InterruptedException e) {//			e.printStackTrace();//			e.printStackTrace();//		}//		}//		Throwable exception = executor.getException();//		Throwable exception = executor.getException();//		if(exception!=null) {//		if(exception!=null) {//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);//		}//		} while(!worklist.isEmpty()) {while(!worklist.isEmpty()){//			if(jobCounter % 100_000 == 0)//			if(jobCounter % 100_000 == 0)  PathEdgeProcessingTask current = worklist.removeLast();PathEdgeProcessingTaskcurrent=worklist.removeLast(); int size = worklist.size();intsize=worklist.size(); current.run();current.run(); jobCounter++;jobCounter++; M method = icfg.getMethodOf(current.edge.getTarget());Mmethod=icfg.getMethodOf(current.edge.getTarget());//			edgesPerMethod.put(method, current.edge);//			edgesPerMethod.put(method, current.edge);//			if(edgesPerMethod.get(method).size() > 10_000) {//			if(edgesPerMethod.get(method).size() > 10_000) {//				System.out.println(method);//				System.out.println(method);//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));//				}//				}//			}//			} if(worklist.size() > size + 100 || jobCounter%10_000 == 0) {if(worklist.size()>size+100||jobCounter%10_000==0){ System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ",size,worklist.size(),jobCounter)+ String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s",method,current.edge.factAtSource(),current.edge.factAtTarget(),current.edge.getTarget())); }}//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +//			System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));//					String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget())); }} }} /**/**     * Dispatch the processing of a given edge. It may be executed in a different thread.     * Dispatch the processing of a given edge. It may be executed in a different thread.     * @param edge the edge to process     * @param edge the edge to process     */     */ protected void scheduleEdgeProcessing(PathEdge<N,D> edge){protectedvoidscheduleEdgeProcessing(PathEdge<N,D>edge){ // If the executor has been killed, there is little point// If the executor has been killed, there is little point // in submitting new tasks// in submitting new tasks//    	if (executor.isTerminating())//    	if (executor.isTerminating())//    		return;//    		return;//    	executor.execute(new PathEdgeProcessingTask(edge));//    	executor.execute(new PathEdgeProcessingTask(edge)); worklist.add(new PathEdgeProcessingTask(edge));worklist.add(newPathEdgeProcessingTask(edge)); propagationCount++;propagationCount++; }}  /**/**	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.	 * 	 * 	 * For each possible callee, registers incoming call edges.	 * For each possible callee, registers incoming call edges.	 * Also propagates call-to-return flows and summarized callee flows within the caller. 	 * Also propagates call-to-return flows and summarized callee flows within the caller. 	 * 	 * 	 * @param edge an edge whose target node resembles a method call	 * @param edge an edge whose target node resembles a method call	 */	 */ private void processCall(PathEdge<N,D> edge) {privatevoidprocessCall(PathEdge<N,D>edge){ final D d1 = edge.factAtSource();finalDd1=edge.factAtSource(); final N n = edge.getTarget(); // a call node; line 14...finalNn=edge.getTarget();// a call node; line 14... logger.trace("Processing call to {}", n);logger.trace("Processing call to {}",n); final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget(); assert d2 != null;assertd2!=null; Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);Collection<N>returnSiteNs=icfg.getReturnSitesOfCallAt(n);  //for each possible callee//for each possible callee Collection<M> callees = icfg.getCalleesOfCallAt(n);Collection<M>callees=icfg.getCalleesOfCallAt(n); for(M sCalledProcN: callees) { //still line 14for(MsCalledProcN:callees){//still line 14 //compute the call-flow function//compute the call-flow function FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);FlowFunction<FieldRef,D>function=flowFunctions.getCallFlowFunction(n,sCalledProcN); Set<ConstrainedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);Set<ConstrainedFact<FieldRef,D>>res=computeCallFlowFunction(function,d1,d2);  Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);Collection<N>startPointsOf=icfg.getStartPointsOf(sCalledProcN); //for each result node of the call-flow function//for each result node of the call-flow function for(ConstrainedFact<FieldRef, D> d3: res) {for(ConstrainedFact<FieldRef,D>d3:res){ //for each callee's start point(s)//for each callee's start point(s) for(N sP: startPointsOf) {for(NsP:startPointsOf){ //create initial self-loop//create initial self-loop D abstractStartPointFact = AccessPathUtil.cloneWithAccessPath(d3.getFact(), new AccessPath<FieldRef>());DabstractStartPointFact=AccessPathUtil.cloneWithAccessPath(d3.getFact(),newAccessPath<FieldRef>()); propagate(new PathEdge<>(abstractStartPointFact, sP, abstractStartPointFact), n, false); //line 15propagate(newPathEdge<>(abstractStartPointFact,sP,abstractStartPointFact),n,false);//line 15 }}  //register the fact that <sp,d3> has an incoming edge from <n,d2>//register the fact that <sp,d3> has an incoming edge from <n,d2> //line 15.1 of Naeem/Lhotak/Rodriguez//line 15.1 of Naeem/Lhotak/Rodriguez IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(d3.getFact(),n,d1,d2);IncomingEdge<D,N>incomingEdge=newIncomingEdge<D,N>(d3.getFact(),n,d1,d2); if (!addIncoming(sCalledProcN, incomingEdge))if(!addIncoming(sCalledProcN,incomingEdge)) continue;continue;  resumeEdges(sCalledProcN, d3.getFact());resumeEdges(sCalledProcN,d3.getFact()); registerInterestedCaller(sCalledProcN, incomingEdge);registerInterestedCaller(sCalledProcN,incomingEdge);   //line 15.2//line 15.2 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());Set<SummaryEdge<D,N>>endSumm=endSummary(sCalledProcN,d3.getFact());  //still line 15.2 of Naeem/Lhotak/Rodriguez//still line 15.2 of Naeem/Lhotak/Rodriguez //for each already-queried exit value <eP,d4> reachable from <sP,d3>,//for each already-queried exit value <eP,d4> reachable from <sP,d3>, //create new caller-side jump functions to the return sites//create new caller-side jump functions to the return sites //because we have observed a potentially new incoming edge into <sP,d3>//because we have observed a potentially new incoming edge into <sP,d3> if (endSumm != null)if(endSumm!=null) for(SummaryEdge<D, N> summary: endSumm) {for(SummaryEdge<D,N>summary:endSumm){ Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(d3.getFact(), summary);Optional<Delta<FieldRef>>delta=AccessPathUtil.getDelta(d3.getFact(),summary); if(delta.isPresent()) {if(delta.isPresent()){ //for each return site//for each return site for(N retSiteN: returnSiteNs) {for(NretSiteN:returnSiteNs){ //compute return-flow function//compute return-flow function FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN); //for each target value of the function//for each target value of the function for(ConstrainedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {for(ConstrainedFact<FieldRef,D>d5:computeReturnFlowFunction(retFunction,summary.getTargetFact(),n)){ D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());Dd5p_restoredCtx=restoreContextOnReturnedFact(d2,d5.getFact()); Resolver resolver = getResolver(d1, d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteN);Resolverresolver=getResolver(d1,d5p_restoredCtx.cloneWithAccessPath(AccessPath.<FieldRef>empty()),retSiteN); resolver.addIncomingFact(summary, d5p_restoredCtx, delta.get());resolver.addIncomingFact(summary,d5p_restoredCtx,delta.get());  AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));AccessPath<FieldRef>abstractedAccPath=newAccessPath<FieldRef>().setResolver(newDecoratingResolver(resolver)); D abstractedTargetFact = d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath);DabstractedTargetFact=d5p_restoredCtx.cloneWithAccessPath(abstractedAccPath); propagate(new PathEdge<>(d1, retSiteN, abstractedTargetFact), n, false);propagate(newPathEdge<>(d1,retSiteN,abstractedTargetFact),n,false); }} }} }} }} }} }} //line 17-19 of Naeem/Lhotak/Rodriguez		//line 17-19 of Naeem/Lhotak/Rodriguez		 //process intra-procedural flows along call-to-return flow functions//process intra-procedural flows along call-to-return flow functions for (N returnSiteN : returnSiteNs) {for(NreturnSiteN:returnSiteNs){ FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);FlowFunction<FieldRef,D>callToReturnFlowFunction=flowFunctions.getCallToReturnFlowFunction(n,returnSiteN); for(ConstrainedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))for(ConstrainedFact<FieldRef,D>d3:computeCallToReturnFlowFunction(callToReturnFlowFunction,d1,d2)) propagate(new PathEdge<>(d1, returnSiteN, d3.getFact()), n, false);propagate(newPathEdge<>(d1,returnSiteN,d3.getFact()),n,false); }} }} private void resumeEdges(M method, D factAtMethodStartPoint) {privatevoidresumeEdges(Mmethod,DfactAtMethodStartPoint){ ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);ConcurrentHashSet<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){ if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(edge.factAtSource(),factAtMethodStartPoint)==PrefixTestResult.GUARANTEED_PREFIX){ if(edges.remove(edge)) {if(edges.remove(edge)){ logger.trace("RESUME-EDGE: {}", edge);logger.trace("RESUME-EDGE: {}",edge); propagate(edge, edge instanceof CallConcretizationPathEdge ? edge.getTarget() : null, false);propagate(edge,edgeinstanceofCallConcretizationPathEdge?edge.getTarget():null,false); }} }} }} }} }}  private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {privatevoidregisterInterestedCaller(Mmethod,IncomingEdge<D,N>incomingEdge){ Set<PathEdge<N, D>> edges = pausedEdges.get(method);Set<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ if(edges.size() > 100)if(edges.size()>100) System.out.println("Paused edges for method "+method+": "+edges.size());System.out.println("Paused edges for method "+method+": "+edges.size());  for(final PathEdge<N, D> edge : edges) {for(finalPathEdge<N,D>edge:edges){ if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(),edge.factAtSource()).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}",edge,incomingEdge);  Constraint<FieldRef> constraint = new DeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());Constraint<FieldRef>constraint=newDeltaConstraint<FieldRef>(incomingEdge.getCalleeSourceFact().getAccessPath(),edge.factAtSource().getAccessPath());  if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath()) && if(constraint.canBeAppliedTo(incomingEdge.getCallerSourceFact().getAccessPath())&& constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())){ if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {if(incomingEdge.getCalleeSourceFact().getAccessPath().hasResolver()){ DecoratingResolver decoratingResolver = (DecoratingResolver) incomingEdge.getCalleeSourceFact().getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)incomingEdge.getCalleeSourceFact().getAccessPath().getResolver(); decoratingResolver.resolve(constraint, new CallConcretizationPathEdge<>(decoratingResolver.resolve(constraint,newCallConcretizationPathEdge<>( applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), applyConstraint(constraint,incomingEdge.getCallerSourceFact(),true), incomingEdge.getCallSite(), incomingEdge.getCallSite(), applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),applyConstraint(constraint,incomingEdge.getCallerCallSiteFact(),false), method,method, applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));applyConstraint(constraint,incomingEdge.getCalleeSourceFact(),true))); }} else {else{ propagateConstrained(new CallConcretizationPathEdge<>(propagateConstrained(newCallConcretizationPathEdge<>( applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), applyConstraint(constraint,incomingEdge.getCallerSourceFact(),true), incomingEdge.getCallSite(), incomingEdge.getCallSite(), applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),applyConstraint(constraint,incomingEdge.getCallerCallSiteFact(),false), method,method, applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));applyConstraint(constraint,incomingEdge.getCalleeSourceFact(),true))); }} }} }} }} }} }} /**/**	 * Computes the call flow function for the given call-site abstraction	 * Computes the call flow function for the given call-site abstraction	 * @param callFlowFunction The call flow function to compute	 * @param callFlowFunction The call flow function to compute	 * @param d1 The abstraction at the current method's start node.	 * @param d1 The abstraction at the current method's start node.	 * @param d2 The abstraction at the call site	 * @param d2 The abstraction at the call site	 * @return The set of caller-side abstractions at the callee's start node	 * @return The set of caller-side abstractions at the callee's start node	 */	 */ protected Set<ConstrainedFact<FieldRef, D>> computeCallFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeCallFlowFunction (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {(FlowFunction<FieldRef,D>callFlowFunction,Dd1,Dd2){ return callFlowFunction.computeTargets(d2);returncallFlowFunction.computeTargets(d2); }} /**/**	 * Computes the call-to-return flow function for the given call-site	 * Computes the call-to-return flow function for the given call-site	 * abstraction	 * abstraction	 * @param callToReturnFlowFunction The call-to-return flow function to	 * @param callToReturnFlowFunction The call-to-return flow function to	 * compute	 * compute	 * @param d1 The abstraction at the current method's start node.	 * @param d1 The abstraction at the current method's start node.	 * @param d2 The abstraction at the call site	 * @param d2 The abstraction at the call site	 * @return The set of caller-side abstractions at the return site	 * @return The set of caller-side abstractions at the return site	 */	 */ protected Set<ConstrainedFact<FieldRef, D>> computeCallToReturnFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeCallToReturnFlowFunction (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {(FlowFunction<FieldRef,D>callToReturnFlowFunction,Dd1,Dd2){ return callToReturnFlowFunction.computeTargets(d2);returncallToReturnFlowFunction.computeTargets(d2); }}  /**/**	 * Lines 21-32 of the algorithm.	 * Lines 21-32 of the algorithm.	 * 	 * 	 * Stores callee-side summaries.	 * Stores callee-side summaries.	 * Also, at the side of the caller, propagates intra-procedural flows to return sites	 * Also, at the side of the caller, propagates intra-procedural flows to return sites	 * using those newly computed summaries.	 * using those newly computed summaries.	 * 	 * 	 * @param edge an edge whose target node resembles a method exits	 * @param edge an edge whose target node resembles a method exits	 */	 */ protected void processExit(PathEdge<N,D> edge) {protectedvoidprocessExit(PathEdge<N,D>edge){ final N n = edge.getTarget(); // an exit node; line 21...finalNn=edge.getTarget();// an exit node; line 21... M methodThatNeedsSummary = icfg.getMethodOf(n);MmethodThatNeedsSummary=icfg.getMethodOf(n);  final D d1 = edge.factAtSource();finalDd1=edge.factAtSource(); final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();  //for each of the method's start points, determine incoming calls//for each of the method's start points, determine incoming calls  //line 21.1 of Naeem/Lhotak/Rodriguez//line 21.1 of Naeem/Lhotak/Rodriguez //register end-summary//register end-summary SummaryEdge<D, N> summaryEdge = new SummaryEdge<D, N>(d1, n, d2);SummaryEdge<D,N>summaryEdge=newSummaryEdge<D,N>(d1,n,d2); if (!addEndSummary(methodThatNeedsSummary, summaryEdge))if(!addEndSummary(methodThatNeedsSummary,summaryEdge)) return; //FIXME: should never be reached?! -> assert ?return;//FIXME: should never be reached?! -> assert ?  //for each incoming call edge already processed//for each incoming call edge already processed //(see processCall(..))//(see processCall(..)) for (IncomingEdge<D, N> incomingEdge : incoming(methodThatNeedsSummary)) {for(IncomingEdge<D,N>incomingEdge:incoming(methodThatNeedsSummary)){ // line 22// line 22 N callSite = incomingEdge.getCallSite();NcallSite=incomingEdge.getCallSite(); // for each return site// for each return site for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(callSite)){ // compute return-flow function// compute return-flow function FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC);  if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(d1,incomingEdge.getCalleeSourceFact())==PrefixTestResult.GUARANTEED_PREFIX){ Optional<Delta<FieldRef>> delta = AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(), summaryEdge);Optional<Delta<FieldRef>>delta=AccessPathUtil.getDelta(incomingEdge.getCalleeSourceFact(),summaryEdge); if(delta.isPresent()) {if(delta.isPresent()){ Set<ConstrainedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);Set<ConstrainedFact<FieldRef,D>>callerTargetFacts=computeReturnFlowFunction(retFunction,d2,callSite);  // for each incoming-call value// for each incoming-call value for (ConstrainedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {for(ConstrainedFact<FieldRef,D>callerTargetAnnotatedFact:callerTargetFacts){ D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact()); Resolver resolver = getResolver(incomingEdge.getCallerSourceFact(), callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);Resolverresolver=getResolver(incomingEdge.getCallerSourceFact(),callerTargetFact.cloneWithAccessPath(AccessPath.<FieldRef>empty()),retSiteC); resolver.addIncomingFact(summaryEdge, callerTargetFact, delta.get());resolver.addIncomingFact(summaryEdge,callerTargetFact,delta.get()); AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));AccessPath<FieldRef>abstractedAccPath=newAccessPath<FieldRef>().setResolver(newDecoratingResolver(resolver)); propagate(new PathEdge<>(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact.cloneWithAccessPath(abstractedAccPath)), callSite, false);propagate(newPathEdge<>(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact.cloneWithAccessPath(abstractedAccPath)),callSite,false); }} }} }} }} }}   //handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow//handling for unbalanced problems where we return out of a method with a fact for which we have no incoming flow //note: we propagate that way only values that originate from ZERO, as conditionally generated values should only//note: we propagate that way only values that originate from ZERO, as conditionally generated values should only //be propagated into callers that have an incoming edge for this condition//be propagated into callers that have an incoming edge for this condition if(followReturnsPastSeeds && d1 == zeroValue) {if(followReturnsPastSeeds&&d1==zeroValue){ Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);Collection<N>callers=icfg.getCallersOf(methodThatNeedsSummary); for(N c: callers) {for(Nc:callers){ for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(c)){ FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(c,methodThatNeedsSummary,n,retSiteC); Set<ConstrainedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);Set<ConstrainedFact<FieldRef,D>>targets=computeReturnFlowFunction(retFunction,d2,c); for(ConstrainedFact<FieldRef, D> d5: targets) {for(ConstrainedFact<FieldRef,D>d5:targets){  Resolver resolver = getResolver(zeroValue, d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()), retSiteC);Resolverresolver=getResolver(zeroValue,d5.getFact().cloneWithAccessPath(AccessPath.<FieldRef>empty()),retSiteC); resolver.addIncomingFact(summaryEdge, d5.getFact(), AccessPath.Delta.<FieldRef> empty());resolver.addIncomingFact(summaryEdge,d5.getFact(),AccessPath.Delta.<FieldRef>empty()); AccessPath<FieldRef> abstractedAccPath = new AccessPath<FieldRef>().setResolver(new DecoratingResolver(resolver));AccessPath<FieldRef>abstractedAccPath=newAccessPath<FieldRef>().setResolver(newDecoratingResolver(resolver)); propagateUnbalancedReturnFlow(new PathEdge<>(zeroValue, retSiteC, d5.getFact().cloneWithAccessPath(abstractedAccPath)), c);propagateUnbalancedReturnFlow(newPathEdge<>(zeroValue,retSiteC,d5.getFact().cloneWithAccessPath(abstractedAccPath)),c); }} }} }} //in cases where there are no callers, the return statement would normally not be processed at all;//in cases where there are no callers, the return statement would normally not be processed at all; //this might be undesirable if the flow function has a side effect such as registering a taint;//this might be undesirable if the flow function has a side effect such as registering a taint; //instead we thus call the return flow function will a null caller//instead we thus call the return flow function will a null caller if(callers.isEmpty()) {if(callers.isEmpty()){ FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);FlowFunction<FieldRef,D>retFunction=flowFunctions.getReturnFlowFunction(null,methodThatNeedsSummary,n,null); retFunction.computeTargets(d2);retFunction.computeTargets(d2); }} }} }}  private Map<HashKey, Resolver> returnSiteIncomingEdges = Maps.newHashMap();privateMap<HashKey,Resolver>returnSiteIncomingEdges=Maps.newHashMap();  private Resolver getResolver(D sourceFact, D targetFact, N stmt) {privateResolvergetResolver(DsourceFact,DtargetFact,Nstmt){ HashKey key = new HashKey(sourceFact, targetFact, stmt);HashKeykey=newHashKey(sourceFact,targetFact,stmt); if(!returnSiteIncomingEdges.containsKey(key))if(!returnSiteIncomingEdges.containsKey(key)) returnSiteIncomingEdges.put(key, new Resolver(sourceFact, targetFact, stmt));returnSiteIncomingEdges.put(key,newResolver(sourceFact,targetFact,stmt)); return returnSiteIncomingEdges.get(key);returnreturnSiteIncomingEdges.get(key); }}  private class PausedReturnSiteEdge {privateclassPausedReturnSiteEdge{ private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint; private PathEdge<N, D> pathEdge;privatePathEdge<N,D>pathEdge; private AccessPath<FieldRef> alreadyResolvedAccPath;privateAccessPath<FieldRef>alreadyResolvedAccPath; private D concretizedStmtFact;privateDconcretizedStmtFact; public PausedReturnSiteEdge(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, D concretizedStmtFact) {publicPausedReturnSiteEdge(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge,AccessPath<FieldRef>alreadyResolvedAccPath,DconcretizedStmtFact){ this.constraint = constraint;this.constraint=constraint; this.pathEdge = pathEdge;this.pathEdge=pathEdge; this.alreadyResolvedAccPath = alreadyResolvedAccPath;this.alreadyResolvedAccPath=alreadyResolvedAccPath; this.concretizedStmtFact = concretizedStmtFact;this.concretizedStmtFact=concretizedStmtFact; }} }}  class Resolver {classResolver{ private D sourceFact;privateDsourceFact; private N stmt;privateNstmt; private Set<IncomingFact> incomingFacts = Sets.newHashSet();privateSet<IncomingFact>incomingFacts=Sets.newHashSet(); private D targetFact;privateDtargetFact; private List<PausedReturnSiteEdge> paused = Lists.newLinkedList();privateList<PausedReturnSiteEdge>paused=Lists.newLinkedList(); public Resolver(D sourceFact, D targetFact, N stmt) {publicResolver(DsourceFact,DtargetFact,Nstmt){ this.sourceFact = sourceFact;this.sourceFact=sourceFact; this.targetFact = targetFact;this.targetFact=targetFact; this.stmt = stmt;this.stmt=stmt; }} public void addIncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {publicvoidaddIncomingFact(SummaryEdge<D,N>summaryEdge,Dfact,Delta<FieldRef>delta){ if(summaryEdge.getTargetFact().getAccessPath().hasResolver()) {if(summaryEdge.getTargetFact().getAccessPath().hasResolver()){ if(!fact.getAccessPath().hasResolver())if(!fact.getAccessPath().hasResolver()) throw new AssertionError();thrownewAssertionError(); if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver()))if(!summaryEdge.getTargetFact().getAccessPath().getResolver().equals(fact.getAccessPath().getResolver())) throw new AssertionError();thrownewAssertionError(); }}  logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}", stmt, fact, delta, summaryEdge);logger.trace("new incoming return edge at {}: {} with delta '{}' from summary {}",stmt,fact,delta,summaryEdge); IncomingFact incFact = new IncomingFact(summaryEdge, fact, delta);IncomingFactincFact=newIncomingFact(summaryEdge,fact,delta); incomingFacts.add(incFact);incomingFacts.add(incFact);  for(PausedReturnSiteEdge edge: Lists.newLinkedList(paused)) {for(PausedReturnSiteEdgeedge:Lists.newLinkedList(paused)){ if(resolve(edge.constraint, edge.pathEdge, edge.alreadyResolvedAccPath, edge.concretizedStmtFact, incFact, new Visited())) {if(resolve(edge.constraint,edge.pathEdge,edge.alreadyResolvedAccPath,edge.concretizedStmtFact,incFact,newVisited())){ propagate(edge.pathEdge, null, false);propagate(edge.pathEdge,null,false); paused.remove(edge);paused.remove(edge); }} }} }} private boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath, Visited visited) {privatebooleanresolve(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge,AccessPath<FieldRef>alreadyResolvedAccPath,Visitedvisited){ if(!visited.resolver.add(this))if(!visited.resolver.add(this)) return false;returnfalse;  alreadyResolvedAccPath = constraint.applyToAccessPath(alreadyResolvedAccPath, false);alreadyResolvedAccPath=constraint.applyToAccessPath(alreadyResolvedAccPath,false); D concretizedStmtFact = targetFact.cloneWithAccessPath(alreadyResolvedAccPath);DconcretizedStmtFact=targetFact.cloneWithAccessPath(alreadyResolvedAccPath);  logger.trace("Resolving {} through return site {} (inc edges: {})", alreadyResolvedAccPath, stmt, incomingFacts.size());logger.trace("Resolving {} through return site {} (inc edges: {})",alreadyResolvedAccPath,stmt,incomingFacts.size());  boolean resolved = false;booleanresolved=false; for(final IncomingFact incFact : incomingFacts) {for(finalIncomingFactincFact:incomingFacts){ resolved |= resolve(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact, incFact, visited);resolved|=resolve(constraint,pathEdge,alreadyResolvedAccPath,concretizedStmtFact,incFact,visited); if(resolved)if(resolved) break;break; }} if(resolved) {if(resolved){ propagate(pathEdge, null, false);propagate(pathEdge,null,false); } else {}else{ logger.trace("Pause {} at {}", pathEdge, stmt);logger.trace("Pause {} at {}",pathEdge,stmt); paused.add(new PausedReturnSiteEdge(constraint, pathEdge, alreadyResolvedAccPath, concretizedStmtFact));paused.add(newPausedReturnSiteEdge(constraint,pathEdge,alreadyResolvedAccPath,concretizedStmtFact)); }} return resolved;returnresolved; }} protected boolean resolve(Constraint<FieldRef> constraint, final PathEdge<N, D> pathEdge, AccessPath<FieldRef> alreadyResolvedAccPath,protectedbooleanresolve(Constraint<FieldRef>constraint,finalPathEdge<N,D>pathEdge,AccessPath<FieldRef>alreadyResolvedAccPath, final D concretizedStmtFact, final IncomingFact incFact, Visited visited) {finalDconcretizedStmtFact,finalIncomingFactincFact,Visitedvisited){   logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}", incFact.fact, incFact.delta, incFact.summaryEdge, stmt, alreadyResolvedAccPath);logger.trace("Checking Incoming Fact {} with delta '{}' ({}) at {} to resolve {}",incFact.fact,incFact.delta,incFact.summaryEdge,stmt,alreadyResolvedAccPath);  if(AccessPathUtil.isPrefixOf(concretizedStmtFact, incFact.fact) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(concretizedStmtFact,incFact.fact)==PrefixTestResult.GUARANTEED_PREFIX){ logger.trace("Resolved by incoming fact {}", incFact.fact);logger.trace("Resolved by incoming fact {}",incFact.fact); return true;returntrue; } else if(AccessPathUtil.isPrefixOf(incFact.fact, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {}elseif(AccessPathUtil.isPrefixOf(incFact.fact,concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ if(incFact.fact.getAccessPath().hasResolver()) {if(incFact.fact.getAccessPath().hasResolver()){ DecoratingResolver decoratingResolver = (DecoratingResolver) incFact.fact.getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)incFact.fact.getAccessPath().getResolver(); logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);logger.trace("Asking {} to resolve {}",decoratingResolver,alreadyResolvedAccPath); final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(incFact.fact.getAccessPath(), alreadyResolvedAccPath);finalConstraint<FieldRef>deltaConstraint=newDeltaConstraint<FieldRef>(incFact.fact.getAccessPath(),alreadyResolvedAccPath); if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath()) && deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {if(deltaConstraint.canBeAppliedTo(incFact.fact.getAccessPath())&&deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)){ boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, new ReturnConcretizationPathEdge<N, D>(booleanresolved=decoratingResolver.resolver.resolve(deltaConstraint,newReturnConcretizationPathEdge<N,D>( incFact.summaryEdge.getSourceFact(), incFact.summaryEdge.getSourceFact(), incFact.summaryEdge.getTargetStmt(), incFact.summaryEdge.getTargetStmt(), applyConstraint(deltaConstraint, incFact.summaryEdge.getTargetFact(), false)) {applyConstraint(deltaConstraint,incFact.summaryEdge.getTargetFact(),false)){ @Override@Override public void _propagate(D dSource, N target, D dTarget) {publicvoid_propagate(DdSource,Ntarget,DdTarget){ addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), applyConstraint(deltaConstraint, incFact.fact, false), incFact.delta);addIncomingFact(newSummaryEdge<>(dSource,target,dTarget),applyConstraint(deltaConstraint,incFact.fact,false),incFact.delta); }} }, decoratingResolver.alreadyResolvedAccPath, visited);},decoratingResolver.alreadyResolvedAccPath,visited); if(resolved) {if(resolved){ propagate(pathEdge, null, false);propagate(pathEdge,null,false); return true;returntrue; }} }} }} else {else{ D factWithDelta = incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath()));DfactWithDelta=incFact.fact.cloneWithAccessPath(incFact.delta.applyTo(incFact.fact.getAccessPath())); if(AccessPathUtil.isPrefixOf(concretizedStmtFact, factWithDelta) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(concretizedStmtFact,factWithDelta)==PrefixTestResult.GUARANTEED_PREFIX){ logger.trace("Resolved by incoming fact {} with delta {}", incFact.fact, incFact.delta);logger.trace("Resolved by incoming fact {} with delta {}",incFact.fact,incFact.delta); return true;returntrue; } else if(AccessPathUtil.isPrefixOf(factWithDelta, concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {}elseif(AccessPathUtil.isPrefixOf(factWithDelta,concretizedStmtFact).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ if(factWithDelta.getAccessPath().hasResolver()) {if(factWithDelta.getAccessPath().hasResolver()){ DecoratingResolver decoratingResolver = (DecoratingResolver) factWithDelta.getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)factWithDelta.getAccessPath().getResolver(); logger.trace("Asking {} to resolve {}", decoratingResolver, alreadyResolvedAccPath);logger.trace("Asking {} to resolve {}",decoratingResolver,alreadyResolvedAccPath);  final Constraint<FieldRef> deltaConstraint = new DeltaConstraint<FieldRef>(factWithDelta.getAccessPath(), alreadyResolvedAccPath);finalConstraint<FieldRef>deltaConstraint=newDeltaConstraint<FieldRef>(factWithDelta.getAccessPath(),alreadyResolvedAccPath); if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)) {if(deltaConstraint.canBeAppliedTo(decoratingResolver.alreadyResolvedAccPath)){ D target = applyConstraint(deltaConstraint, decoratingResolver.resolver.targetFact, false);Dtarget=applyConstraint(deltaConstraint,decoratingResolver.resolver.targetFact,false); target = target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint));target=target.cloneWithAccessPath(target.getAccessPath().setResolver(decoratingResolver).decorateResolver(deltaConstraint)); PathEdge<N, D> newEdge = new ReturnConcretizationPathEdge<N, D>(decoratingResolver.resolver.sourceFact, decoratingResolver.resolver.stmt, target) {PathEdge<N,D>newEdge=newReturnConcretizationPathEdge<N,D>(decoratingResolver.resolver.sourceFact,decoratingResolver.resolver.stmt,target){ @Override@Override protected void _propagate(D dSource, N target, D dTarget) {protectedvoid_propagate(DdSource,Ntarget,DdTarget){ FieldSensitiveIFDSSolver.this.propagate(pathEdge, null, false);FieldSensitiveIFDSSolver.this.propagate(pathEdge,null,false); }} };};  boolean resolved = decoratingResolver.resolver.resolve(deltaConstraint, newEdge, decoratingResolver.alreadyResolvedAccPath, visited);booleanresolved=decoratingResolver.resolver.resolve(deltaConstraint,newEdge,decoratingResolver.alreadyResolvedAccPath,visited); if(resolved) {if(resolved){ return true;returntrue; }} }} }} else {else{ final DeltaConstraint<FieldRef> deltaConstraint = new DeltaConstraint<>(alreadyResolvedAccPath, constraint.applyToAccessPath(factWithDelta.getAccessPath(), false));finalDeltaConstraint<FieldRef>deltaConstraint=newDeltaConstraint<>(alreadyResolvedAccPath,constraint.applyToAccessPath(factWithDelta.getAccessPath(),false)); AccessPath<FieldRef> newAccPath = deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null), false);AccessPath<FieldRef>newAccPath=deltaConstraint.applyToAccessPath(pathEdge.factAtTarget().getAccessPath().setResolver(null),false); boolean resolved = propagateConstrained(new ReturnConcretizationPathEdge<N, D>(booleanresolved=propagateConstrained(newReturnConcretizationPathEdge<N,D>( applyConstraint(constraint, sourceFact, true), pathEdge.getTarget(), applyConstraint(constraint,sourceFact,true),pathEdge.getTarget(), pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)) {pathEdge.factAtTarget().cloneWithAccessPath(newAccPath)){ @Override@Override protected void _propagate(D dSource, N target, D dTarget) {protectedvoid_propagate(DdSource,Ntarget,DdTarget){ addIncomingFact(new SummaryEdge<>(dSource, target, dTarget), dTarget, incFact.delta);addIncomingFact(newSummaryEdge<>(dSource,target,dTarget),dTarget,incFact.delta); }} }, visited);},visited); if(resolved)if(resolved) return true;returntrue; }} }} }} }} return false;returnfalse; }}  @Override@Override public String toString() {publicStringtoString(){ return stmt.toString();returnstmt.toString(); }} }} private class Visited {privateclassVisited{ Set<Resolver> resolver = Sets.newHashSet();Set<Resolver>resolver=Sets.newHashSet(); Map<N, Boolean> visitedCallSites = Maps.newHashMap();Map<N,Boolean>visitedCallSites=Maps.newHashMap(); }}  class DecoratingResolver implements SubPathResolver<FieldRef> {classDecoratingResolverimplementsSubPathResolver<FieldRef>{  private Resolver resolver;privateResolverresolver; private AccessPath<FieldRef> alreadyResolvedAccPath;privateAccessPath<FieldRef>alreadyResolvedAccPath; public DecoratingResolver(Resolver resolver) {publicDecoratingResolver(Resolverresolver){ this.resolver = resolver;this.resolver=resolver; this.alreadyResolvedAccPath = new AccessPath<FieldRef>();this.alreadyResolvedAccPath=newAccessPath<FieldRef>(); }}  public DecoratingResolver(Resolver resolver, AccessPath<FieldRef> alreadyResolvedAccPath) {publicDecoratingResolver(Resolverresolver,AccessPath<FieldRef>alreadyResolvedAccPath){ this.resolver = resolver;this.resolver=resolver; this.alreadyResolvedAccPath = alreadyResolvedAccPath;this.alreadyResolvedAccPath=alreadyResolvedAccPath; }}  public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {publicbooleanresolve(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge){ return resolve(constraint, pathEdge, new Visited());returnresolve(constraint,pathEdge,newVisited()); }} public boolean resolve(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge, Visited visited) {publicbooleanresolve(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge,Visitedvisited){ return resolver.resolve(constraint, pathEdge, alreadyResolvedAccPath, visited);returnresolver.resolve(constraint,pathEdge,alreadyResolvedAccPath,visited); }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((alreadyResolvedAccPath == null) ? 0 : alreadyResolvedAccPath.hashCode());result=prime*result+((alreadyResolvedAccPath==null)?0:alreadyResolvedAccPath.hashCode()); result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());result=prime*result+((resolver==null)?0:resolver.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; DecoratingResolver other = (DecoratingResolver) obj;DecoratingResolverother=(DecoratingResolver)obj; if (alreadyResolvedAccPath == null) {if(alreadyResolvedAccPath==null){ if (other.alreadyResolvedAccPath != null)if(other.alreadyResolvedAccPath!=null) return false;returnfalse; } else if (!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath))}elseif(!alreadyResolvedAccPath.equals(other.alreadyResolvedAccPath)) return false;returnfalse; if (resolver == null) {if(resolver==null){ if (other.resolver != null)if(other.resolver!=null) return false;returnfalse; } else if (!resolver.equals(other.resolver))}elseif(!resolver.equals(other.resolver)) return false;returnfalse; return true;returntrue; }}  @Override@Override public String toString() {publicStringtoString(){ return alreadyResolvedAccPath+ ":"+resolver.toString();returnalreadyResolvedAccPath+":"+resolver.toString(); }} @Override@Override public SubPathResolver<FieldRef> decorate(Constraint<FieldRef> constraint) {publicSubPathResolver<FieldRef>decorate(Constraint<FieldRef>constraint){ return new DecoratingResolver(resolver, constraint.applyToAccessPath(alreadyResolvedAccPath, false));returnnewDecoratingResolver(resolver,constraint.applyToAccessPath(alreadyResolvedAccPath,false)); }} }}  private class IncomingFact {privateclassIncomingFact{ private D fact;privateDfact; private Delta<FieldRef> delta;privateDelta<FieldRef>delta; private SummaryEdge<D, N> summaryEdge;privateSummaryEdge<D,N>summaryEdge; public IncomingFact(SummaryEdge<D, N> summaryEdge, D fact, Delta<FieldRef> delta) {publicIncomingFact(SummaryEdge<D,N>summaryEdge,Dfact,Delta<FieldRef>delta){ this.summaryEdge = summaryEdge;this.summaryEdge=summaryEdge; this.fact = fact;this.fact=fact; this.delta = delta;this.delta=delta; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + getOuterType().hashCode();result=prime*result+getOuterType().hashCode(); result = prime * result + ((delta == null) ? 0 : delta.hashCode());result=prime*result+((delta==null)?0:delta.hashCode()); result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode()); result = prime * result + ((summaryEdge == null) ? 0 : summaryEdge.hashCode());result=prime*result+((summaryEdge==null)?0:summaryEdge.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; IncomingFact other = (IncomingFact) obj;IncomingFactother=(IncomingFact)obj; if (!getOuterType().equals(other.getOuterType()))if(!getOuterType().equals(other.getOuterType())) return false;returnfalse; if (delta == null) {if(delta==null){ if (other.delta != null)if(other.delta!=null) return false;returnfalse; } else if (!delta.equals(other.delta))}elseif(!delta.equals(other.delta)) return false;returnfalse; if (fact == null) {if(fact==null){ if (other.fact != null)if(other.fact!=null) return false;returnfalse; } else if (!fact.equals(other.fact))}elseif(!fact.equals(other.fact)) return false;returnfalse; if (summaryEdge == null) {if(summaryEdge==null){ if (other.summaryEdge != null)if(other.summaryEdge!=null) return false;returnfalse; } else if (!summaryEdge.equals(other.summaryEdge))}elseif(!summaryEdge.equals(other.summaryEdge)) return false;returnfalse; return true;returntrue; }} private FieldSensitiveIFDSSolver getOuterType() {privateFieldSensitiveIFDSSolvergetOuterType(){ return FieldSensitiveIFDSSolver.this;returnFieldSensitiveIFDSSolver.this; }}  }}  /**/**	 * Computes the return flow function for the given set of caller-side	 * Computes the return flow function for the given set of caller-side	 * abstractions.	 * abstractions.	 * @param retFunction The return flow function to compute	 * @param retFunction The return flow function to compute	 * @param d2 The abstraction at the exit node in the callee	 * @param d2 The abstraction at the exit node in the callee	 * @param callSite The call site	 * @param callSite The call site	 * @return The set of caller-side abstractions at the return site	 * @return The set of caller-side abstractions at the return site	 */	 */ protected Set<ConstrainedFact<FieldRef, D>> computeReturnFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeReturnFlowFunction (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {(FlowFunction<FieldRef,D>retFunction,Dd2,NcallSite){ return retFunction.computeTargets(d2);returnretFunction.computeTargets(d2); }} /**/**	 * Lines 33-37 of the algorithm.	 * Lines 33-37 of the algorithm.	 * Simply propagate normal, intra-procedural flows.	 * Simply propagate normal, intra-procedural flows.	 * @param edge	 * @param edge	 */	 */ @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") private void processNormalFlow(PathEdge<N,D> edge) {privatevoidprocessNormalFlow(PathEdge<N,D>edge){ final D d1 = edge.factAtSource();finalDd1=edge.factAtSource(); final N n = edge.getTarget(); finalNn=edge.getTarget(); final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();  for (N m : icfg.getSuccsOf(n)) {for(Nm:icfg.getSuccsOf(n)){ FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);FlowFunction<FieldRef,D>flowFunction=flowFunctions.getNormalFlowFunction(n,m); Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);Set<ConstrainedFact<FieldRef,D>>res=computeNormalFlowFunction(flowFunction,d1,d2); for (ConstrainedFact<FieldRef, D> d3 : res) {for(ConstrainedFact<FieldRef,D>d3:res){ if(d3.getConstraint() != null) {if(d3.getConstraint()!=null){ if(d3.getFact().getAccessPath().hasResolver()) {if(d3.getFact().getAccessPath().hasResolver()){ AccessPath<FieldRef> accPath = d3.getFact().getAccessPath().decorateResolver(d3.getConstraint());AccessPath<FieldRef>accPath=d3.getFact().getAccessPath().decorateResolver(d3.getConstraint()); ((DecoratingResolver) d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(), new PathEdge<>(d1, m, d3.getFact().cloneWithAccessPath(accPath)));((DecoratingResolver)d3.getFact().getAccessPath().getResolver()).resolve(d3.getConstraint(),newPathEdge<>(d1,m,d3.getFact().cloneWithAccessPath(accPath))); } else}else propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));propagateConstrained(newPathEdge<>(applyConstraint(d3.getConstraint(),d1,true),m,d3.getFact())); }} elseelse propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);propagate(newPathEdge<>(d1,m,d3.getFact()),null,false); }} }} }}  private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {privateDapplyConstraint(Constraint<FieldRef>constraint,Dfact,booleansourceFact){ if(fact.equals(zeroValue))if(fact.equals(zeroValue)) return zeroValue;returnzeroValue; elseelse return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));returnfact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(),sourceFact)); }}  private boolean propagateConstrained(PathEdge<N, D> pathEdge) {privatebooleanpropagateConstrained(PathEdge<N,D>pathEdge){ return propagateConstrained(pathEdge, new Visited());returnpropagateConstrained(pathEdge,newVisited()); }}  private boolean propagateConstrained(PathEdge<N, D> pathEdge, Visited visited) {privatebooleanpropagateConstrained(PathEdge<N,D>pathEdge,Visitedvisited){ M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());McalleeMethod=icfg.getMethodOf(pathEdge.getTarget()); logger.trace("Checking interest at method {} in fact {} for edge {}", calleeMethod, pathEdge.factAtSource(), pathEdge);logger.trace("Checking interest at method {} in fact {} for edge {}",calleeMethod,pathEdge.factAtSource(),pathEdge); boolean propagate = false;booleanpropagate=false; if(pathEdge.factAtSource().equals(zeroValue))if(pathEdge.factAtSource().equals(zeroValue)) propagate = true;propagate=true; else if(hasPausedEdges(calleeMethod, pathEdge))elseif(hasPausedEdges(calleeMethod,pathEdge)) propagate = false;propagate=false; else {else{ Set<N> callSitesWithInterest = Sets.newHashSet();Set<N>callSitesWithInterest=Sets.newHashSet(); for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) { //guaranteedfor(IncomingEdge<D,N>incEdge:incomingEdgesPrefixedWith(calleeMethod,pathEdge.factAtSource())){//guaranteed callSitesWithInterest.add(incEdge.getCallSite());callSitesWithInterest.add(incEdge.getCallSite()); }} propagate = !callSitesWithInterest.isEmpty();propagate=!callSitesWithInterest.isEmpty();  Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf = incomingEdgesPotentialPrefixesOf(calleeMethod, pathEdge.factAtSource());Set<IncomingEdge<D,N>>incomingEdgesPotentialPrefixesOf=incomingEdgesPotentialPrefixesOf(calleeMethod,pathEdge.factAtSource()); Collection<IncomingEdge<D, N>> candidates = reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);Collection<IncomingEdge<D,N>>candidates=reduceToMostAbstractCalleeFactsPerCallSite(incomingEdgesPotentialPrefixesOf);  for(IncomingEdge<D, N> incEdge : candidates) { //potentialfor(IncomingEdge<D,N>incEdge:candidates){//potential if(visited.visitedCallSites.containsKey(incEdge.getCallSite())) {if(visited.visitedCallSites.containsKey(incEdge.getCallSite())){ if(visited.visitedCallSites.get(incEdge.getCallSite()) != null)if(visited.visitedCallSites.get(incEdge.getCallSite())!=null) propagate |= visited.visitedCallSites.get(incEdge.getCallSite());propagate|=visited.visitedCallSites.get(incEdge.getCallSite()); }} else {else{ if(!callSitesWithInterest.contains(incEdge.getCallSite())) {if(!callSitesWithInterest.contains(incEdge.getCallSite())){ if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()) {if(incEdge.getCalleeSourceFact().getAccessPath().hasResolver()){ Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());Constraint<FieldRef>callerConstraint=newDeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(),pathEdge.factAtSource().getAccessPath()); if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath())&& callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())){ DecoratingResolver decoratingResolver = (DecoratingResolver) incEdge.getCalleeSourceFact().getAccessPath().getResolver();DecoratingResolverdecoratingResolver=(DecoratingResolver)incEdge.getCalleeSourceFact().getAccessPath().getResolver(); D calleeSourceFact = applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true);DcalleeSourceFact=applyConstraint(callerConstraint,incEdge.getCalleeSourceFact(),true); calleeSourceFact = calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver(calleeSourceFact=calleeSourceFact.cloneWithAccessPath(calleeSourceFact.getAccessPath().setResolver( incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint)));incEdge.getCalleeSourceFact().getAccessPath().getResolver().decorate(callerConstraint))); boolean result = decoratingResolver.resolve(callerConstraint, new CallConcretizationPathEdge<>(booleanresult=decoratingResolver.resolve(callerConstraint,newCallConcretizationPathEdge<>( applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), applyConstraint(callerConstraint,incEdge.getCallerSourceFact(),true), incEdge.getCallSite(), incEdge.getCallSite(), applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false), applyConstraint(callerConstraint,incEdge.getCallerCallSiteFact(),false), calleeMethod,calleeMethod, calleeSourceFact), visited);calleeSourceFact),visited); visited.visitedCallSites.put(incEdge.getCallSite(), result);visited.visitedCallSites.put(incEdge.getCallSite(),result); propagate |= result;propagate|=result; }} }} else {else{ Constraint<FieldRef> callerConstraint = new DeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(), pathEdge.factAtSource().getAccessPath());Constraint<FieldRef>callerConstraint=newDeltaConstraint<FieldRef>(incEdge.getCalleeSourceFact().getAccessPath(),pathEdge.factAtSource().getAccessPath()); if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath()) && if(callerConstraint.canBeAppliedTo(incEdge.getCallerSourceFact().getAccessPath())&& callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())){  PathEdge<N,D> callerEdge = new CallConcretizationPathEdge<>(PathEdge<N,D>callerEdge=newCallConcretizationPathEdge<>( applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), applyConstraint(callerConstraint,incEdge.getCallerSourceFact(),true), incEdge.getCallSite(), incEdge.getCallSite(), applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),applyConstraint(callerConstraint,incEdge.getCallerCallSiteFact(),false), calleeMethod,calleeMethod, applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));applyConstraint(callerConstraint,incEdge.getCalleeSourceFact(),true)); visited.visitedCallSites.put(incEdge.getCallSite(), null);visited.visitedCallSites.put(incEdge.getCallSite(),null); boolean result = propagateConstrained(callerEdge, visited);booleanresult=propagateConstrained(callerEdge,visited); visited.visitedCallSites.put(incEdge.getCallSite(), result);visited.visitedCallSites.put(incEdge.getCallSite(),result); propagate |= result;propagate|=result; }} }} }} }} }} }}  if(propagate) {if(propagate){ propagate(pathEdge, pathEdge instanceof CallConcretizationPathEdge ? pathEdge.getTarget() : null, false);propagate(pathEdge,pathEdgeinstanceofCallConcretizationPathEdge?pathEdge.getTarget():null,false); return true;returntrue; } else {}else{ pauseEdge(pathEdge);pauseEdge(pathEdge); return false;returnfalse; }} }} private Collection<IncomingEdge<D, N>> reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D, N>> candidates) {privateCollection<IncomingEdge<D,N>>reduceToMostAbstractCalleeFactsPerCallSite(Set<IncomingEdge<D,N>>candidates){ Map<N, IncomingEdge<D, N>> result = Maps.newHashMap();Map<N,IncomingEdge<D,N>>result=Maps.newHashMap(); for(IncomingEdge<D, N> incEdge : candidates) {for(IncomingEdge<D,N>incEdge:candidates){ if(result.containsKey(incEdge.getCallSite())) {if(result.containsKey(incEdge.getCallSite())){ IncomingEdge<D, N> currentIncEdge = result.get(incEdge.getCallSite());IncomingEdge<D,N>currentIncEdge=result.get(incEdge.getCallSite()); if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(), currentIncEdge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX) {if(AccessPathUtil.isPrefixOf(incEdge.getCalleeSourceFact(),currentIncEdge.getCalleeSourceFact())==PrefixTestResult.GUARANTEED_PREFIX){ result.put(incEdge.getCallSite(), incEdge);result.put(incEdge.getCallSite(),incEdge); }} }} elseelse result.put(incEdge.getCallSite(), incEdge);result.put(incEdge.getCallSite(),incEdge); }} return result.values();returnresult.values(); }} private boolean hasPausedEdges(M calleeMethod, PathEdge<N, D> pathEdge) {privatebooleanhasPausedEdges(McalleeMethod,PathEdge<N,D>pathEdge){ ConcurrentHashSet<PathEdge<N, D>> pe = pausedEdges.get(calleeMethod);ConcurrentHashSet<PathEdge<N,D>>pe=pausedEdges.get(calleeMethod); if(pe != null) {if(pe!=null){ for(PathEdge<N, D> edge : pe) {for(PathEdge<N,D>edge:pe){ if(AccessPathUtil.isPrefixOf(edge.factAtSource(), pathEdge.factAtSource()) == PrefixTestResult.GUARANTEED_PREFIX)if(AccessPathUtil.isPrefixOf(edge.factAtSource(),pathEdge.factAtSource())==PrefixTestResult.GUARANTEED_PREFIX) return true;returntrue; }} }} return false;returnfalse; }} private void pauseEdge(PathEdge<N,D> edge) {privatevoidpauseEdge(PathEdge<N,D>edge){ M method = icfg.getMethodOf(edge.getTarget());Mmethod=icfg.getMethodOf(edge.getTarget()); ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());ConcurrentHashSet<PathEdge<N,D>>edges=pausedEdges.putIfAbsentElseGet(method,newConcurrentHashSet<PathEdge<N,D>>()); if(edges.add(edge)) {if(edges.add(edge)){ logger.trace("PAUSED: {}: {}", method, edge);logger.trace("PAUSED: {}: {}",method,edge); }} }}  /**/**	 * Computes the normal flow function for the given set of start and end	 * Computes the normal flow function for the given set of start and end	 * abstractions.	 * abstractions.	 * @param flowFunction The normal flow function to compute	 * @param flowFunction The normal flow function to compute	 * @param d1 The abstraction at the method's start node	 * @param d1 The abstraction at the method's start node	 * @param d1 The abstraction at the current node	 * @param d1 The abstraction at the current node	 * @return The set of abstractions at the successor node	 * @return The set of abstractions at the successor node	 */	 */ protected Set<ConstrainedFact<FieldRef, D>> computeNormalFlowFunctionprotectedSet<ConstrainedFact<FieldRef,D>>computeNormalFlowFunction (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {(FlowFunction<FieldRef,D>flowFunction,Dd1,Dd2){ return flowFunction.computeTargets(d2);returnflowFunction.computeTargets(d2); }}  /**/**	 * This method will be called for each incoming edge and can be used to	 * This method will be called for each incoming edge and can be used to	 * transfer knowledge from the calling edge to the returning edge, without	 * transfer knowledge from the calling edge to the returning edge, without	 * affecting the summary edges at the callee.	 * affecting the summary edges at the callee.	 * 	 * 	 * @param d4	 * @param d4	 *            Fact stored with the incoming edge, i.e., present at the	 *            Fact stored with the incoming edge, i.e., present at the	 *            caller side	 *            caller side	 * @param d5	 * @param d5	 *            Fact that originally should be propagated to the caller.	 *            Fact that originally should be propagated to the caller.	 * @return Fact that will be propagated to the caller.	 * @return Fact that will be propagated to the caller.	 */	 */ protected D restoreContextOnReturnedFact(D d4, D d5) {protectedDrestoreContextOnReturnedFact(Dd4,Dd5){ d5.setCallingContext(d4);d5.setCallingContext(d4); return d5;returnd5; }}  protected void propagateUnbalancedReturnFlow(PathEdge<N,D> edge,protectedvoidpropagateUnbalancedReturnFlow(PathEdge<N,D>edge, /* deliberately exposed to clients */ N relatedCallSite) {/* deliberately exposed to clients */NrelatedCallSite){ propagate(edge, relatedCallSite, true);propagate(edge,relatedCallSite,true); }}  private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> sourceBaseValueCache = HashMultimap.create();privateHashMultimap<CacheKey<N,D,BaseValue>,PathEdge<N,D>>sourceBaseValueCache=HashMultimap.create(); private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();privateHashMultimap<CacheKey<N,D,BaseValue>,PathEdge<N,D>>cache=HashMultimap.create(); private int cacheHits = 0;privateintcacheHits=0; private int cacheMerges = 0;privateintcacheMerges=0; private int cacheOppositePrefix = 0;privateintcacheOppositePrefix=0; private int cacheSourceBaseValue = 0;privateintcacheSourceBaseValue=0; private int concretizationEdges = 0;privateintconcretizationEdges=0; private int cacheEquals = 0;privateintcacheEquals=0; /**/**	 * Propagates the flow further down the exploded super graph. 	 * Propagates the flow further down the exploded super graph. 	 * @param edge the PathEdge that should be propagated	 * @param edge the PathEdge that should be propagated	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise	 * @param relatedCallSite for call and return flows the related call statement, <code>null</code> otherwise	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver}) 	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an unbalanced return	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})	 *        (this value is not used within this implementation but may be useful for subclasses of {@link IFDSSolver})	 */	 */ protected void propagate(PathEdge<N,D> edge,protectedvoidpropagate(PathEdge<N,D>edge, /* deliberately exposed to clients */ N relatedCallSite,/* deliberately exposed to clients */NrelatedCallSite, /* deliberately exposed to clients */ boolean isUnbalancedReturn) {/* deliberately exposed to clients */booleanisUnbalancedReturn){  final D existingVal = jumpFn.addFunction(edge);finalDexistingVal=jumpFn.addFunction(edge);   if(!edge.factAtTarget().getAccessPath().hasResolver()) {if(!edge.factAtTarget().getAccessPath().hasResolver()){ if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())) {if(!edge.factAtTarget().getAccessPath().hasAllExclusionsOf(edge.factAtSource().getAccessPath())){ throw new AssertionError();thrownewAssertionError(); }} }}  if(edge instanceof CallConcretizationPathEdge) {if(edgeinstanceofCallConcretizationPathEdge){ concretizationEdges++;concretizationEdges++; CallConcretizationPathEdge<M, N, D> concEdge = (CallConcretizationPathEdge<M,N,D>) edge;CallConcretizationPathEdge<M,N,D>concEdge=(CallConcretizationPathEdge<M,N,D>)edge; IncomingEdge<D, N> incomingEdge = new IncomingEdge<D, N>(concEdge.getCalleeSourceFact(), IncomingEdge<D,N>incomingEdge=newIncomingEdge<D,N>(concEdge.getCalleeSourceFact(), concEdge.getTarget(), concEdge.factAtSource(), concEdge.factAtTarget());concEdge.getTarget(),concEdge.factAtSource(),concEdge.factAtTarget()); if (!addIncoming(concEdge.getCalleeMethod(), incomingEdge))if(!addIncoming(concEdge.getCalleeMethod(),incomingEdge)) return;return;  resumeEdges(concEdge.getCalleeMethod(), concEdge.getCalleeSourceFact());resumeEdges(concEdge.getCalleeMethod(),concEdge.getCalleeSourceFact()); registerInterestedCaller(concEdge.getCalleeMethod(), incomingEdge);registerInterestedCaller(concEdge.getCalleeMethod(),incomingEdge); } else if(edge instanceof ReturnConcretizationPathEdge) {}elseif(edgeinstanceofReturnConcretizationPathEdge){ ((ReturnConcretizationPathEdge<N,D>) edge).propagate();((ReturnConcretizationPathEdge<N,D>)edge).propagate(); } else {}else{//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {//			if(cacheSourceBaseValue % 10_000 == 0 || cacheEquals % 100_000 == 0) {//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",//				System.out.println(String.format("cache hits: %,8d, cache hits on SourceBaseValue: %,8d, equals: %,8d, merges: %,8d, opposite: %,8d, concretizationEdges: %,8d",//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));//						cacheHits, cacheSourceBaseValue, cacheEquals, cacheMerges, cacheOppositePrefix, concretizationEdges));//			}//			}   if (existingVal != null) {if(existingVal!=null){ cacheEquals++;cacheEquals++; if (existingVal != edge.factAtTarget())if(existingVal!=edge.factAtTarget()) existingVal.addNeighbor(edge.factAtTarget());existingVal.addNeighbor(edge.factAtTarget()); }} else {else{ CacheKey<N,D,BaseValue> sourceValueKey = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource().getBaseValue(), edge.factAtTarget().getBaseValue());CacheKey<N,D,BaseValue>sourceValueKey=newCacheKey<N,D,BaseValue>(edge.getTarget(),edge.factAtSource().getBaseValue(),edge.factAtTarget().getBaseValue());  if(sourceBaseValueCache.containsKey(sourceValueKey)) {if(sourceBaseValueCache.containsKey(sourceValueKey)){ cacheSourceBaseValue++;cacheSourceBaseValue++; }} sourceBaseValueCache.put(sourceValueKey, edge);sourceBaseValueCache.put(sourceValueKey,edge);   CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());CacheKey<N,D,BaseValue>key=newCacheKey<N,D,BaseValue>(edge.getTarget(),edge.factAtSource(),edge.factAtTarget().getBaseValue()); if(cache.containsKey(key)) {if(cache.containsKey(key)){//					if(cacheHits % 10_000 == 0) {//					if(cacheHits % 10_000 == 0) {//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));//						System.out.println(String.format("cache hits: %,8d, merges: %,8d, opposite: %,8d", cacheHits, cacheMerges, cacheOppositePrefix));//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));//						System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));//						System.out.println(edge);//						System.out.println(edge);//						System.out.println(icfg.getMethodOf(edge.getTarget()));//						System.out.println(icfg.getMethodOf(edge.getTarget()));//						System.out.println("---");//						System.out.println("---");//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//							System.out.println(cachedEdge);//							System.out.println(cachedEdge);//						}//						}//						System.out.println("---");//						System.out.println("---");//					}//					} cacheHits++;cacheHits++; boolean opposite = false;booleanopposite=false; for(PathEdge<N,D> cachedEdge : cache.get(key)) {for(PathEdge<N,D>cachedEdge:cache.get(key)){ if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())) {if(cachedEdge.factAtTarget().getAccessPath().subsumes(edge.factAtTarget().getAccessPath())){ cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget()); cacheMerges++;cacheMerges++; logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);logger.trace("MERGE: {} with previous edge {}",edge,cachedEdge); return;return; }}//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))//						else if(edge.factAtTarget().getAccessPath().subsumes(cachedEdge.factAtTarget().getAccessPath()))//							opposite=true;//							opposite=true; }}//					if(opposite)//					if(opposite)//						cacheOppositePrefix++;//						cacheOppositePrefix++;//					else if(cache.get(key).size() > 500) {//					else if(cache.get(key).size() > 500) {//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");//						System.out.println("had to check "+cache.get(key).size()+" items to find out there is no subsumption relation");//						System.out.println(edge.factAtTarget());//						System.out.println(edge.factAtTarget());//					}//					} } }  cache.put(key, edge);cache.put(key,edge); scheduleEdgeProcessing(edge);scheduleEdgeProcessing(edge); if(edge.factAtTarget()!=zeroValue)if(edge.factAtTarget()!=zeroValue) logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);logger.trace("EDGE: {}: {}",icfg.getMethodOf(edge.getTarget()),edge); MethodAnalyzer<FieldRef, D,N,M> analyzer = methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint));MethodAnalyzer<FieldRef,D,N,M>analyzer=methodAnalyzers.getOrCreate(tabulationProblem.interproceduralCFG().getMethodOf(startPoint)); for(D val: seed.getValue()) {for(Dval:seed.getValue()){ analyzer.addInitialSeed(startPoint, val);analyzer.addInitialSeed(startPoint,val); debugger.initialSeed(startPoint);debugger.initialSeed(startPoint); }} }} }}  private static class CacheKey<N, D, BaseValue> {privatestaticclassCacheKey<N,D,BaseValue>{ private Object[] values;privateObject[]values; public CacheKey(Object...values) {publicCacheKey(Object...values){ this.values = values;this.values=values; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(values);result=prime*result+Arrays.hashCode(values); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof CacheKey))if(!(objinstanceofCacheKey)) return false;returnfalse; CacheKey other = (CacheKey) obj;CacheKeyother=(CacheKey)obj; if (!Arrays.equals(values, other.values))if(!Arrays.equals(values,other.values)) return false;returnfalse; return true;returntrue; }}  }} private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {privateSet<SummaryEdge<D,N>>endSummary(Mm,finalDd3){ Set<SummaryEdge<D, N>> map = endSummary.get(m);Set<SummaryEdge<D,N>>map=endSummary.get(m); if(map == null)if(map==null) return null;returnnull;  return Sets.filter(map, new Predicate<SummaryEdge<D,N>>() {returnSets.filter(map,newPredicate<SummaryEdge<D,N>>(){ @Override@Override public boolean apply(SummaryEdge<D, N> edge) {publicbooleanapply(SummaryEdge<D,N>edge){ return AccessPathUtil.isPrefixOf(edge.getSourceFact(), d3) == PrefixTestResult.GUARANTEED_PREFIX;returnAccessPathUtil.isPrefixOf(edge.getSourceFact(),d3)==PrefixTestResult.GUARANTEED_PREFIX; }} });}); }} private boolean addEndSummary(M m, SummaryEdge<D,N> summaryEdge) {privatebooleanaddEndSummary(Mm,SummaryEdge<D,N>summaryEdge){ Set<SummaryEdge<D, N>> summaries = endSummary.putIfAbsentElseGetSet<SummaryEdge<D,N>>summaries=endSummary.putIfAbsentElseGet (m, new ConcurrentHashSet<SummaryEdge<D, N>>());(m,newConcurrentHashSet<SummaryEdge<D,N>>()); return summaries.add(summaryEdge);returnsummaries.add(summaryEdge); } } protected Set<IncomingEdge<D, N>> incoming(M m) {protectedSet<IncomingEdge<D,N>>incoming(Mm){ Set<IncomingEdge<D, N>> result = incoming.get(m);Set<IncomingEdge<D,N>>result=incoming.get(m); if(result == null)if(result==null) return Collections.emptySet();returnCollections.emptySet(); elseelse return result;returnresult; }}  protected Set<IncomingEdge<D, N>> incomingEdgesPrefixedWith(M m, final D fact) {protectedSet<IncomingEdge<D,N>>incomingEdgesPrefixedWith(Mm,finalDfact){ Set<IncomingEdge<D, N>> result = incoming(m);Set<IncomingEdge<D,N>>result=incoming(m); return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {returnSets.filter(result,newPredicate<IncomingEdge<D,N>>(){ @Override@Override public boolean apply(IncomingEdge<D, N> edge) {publicbooleanapply(IncomingEdge<D,N>edge){ return AccessPathUtil.isPrefixOf(fact, edge.getCalleeSourceFact()) == PrefixTestResult.GUARANTEED_PREFIX;returnAccessPathUtil.isPrefixOf(fact,edge.getCalleeSourceFact())==PrefixTestResult.GUARANTEED_PREFIX; }} });}); }}  protected Set<IncomingEdge<D, N>> incomingEdgesPotentialPrefixesOf(M m, final D fact) {protectedSet<IncomingEdge<D,N>>incomingEdgesPotentialPrefixesOf(Mm,finalDfact){ Set<IncomingEdge<D, N>> result = incoming(m);Set<IncomingEdge<D,N>>result=incoming(m); return Sets.filter(result, new Predicate<IncomingEdge<D,N>>() {returnSets.filter(result,newPredicate<IncomingEdge<D,N>>(){ @Override@Override public boolean apply(IncomingEdge<D, N> edge) {publicbooleanapply(IncomingEdge<D,N>edge){ return AccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(), fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX);returnAccessPathUtil.isPrefixOf(edge.getCalleeSourceFact(),fact).atLeast(PrefixTestResult.POTENTIAL_PREFIX); }} });}); }}  protected boolean addIncoming(M m, IncomingEdge<D, N> incomingEdge) {protectedbooleanaddIncoming(Mm,IncomingEdge<D,N>incomingEdge){ logger.trace("Incoming Edge for method {}: {}", m, incomingEdge);logger.trace("Incoming Edge for method {}: {}",m,incomingEdge); Set<IncomingEdge<D,N>> set = incoming.putIfAbsentElseGet(m, new ConcurrentHashSet<IncomingEdge<D,N>>());Set<IncomingEdge<D,N>>set=incoming.putIfAbsentElseGet(m,newConcurrentHashSet<IncomingEdge<D,N>>()); return set.add(incomingEdge);returnset.add(incomingEdge); }}  /**/**	 * Factory method for this solver's thread-pool executor.	 * Factory method for this solver's thread-pool executor.	 */	 */ protected CountingThreadPoolExecutor getExecutor() {protectedCountingThreadPoolExecutorgetExecutor(){ return new CountingThreadPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());returnnewCountingThreadPoolExecutor(1,this.numThreads,30,TimeUnit.SECONDS,newLinkedBlockingQueue<Runnable>()); }}  /**/**	 * Returns a String used to identify the output of this solver in debug mode.	 * Returns a String used to identify the output of this solver in debug mode.	 * Subclasses can overwrite this string to distinguish the output from different solvers.	 * Subclasses can overwrite this string to distinguish the output from different solvers.	 */	 */ protected String getDebugName() {protectedStringgetDebugName(){ return "FAST IFDS SOLVER";return"FAST IFDS SOLVER"; }} public void printStats() {publicvoidprintStats(){ if(logger.isDebugEnabled()) {if(logger.isDebugEnabled()){ if(ffCache!=null)if(ffCache!=null) ffCache.printStats();ffCache.printStats(); } else {}else{ logger.info("No statistics were collected, as DEBUG is disabled.");logger.info("No statistics were collected, as DEBUG is disabled."); }} }}  private class PathEdgeProcessingTask implements Runnable {privateclassPathEdgeProcessingTaskimplementsRunnable{ private final PathEdge<N,D> edge;privatefinalPathEdge<N,D>edge; public PathEdgeProcessingTask(PathEdge<N,D> edge) {publicPathEdgeProcessingTask(PathEdge<N,D>edge){ this.edge = edge;this.edge=edge; }} public void run() {publicvoidrun(){ if(icfg.isCallStmt(edge.getTarget())) {if(icfg.isCallStmt(edge.getTarget())){ processCall(edge);processCall(edge); } else {}else{ //note that some statements, such as "throw" may be//note that some statements, such as "throw" may be //both an exit statement and a "normal" statement//both an exit statement and a "normal" statement if(icfg.isExitStmt(edge.getTarget())) {if(icfg.isExitStmt(edge.getTarget())){ processExit(edge);processExit(edge); }} if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()) {if(!icfg.getSuccsOf(edge.getTarget()).isEmpty()){ processNormalFlow(edge);processNormalFlow(edge); }} }} }} }}  public void writeDebugFile() {publicvoidwriteDebugFile(){ try {try{ FileWriter writer = new FileWriter("debug-solver-dump.json");FileWriterwriter=newFileWriter("debug-solver-dump.json"); writer.write("var methods= {\n\t");writer.write("var methods= {\n\t"); Enumeration<M> summaryEnumerable = endSummary.keys();Enumeration<M>summaryEnumerable=endSummary.keys();  while(summaryEnumerable.hasMoreElements()) {while(summaryEnumerable.hasMoreElements()){ M m = summaryEnumerable.nextElement();Mm=summaryEnumerable.nextElement(); writer.write("\""+m.toString()+"\"");writer.write("\""+m.toString()+"\""); writer.write(": { \n\t\tsummaries: [\n");writer.write(": { \n\t\tsummaries: [\n"); for(SummaryEdge<D,N> summary : endSummary.get(m)) {for(SummaryEdge<D,N>summary:endSummary.get(m)){ writer.write("\t\t\t{ \n\t\t\t\tsource: ");writer.write("\t\t\t{ \n\t\t\t\tsource: "); writeFact(writer, summary.getSourceFact());writeFact(writer,summary.getSourceFact()); writer.write(",\n\t\t\t\ttarget: ");writer.write(",\n\t\t\t\ttarget: "); writeFact(writer, summary.getTargetFact());writeFact(writer,summary.getTargetFact()); writer.write("\n\t\t\t},");writer.write("\n\t\t\t},"); }} writer.write("\n\t\t],");writer.write("\n\t\t],"); writer.write("\n\t\tincoming: [\n");writer.write("\n\t\tincoming: [\n"); Set<IncomingEdge<D, N>> incEdges = incoming.get(m);Set<IncomingEdge<D,N>>incEdges=incoming.get(m); if(incEdges!=null)if(incEdges!=null) for(IncomingEdge<D,N> incEdge : incEdges) {for(IncomingEdge<D,N>incEdge:incEdges){ writer.write("\t\t\t{ \n\t\t\t\tcallee_source: ");writer.write("\t\t\t{ \n\t\t\t\tcallee_source: "); writeFact(writer, incEdge.getCalleeSourceFact());writeFact(writer,incEdge.getCalleeSourceFact()); writer.write(",\n\t\t\t\tcalling_method: ");writer.write(",\n\t\t\t\tcalling_method: "); writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\"");writer.write("\""+icfg.getMethodOf(incEdge.getCallSite())+"\""); writer.write("\n\t\t\t},");writer.write("\n\t\t\t},"); }}  writer.write("\n\t\t]");writer.write("\n\t\t]"); writer.write("\n\t},\n");writer.write("\n\t},\n"); }}  writer.write("}");writer.write("}"); writer.flush();writer.flush(); writer.close();writer.close(); } catch (IOException e) {}catch(IOExceptione){ e.printStackTrace();e.printStackTrace(); }} }} private void writeFact(FileWriter writer, D sourceFact) throws IOException {privatevoidwriteFact(FileWriterwriter,DsourceFact)throwsIOException{ writer.write("{");writer.write("{");//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", ");//		writer.write("type: \""+((AbstractionWithSourceStmt) sourceFact).getAbstraction().getClass().getSimpleName()+"\", "); writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", ");writer.write("baseValue: \""+sourceFact.getBaseValue()+"\", "); writer.write("accPath: [");writer.write("accPath: ["); for(String s :sourceFact.getAccessPath().tokenize()) {for(Strings:sourceFact.getAccessPath().tokenize()){ writer.write("\""+s+"\",");writer.write("\""+s+"\","); }} writer.write("]}");writer.write("]}"); }}}}








src/heros/alias/FlowFunction.java








View file @ 3398e46f






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......












src/heros/alias/FlowFunction.java








View file @ 3398e46f








src/heros/alias/FlowFunction.java










View file @ 3398e46f


3398e46f



......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......






......@@ -31,29 +31,30 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);










 Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {










 










 private D fact;










 private WrappedFact<FieldRef, D, Stmt, Method> fact;










 private Constraint<FieldRef> constraint;










 










 public ConstrainedFact(D fact) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {










 this.fact = fact;










 this.constraint = null;










 }










 










 public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {










 ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.constraint = constraint;










 }










 










 public D getFact() {










 public WrappedFact<FieldRef, D, Stmt, Method> getFact() {










 return fact;










 }










 



......


 *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {publicinterfaceFlowFunction<FieldRefextendsAccessPath.FieldRef<FieldRef>,D extendsextends FieldSensitiveFactFieldSensitiveFact<?,<?, FieldRefFieldRef,, DD>>>{public interface FlowFunction<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {publicinterfaceFlowFunction<FieldRefextendsAccessPath.FieldRef<FieldRef>,D,, StmtStmt,, MethodMethod>{ /**/**	 * Returns the target values reachable from the source.	 * Returns the target values reachable from the source.	 */	 */ Set<ConstrainedFact<FieldRef, D>> computeTargets(D source);Set<ConstrainedFact<FieldRef,D>>computeTargets(Dsource); Set<ConstrainedFact<FieldRef, D, Stmt, Method>> computeTargets(D source, AccessPathHandler<FieldRef, D, Stmt, Method> accPathHandler);Set<ConstrainedFact<FieldRef,D,, StmtStmt,, MethodMethod>>computeTargets(Dsource,, AccessPathHandlerAccessPathHandler<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>> accPathHandleraccPathHandler);  public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> {publicstaticclassConstrainedFact<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>{  public static class ConstrainedFact<FieldRef extends AccessPath.FieldRef<FieldRef>, D, Stmt, Method> {publicstaticclassConstrainedFact<FieldRefextendsAccessPath.FieldRef<FieldRef>,D,Stmt,Method>{  private D fact;privateDDfact; private WrappedFact<FieldRef, D, Stmt, Method> fact;privateWrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>fact; private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint;  public ConstrainedFact(D fact) {publicpublic ConstrainedFact(DDfact){ ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact) {ConstrainedFact(WrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>fact){ this.fact = fact;this.fact=fact; this.constraint = null;this.constraint=null; }}  public ConstrainedFact(D fact, Constraint<FieldRef> constraint) {publicpublic ConstrainedFact(DDfact,Constraint<FieldRef>constraint){ ConstrainedFact(WrappedFact<FieldRef, D, Stmt, Method> fact, Constraint<FieldRef> constraint) {ConstrainedFact(WrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>fact,Constraint<FieldRef>constraint){ this.fact = fact;this.fact=fact; this.constraint = constraint;this.constraint=constraint; }}  public D getFact() {publicDDgetFact(){ public WrappedFact<FieldRef, D, Stmt, Method> getFact() {publicWrappedFactWrappedFact<<FieldRefFieldRef,, DD,, StmtStmt,, MethodMethod>>getFact(){ return fact;returnfact; }} 








src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}












src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644







View file @ 3398e46f








src/heros/alias/FlowFunctionProcessor.java



0 â†’ 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.ConstrainedFact;





















import java.util.Set;





















import com.google.common.collect.Sets;





















public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {





















 private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;





















 public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {










 this.flowFunctions = flowFunctions;










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










 










 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,










 IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 










 for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {










 factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 }










 return targets;










 }





















 public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, 










 Method calleeMethod, Stmt returnSite, Stmt callSite) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);










 return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import java.util.Set;importjava.util.Set;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class FlowFunctionProcessor<Fact, Stmt, Method, Field extends AccessPath.FieldRef<Field>> {publicclassFlowFunctionProcessor<Fact,Stmt,Method,FieldextendsAccessPath.FieldRef<Field>>{ private FlowFunctions<Stmt, Field, Fact, Method> flowFunctions;privateFlowFunctions<Stmt,Field,Fact,Method>flowFunctions; public FlowFunctionProcessor(FlowFunctions<Stmt, Field, Fact, Method> flowFunctions) {publicFlowFunctionProcessor(FlowFunctions<Stmt,Field,Fact,Method>flowFunctions){ this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; }}  public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeNormalFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source) {publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeNormalFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>source){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getNormalFlowFunction(source.getStatement());FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getNormalFlowFunction(source.getStatement()); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }}  public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calledMethod) {publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeCallFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>source,MethodcalledMethod){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallFlowFunction(source.getStatement(), calledMethod);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getCallFlowFunction(source.getStatement(),calledMethod); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }} public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Stmt returnSite) {publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeCallToReturnFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>source,StmtreturnSite){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getCallToReturnFlowFunction(source.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getCallToReturnFlowFunction(source.getStatement(),returnSite); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }} public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeReturnFlow(FactMergeHandler<Fact> factHandler, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, Method calleeMethod, Stmt returnSite,publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeReturnFlow(FactMergeHandler<Fact>factHandler,WrappedFactAtStatement<Field,Fact,Stmt,Method>source,MethodcalleeMethod,StmtreturnSite, IncomingEdge<Field, Fact, Stmt, Method> incEdge) {IncomingEdge<Field,Fact,Stmt,Method>incEdge){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), calleeMethod, source.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getReturnFlowFunction(incEdge.getCallSite(),calleeMethod,source.getStatement(),returnSite); Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));Set<ConstrainedFact<Field,Fact,Stmt,Method>>targets=flowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver()));  for (ConstrainedFact<Field, Fact, Stmt, Method> constrainedFact : targets) {for(ConstrainedFact<Field,Fact,Stmt,Method>constrainedFact:targets){ factHandler.restoreCallingContext(constrainedFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());factHandler.restoreCallingContext(constrainedFact.getFact().getFact(),incEdge.getCallerCallSiteFact().getFact()); }} return targets;returntargets; }} public Set<ConstrainedFact<Field, Fact, Stmt, Method>> computeUnbalancedReturnFlow(Fact zero, WrappedFactAtStatement<Field, Fact, Stmt, Method> source, publicSet<ConstrainedFact<Field,Fact,Stmt,Method>>computeUnbalancedReturnFlow(Factzero,WrappedFactAtStatement<Field,Fact,Stmt,Method>source, Method calleeMethod, Stmt returnSite, Stmt callSite) {MethodcalleeMethod,StmtreturnSite,StmtcallSite){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = flowFunctions.getReturnFlowFunction(callSite, calleeMethod, source.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=flowFunctions.getReturnFlowFunction(callSite,calleeMethod,source.getStatement(),returnSite); return flowFunction.computeTargets(source.getFact().getFact(), new AccessPathHandler<>(source.getFact().getAccessPath(), source.getFact().getResolver()));returnflowFunction.computeTargets(source.getFact().getFact(),newAccessPathHandler<>(source.getFact().getAccessPath(),source.getFact().getResolver())); }}}}








src/heros/alias/FlowFunctions.java








View file @ 3398e46f






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......












src/heros/alias/FlowFunctions.java








View file @ 3398e46f








src/heros/alias/FlowFunctions.java










View file @ 3398e46f


3398e46f



......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -35,12 +35,8 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);





















 










 /**



......@@ -52,7 +48,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +78,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +98,7 @@ public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldR









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......


 *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. */ */public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {publicinterfaceFlowFunctions<Stmt,FieldRefextendsAccessPath.FieldRef<FieldRef>,F extendsextends FieldSensitiveFactFieldSensitiveFact<?,<?, FieldRefFieldRef,, FF>,>Method>{public interface FlowFunctions<Stmt, FieldRef extends AccessPath.FieldRef<FieldRef>, F, Method> {publicinterfaceFlowFunctions<Stmt,FieldRefextendsAccessPath.FieldRef<FieldRef>,F,Method>{ /**/**	 * Returns the flow function that computes the flow for a normal statement,	 * Returns the flow function that computes the flow for a normal statement,	 * 	 * 	 * @param curr	 * @param curr	 *            The current statement.	 *            The current statement.	 * @param succ	 * @param succ	 *            The successor for which the flow is computed. This value can	 *            The successor for which the flow is computed. This value can	 *            be used to compute a branched analysis that propagates	 *            be used to compute a branched analysis that propagates	 *            different values depending on where control0flow branches.	 *            different values depending on where control0flow branches.	 */	 */ public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);publicFlowFunction<FieldRef,F>getNormalFlowFunction(Stmtcurr,, StmtStmt succsucc); public FlowFunction<FieldRef, F, Stmt, Method> getNormalFlowFunction(Stmt curr);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getNormalFlowFunction(Stmtcurr);  /**/**	 * @param destinationMethod	 * @param destinationMethod	 *            The concrete target method for which the flow is computed.	 *            The concrete target method for which the flow is computed.	 */	 */ public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);publicFlowFunction<FieldRef,F>getCallFlowFunction(StmtcallStmt,MethoddestinationMethod); public FlowFunction<FieldRef, F, Stmt, Method> getCallFlowFunction(Stmt callStmt, Method destinationMethod);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getCallFlowFunction(StmtcallStmt,MethoddestinationMethod); /**/**	 * Returns the flow function that computes the flow for a an exit from a	 * Returns the flow function that computes the flow for a an exit from a	 *            does not contain a caller for the method that is returned from.	 *            does not contain a caller for the method that is returned from.	 * @return	 * @return	 */	 */ public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);publicFlowFunction<FieldRef,F>getReturnFlowFunction(StmtcallSite,MethodcalleeMethod,StmtexitStmt,StmtreturnSite); public FlowFunction<FieldRef, F, Stmt, Method> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getReturnFlowFunction(StmtcallSite,MethodcalleeMethod,StmtexitStmt,StmtreturnSite); /**/**	 * Returns the flow function that computes the flow from a call site to a	 * Returns the flow function that computes the flow from a call site to a	 *            exceptional flow, this may actually be the start of an	 *            exceptional flow, this may actually be the start of an	 *            exception handler.	 *            exception handler.	 */	 */ public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);publicFlowFunction<FieldRef,F>getCallToReturnFlowFunction(StmtcallSite,StmtreturnSite); public FlowFunction<FieldRef, F, Stmt, Method> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);publicFlowFunction<FieldRef,F,, StmtStmt,, MethodMethod>getCallToReturnFlowFunction(StmtcallSite,StmtreturnSite);  








src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}












src/heros/alias/IFDSTabulationProblem.java








View file @ 3398e46f








src/heros/alias/IFDSTabulationProblem.java










View file @ 3398e46f


3398e46f



......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}






......@@ -13,6 +13,7 @@ package heros.alias;









import heros.InterproceduralCFG;










import heros.SolverConfiguration;










import heros.solver.IFDSSolver;










import heros.solver.Pair;





















import java.util.Map;










import java.util.Set;



......@@ -28,7 +29,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -64,4 +65,6 @@ public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<Fi









	 */










 D zeroValue();





















 ZeroHandler<FieldRef> zeroHandler();





















}


import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SolverConfiguration;importheros.SolverConfiguration;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.solver.Pair;importheros.solver.Pair;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set; * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRefextendsAccessPath.FieldRef<FieldRef>,Dextendsextends FieldSensitiveFactFieldSensitiveFact<?,<?, FieldRefFieldRef,, DD>,>M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{public interface IFDSTabulationProblem<N,FieldRef extends AccessPath.FieldRef<FieldRef>, D ,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRefextendsAccessPath.FieldRef<FieldRef>,D,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{ /**/**	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 */	 */ D zeroValue();DzeroValue(); ZeroHandler<FieldRef> zeroHandler();ZeroHandler<FieldRef>zeroHandler();}}








src/heros/alias/IncomingEdge.java








View file @ 3398e46f






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......












src/heros/alias/IncomingEdge.java








View file @ 3398e46f








src/heros/alias/IncomingEdge.java










View file @ 3398e46f


3398e46f



......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......






......@@ -10,50 +10,81 @@









 ******************************************************************************/










package heros.alias;





















public class IncomingEdge<D, N> {










import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















 private D calleeSourceFact;










 private N callSite;










 private D callerSourceFact;










 private D callerCallSiteFact;










public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;










 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;










 










 public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {










 super();










 public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, 










 WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {










 this.callerAnalyzer = callerAnalyzer;










 this.factAtCallSite = factAtCallSite;










 this.calleeSourceFact = calleeSourceFact;










 this.callSite = callSite;










 this.callerSourceFact = callerSourceFact;










 this.callerCallSiteFact = callerCallSiteFact;










 }










 










 public D getCalleeSourceFact() {










 public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {










 return calleeSourceFact;










 }










 










 public D getCallerCallSiteFact() {










 return callerCallSiteFact;










 public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {










 return factAtCallSite.getFact();










 }










 










 public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {










 return callerAnalyzer.wrappedSource();










 }










 










 public D getCallerSourceFact() {










 return callerSourceFact;










 public Stmt getCallSite() {










 return factAtCallSite.getStatement();










 }










 










 public N getCallSite() {










 return callSite;










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {










 return callerAnalyzer;










 }










 










 public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {










 final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());










 










 if(!factAtCallSite.canDeltaBeApplied(delta))










 return;










 










 factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), 










 calleeSourceFactWithDelta));










 }










 










 @Override










 public void canBeResolvedEmpty() {










 callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);










 }










 });










 }










 










 @Override










 public String toString() {










 return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";










 return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());










 result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());










 result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());










 result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());










 result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());










 return result;










 }














......@@ -63,28 +94,23 @@ public class IncomingEdge<D, N> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof IncomingEdge))










 if (getClass() != obj.getClass())










 return false;










 IncomingEdge other = (IncomingEdge) obj;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeSourceFact == null) {










 if (other.calleeSourceFact != null)










 return false;










 } else if (!calleeSourceFact.equals(other.calleeSourceFact))










 return false;










 if (callerCallSiteFact == null) {










 if (other.callerCallSiteFact != null)










 if (callerAnalyzer == null) {










 if (other.callerAnalyzer != null)










 return false;










 } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))










 } else if (!callerAnalyzer.equals(other.callerAnalyzer))










 return false;










 if (callerSourceFact == null) {










 if (other.callerSourceFact != null)










 if (factAtCallSite == null) {










 if (other.factAtCallSite != null)










 return false;










 } else if (!callerSourceFact.equals(other.callerSourceFact))










 } else if (!factAtCallSite.equals(other.factAtCallSite))










 return false;










 return true;










 }



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class IncomingEdge<D, N> {publicclassIncomingEdge<D,N>{import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult; private D calleeSourceFact;privateDcalleeSourceFact; private N callSite;privateNcallSite; private D callerSourceFact;privateDcallerSourceFact; private D callerCallSiteFact;privateDcallerCallSiteFact;public class IncomingEdge<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassIncomingEdge<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ private WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact;privateWrappedFact<Field,Fact,Stmt,Method>calleeSourceFact; private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer;privatePerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>callerAnalyzer; private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite;privateWrappedFactAtStatement<Field,Fact,Stmt,Method>factAtCallSite;  public IncomingEdge(D calleeSourceFact, N callSite, D callerSourceFact, D callerCallSiteFact) {publicIncomingEdge(DcalleeSourceFact,NcallSite,DcallerSourceFact,DcallerCallSiteFact){ super();super(); public IncomingEdge(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> callerAnalyzer, publicIncomingEdge(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>callerAnalyzer, WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtCallSite,WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtCallSite, WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact) {WrappedFact<Field,Fact,Stmt,Method>calleeSourceFact){ this.callerAnalyzer = callerAnalyzer;this.callerAnalyzer=callerAnalyzer; this.factAtCallSite = factAtCallSite;this.factAtCallSite=factAtCallSite; this.calleeSourceFact = calleeSourceFact;this.calleeSourceFact=calleeSourceFact; this.callSite = callSite;this.callSite=callSite; this.callerSourceFact = callerSourceFact;this.callerSourceFact=callerSourceFact; this.callerCallSiteFact = callerCallSiteFact;this.callerCallSiteFact=callerCallSiteFact; }}  public D getCalleeSourceFact() {publicDDgetCalleeSourceFact(){ public WrappedFact<Field, Fact, Stmt, Method> getCalleeSourceFact() {publicWrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>>getCalleeSourceFact(){ return calleeSourceFact;returncalleeSourceFact; }}  public D getCallerCallSiteFact() {publicDgetCallerCallSiteFact(){ return callerCallSiteFact;returncallerCallSiteFact; public WrappedFact<Field, Fact, Stmt, Method> getCallerCallSiteFact() {publicWrappedFact<Field,Fact,Stmt,Method>getCallerCallSiteFact(){ return factAtCallSite.getFact();returnfactAtCallSite.getFact(); }}  public WrappedFact<Field, Fact, Stmt, Method> getCallerSourceFact() {publicWrappedFact<Field,Fact,Stmt,Method>getCallerSourceFact(){ return callerAnalyzer.wrappedSource();returncallerAnalyzer.wrappedSource(); }}  public D getCallerSourceFact() {publicDDgetCallerSourceFacterSourceFact(){ return callerSourceFact;returncallerSourceFactcallerSourceFact; public Stmt getCallSite() {publicStmtStmtgetCallSiteSite(){ return factAtCallSite.getStatement();returnfactAtCallSitefactAtCallSite..getStatementgetStatement();() }}  public N getCallSite() {publicNgetCallSite(){ return callSite;returncallSite; public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getCallerAnalyzer() {publicPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>getCallerAnalyzer(){ return callerAnalyzer;returncallerAnalyzer; }}  public void registerInterestCallback(final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> interestedAnalyzer) {publicvoidregisterInterestCallback(finalPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>interestedAnalyzer){ final Delta<Field> delta = calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());finalDelta<Field>delta=calleeSourceFact.getAccessPath().getDeltaTo(interestedAnalyzer.getAccessPath());  if(!factAtCallSite.canDeltaBeApplied(delta))if(!factAtCallSite.canDeltaBeApplied(delta)) return;return;  factAtCallSite.getFact().getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {factAtCallSite.getFact().getResolver().resolve(newDeltaConstraint<Field>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){  @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath(), false), resolver);WrappedFact<Field,Fact,Stmt,Method>calleeSourceFactWithDelta=newWrappedFact<>(calleeSourceFact.getFact(),delta.applyTo(calleeSourceFact.getAccessPath(),false),resolver); if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath())!=PrefixTestResult.GUARANTEED_PREFIX) throw new AssertionError();thrownewAssertionError(); interestedAnalyzer.addIncomingEdge(new IncomingEdge<>(analyzer, interestedAnalyzer.addIncomingEdge(newIncomingEdge<>(analyzer, new WrappedFactAtStatement<>(factAtCallSite.getStatement(), newWrappedFactAtStatement<>(factAtCallSite.getStatement(), new WrappedFact<>(factAtCallSite.getFact().getFact(), delta.applyTo(factAtCallSite.getFact().getAccessPath(), false), resolver)), newWrappedFact<>(factAtCallSite.getFact().getFact(),delta.applyTo(factAtCallSite.getFact().getAccessPath(),false),resolver)), calleeSourceFactWithDelta));calleeSourceFactWithDelta)); }}  @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ callerAnalyzer.getCallEdgeResolver().resolve(new DeltaConstraint<Field>(delta), this);callerAnalyzer.getCallEdgeResolver().resolve(newDeltaConstraint<Field>(delta),this); }} });}); }}  @Override@Override public String toString() {publicStringtoString(){ return "[IncEdge CSite:"+callSite+", Caller-Edge: "+callerSourceFact+"->"+callerCallSiteFact+",  CalleeFact: "+calleeSourceFact+"]";return"[IncEdge CSite:"+callSitec+", Caller-Edge: "+callerSourceFactc+"->"+callerCallSiteFactc+",  CalleeFact: "+calleeSourceFact+"]"; return "[IncEdge CSite:"+getCallSite()+", Caller-Edge: "+getCallerSourceFact()+"->"+getCallerCallSiteFact()+",  CalleeFact: "+calleeSourceFact+"]";return"[IncEdge CSite:"+getCallSitegetC()+()", Caller-Edge: "+getCallerSourceFactgetC()+()"->"+getCallerCallSiteFactgetC()+()",  CalleeFact: "+calleeSourceFact+"]"; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());result=prime*result+((callSite==null)?0:callSite.hashCode()); result = prime * result + ((calleeSourceFact == null) ? 0 : calleeSourceFact.hashCode());result=prime*result+((calleeSourceFact==null)?0:calleeSourceFact.hashCode()); result = prime * result + ((callerCallSiteFact == null) ? 0 : callerCallSiteFact.hashCode());result=prime*result+((callerCallSiteFactCallSiteFact==null)?0:callerCallSiteFactCallSiteFact.hashCode()); result = prime * result + ((callerSourceFact == null) ? 0 : callerSourceFact.hashCode());result=prime*result+((callerSourceFactcallerSourceFact ==== nullnull)) ?? 00 :: callerSourceFactcallerSourceFact.hashCode()); result = prime * result + ((callerAnalyzer == null) ? 0 : callerAnalyzer.hashCode());result=prime*result+((callerAnalyzerAnalyzer==null)?0:callerAnalyzerAnalyzer.hashCode()); result = prime * result + ((factAtCallSite == null) ? 0 : factAtCallSite.hashCode());result=prime*result+((factAtCallSitefactAtCallSite ==== nullnull)) ?? 00 :: factAtCallSitefactAtCallSite.hashCode()); return result;returnresult; }} return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof IncomingEdge))if(!(!(objobj instanceofinstanceof IncomingEdgeIncomingEdge)) if (getClass() != obj.getClass())if(getClassgetClass()() !=!= objobj..getClassgetClass())( return false;returnfalse; IncomingEdge other = (IncomingEdge) obj;IncomingEdgeother=(IncomingEdge)obj; if (callSite == null) {if(callSite==null){ if (other.callSite != null)if(other.callSite!=null) return false;returnfalse; } else if (!callSite.equals(other.callSite))}elseif(!callSite.equals(other.callSite)) return false;returnfalse; if (calleeSourceFact == null) {if(calleeSourceFact==null){ if (other.calleeSourceFact != null)if(other.calleeSourceFact!=null) return false;returnfalse; } else if (!calleeSourceFact.equals(other.calleeSourceFact))}elseif(!calleeSourceFact.equals(other.calleeSourceFact)) return false;returnfalse; if (callerCallSiteFact == null) {if(callerCallSiteFactCallSiteFact==null){ if (other.callerCallSiteFact != null)if(other.callerCallSiteFactCallSiteFact!=null) if (callerAnalyzer == null) {if(callerAnalyzerAnalyzer==null){ if (other.callerAnalyzer != null)if(other.callerAnalyzerAnalyzer!=null) return false;returnfalse; } else if (!callerCallSiteFact.equals(other.callerCallSiteFact))}elseif(!callerCallSiteFactCallSiteFact.equals(other.callerCallSiteFactCallSiteFact)) } else if (!callerAnalyzer.equals(other.callerAnalyzer))}elseif(!callerAnalyzerAnalyzer.equals(other.callerAnalyzerAnalyzer)) return false;returnfalse; if (callerSourceFact == null) {if(callerSourceFactcallerSourceFact==null){ if (other.callerSourceFact != null)if(other.callerSourceFactcallerSourceFact!=null) if (factAtCallSite == null) {if(factAtCallSitefactAtCallSite==null){ if (other.factAtCallSite != null)if(other.factAtCallSitefactAtCallSite!=null) return false;returnfalse; } else if (!callerSourceFact.equals(other.callerSourceFact))}elseif(!callerSourceFactcallerSourceFact..equalsequals((otherother..callerSourceFactcallerSourceFact)) } else if (!factAtCallSite.equals(other.factAtCallSite))}elseif(!factAtCallSitefactAtCallSite..equalsequals((otherother..factAtCallSitefactAtCallSite)) return false;returnfalse; return true;returntrue; }}



Prev


1


2


3


Next





Prev

1

2

3

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






