



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

2b03285f















Commit
2b03285f


authored
Jun 01, 2015
by


Johannes Lerch



Browse files




switching to Java 6 compatibility







parent
8e3dd9b0













Changes
16




Hide whitespace changes

Inline
Side-by-side















build.xml








View file @ 2b03285f






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......














src/heros/fieldsens/AccessPath.java








View file @ 2b03285f






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......














src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......














src/heros/fieldsens/CallEdge.java








View file @ 2b03285f






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......














src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......














src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......














src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......














src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......














src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......














src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......














test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......














test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......














test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......














test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......














test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

2b03285f















Commit
2b03285f


authored
Jun 01, 2015
by


Johannes Lerch



Browse files




switching to Java 6 compatibility







parent
8e3dd9b0













Changes
16




Hide whitespace changes

Inline
Side-by-side















build.xml








View file @ 2b03285f






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......














src/heros/fieldsens/AccessPath.java








View file @ 2b03285f






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......














src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......














src/heros/fieldsens/CallEdge.java








View file @ 2b03285f






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......














src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......














src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......














src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......














src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......














src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......














src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......














test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......














test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......














test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......














test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......














test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

2b03285f







Open sidebar



Joshua Garcia heros
Commits

2b03285f




Open sidebar

Joshua Garcia heros
Commits

2b03285f


Joshua GarciaherosherosCommits
2b03285f








Commit
2b03285f


authored
Jun 01, 2015
by


Johannes Lerch



Browse files




switching to Java 6 compatibility







parent
8e3dd9b0













Changes
16




Hide whitespace changes

Inline
Side-by-side















build.xml








View file @ 2b03285f






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......














src/heros/fieldsens/AccessPath.java








View file @ 2b03285f






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......














src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......














src/heros/fieldsens/CallEdge.java








View file @ 2b03285f






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......














src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......














src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......














src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......














src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......














src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......














src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......














test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......














test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......














test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......














test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......














test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
2b03285f


authored
Jun 01, 2015
by


Johannes Lerch



Browse files




switching to Java 6 compatibility







parent
8e3dd9b0













Changes
16




Hide whitespace changes

Inline
Side-by-side















build.xml








View file @ 2b03285f






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......














src/heros/fieldsens/AccessPath.java








View file @ 2b03285f






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......














src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......














src/heros/fieldsens/CallEdge.java








View file @ 2b03285f






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......














src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......














src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......














src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......














src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......














src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......














src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......














test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......














test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......














test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......














test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......














test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
2b03285f


authored
Jun 01, 2015
by


Johannes Lerch



Browse files



Commit
2b03285f


authored
Jun 01, 2015
by


Johannes Lerch

2b03285fauthoredbyJohannes Lerch

switching to Java 6 compatibility






parent
8e3dd9b0
















parent
8e3dd9b0





parent












Changes
16
16


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










build.xml








View file @ 2b03285f






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......














src/heros/fieldsens/AccessPath.java








View file @ 2b03285f






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......














src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......














src/heros/fieldsens/CallEdge.java








View file @ 2b03285f






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......














src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......














src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......














src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......














src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......














src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......














src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......














test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......














test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......














test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......














test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......














test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......














test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......














build.xml








View file @ 2b03285f






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......












build.xml








View file @ 2b03285f








build.xml










View file @ 2b03285f


2b03285f



......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......






......@@ -37,8 +37,8 @@









 debug="true"










 includeantruntime="true"










 deprecation="on"










 source="1.5"










 target="1.5"










 source="1.6"










 target="1.6"










 fork="true"










 memorymaximumsize="512m"










 >



......


 debug="true"debug="true" includeantruntime="true"includeantruntime="true" deprecation="on"deprecation="on" source="1.5"source="1.5"5 target="1.5"target="1.5"5 source="1.6"source="1.6"6 target="1.6"target="1.6"6 fork="true"fork="true" memorymaximumsize="512m"memorymaximumsize="512m" >>








src/heros/fieldsens/AccessPath.java








View file @ 2b03285f






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......












src/heros/fieldsens/AccessPath.java








View file @ 2b03285f








src/heros/fieldsens/AccessPath.java










View file @ 2b03285f


2b03285f



......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......






......@@ -58,32 +58,32 @@ public class AccessPath<T> {




















 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 return new AccessPath<>(newAccesses, Sets.<T>newHashSet());










 return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());










 }





















 public AccessPath<T> prepend(T fieldRef) {










 T[] newAccesses = (T[]) new Object[accesses.length+1];










 newAccesses[0] = fieldRef;










 System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }





















 public AccessPath<T> removeFirst() {










 T[] newAccesses = (T[]) new Object[accesses.length-1];










 System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);










 return new AccessPath<>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }





















 public static enum PrefixTestResult {



......@@ -209,7 +209,7 @@ public class AccessPath<T> {









 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<T>(accesses, newExclusions);










 }










 










 public boolean canRead(T field) {



......


 T[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);T[]newAccesses=Arrays.copyOf(accesses,accesses.length+fieldReferences.length); System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);System.arraycopy(fieldReferences,0,newAccesses,accesses.length,fieldReferences.length); return new AccessPath<>(newAccesses, Sets.<T>newHashSet());returnnewAccessPath<>(newAccesses,Sets.<T>newHashSet()); return new AccessPath<T>(newAccesses, Sets.<T>newHashSet());returnnewAccessPath<TT>(newAccesses,Sets.<T>newHashSet()); }} public AccessPath<T> prepend(T fieldRef) {publicAccessPath<T>prepend(TfieldRef){ T[] newAccesses = (T[]) new Object[accesses.length+1];T[]newAccesses=(T[])newObject[accesses.length+1]; newAccesses[0] = fieldRef;newAccesses[0]=fieldRef; System.arraycopy(accesses, 0, newAccesses, 1, accesses.length);System.arraycopy(accesses,0,newAccesses,1,accesses.length); return new AccessPath<>(newAccesses, exclusions);returnnewAccessPath<>(newAccesses,exclusions); return new AccessPath<T>(newAccesses, exclusions);returnnewAccessPath<TT>(newAccesses,exclusions); }} public AccessPath<T> removeFirst() {publicAccessPath<T>removeFirst(){ T[] newAccesses = (T[]) new Object[accesses.length-1];T[]newAccesses=(T[])newObject[accesses.length-1]; System.arraycopy(accesses, 1, newAccesses, 0, accesses.length-1);System.arraycopy(accesses,1,newAccesses,0,accesses.length-1); return new AccessPath<>(newAccesses, exclusions);returnnewAccessPath<>(newAccesses,exclusions); return new AccessPath<T>(newAccesses, exclusions);returnnewAccessPath<TT>(newAccesses,exclusions); }}  public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(Collection<T>fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); return new AccessPath<T>(accesses, newExclusions);returnnewAccessPath<TT>(accesses,newExclusions); }}  public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(T...fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); return new AccessPath<T>(accesses, newExclusions);returnnewAccessPath<TT>(accesses,newExclusions); }} public static enum PrefixTestResult {publicstaticenumPrefixTestResult{ public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {publicAccessPath<T>mergeExcludedFieldReferences(AccessPath<T>accPath){ HashSet<T> newExclusions = Sets.newHashSet(exclusions);HashSet<T>newExclusions=Sets.newHashSet(exclusions); newExclusions.addAll(accPath.exclusions);newExclusions.addAll(accPath.exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); return new AccessPath<T>(accesses, newExclusions);returnnewAccessPath<TT>(accesses,newExclusions); }}  public boolean canRead(T field) {publicbooleancanRead(Tfield){








src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......












src/heros/fieldsens/AccessPathHandler.java








View file @ 2b03285f








src/heros/fieldsens/AccessPathHandler.java










View file @ 2b03285f


2b03285f



......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......






......@@ -38,18 +38,18 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 }





















 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 }










 










 public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));










 }










 










 public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {










 return new ResultBuilder<Field, Fact, Stmt, Method>() {










 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));










 }










 };










 }



......@@ -60,9 +60,9 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 @Override










 public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {










 if(canRead(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));










 }










 };










 }



......@@ -78,13 +78,13 @@ public class AccessPathHandler<Field, Fact, Stmt, Method> {









 if(accessPath.canRead(field)) {










 AccessPath<Field> tempAccPath = accessPath.removeFirst();










 if(tempAccPath.hasEmptyAccessPath())










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));










 } else if(accessPath.isAccessInExclusions(field))










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));










 else










 return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));










 return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));










 }










 };










 else



......


 }} public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ return new ConstrainedFact<>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));returnnewConstrainedFact<>(newWrappedFact<Field,Fact,Stmt,Method>(fact,accessPath,resolver)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(newWrappedFact<Field,Fact,Stmt,Method>(fact,accessPath,resolver)); }}  public ConstrainedFact<Field, Fact, Stmt, Method> generateWithEmptyAccessPath(Fact fact, ZeroHandler<Field> zeroHandler) {publicConstrainedFact<Field,Fact,Stmt,Method>generateWithEmptyAccessPath(Factfact,ZeroHandler<Field>zeroHandler){ return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<>(resolver.analyzer, zeroHandler)));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,newAccessPath<Field>(),newZeroCallEdgeResolver<>(resolver.analyzer,zeroHandler))); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(resolver.analyzer, zeroHandler)));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,newAccessPath<Field>(),newZeroCallEdgeResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(resolver.analyzer,zeroHandler))); }}  public ResultBuilder<Field, Fact, Stmt, Method> prepend(final Field field) {publicResultBuilder<Field,Fact,Stmt,Method>prepend(finalFieldfield){ return new ResultBuilder<Field, Fact, Stmt, Method>() {returnnewResultBuilder<Field,Fact,Stmt,Method>(){ @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.prepend(field), resolver));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,accessPath.prepend(field),resolver)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.prepend(field), resolver));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,accessPath.prepend(field),resolver)); }} };}; }} @Override@Override public ConstrainedFact<Field, Fact, Stmt, Method> generate(Fact fact) {publicConstrainedFact<Field,Fact,Stmt,Method>generate(Factfact){ if(canRead(field))if(canRead(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.removeFirst(), resolver));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,accessPath.removeFirst(),resolver)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.removeFirst(), resolver));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,accessPath.removeFirst(),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<>(field));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,newAccessPath<Field>(),resolver),newReadFieldConstraint<>(field)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, new AccessPath<Field>(), resolver), new ReadFieldConstraint<Field>(field));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,newAccessPath<Field>(),resolver),newReadFieldConstraint<FieldField>(field)); }} };}; }} if(accessPath.canRead(field)) {if(accessPath.canRead(field)){ AccessPath<Field> tempAccPath = accessPath.removeFirst();AccessPath<Field>tempAccPath=accessPath.removeFirst(); if(tempAccPath.hasEmptyAccessPath())if(tempAccPath.hasEmptyAccessPath()) return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,tempAccPath.appendExcludedFieldReference(field),resolver)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath.appendExcludedFieldReference(field), resolver));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,tempAccPath.appendExcludedFieldReference(field),resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, tempAccPath, resolver));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,tempAccPath,resolver)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, tempAccPath, resolver));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,tempAccPath,resolver)); } else if(accessPath.isAccessInExclusions(field))}elseif(accessPath.isAccessInExclusions(field)) return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath, resolver));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,accessPath,resolver)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath, resolver));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,accessPath,resolver)); elseelse return new ConstrainedFact<>(new WrappedFact<>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<>(field));returnnewConstrainedFact<>(>(newnew WrappedFactWrappedFact<>(<fact,accessPath.appendExcludedFieldReference(field),resolver),newWriteFieldConstraint<>(field)); return new ConstrainedFact<Field, Fact, Stmt, Method>(new WrappedFact<Field, Fact, Stmt, Method>(fact, accessPath.appendExcludedFieldReference(field), resolver), new WriteFieldConstraint<Field>(field));returnnewConstrainedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(>(newnew WrappedFactWrappedFact<<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,accessPath.appendExcludedFieldReference(field),resolver),newWriteFieldConstraint<FieldField>(field)); }} };}; elseelse








src/heros/fieldsens/CallEdge.java








View file @ 2b03285f






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......












src/heros/fieldsens/CallEdge.java








View file @ 2b03285f








src/heros/fieldsens/CallEdge.java










View file @ 2b03285f


2b03285f



......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......






......@@ -60,12 +60,12 @@ public class CallEdge<Field, Fact, Stmt, Method> {









 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);










 if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)










 throw new AssertionError();










 interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, 










 new WrappedFactAtStatement<>(factAtCallSite.getStatement(), 










 new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), 










 new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), 










 new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), 










 delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), 










 resolver)), 










 calleeSourceFactWithDelta));



......


  @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);WrappedFact<Field,Fact,Stmt,Method>calleeSourceFactWithDelta=newWrappedFact<>(calleeSourceFact.getFact(),delta.applyTo(calleeSourceFact.getAccessPath()),resolver); WrappedFact<Field, Fact, Stmt, Method> calleeSourceFactWithDelta = new WrappedFact<Field, Fact, Stmt, Method>(calleeSourceFact.getFact(), delta.applyTo(calleeSourceFact.getAccessPath()), resolver);WrappedFact<Field,Fact,Stmt,Method>calleeSourceFactWithDelta=newWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(calleeSourceFact.getFact(),delta.applyTo(calleeSourceFact.getAccessPath()),resolver); if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath()) != PrefixTestResult.GUARANTEED_PREFIX)if(interestedAnalyzer.getAccessPath().isPrefixOf(calleeSourceFactWithDelta.getAccessPath())!=PrefixTestResult.GUARANTEED_PREFIX) throw new AssertionError();thrownewAssertionError(); interestedAnalyzer.addIncomingEdge(new CallEdge<Field, Fact, Stmt, Method>(analyzer, interestedAnalyzer.addIncomingEdge(newCallEdge<Field,Fact,Stmt,Method>(analyzer, new WrappedFactAtStatement<>(factAtCallSite.getStatement(), newWrappedFactAtStatement<>(factAtCallSite.getStatement(), new WrappedFact<>(factAtCallSite.getWrappedFact().getFact(), newWrappedFact<>(factAtCallSite.getWrappedFact().getFact(), new WrappedFactAtStatement<Field, Fact, Stmt, Method>(factAtCallSite.getStatement(), newWrappedFactAtStatement<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtCallSite.getStatement(), new WrappedFact<Field, Fact, Stmt, Method>(factAtCallSite.getWrappedFact().getFact(), newWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtCallSite.getWrappedFact().getFact(), delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), delta.applyTo(factAtCallSite.getWrappedFact().getAccessPath()), resolver)), resolver)), calleeSourceFactWithDelta));calleeSourceFactWithDelta));








src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......












src/heros/fieldsens/ControlFlowJoinResolver.java








View file @ 2b03285f








src/heros/fieldsens/ControlFlowJoinResolver.java










View file @ 2b03285f


2b03285f



......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......






......@@ -41,7 +41,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {










 if(!propagated) {










 propagated=true;










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(










 analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(










 fact.getFact(), new AccessPath<Field>(), this)));










 }










 };



......@@ -50,7 +50,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {










 lock();










 Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);










 fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, 










 Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -67,7 +67,7 @@ public class ControlFlowJoinResolver<Field, Fact, Stmt, Method> extends Resolver









 










 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);










 }





















 @Override



......


 protected void processIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method> fact) {protectedvoidprocessIncomingGuaranteedPrefix(heros.fieldsens.structs.WrappedFact<Field,Fact,Stmt,Method>fact){ if(!propagated) {if(!propagated){ propagated=true;propagated=true; analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(analyzer.processFlowFromJoinStmt(newWrappedFactAtStatement<>(joinStmt,newWrappedFact<>( analyzer.processFlowFromJoinStmt(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(joinStmt, new WrappedFact<Field, Fact, Stmt, Method>(analyzer.processFlowFromJoinStmt(newWrappedFactAtStatement<FieldField,, FactFact,, StmtStmt,, MethodMethod>(joinStmt,newWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>( fact.getFact(), new AccessPath<Field>(), this)));fact.getFact(),newAccessPath<Field>(),this))); }} };}; protected void processIncomingPotentialPrefix(WrappedFact<Field, Fact, Stmt, Method> fact) {protectedvoidprocessIncomingPotentialPrefix(WrappedFact<Field,Fact,Stmt,Method>fact){ lock();lock(); Delta<Field> delta = fact.getAccessPath().getDeltaTo(resolvedAccPath);Delta<Field>delta=fact.getAccessPath().getDeltaTo(resolvedAccPath); fact.getResolver().resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {fact.getResolver().resolve(newDeltaConstraint<>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ fact.getResolver().resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {fact.getResolver().resolve(newDeltaConstraint<FieldField>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {Resolver<Field,Fact,Stmt,Method>resolver){  @Override@Override protected ResolverTemplate<Field, Fact, Stmt, Method, WrappedFact<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {protectedResolverTemplate<Field,Fact,Stmt,Method,WrappedFact<Field,Fact,Stmt,Method>>createNestedResolver(AccessPath<Field>newAccPath){ return new ControlFlowJoinResolver<>(analyzer, joinStmt, newAccPath, this);returnnewControlFlowJoinResolver<>(analyzer,joinStmt,newAccPath,this); return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(analyzer, joinStmt, newAccPath, this);returnnewControlFlowJoinResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(analyzer,joinStmt,newAccPath,this); }} @Override@Override








src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......












src/heros/fieldsens/FieldSensitiveIFDSSolver.java








View file @ 2b03285f








src/heros/fieldsens/FieldSensitiveIFDSSolver.java










View file @ 2b03285f


2b03285f



......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......






......@@ -56,7 +56,7 @@ public class FieldSensitiveIFDSSolver<FieldRef, D, N, M, I extends Interprocedur









 }










 










 protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {










 return new MethodAnalyzerImpl<>(method, context);










 return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);










 }





















 /**



......


 }}  protected MethodAnalyzer<FieldRef, D, N, M> createMethodAnalyzer(M method) {protectedMethodAnalyzer<FieldRef,D,N,M>createMethodAnalyzer(Mmethod){ return new MethodAnalyzerImpl<>(method, context);returnnewMethodAnalyzerImpl<>(method,context); return new MethodAnalyzerImpl<FieldRef, D, N, M>(method, context);returnnewMethodAnalyzerImpl<FieldRefFieldRef,, DD,, NN,, MM>(method,context); }} /**/**








src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......












src/heros/fieldsens/PerAccessPathMethodAnalyzer.java








View file @ 2b03285f








src/heros/fieldsens/PerAccessPathMethodAnalyzer.java










View file @ 2b03285f


2b03285f



......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......






......@@ -44,13 +44,13 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;



......@@ -69,20 +69,20 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 this.accessPath = accPath;










 this.context = context;










 if(parent == null) {










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);










 }










 else {










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);










 this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);










 }










 log("initialized");










 }










 










 public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {










 return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {



......@@ -96,19 +96,19 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void bootstrapAtMethodStartPoints() {










 callEdgeResolver.interest();










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));










 }










 }














......@@ -137,7 +137,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);



......@@ -162,10 +162,10 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);










 }










 }










 }



......@@ -174,7 +174,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 }










 }










 }



......@@ -194,7 +194,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));



......@@ -223,7 +223,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());



......@@ -232,7 +232,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override



......@@ -255,7 +255,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {









 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));










 Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {










 context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());










 //TODO handle constraint



......@@ -266,7 +266,7 @@ class PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> {




















 public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), 










 fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());










 }










 



......


 private DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {privateDefaultValueMap<FactAtStatement<Fact,Stmt>,ReturnSiteResolver<Field,Fact,Stmt,Method>>returnSiteResolvers=newDefaultValueMap<FactAtStatement<Fact,Stmt>,ReturnSiteResolver<Field,Fact,Stmt,Method>>(){ @Override@Override protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {protectedReturnSiteResolver<Field,Fact,Stmt,Method>createItem(FactAtStatement<Fact,Stmt>key){ return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);returnnewReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this,key.stmt); return new ReturnSiteResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);returnnewReturnSiteResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(PerAccessPathMethodAnalyzer.this,key.stmt); }} };}; private DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new DefaultValueMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {privateDefaultValueMap<FactAtStatement<Fact,Stmt>,ControlFlowJoinResolver<Field,Fact,Stmt,Method>>ctrFlowJoinResolvers=newDefaultValueMap<FactAtStatement<Fact,Stmt>,ControlFlowJoinResolver<Field,Fact,Stmt,Method>>(){ @Override@Override protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {protectedControlFlowJoinResolver<Field,Fact,Stmt,Method>createItem(FactAtStatement<Fact,Stmt>key){ return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);returnnewControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this,key.stmt); return new ControlFlowJoinResolver<Field, Fact, Stmt, Method>(PerAccessPathMethodAnalyzer.this, key.stmt);returnnewControlFlowJoinResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(PerAccessPathMethodAnalyzer.this,key.stmt); }} };}; private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;privateCallEdgeResolver<Field,Fact,Stmt,Method>callEdgeResolver; this.accessPath = accPath;this.accessPath=accPath; this.context = context;this.context=context; if(parent == null) {if(parent==null){ this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);this.callEdgeResolver=isZeroSource()?newZeroCallEdgeResolver<>(this,context.zeroHandler):newCallEdgeResolver<>(this); this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<Field, Fact, Stmt, Method>(this, context.zeroHandler) : new CallEdgeResolver<Field, Fact, Stmt, Method>(this);this.callEdgeResolver=isZeroSource()?newZeroCallEdgeResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(this,context.zeroHandler):newCallEdgeResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(this); }} else {else{ this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<>(this, parent.callEdgeResolver);this.callEdgeResolver=isZeroSource()?parent.callEdgeResolver:newCallEdgeResolver<>(this,parent.callEdgeResolver); this.callEdgeResolver = isZeroSource() ? parent.callEdgeResolver : new CallEdgeResolver<Field, Fact, Stmt, Method>(this, parent.callEdgeResolver);this.callEdgeResolver=isZeroSource()?parent.callEdgeResolver:newCallEdgeResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(this,parent.callEdgeResolver); }} log("initialized");log("initialized"); }}  public PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createWithAccessPath(AccessPath<Field> accPath) {publicPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>createWithAccessPath(AccessPath<Field>accPath){ return new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, accPath, this);returnnewPerAccessPathMethodAnalyzer<>(method,sourceFact,context,accPath,this); return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, sourceFact, context, accPath, this);returnnewPerAccessPathMethodAnalyzer<FieldField,, FactFact,, StmtStmt,, MethodMethod>(method,sourceFact,context,accPath,this); }}  WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {WrappedFact<Field,Fact,Stmt,Method>wrappedSource(){ return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);returnnewWrappedFact<>(sourceFact,accessPath,callEdgeResolver); return new WrappedFact<Field, Fact, Stmt, Method>(sourceFact, accessPath, callEdgeResolver);returnnewWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(sourceFact,accessPath,callEdgeResolver); }}  public AccessPath<Field> getAccessPath() {publicAccessPath<Field>getAccessPath(){ private void bootstrapAtMethodStartPoints() {privatevoidbootstrapAtMethodStartPoints(){ callEdgeResolver.interest();callEdgeResolver.interest(); for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {for(StmtstartPoint:context.icfg.getStartPointsOf(method)){ WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());WrappedFactAtStatement<Field,Fact,Stmt,Method>target=newWrappedFactAtStatement<>(startPoint,wrappedSource()); WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<Field, Fact, Stmt, Method>(startPoint, wrappedSource());WrappedFactAtStatement<Field,Fact,Stmt,Method>target=newWrappedFactAtStatement<FieldField,, FactFact,, StmtStmt,, MethodMethod>(startPoint,wrappedSource()); if(!reachableStatements.containsKey(target))if(!reachableStatements.containsKey(target)) scheduleEdgeTo(target);scheduleEdgeTo(target); }} }}  public void addInitialSeed(Stmt stmt) {publicvoidaddInitialSeed(Stmtstmt){ scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));scheduleEdgeTo(newWrappedFactAtStatement<>(stmt,wrappedSource())); scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, wrappedSource()));scheduleEdgeTo(newWrappedFactAtStatement<FieldField,, FactFact,, StmtStmt,, MethodMethod>(stmt,wrappedSource())); }}  private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {privatevoidscheduleEdgeTo(Collection<Stmt>successors,WrappedFact<Field,Fact,Stmt,Method>fact){ for (Stmt stmt : successors) {for(Stmtstmt:successors){ scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));scheduleEdgeTo(newWrappedFactAtStatement<>(stmt,fact)); scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(stmt, fact));scheduleEdgeTo(newWrappedFactAtStatement<FieldField,, FactFact,, StmtStmt,, MethodMethod>(stmt,fact)); }} }} Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());Collection<Method>calledMethods=context.icfg.getCalleesOfCallAt(factAtStmt.getStatement()); for (Method calledMethod : calledMethods) {for(MethodcalledMethod:calledMethods){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(), calledMethod);FlowFunction<Field,Fact,Stmt,Method>flowFunction=context.flowFunctions.getCallFlowFunction(factAtStmt.getStatement(),calledMethod); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);MethodAnalyzer<Field,Fact,Stmt,Method>analyzer=context.getAnalyzer(calledMethod); Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);Collection<Stmt>returnSites=context.icfg.getReturnSitesOfCallAt(callSite); for(Stmt returnSite : returnSites) {for(StmtreturnSite:returnSites){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(callSite, method, factAtStmt.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=context.flowFunctions.getReturnFlowFunction(callSite,method,factAtStmt.getStatement(),returnSite); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()), callSite);context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(newWrappedFactAtStatement<>(returnSite,targetFact.getFact()),callSite); context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()), callSite);context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(newWrappedFactAtStatement<FieldField,, FactFact,, StmtStmt,, MethodMethod>(returnSite,targetFact.getFact()),callSite); }} }} }} //instead we thus call the return flow function will a null caller//instead we thus call the return flow function will a null caller if(callSites.isEmpty()) {if(callSites.isEmpty()){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(null, method, factAtStmt.getStatement(), null);FlowFunction<Field,Fact,Stmt,Method>flowFunction=context.flowFunctions.getReturnFlowFunction(null,method,factAtStmt.getStatement(),null); flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); }} }} }} Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());Collection<Stmt>returnSites=context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement()); for(Stmt returnSite : returnSites) {for(StmtreturnSite:returnSites){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=context.flowFunctions.getCallToReturnFlowFunction(factAtStmt.getStatement(),returnSite); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));scheduleEdgeTo(newWrappedFactAtStatement<Field,Fact,Stmt,Method>(returnSite,targetFact.getFact())); private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {privatevoidprocessNormalNonJoiningFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());finalList<Stmt>successors=context.icfg.getSuccsOf(factAtStmt.getStatement()); FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement());FlowFunction<Field,Fact,Stmt,Method>flowFunction=context.flowFunctions.getNormalFlowFunction(factAtStmt.getStatement()); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = flowFunction.computeTargets(factAtStmt.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(factAtStmt.getAccessPath(), factAtStmt.getResolver()));Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=flowFunction.computeTargets(factAtStmt.getFact(),newAccessPathHandler<FieldField,, FactFact,, StmtStmt,, MethodMethod>(factAtStmt.getAccessPath(),factAtStmt.getResolver())); for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(finalConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ if(targetFact.getConstraint() == null)if(targetFact.getConstraint()==null) scheduleEdgeTo(successors, targetFact.getFact());scheduleEdgeTo(successors,targetFact.getFact()); @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {Resolver<Field,Fact,Stmt,Method>resolver){ analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));analyzer.scheduleEdgeTo(successors,newWrappedFact<>(targetFact.getFact().getFact(),targetFact.getFact().getAccessPath(),resolver)); analyzer.scheduleEdgeTo(successors, new WrappedFact<Field, Fact, Stmt, Method>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));analyzer.scheduleEdgeTo(successors,newWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(targetFact.getFact().getFact(),targetFact.getFact().getAccessPath(),resolver)); }} @Override@Override Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());Collection<Stmt>returnSites=context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite()); for(Stmt returnSite : returnSites) {for(StmtreturnSite:returnSites){ FlowFunction<Field, Fact, Stmt, Method> flowFunction = context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(), method, exitFact.getStatement(), returnSite);FlowFunction<Field,Fact,Stmt,Method>flowFunction=context.flowFunctions.getReturnFlowFunction(incEdge.getCallSite(),method,exitFact.getStatement(),returnSite); Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<>(exitFact.getAccessPath(), exitFact.getResolver()));Set<ConstrainedFact<Field,Fact,Stmt,Method>>targets=flowFunction.computeTargets(exitFact.getFact(),newAccessPathHandler<>(exitFact.getAccessPath(),exitFact.getResolver())); Set<ConstrainedFact<Field, Fact, Stmt, Method>> targets = flowFunction.computeTargets(exitFact.getFact(), new AccessPathHandler<Field, Fact, Stmt, Method>(exitFact.getAccessPath(), exitFact.getResolver()));Set<ConstrainedFact<Field,Fact,Stmt,Method>>targets=flowFunction.computeTargets(exitFact.getFact(),newAccessPathHandler<FieldField,, FactFact,, StmtStmt,, MethodMethod>(exitFact.getAccessPath(),exitFact.getResolver())); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targets) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targets){ context.factHandler.restoreCallingContext(targetFact.getFact().getFact(), incEdge.getCallerCallSiteFact().getFact());context.factHandler.restoreCallingContext(targetFact.getFact().getFact(),incEdge.getCallerCallSiteFact().getFact()); //TODO handle constraint//TODO handle constraint public void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {publicvoidscheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field,Fact,Stmt,Method>fact){ ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());ReturnSiteResolver<Field,Fact,Stmt,Method>resolver=returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement()); resolver.addIncoming(new WrappedFact<>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), resolver.addIncoming(newWrappedFact<>(fact.getWrappedFact().getFact(),fact.getWrappedFact().getAccessPath(), resolver.addIncoming(new WrappedFact<Field, Fact, Stmt, Method>(fact.getWrappedFact().getFact(), fact.getWrappedFact().getAccessPath(), resolver.addIncoming(newWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact.getWrappedFact().getFact(),fact.getWrappedFact().getAccessPath(), fact.getWrappedFact().getResolver()), null, Delta.<Field>empty());fact.getWrappedFact().getResolver()),null,Delta.<Field>empty()); }} 








src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......












src/heros/fieldsens/ReturnSiteResolver.java








View file @ 2b03285f








src/heros/fieldsens/ReturnSiteResolver.java










View file @ 2b03285f


2b03285f



......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......






......@@ -61,7 +61,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 };










 



......@@ -76,7 +76,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl




















 @Override










 protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {










 return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);










 return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);










 }










 










 public Stmt getReturnSite() {



......@@ -90,7 +90,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 //resolve via incoming facts resolver










 Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());










 assert delta.accesses.length <= 1;










 retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {



......@@ -120,7 +120,7 @@ public class ReturnSiteResolver<Field, Fact, Stmt, Method> extends ResolverTempl









 if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {










 canBeResolvedEmpty();










 } else {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));



......


 if(!propagated) {if(!propagated){ propagated=true;propagated=true; analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, analyzer.scheduleEdgeTo(newWrappedFactAtStatement<Field,Fact,Stmt,Method>(returnSite, new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));newWrappedFact<>(retEdge.incFact,newAccessPath<Field>(),this))); new WrappedFact<Field, Fact, Stmt, Method>(retEdge.incFact, new AccessPath<Field>(), this)));newWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(retEdge.incFact,newAccessPath<Field>(),this))); }} };};  @Override@Override protected ResolverTemplate<Field, Fact, Stmt, Method, ReturnEdge<Field, Fact, Stmt, Method>> createNestedResolver(AccessPath<Field> newAccPath) {protectedResolverTemplate<Field,Fact,Stmt,Method,ReturnEdge<Field,Fact,Stmt,Method>>createNestedResolver(AccessPath<Field>newAccPath){ return new ReturnSiteResolver<>(analyzer, returnSite, newAccPath, this);returnnewReturnSiteResolver<>(analyzer,returnSite,newAccPath,this); return new ReturnSiteResolver<Field, Fact, Stmt, Method>(analyzer, returnSite, newAccPath, this);returnnewReturnSiteResolver<FieldField,, FactFact,, StmtStmt,, MethodMethod>(analyzer,returnSite,newAccPath,this); }}  public Stmt getReturnSite() {publicStmtgetReturnSite(){ //resolve via incoming facts resolver//resolve via incoming facts resolver Delta<Field> delta = retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath());Delta<Field>delta=retEdge.usedAccessPathOfIncResolver.applyTo(retEdge.incAccessPath).getDeltaTo(getResolvedAccessPath()); assert delta.accesses.length <= 1;assertdelta.accesses.length<=1; retEdge.incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {retEdge.incResolver.resolve(newDeltaConstraint<>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ retEdge.incResolver.resolve(new DeltaConstraint<Field>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {retEdge.incResolver.resolve(newDeltaConstraint<FieldField>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ if(retEdge.resolverAtCaller == null || retEdge.resolverAtCaller instanceof CallEdgeResolver) {if(retEdge.resolverAtCaller==null||retEdge.resolverAtCallerinstanceofCallEdgeResolver){ canBeResolvedEmpty();canBeResolvedEmpty(); } else {}else{ retEdge.resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {retEdge.resolverAtCaller.resolve(newDeltaConstraint<>(currAccPath.getDeltaTo(getResolvedAccessPath())),newInterestCallback<Field,Fact,Stmt,Method>(){ retEdge.resolverAtCaller.resolve(new DeltaConstraint<Field>(currAccPath.getDeltaTo(getResolvedAccessPath())), new InterestCallback<Field, Fact, Stmt, Method>() {retEdge.resolverAtCaller.resolve(newDeltaConstraint<FieldField>(currAccPath.getDeltaTo(getResolvedAccessPath())),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver, retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));incomingEdges.add(retEdge.copyWithResolverAtCaller(resolver,retEdge.incAccessPath.getDeltaTo(getResolvedAccessPath())));








src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......












src/heros/fieldsens/structs/ReturnEdge.java








View file @ 2b03285f








src/heros/fieldsens/structs/ReturnEdge.java










View file @ 2b03285f


2b03285f



......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......






......@@ -46,12 +46,12 @@ public class ReturnEdge<Field, Fact, Stmt, Method> {









 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(










 Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {










 return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);










 }










 










 @Override



......


  public ReturnEdge<Field, Fact, Stmt, Method> copyWithIncomingResolver(publicReturnEdge<Field,Fact,Stmt,Method>copyWithIncomingResolver( Resolver<Field, Fact, Stmt, Method> incResolver, Delta<Field> usedAccessPathOfIncResolver) {Resolver<Field,Fact,Stmt,Method>incResolver,Delta<Field>usedAccessPathOfIncResolver){ return new ReturnEdge<>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);returnnewReturnEdge<>(incFact,incAccessPath,incResolver,resolverAtCaller,callDelta,usedAccessPathOfIncResolver); return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, incResolver, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);returnnewReturnEdge<FieldField,, FactFact,, StmtStmt,, MethodMethod>(incFact,incAccessPath,incResolver,resolverAtCaller,callDelta,usedAccessPathOfIncResolver); }}  public ReturnEdge<Field, Fact, Stmt, Method> copyWithResolverAtCaller(publicReturnEdge<Field,Fact,Stmt,Method>copyWithResolverAtCaller( Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> usedAccessPathOfIncResolver) {Resolver<Field,Fact,Stmt,Method>resolverAtCaller,Delta<Field>usedAccessPathOfIncResolver){ return new ReturnEdge<>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);returnnewReturnEdge<>(incFact,incAccessPath,null,resolverAtCaller,callDelta,usedAccessPathOfIncResolver); return new ReturnEdge<Field, Fact, Stmt, Method>(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver);returnnewReturnEdge<FieldField,, FactFact,, StmtStmt,, MethodMethod>(incFact,incAccessPath,null,resolverAtCaller,callDelta,usedAccessPathOfIncResolver); }}  @Override@Override








src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......












src/heros/fieldsens/structs/WrappedFact.java








View file @ 2b03285f








src/heros/fieldsens/structs/WrappedFact.java










View file @ 2b03285f


2b03285f



......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......






......@@ -37,7 +37,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 }










 










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?










 }





















 public AccessPath<Field> getAccessPath() {



......@@ -48,7 +48,7 @@ public class WrappedFact<Field, Fact, Stmt, Method>{









 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);










 return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);










 }










 










 @Override



......


 }}  public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta) {publicWrappedFact<Field,Fact,Stmt,Method>applyDelta(AccessPath.Delta<Field>delta){ return new WrappedFact<>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?returnnewWrappedFact<>(fact,delta.applyTo(accessPath),resolver);//TODO keep resolver? return new WrappedFact<Field, Fact, Stmt, Method>(fact, delta.applyTo(accessPath), resolver); //TODO keep resolver?returnnewWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,delta.applyTo(accessPath),resolver);//TODO keep resolver? }} public AccessPath<Field> getAccessPath() {publicAccessPath<Field>getAccessPath(){ if(fact.equals(zeroValue))if(fact.equals(zeroValue)) return this;returnthis; elseelse return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath), resolver);returnnewWrappedFact<>(fact,constraint.applyToAccessPath(accessPath),resolver); return new WrappedFact<Field, Fact, Stmt, Method>(fact, constraint.applyToAccessPath(accessPath), resolver);returnnewWrappedFact<FieldField,, FactFact,, StmtStmt,, MethodMethod>(fact,constraint.applyToAccessPath(accessPath),resolver); }}  @Override@Override








test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......












test/heros/fieldsens/AccessPathTest.java








View file @ 2b03285f








test/heros/fieldsens/AccessPathTest.java










View file @ 2b03285f


2b03285f



......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......






......@@ -31,7 +31,7 @@ public class AccessPathTest {









 public static AccessPath<String> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<String> accessPath = new AccessPath<>();










 AccessPath<String> accessPath = new AccessPath<String>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {



......


 public static AccessPath<String> ap(String ap) {publicstaticAccessPath<String>ap(Stringap){ Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)?([^\\.\\^]+)"); Matcher matcher = pattern.matcher(ap);Matchermatcher=pattern.matcher(ap); AccessPath<String> accessPath = new AccessPath<>();AccessPath<String>accessPath=newAccessPath<>(); AccessPath<String> accessPath = new AccessPath<String>();AccessPath<String>accessPath=newAccessPath<StringString>(); boolean addedExclusions = false;booleanaddedExclusions=false;  while(matcher.find()) {while(matcher.find()){








test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......












test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java








View file @ 2b03285f








test/heros/fieldsens/BiDiFieldSensitiveIFDSSolverTest.java










View file @ 2b03285f


2b03285f



......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......






......@@ -41,7 +41,7 @@ public class BiDiFieldSensitiveIFDSSolverTest {









 










 public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {










 this.exchange = exchange;










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 forwardHelper = new FieldSensitiveTestHelper(debugger);










 backwardHelper = new FieldSensitiveTestHelper(debugger);










 }



......


  public BiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchange exchange) {publicBiDiFieldSensitiveIFDSSolverTest(TabulationProblemExchangeexchange){ this.exchange = exchange;this.exchange=exchange; debugger = new TestDebugger<>();debugger=newTestDebugger<>(); debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();debugger=newTestDebugger<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod,, InterproceduralCFGInterproceduralCFG<<StatementStatement,, TestMethodTestMethod>>();> forwardHelper = new FieldSensitiveTestHelper(debugger);forwardHelper=newFieldSensitiveTestHelper(debugger); backwardHelper = new FieldSensitiveTestHelper(debugger);backwardHelper=newFieldSensitiveTestHelper(debugger); }}








test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......












test/heros/fieldsens/ControlFlowJoinResolverTest.java








View file @ 2b03285f








test/heros/fieldsens/ControlFlowJoinResolverTest.java










View file @ 2b03285f


2b03285f



......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......






......@@ -37,7 +37,7 @@ import org.mockito.verification.VerificationMode;









public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -46,7 +46,7 @@ public class ControlFlowJoinResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -64,7 +64,7 @@ public class ControlFlowJoinResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new Statement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -72,22 +72,22 @@ public class ControlFlowJoinResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -106,7 +106,7 @@ public class ControlFlowJoinResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));



......


public class ControlFlowJoinResolverTest {publicclassControlFlowJoinResolverTest{ private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<String>getDeltaConstraint(String...fieldRefs){ return new DeltaConstraint<>(getDelta(fieldRefs));returnnewDeltaConstraint<>(getDelta(fieldRefs)); return new DeltaConstraint<String>(getDelta(fieldRefs));returnnewDeltaConstraint<StringString>(getDelta(fieldRefs)); }} private static Delta<String> getDelta(String... fieldRefs) {privatestaticDelta<String>getDelta(String...fieldRefs){ }} protected static AccessPath<String> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<String>createAccessPath(String...fieldRefs){ AccessPath<String> accPath = new AccessPath<>();AccessPath<String>accPath=newAccessPath<>(); AccessPath<String> accPath = new AccessPath<String>();AccessPath<String>accPath=newAccessPath<StringString>(); for (String fieldRef : fieldRefs) {for(StringfieldRef:fieldRefs){ accPath = accPath.append(fieldRef);accPath=accPath.append(fieldRef); }} public void before() {publicvoidbefore(){ analyzer = mock(PerAccessPathMethodAnalyzer.class);analyzer=mock(PerAccessPathMethodAnalyzer.class); joinStmt = new Statement("joinStmt");joinStmt=newStatement("joinStmt"); sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);sut=newControlFlowJoinResolver<>(analyzer,joinStmt); sut = new ControlFlowJoinResolver<String, TestFact, Statement, TestMethod>(analyzer, joinStmt);sut=newControlFlowJoinResolver<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(analyzer,joinStmt); fact = new TestFact("value");fact=newTestFact("value"); callback = mock(InterestCallback.class);callback=mock(InterestCallback.class); callEdgeResolver = mock(CallEdgeResolver.class);callEdgeResolver=mock(CallEdgeResolver.class); @Test@Test public void emptyIncomingFact() {publicvoidemptyIncomingFact(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver)); verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));verify(analyzer).processFlowFromJoinStmt(eq(newWrappedFactAtStatement<>(>(joinStmtjoinStmt,, newnew WrappedFactWrappedFact<>(<fact,createAccessPath(),sut)))); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver)); verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(joinStmt, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));verify(analyzer).processFlowFromJoinStmt(eq(newWrappedFactAtStatement<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(>(joinStmtjoinStmt,, newnew WrappedFactWrappedFact<<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),sut)))); assertTrue(sut.isInterestGiven());assertTrue(sut.isInterestGiven()); }} @Test@Test public void resolveViaIncomingFact() {publicvoidresolveViaIncomingFact(){ sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath("a"),callEdgeResolver)); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath("a"),callEdgeResolver)); verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newResolverArgumentMatcher(createAccessPath("a")))); }} @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver)); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),resolver)); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }} }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver)); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),resolver)); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newResolverArgumentMatcher(createAccessPath("a"))));








test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......












test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java








View file @ 2b03285f








test/heros/fieldsens/FieldSensitiveIFDSSolverTest.java










View file @ 2b03285f


2b03285f



......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......






......@@ -35,7 +35,7 @@ public class FieldSensitiveIFDSSolverTest {









 @Before










 public void before() {










 System.err.println("-----");










 debugger = new TestDebugger<>();










 debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();










 helper = new FieldSensitiveTestHelper(debugger);










 }










 



......


 @Before@Before public void before() {publicvoidbefore(){ System.err.println("-----");System.err.println("-----"); debugger = new TestDebugger<>();debugger=newTestDebugger<>(); debugger = new TestDebugger<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>();debugger=newTestDebugger<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod,, InterproceduralCFGInterproceduralCFG<<StatementStatement,, TestMethodTestMethod>>();> helper = new FieldSensitiveTestHelper(debugger);helper=newFieldSensitiveTestHelper(debugger); }} 








test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......












test/heros/fieldsens/ReturnSiteResolverTest.java








View file @ 2b03285f








test/heros/fieldsens/ReturnSiteResolverTest.java










View file @ 2b03285f


2b03285f



......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......






......@@ -41,7 +41,7 @@ import com.google.common.collect.Lists;









public class ReturnSiteResolverTest {





















 private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 return new DeltaConstraint<String>(getDelta(fieldRefs));










 }





















 private static Delta<String> getDelta(String... fieldRefs) {



......@@ -50,7 +50,7 @@ public class ReturnSiteResolverTest {









 }





















 protected static AccessPath<String> createAccessPath(String... fieldRefs) {










 AccessPath<String> accPath = new AccessPath<>();










 AccessPath<String> accPath = new AccessPath<String>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.append(fieldRef);










 }



......@@ -68,7 +68,7 @@ public class ReturnSiteResolverTest {









 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new Statement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);



......@@ -76,22 +76,22 @@ public class ReturnSiteResolverTest {




















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -110,7 +110,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));



......@@ -132,7 +132,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));



......@@ -145,7 +145,7 @@ public class ReturnSiteResolverTest {









 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }



......@@ -162,7 +162,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -180,14 +180,14 @@ public class ReturnSiteResolverTest {









 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }



......@@ -195,7 +195,7 @@ public class ReturnSiteResolverTest {









 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }



......@@ -232,7 +232,7 @@ public class ReturnSiteResolverTest {









 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));



......@@ -252,7 +252,7 @@ public class ReturnSiteResolverTest {









 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();



......@@ -263,7 +263,7 @@ public class ReturnSiteResolverTest {









 public void resolveViaCallSiteResolver() {










 Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));



......


public class ReturnSiteResolverTest {publicclassReturnSiteResolverTest{ private static DeltaConstraint<String> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<String>getDeltaConstraint(String...fieldRefs){ return new DeltaConstraint<>(getDelta(fieldRefs));returnnewDeltaConstraint<>(getDelta(fieldRefs)); return new DeltaConstraint<String>(getDelta(fieldRefs));returnnewDeltaConstraint<StringString>(getDelta(fieldRefs)); }} private static Delta<String> getDelta(String... fieldRefs) {privatestaticDelta<String>getDelta(String...fieldRefs){ }} protected static AccessPath<String> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<String>createAccessPath(String...fieldRefs){ AccessPath<String> accPath = new AccessPath<>();AccessPath<String>accPath=newAccessPath<>(); AccessPath<String> accPath = new AccessPath<String>();AccessPath<String>accPath=newAccessPath<StringString>(); for (String fieldRef : fieldRefs) {for(StringfieldRef:fieldRefs){ accPath = accPath.append(fieldRef);accPath=accPath.append(fieldRef); }} public void before() {publicvoidbefore(){ analyzer = mock(PerAccessPathMethodAnalyzer.class);analyzer=mock(PerAccessPathMethodAnalyzer.class); returnSite = new Statement("returnSite");returnSite=newStatement("returnSite"); sut = new ReturnSiteResolver<>(analyzer, returnSite);sut=newReturnSiteResolver<>(analyzer,returnSite); sut = new ReturnSiteResolver<String, TestFact, Statement, TestMethod>(analyzer, returnSite);sut=newReturnSiteResolver<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(analyzer,returnSite); fact = new TestFact("value");fact=newTestFact("value"); callback = mock(InterestCallback.class);callback=mock(InterestCallback.class); callEdgeResolver = mock(CallEdgeResolver.class);callEdgeResolver=mock(CallEdgeResolver.class); @Test@Test public void emptyIncomingFact() {publicvoidemptyIncomingFact(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta()); verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));verify(analyzer).scheduleEdgeTo(eq(newWrappedFactAtStatement<>(>(returnSitereturnSite,, newnew WrappedFactWrappedFact<>(<fact,createAccessPath(),sut)))); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta()); verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<String, TestFact, Statement, TestMethod>(returnSite, new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), sut))));verify(analyzer).scheduleEdgeTo(eq(newWrappedFactAtStatement<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(>(returnSitereturnSite,, newnew WrappedFactWrappedFact<<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),sut)))); assertTrue(sut.isInterestGiven());assertTrue(sut.isInterestGiven()); }} @Test@Test public void resolveViaIncomingFact() {publicvoidresolveViaIncomingFact(){ sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath("a"),callEdgeResolver),callEdgeResolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath("a"),callEdgeResolver),callEdgeResolver,getDelta()); verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a")))); }} @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }} }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a")))); }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));verify(callback,never()).interest(any(PerAccessPathMethodAnalyzer.class),any(Resolver.class));  @Test@Test public void resolveViaDelta() {publicvoidresolveViaDelta(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a")); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a")); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a")))); }} }} }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));}).when(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a"))));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a","b")); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a","b")); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));verify(innerCallback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a","b")))); }} }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));}).when(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a"))));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a")); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a")); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(innerCallback).canBeResolvedEmpty();verify(innerCallback).canBeResolvedEmpty(); }} @Test@Test public void resolveViaCallEdgeResolverAtCallSite() {publicvoidresolveViaCallEdgeResolverAtCallSite(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(callback).canBeResolvedEmpty();verify(callback).canBeResolvedEmpty(); }} @Test@Test public void resolveViaResolverAtCallSite() {publicvoidresolveViaResolverAtCallSite(){ Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }}  }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));}).when(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a"))));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));verify(secondCallback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a","b")))); }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,delta); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), resolver), callEdgeResolver, delta);sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),resolver),callEdgeResolver,delta); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback, never()).canBeResolvedEmpty();verify(callback,never()).canBeResolvedEmpty(); public void resolveViaCallSiteResolver() {publicvoidresolveViaCallSiteResolver(){ Resolver<String, TestFact, Statement, TestMethod> resolver = mock(Resolver.class);Resolver<String,TestFact,Statement,TestMethod>resolver=mock(Resolver.class);  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.addIncoming(new WrappedFact<String, TestFact, Statement, TestMethod>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<StringString,, TestFactTestFact,, StatementStatement,, TestMethodTestMethod>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));








test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......












test/heros/utilities/FieldSensitiveTestHelper.java








View file @ 2b03285f








test/heros/utilities/FieldSensitiveTestHelper.java










View file @ 2b03285f


2b03285f



......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......






......@@ -602,10 +602,12 @@ public class FieldSensitiveTestHelper {









 Scheduler scheduler = new Scheduler();










 BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =










 direction == TabulationProblemExchange.AsSpecified ? 










 new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), 










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 createTabulationProblem(true, initialSeeds), 










 backwardHelper.createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler) :










 new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(










 backwardHelper.createTabulationProblem(true, initialSeeds), 










 createTabulationProblem(true, initialSeeds),










 factMergeHandler, debugger, scheduler);










 



......


 Scheduler scheduler = new Scheduler();Schedulerscheduler=newScheduler(); BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>> solver =BiDiFieldSensitiveIFDSSolver<String,TestFact,Statement,TestMethod,InterproceduralCFG<Statement,TestMethod>>solver= direction == TabulationProblemExchange.AsSpecified ? direction==TabulationProblemExchange.AsSpecified? new BiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true, initialSeeds), newBiDiFieldSensitiveIFDSSolver<>(createTabulationProblem(true,initialSeeds), backwardHelper.createTabulationProblem(true, initialSeeds),backwardHelper.createTabulationProblem(true,initialSeeds), factMergeHandler, debugger, scheduler) :factMergeHandler,debugger,scheduler): new BiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true, initialSeeds), newBiDiFieldSensitiveIFDSSolver<>(backwardHelper.createTabulationProblem(true,initialSeeds), new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(newBiDiFieldSensitiveIFDSSolver<String,TestFact,Statement,TestMethod,InterproceduralCFG<Statement,TestMethod>>( createTabulationProblem(true, initialSeeds), createTabulationProblem(true,initialSeeds), backwardHelper.createTabulationProblem(true, initialSeeds),backwardHelper.createTabulationProblem(true,initialSeeds), factMergeHandler, debugger, scheduler) :factMergeHandler,debugger,scheduler): new BiDiFieldSensitiveIFDSSolver<String, TestFact, Statement, TestMethod, InterproceduralCFG<Statement, TestMethod>>(newBiDiFieldSensitiveIFDSSolver<String,TestFact,Statement,TestMethod,InterproceduralCFG<Statement,TestMethod>>( backwardHelper.createTabulationProblem(true, initialSeeds), backwardHelper.createTabulationProblem(true,initialSeeds), createTabulationProblem(true, initialSeeds),createTabulationProblem(true,initialSeeds), factMergeHandler, debugger, scheduler);factMergeHandler,debugger,scheduler); 









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






