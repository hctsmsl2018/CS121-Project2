



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

d3ba7760















Commit
d3ba7760


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




regexp access path







parent
9cd88f45













Changes
9




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d3ba7760






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}














src/heros/alias/AccessPathUtil.java








View file @ d3ba7760






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/DeltaConstraint.java








View file @ d3ba7760






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......














src/heros/alias/FlowFunction.java








View file @ d3ba7760






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}














src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file














test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......














test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

d3ba7760















Commit
d3ba7760


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




regexp access path







parent
9cd88f45













Changes
9




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d3ba7760






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}














src/heros/alias/AccessPathUtil.java








View file @ d3ba7760






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/DeltaConstraint.java








View file @ d3ba7760






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......














src/heros/alias/FlowFunction.java








View file @ d3ba7760






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}














src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file














test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......














test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

d3ba7760







Open sidebar



Joshua Garcia heros
Commits

d3ba7760




Open sidebar

Joshua Garcia heros
Commits

d3ba7760


Joshua GarciaherosherosCommits
d3ba7760








Commit
d3ba7760


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




regexp access path







parent
9cd88f45













Changes
9




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d3ba7760






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}














src/heros/alias/AccessPathUtil.java








View file @ d3ba7760






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/DeltaConstraint.java








View file @ d3ba7760






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......














src/heros/alias/FlowFunction.java








View file @ d3ba7760






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}














src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file














test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......














test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
d3ba7760


authored
Feb 05, 2015
by


Johannes Lerch



Browse files




regexp access path







parent
9cd88f45













Changes
9




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ d3ba7760






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}














src/heros/alias/AccessPathUtil.java








View file @ d3ba7760






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/DeltaConstraint.java








View file @ d3ba7760






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......














src/heros/alias/FlowFunction.java








View file @ d3ba7760






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}














src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file














test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......














test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
d3ba7760


authored
Feb 05, 2015
by


Johannes Lerch



Browse files



Commit
d3ba7760


authored
Feb 05, 2015
by


Johannes Lerch

d3ba7760authoredbyJohannes Lerch

regexp access path






parent
9cd88f45
















parent
9cd88f45





parent












Changes
9
9


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPath.java








View file @ d3ba7760






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}














src/heros/alias/AccessPathUtil.java








View file @ d3ba7760






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}














src/heros/alias/DeltaConstraint.java








View file @ d3ba7760






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......














src/heros/alias/FlowFunction.java








View file @ d3ba7760






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}














src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file














test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......














test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}














src/heros/alias/AccessPath.java








View file @ d3ba7760






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}












src/heros/alias/AccessPath.java








View file @ d3ba7760








src/heros/alias/AccessPath.java










View file @ d3ba7760


d3ba7760



......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}






......@@ -10,87 +10,219 @@









 ******************************************************************************/










package heros.alias;





















import static com.google.common.collect.Iterables.getOnlyElement;





















import java.util.Arrays;










import java.util.Collection;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Function;










import com.google.common.base.Joiner;










import com.google.common.collect.Collections2;










import com.google.common.base.Optional;










import com.google.common.collect.Iterables;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;





















import heros.alias.Transition.MatchResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private final FieldRef[] accesses;










 public static <T> AccessPath<T> empty() {










 return new AccessPath<T>();










 }










 










 private final SubAccessPath<FieldRef>[] accesses;










 private final Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 accesses = new SubAccessPath[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 int k = 2;










 if(accesses.length > k) {










 this.accesses = Arrays.copyOf(accesses, k);










 this.exclusions = new Set[0];










 }










 else {










 this.accesses = accesses;










 if(exclusions.length > k - accesses.length)










 this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);










 else










 this.exclusions = exclusions;










 }










 AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {










 outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 for(FieldRef field : fieldReferences[i].elements()) {










 if(!exclusions[i].contains(field))










 continue outer;










 }










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }










 










 










 AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 if(merge) {










 boolean finiteDepth = true;










 for(int i=fieldReferences.length-1; i>=0; i--) {










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 finiteDepth = false;










 










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].intersects(fieldReferences[i])) {










 // [..., {j-i}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);










 builder.keep(0, j);










 builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);










 builder.append(fieldReferences, i+1, fieldReferences.length);










 if(finiteDepth)










 builder.removeExclusions(fieldReferences.length);










 else










 builder.removeExclusions(Integer.MAX_VALUE);










 return builder.build();










 }










 }










 }










 }










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);










 builder.keep(0, accesses.length);










 builder.append(fieldReferences, 0, fieldReferences.length);










 builder.removeExclusions(fieldReferences.length);










 return builder.build();










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];










 for(int i=0; i<fieldReferences.length; i++) {










 subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);










 }










 return addFieldReference(subPath);










 }










 










 private class AccessPathBuilder {










 










 private Set<FieldRef>[] newExclusions;










 private SubAccessPath<FieldRef>[] newAccesses;










 private int currentIndex = 0;





















 public AccessPathBuilder(int capacity) {










 newAccesses = new SubAccessPath[capacity];










 newExclusions = exclusions;










 }










 










 public AccessPath<FieldRef> build() {










 while(newAccesses.length > 0 && newExclusions.length > 0) {










 HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);










 if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {










 if(newHashSet.isEmpty()) {










 removeExclusions(1);










 }










 else {










 newExclusions[0] = newHashSet;










 break;










 }










 } else break;










 }










 










 return new AccessPath<>(newAccesses, newExclusions);










 }





















 public void removeExclusions(int length) {










 if(length>=newExclusions.length)










 newExclusions = new Set[0];










 else










 newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);










 }





















 public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 for(int i=start; i<endExcl; i++) {










 newAccesses[currentIndex] = fieldReferences[i];










 currentIndex++;










 if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)










 newExclusions = new Set[0];










 }










 currentIndex+=endExcl-start;










 }





















 public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {










 newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));










 }





















 public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {










 Set<FieldRef> set = Sets.newHashSet();










 for(int i=srcIndex; i<destIndexExcl; i++) {










 set.addAll(accesses[i].elements());










 }










 newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);










 currentIndex++;










 return this;










 }





















 public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {










 System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);










 currentIndex += destIndexExcl-srcIndex;










 return this;










 }





















 public void append(FieldRef fieldRef) {










 newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);










 currentIndex++;










 }










 










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {










 if(exclusions.length > 0) 










 throw new IllegalStateException();










 










 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);










 System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);










 return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);










 public AccessPath<FieldRef> prepend(FieldRef fieldRef) {










 for(int j=0; j<accesses.length; j++) {










 if(accesses[j].contains(fieldRef)) {










 // [{0-j}, ...]










 










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);










 builder.merge(0, j+1);










 builder.keep(j+1, accesses.length);










 return builder.build();










 }










 }










 AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);










 builder.append(fieldRef);










 builder.keep(0, accesses.length);










 return builder.build();










 }





















 public AccessPath<FieldRef> removeFirstAccessIfAvailable() {










 if(accesses.length > 0)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 else if(exclusions.length > 0)










 public AccessPath<FieldRef> removeFirst(FieldRef field) {










 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 else










 return this;










 }










 else if(accesses[i] instanceof SpecificFieldAccess)










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 throw new IllegalStateException("Trying to remove "+field+" from "+this);










 }










 










 public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {










 if(exclusions.length > 0)










 return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));










 else










 return this;










 }





















 public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {










 if(hasExclusions())










 if(exclusions.length>0)










 return getExclusions(0).addExclusion(fieldRef);










 else










 return appendExcludedFieldReference(fieldRef);



......@@ -116,42 +248,91 @@ public class AccessPath<FieldRef> {









 }










 }










 










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return PrefixTestResult.NO_PREFIX;










 public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 int finalIndex = finalIndex();










 outer: while(currIndex < finalIndex) {










 Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);










 Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);





















 if(transitions.size() > 1 && otherTransitions.size() > 1)










 throw new AssertionError();










 










 for(Transition<FieldRef> transition : transitions) {










 for(Transition<FieldRef> otherTransition : otherTransitions) {










 MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);










 if(match.hasMatched()) {










 if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())










 throw new AssertionError();










 










 currIndex = transition.transitionToIndex();










 otherIndex = otherTransition.transitionToIndex();










 if(!match.isGuaranteedMatch())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 










 continue outer;










 }










 }










 }










 return PrefixTestResult.NO_PREFIX;










 }










 










 return result;










 }










 










 private int finalIndex() {










 if(exclusions.length > 0)










 return accesses.length + exclusions.length;










 










 int finalIndex = 0;










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return PrefixTestResult.NO_PREFIX;










 if(accesses[i] instanceof SpecificFieldAccess)










 finalIndex = i+1;










 }










 










 PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return PrefixTestResult.NO_PREFIX;










 }










 else {










 if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {










 if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())










 result = PrefixTestResult.POTENTIAL_PREFIX;










 else










 return PrefixTestResult.NO_PREFIX;










 }










 return finalIndex;










 }





















 private Collection<Transition<FieldRef>> possibleTransitions(int index) {










 Collection<Transition<FieldRef>> result = Lists.newLinkedList();










 if(index < accesses.length) {










 if(accesses[index] instanceof SetOfPossibleFieldAccesses) {










 result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));










 result.addAll(possibleTransitions(index+1));










 }










 else










 result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));










 } else if(index - accesses.length < exclusions.length) {










 result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));










 }










 










 return result;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {










 int currentIndex = 0;










 










 for(SubAccessPath<FieldRef> sub : accesses) {










 if(!(sub instanceof SpecificFieldAccess))










 throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());










 










 FieldRef field = sub.elements().iterator().next();










 










 while(true) {










 if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {










 if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)










 currentIndex++;










 break;










 } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {










 currentIndex++;










 }










 else










 throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);










 }










 }










 










 return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {



......@@ -166,6 +347,10 @@ public class AccessPath<FieldRef> {









 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean mayHaveEmptyAccessPath() {










 return finalIndex() == 0;










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }



......@@ -204,20 +389,20 @@ public class AccessPath<FieldRef> {









 return result;










 }










 










 public <T> AccessPath<T> map(Function<FieldRef, T> function) {










 T[] newAccesses = (T[]) new Object[accesses.length];










 for(int i=0; i<accesses.length; i++) {










 newAccesses[i] = function.apply(accesses[i]);










 }










 Set<T>[] newExclusions = new Set[exclusions.length];










 for(int i=0; i<exclusions.length; i++) {










 newExclusions[i] = Sets.newHashSet();










 for(FieldRef excl : exclusions[i]) {










 newExclusions[i].add(function.apply(excl));










 }










 }










 return new AccessPath<T>(newAccesses, newExclusions);










 }










//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {










//		T[] newAccesses = (T[]) new Object[accesses.length];










//		for(int i=0; i<accesses.length; i++) {










//			newAccesses[i] = function.apply(accesses[i]);










//		}










//		Set<T>[] newExclusions = new Set[exclusions.length];










//		for(int i=0; i<exclusions.length; i++) {










//			newExclusions[i] = Sets.newHashSet();










//			for(FieldRef excl : exclusions[i]) {










//				newExclusions[i].add(function.apply(excl));










//			}










//		}










//		return new AccessPath<T>(newAccesses, newExclusions);










//	}










 










 public class ExclusionSet {










 private int index;



......@@ -236,10 +421,14 @@ public class AccessPath<FieldRef> {









 }










 }





















 public FieldRef getFirstAccess() {










 public AccessPath<FieldRef> removeAnyAccess() {










 if(accesses.length > 0)










 return accesses[0];










 else 










 return null;










 return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);










 else










 return this;










 }





















 public boolean hasEmptyAccessPath() {










 return accesses.length == 0;










 }










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static com.google.common.collect.Iterables.getOnlyElement;importstaticcom.google.common.collect.Iterables.getOnlyElement;import java.util.Arrays;importjava.util.Arrays;import java.util.Collection;importjava.util.Collection;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Function;importcom.google.common.base.Function;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Collections2;importcom.google.common.collect.Collections2;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Iterables;importcom.google.common.collect.Iterables;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.Transition.MatchResult;importheros.alias.Transition.MatchResult;import heros.alias.SubAccessPath.*;importheros.alias.SubAccessPath.*;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPath<FieldRef> {publicclassAccessPath<FieldRef>{ private final FieldRef[] accesses;privatefinalFieldRef[]accesses; public static <T> AccessPath<T> empty() {publicstatic<T>AccessPath<T>empty(){ return new AccessPath<T>();returnnewAccessPath<T>(); }}  private final SubAccessPath<FieldRef>[] accesses;privatefinalSubAccessPath<FieldRef>[]accesses; private final Set<FieldRef>[] exclusions;privatefinalSet<FieldRef>[]exclusions;  public AccessPath() {publicAccessPath(){ accesses = (FieldRef[]) new Object[0];accesses=((FieldRefFieldRef[])[]) newnew ObjectObject[0]; accesses = new SubAccessPath[0];accesses=newnew SubAccessPathSubAccessPath[0]; exclusions = new Set[0];exclusions=newSet[0]; }}  AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {AccessPath(FieldRef[]accesses,Set<FieldRef>[]exclusions){ int k = 2;intk=2; if(accesses.length > k) {if(accesses.length>k){ this.accesses = Arrays.copyOf(accesses, k);this.accesses=Arrays.copyOf(accesses,k); this.exclusions = new Set[0];this.exclusions=newSet[0]; }} else {else{ this.accesses = accesses;this.accesses=accesses; if(exclusions.length > k - accesses.length)if(exclusions.length>k-accesses.length) this.exclusions = Arrays.copyOf(exclusions, k - accesses.length);this.exclusions=Arrays.copyOf(exclusions,k-accesses.length); elseelse this.exclusions = exclusions;this.exclusions=exclusions; }} AccessPath(SubAccessPath<FieldRef>[] accesses, Set<FieldRef>[] exclusions) {AccessPath(SubAccessPath<FieldRef>[]accesses,Set<FieldRef>[]exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; }} public boolean hasExclusions() {publicbooleanhasExclusions(){ return exclusions.length > 0;returnexclusions.length>0; }}  public boolean isAccessInExclusions(FieldRef... fieldReferences) {publicbooleanisAccessInExclusions(FieldRef...fieldReferences){ for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {for(inti=0;i<fieldReferences.length&&i<exclusions.length;i++){ if(exclusions[i].contains(fieldReferences[i]))if(exclusions[i].contains(fieldReferences[i])) return true;returntrue; public boolean isAccessInExclusions(SubAccessPath<FieldRef>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<FieldRef>...fieldReferences){ outer: for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {outer:for(inti=0;i<fieldReferences.length&&i<exclusions.length;i++){ for(FieldRef field : fieldReferences[i].elements()) {for(FieldReffield:fieldReferences[i].elements()){ if(!exclusions[i].contains(field))if(!exclusions[i].contains(field)) continue outer;continueouter; }} return true;returntrue; } } return false;returnfalse; }}  public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRef>addFieldReference(FieldRef...fieldReferences){ public AccessPath<FieldRef> addFieldReference(SubAccessPath<FieldRef>... fieldReferences) {publicAccessPath<FieldRef>addFieldReference(SubAccessPath<FieldRef>...fieldReferences){ return addFieldReference(true, fieldReferences);returnaddFieldReference(true,fieldReferences); }}   AccessPath<FieldRef> addFieldReference(boolean merge, SubAccessPath<FieldRef>... fieldReferences) {AccessPath<FieldRef>addFieldReference(booleanmerge,SubAccessPath<FieldRef>...fieldReferences){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) throw new IllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString());thrownewIllegalArgumentException("FieldRef "+Arrays.toString(fieldReferences)+" cannot be added to "+toString()); FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);FieldRef[]newAccesses=Arrays.copyOf(accesses,accesses.length+fieldReferences.length); System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);System.arraycopy(fieldReferences,0,newAccesses,accesses.length,fieldReferences.length); Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); Set<FieldRef>[]newExclusionsArray=exclusions.length<fieldReferences.length?exclusions:Arrays.copyOfRange(exclusions,fieldReferences.length,exclusions.length); return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);returnnewAccessPath<FieldRef>(newAccesses,newExclusionsArray); if(merge) {if(merge){ boolean finiteDepth = true;booleanfiniteDepth=true; for(int i=fieldReferences.length-1; i>=0; i--) {for(inti=fieldReferences.length-1;i>=0;i--){ if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)if(fieldReferences[i]instanceofSetOfPossibleFieldAccesses) finiteDepth = false;finiteDepth=false;  for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].intersects(fieldReferences[i])) {if(accesses[j].intersects(fieldReferences[i])){ // [..., {j-i}, ...]// [..., {j-i}, ...]  AccessPathBuilder builder = new AccessPathBuilder(j+fieldReferences.length-i);AccessPathBuilderbuilder=newAccessPathBuilder(j+fieldReferences.length-i); builder.keep(0, j);builder.keep(0,j); builder.merge(j, accesses.length).mergeWithLast(fieldReferences, 0, i);builder.merge(j,accesses.length).mergeWithLast(fieldReferences,0,i); builder.append(fieldReferences, i+1, fieldReferences.length);builder.append(fieldReferences,i+1,fieldReferences.length); if(finiteDepth)if(finiteDepth) builder.removeExclusions(fieldReferences.length);builder.removeExclusions(fieldReferences.length); elseelse builder.removeExclusions(Integer.MAX_VALUE);builder.removeExclusions(Integer.MAX_VALUE); return builder.build();returnbuilder.build(); }} }} }} }}  AccessPathBuilder builder = new AccessPathBuilder(accesses.length + fieldReferences.length);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+fieldReferences.length); builder.keep(0, accesses.length);builder.keep(0,accesses.length); builder.append(fieldReferences, 0, fieldReferences.length);builder.append(fieldReferences,0,fieldReferences.length); builder.removeExclusions(fieldReferences.length);builder.removeExclusions(fieldReferences.length); return builder.build();returnbuilder.build(); }}  public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRef>addFieldReference(FieldRef...fieldReferences){ SubAccessPath<FieldRef>[] subPath = new SubAccessPath[fieldReferences.length];SubAccessPath<FieldRef>[]subPath=newSubAccessPath[fieldReferences.length]; for(int i=0; i<fieldReferences.length; i++) {for(inti=0;i<fieldReferences.length;i++){ subPath[i] = new SpecificFieldAccess<>(fieldReferences[i]);subPath[i]=newSpecificFieldAccess<>(fieldReferences[i]); }} return addFieldReference(subPath);returnaddFieldReference(subPath); }}  private class AccessPathBuilder {privateclassAccessPathBuilder{  private Set<FieldRef>[] newExclusions;privateSet<FieldRef>[]newExclusions; private SubAccessPath<FieldRef>[] newAccesses;privateSubAccessPath<FieldRef>[]newAccesses; private int currentIndex = 0;privateintcurrentIndex=0; public AccessPathBuilder(int capacity) {publicAccessPathBuilder(intcapacity){ newAccesses = new SubAccessPath[capacity];newAccesses=newSubAccessPath[capacity]; newExclusions = exclusions;newExclusions=exclusions; }}  public AccessPath<FieldRef> build() {publicAccessPath<FieldRef>build(){ while(newAccesses.length > 0 && newExclusions.length > 0) {while(newAccesses.length>0&&newExclusions.length>0){ HashSet<FieldRef> newHashSet = Sets.newHashSet(newExclusions[0]);HashSet<FieldRef>newHashSet=Sets.newHashSet(newExclusions[0]); if(newAccesses[newAccesses.length-1] instanceof SetOfPossibleFieldAccesses && newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())) {if(newAccesses[newAccesses.length-1]instanceofSetOfPossibleFieldAccesses&&newHashSet.removeAll(newAccesses[newAccesses.length-1].elements())){ if(newHashSet.isEmpty()) {if(newHashSet.isEmpty()){ removeExclusions(1);removeExclusions(1); }} else {else{ newExclusions[0] = newHashSet;newExclusions[0]=newHashSet; break;break; }} } else break;}elsebreak; }}  return new AccessPath<>(newAccesses, newExclusions);returnnewAccessPath<>(newAccesses,newExclusions); }} public void removeExclusions(int length) {publicvoidremoveExclusions(intlength){ if(length>=newExclusions.length)if(length>=newExclusions.length) newExclusions = new Set[0];newExclusions=newSet[0]; elseelse newExclusions = Arrays.copyOfRange(newExclusions, length, newExclusions.length);newExclusions=Arrays.copyOfRange(newExclusions,length,newExclusions.length); }} public void append(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {publicvoidappend(SubAccessPath<FieldRef>[]fieldReferences,intstart,intendExcl){ for(int i=start; i<endExcl; i++) {for(inti=start;i<endExcl;i++){ newAccesses[currentIndex] = fieldReferences[i];newAccesses[currentIndex]=fieldReferences[i]; currentIndex++;currentIndex++; if(fieldReferences[i] instanceof SetOfPossibleFieldAccesses)if(fieldReferences[i]instanceofSetOfPossibleFieldAccesses) newExclusions = new Set[0];newExclusions=newSet[0]; }} currentIndex+=endExcl-start;currentIndex+=endExcl-start; }} public void mergeWithLast(SubAccessPath<FieldRef>[] fieldReferences, int start, int endExcl) {publicvoidmergeWithLast(SubAccessPath<FieldRef>[]fieldReferences,intstart,intendExcl){ newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences, start, endExcl));newAccesses[currentIndex-1].merge(Arrays.copyOfRange(fieldReferences,start,endExcl)); }} public AccessPathBuilder merge(int srcIndex, int destIndexExcl) {publicAccessPathBuildermerge(intsrcIndex,intdestIndexExcl){ Set<FieldRef> set = Sets.newHashSet();Set<FieldRef>set=Sets.newHashSet(); for(int i=srcIndex; i<destIndexExcl; i++) {for(inti=srcIndex;i<destIndexExcl;i++){ set.addAll(accesses[i].elements());set.addAll(accesses[i].elements()); }} newAccesses[currentIndex] = new SubAccessPath.SetOfPossibleFieldAccesses<>(set);newAccesses[currentIndex]=newSubAccessPath.SetOfPossibleFieldAccesses<>(set); currentIndex++;currentIndex++; return this;returnthis; }} public AccessPathBuilder keep(int srcIndex, int destIndexExcl) {publicAccessPathBuilderkeep(intsrcIndex,intdestIndexExcl){ System.arraycopy(accesses, srcIndex, newAccesses, currentIndex, destIndexExcl-srcIndex);System.arraycopy(accesses,srcIndex,newAccesses,currentIndex,destIndexExcl-srcIndex); currentIndex += destIndexExcl-srcIndex;currentIndex+=destIndexExcl-srcIndex; return this;returnthis; }} public void append(FieldRef fieldRef) {publicvoidappend(FieldReffieldRef){ newAccesses[currentIndex] = new SubAccessPath.SpecificFieldAccess<>(fieldRef);newAccesses[currentIndex]=newSubAccessPath.SpecificFieldAccess<>(fieldRef); currentIndex++;currentIndex++; }}  }} public ExclusionSet getExclusions(int index) {publicExclusionSetgetExclusions(intindex){ return new ExclusionSet(index);returnnewExclusionSet(index); }}  public AccessPath<FieldRef> append(AccessPath<FieldRef> accessPath) {publicAccessPath<FieldRef>append(AccessPath<FieldRef>accessPath){ if(exclusions.length > 0) if(exclusions.length>0) throw new IllegalStateException();thrownewIllegalStateException();  FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length + accessPath.accesses.length);FieldRef[]newAccesses=Arrays.copyOf(accesses,accesses.length+accessPath.accesses.length); System.arraycopy(accessPath.accesses, 0, newAccesses, accesses.length, accessPath.accesses.length);System.arraycopy(accessPath.accesses,0,newAccesses,accesses.length,accessPath.accesses.length); return new AccessPath<FieldRef>(newAccesses, accessPath.exclusions);returnnewAccessPath<FieldRef>(newAccesses,accessPath.exclusions); public AccessPath<FieldRef> prepend(FieldRef fieldRef) {publicAccessPath<FieldRef>prepend(FieldReffieldRef){ for(int j=0; j<accesses.length; j++) {for(intj=0;j<accesses.length;j++){ if(accesses[j].contains(fieldRef)) {if(accesses[j].contains(fieldRef)){ // [{0-j}, ...]// [{0-j}, ...]  AccessPathBuilder builder = new AccessPathBuilder(accesses.length-j);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length-j); builder.merge(0, j+1);builder.merge(0,j+1); builder.keep(j+1, accesses.length);builder.keep(j+1,accesses.length); return builder.build();returnbuilder.build(); }} }} AccessPathBuilder builder = new AccessPathBuilder(accesses.length + 1);AccessPathBuilderbuilder=newAccessPathBuilder(accesses.length+1); builder.append(fieldRef);builder.append(fieldRef); builder.keep(0, accesses.length);builder.keep(0,accesses.length); return builder.build();returnbuilder.build(); }} public AccessPath<FieldRef> removeFirstAccessIfAvailable() {publicAccessPath<FieldRef>removeFirstAccessIfAvailable(){ if(accesses.length > 0)if(accesses.length>0) return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);returnnewAccessPath<FieldRef>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions); else if(exclusions.length > 0)elseif(exclusions.length>0) public AccessPath<FieldRef> removeFirst(FieldRef field) {publicAccessPath<FieldRef>removeFirst(FieldReffield){ for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i].contains(field)) {if(accesses[i].contains(field)){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) return new AccessPath<FieldRef>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<FieldRef>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); elseelse return this;returnthis; }} else if(accesses[i] instanceof SpecificFieldAccess)elseif(accesses[i]instanceofSpecificFieldAccess) throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this); }}  throw new IllegalStateException("Trying to remove "+field+" from "+this);thrownewIllegalStateException("Trying to remove "+field+" from "+this); }}  public AccessPath<FieldRef> removeFirstExclusionSetIfAvailable() {publicAccessPath<FieldRef>removeFirstExclusionSetIfAvailable(){ if(exclusions.length > 0)if(exclusions.length>0) return new AccessPath<FieldRef>(accesses, Arrays.copyOfRange(exclusions, 1, exclusions.length));returnnewAccessPath<FieldRef>(accesses,Arrays.copyOfRange(exclusions,1,exclusions.length)); elseelse return this;returnthis; }} public AccessPath<FieldRef> mergeExcludedFieldReference(FieldRef... fieldRef) {publicAccessPath<FieldRef>mergeExcludedFieldReference(FieldRef...fieldRef){ if(hasExclusions())if(hasExclusionshasE())() if(exclusions.length>0)if(exclusionse..lengthlength>>00) return getExclusions(0).addExclusion(fieldRef);returngetExclusions(0).addExclusion(fieldRef); elseelse return appendExcludedFieldReference(fieldRef);returnappendExcludedFieldReference(fieldRef); }} }}  public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accessPath) {publicPrefixTestResultisPrefixOf(AccessPath<FieldRef>accessPath){ if(accesses.length > accessPath.accesses.length)if(accesses.length>accessPath.accesses.length) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; public PrefixTestResult isPrefixOf(AccessPath<FieldRef> accPath) {publicPrefixTestResultisPrefixOf(AccessPath<FieldRef>accPath){ int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0; PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;PrefixTestResultresult=PrefixTestResult.GUARANTEED_PREFIX;  if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)if(accesses.length+exclusions.length>accessPath.accesses.length+accessPath.exclusions.length) int finalIndex = finalIndex();intfinalIndex=finalIndex(); outer: while(currIndex < finalIndex) {outer:while(currIndex<finalIndex){ Collection<Transition<FieldRef>> transitions = possibleTransitions(currIndex);Collection<Transition<FieldRef>>transitions=possibleTransitions(currIndex); Collection<Transition<FieldRef>> otherTransitions = accPath.possibleTransitions(otherIndex);Collection<Transition<FieldRef>>otherTransitions=accPath.possibleTransitions(otherIndex); if(transitions.size() > 1 && otherTransitions.size() > 1)if(transitions.size()>1&&otherTransitions.size()>1) throw new AssertionError();thrownewAssertionError();  for(Transition<FieldRef> transition : transitions) {for(Transition<FieldRef>transition:transitions){ for(Transition<FieldRef> otherTransition : otherTransitions) {for(Transition<FieldRef>otherTransition:otherTransitions){ MatchResult<Transition<FieldRef>> match = transition.isPrefixMatchOf(otherTransition);MatchResult<Transition<FieldRef>>match=transition.isPrefixMatchOf(otherTransition); if(match.hasMatched()) {if(match.hasMatched()){ if(currIndex == transition.transitionToIndex() && otherIndex == otherTransition.transitionToIndex())if(currIndex==transition.transitionToIndex()&&otherIndex==otherTransition.transitionToIndex()) throw new AssertionError();thrownewAssertionError();  currIndex = transition.transitionToIndex();currIndex=transition.transitionToIndex(); otherIndex = otherTransition.transitionToIndex();otherIndex=otherTransition.transitionToIndex(); if(!match.isGuaranteedMatch())if(!match.isGuaranteedMatch()) result = PrefixTestResult.POTENTIAL_PREFIX;result=PrefixTestResult.POTENTIAL_PREFIX;  continue outer;continueouter; }} }} }} return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; }}  return result;returnresult; }}  private int finalIndex() {privateintfinalIndex(){ if(exclusions.length > 0)if(exclusions.length>0) return accesses.length + exclusions.length;returnaccesses.length+exclusions.length;  int finalIndex = 0;intfinalIndex=0; for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(!accesses[i].equals(accessPath.accesses[i]))if(!!accesses[i]..equalsequals((accessPathaccessPath..accessesaccesses[[ii]))]) return PrefixTestResult.NO_PREFIX;returnreturn PrefixTestResultPrefixTestResult..NO_PREFIXNO_PREFIX; if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i] instanceofinstanceof SpecificFieldAccessSpecificFieldAccess) finalIndex = i+1;finalIndexfinalIndex == ii++11; }}  PrefixTestResult result = PrefixTestResult.GUARANTEED_PREFIX;PrefixTestResultresult=PrefixTestResult.GUARANTEED_PREFIX; for(int i=0; i<exclusions.length; i++) {for(inti=0;i<exclusions.length;i++){ if(i+accesses.length < accessPath.accesses.length) {if(i+accesses.length<accessPath.accesses.length){ if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))if(exclusions[i].contains(accessPath.accesses[i+accesses.length])) return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; }} else {else{ if(!accessPath.exclusions[i+accesses.length - accessPath.accesses.length].containsAll(exclusions[i])) {if(!accessPath.exclusions[i+accesses.length-accessPath.accesses.length].containsAll(exclusions[i])){ if(Sets.intersection(exclusions[i], accessPath.exclusions[i+accesses.length - accessPath.accesses.length]).isEmpty())if(Sets.intersection(exclusions[i],accessPath.exclusions[i+accesses.length-accessPath.accesses.length]).isEmpty()) result = PrefixTestResult.POTENTIAL_PREFIX;result=PrefixTestResult.POTENTIAL_PREFIX; elseelse return PrefixTestResult.NO_PREFIX;returnPrefixTestResult.NO_PREFIX; }} return finalIndex;returnfinalIndex; }} private Collection<Transition<FieldRef>> possibleTransitions(int index) {privateCollection<Transition<FieldRef>>possibleTransitions(intindex){ Collection<Transition<FieldRef>> result = Lists.newLinkedList();Collection<Transition<FieldRef>>result=Lists.newLinkedList(); if(index < accesses.length) {if(index<accesses.length){ if(accesses[index] instanceof SetOfPossibleFieldAccesses) {if(accesses[index]instanceofSetOfPossibleFieldAccesses){ result.add(new Transition.SubAccessPathTransition<>(index, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index,accesses[index])); result.addAll(possibleTransitions(index+1));result.addAll(possibleTransitions(index+1)); }} elseelse result.add(new Transition.SubAccessPathTransition<>(index+1, accesses[index]));result.add(newTransition.SubAccessPathTransition<>(index+1,accesses[index])); } else if(index - accesses.length < exclusions.length) {}elseif(index-accesses.length<exclusions.length){ result.add(new Transition.ExclusionPathTransition<FieldRef>(index+1, exclusions[index-accesses.length]));result.add(newTransition.ExclusionPathTransition<FieldRef>(index+1,exclusions[index-accesses.length])); }}  return result;returnresult; }}  public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {publicFieldRef[]getDeltaTo(AccessPath<FieldRef>accPath){ if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))if(isPrefixOf(accPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,accesses.length,accPath.accesses.length); elseelse throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");thrownewIllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath"); public SubAccessPath<FieldRef>[] getDeltaTo(AccessPath<FieldRef> accPath) {publicSubAccessPath<FieldRef>[]getDeltaTo(AccessPath<FieldRef>accPath){ int currentIndex = 0;intcurrentIndex=0;  for(SubAccessPath<FieldRef> sub : accesses) {for(SubAccessPath<FieldRef>sub:accesses){ if(!(sub instanceof SpecificFieldAccess))if(!(subinstanceofSpecificFieldAccess)) throw new IllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());thrownewIllegalArgumentException("Cannot calculate delta to. Current AccessPath contains set elements: "+toString());  FieldRef field = sub.elements().iterator().next();FieldReffield=sub.elements().iterator().next();  while(true) {while(true){ if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex].contains(field)) {if(currentIndex<accPath.accesses.length&&accPath.accesses[currentIndex].contains(field)){ if(accPath.accesses[currentIndex] instanceof SpecificFieldAccess)if(accPath.accesses[currentIndex]instanceofSpecificFieldAccess) currentIndex++;currentIndex++; break;break; } else if(currentIndex<accPath.accesses.length && accPath.accesses[currentIndex] instanceof SetOfPossibleFieldAccesses) {}elseif(currentIndex<accPath.accesses.length&&accPath.accesses[currentIndex]instanceofSetOfPossibleFieldAccesses){ currentIndex++;currentIndex++; }} elseelse throw new IllegalArgumentException("'"+toString()+ "' is not a prefix of the given AccessPath: "+accPath);thrownewIllegalArgumentException("'"+toString()+"' is not a prefix of the given AccessPath: "+accPath); }} }}  return Arrays.copyOfRange(accPath.accesses, currentIndex, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,currentIndex,accPath.accesses.length); }}  public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>mergeExcludedFieldReferences(AccessPath<FieldRef>accPath){ return new AccessPath<>(accesses, newExclusionArray);returnnewAccessPath<>(accesses,newExclusionArray); }}  public boolean mayHaveEmptyAccessPath() {publicbooleanmayHaveEmptyAccessPath(){ return finalIndex() == 0;returnfinalIndex()==0; }}  public boolean isEmpty() {publicbooleanisEmpty(){ return exclusions.length == 0 && accesses.length == 0;returnexclusions.length==0&&accesses.length==0; }} return result;returnresult; }}  public <T> AccessPath<T> map(Function<FieldRef, T> function) {public<T>AccessPath<T>map(Function<FieldRef,T>function){ T[] newAccesses = (T[]) new Object[accesses.length];T[]newAccesses=(T[])newObject[accesses.length]; for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ newAccesses[i] = function.apply(accesses[i]);newAccesses[i]=function.apply(accesses[i]); }} Set<T>[] newExclusions = new Set[exclusions.length];Set<T>[]newExclusions=newSet[exclusions.length]; for(int i=0; i<exclusions.length; i++) {for(inti=0;i<exclusions.length;i++){ newExclusions[i] = Sets.newHashSet();newExclusions[i]=Sets.newHashSet(); for(FieldRef excl : exclusions[i]) {for(FieldRefexcl:exclusions[i]){ newExclusions[i].add(function.apply(excl));newExclusions[i].add(function.apply(excl)); }} }} return new AccessPath<T>(newAccesses, newExclusions);returnnewAccessPath<T>(newAccesses,newExclusions); }}//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {//	public <T> AccessPath<T> map(Function<FieldRef, T> function) {////		T[] newAccesses = (T[]) new Object[accesses.length];//		T[] newAccesses = (T[]) new Object[accesses.length];////		for(int i=0; i<accesses.length; i++) {//		for(int i=0; i<accesses.length; i++) {////			newAccesses[i] = function.apply(accesses[i]);//			newAccesses[i] = function.apply(accesses[i]);////		}//		}////		Set<T>[] newExclusions = new Set[exclusions.length];//		Set<T>[] newExclusions = new Set[exclusions.length];////		for(int i=0; i<exclusions.length; i++) {//		for(int i=0; i<exclusions.length; i++) {////			newExclusions[i] = Sets.newHashSet();//			newExclusions[i] = Sets.newHashSet();////			for(FieldRef excl : exclusions[i]) {//			for(FieldRef excl : exclusions[i]) {////				newExclusions[i].add(function.apply(excl));//				newExclusions[i].add(function.apply(excl));////			}//			}////		}//		}////		return new AccessPath<T>(newAccesses, newExclusions);//		return new AccessPath<T>(newAccesses, newExclusions);////	}//	}//  public class ExclusionSet {publicclassExclusionSet{ private int index;privateintindex; }} }} public FieldRef getFirstAccess() {publicFieldRefFieldRef getFirstAccessgetFirst(){ public AccessPath<FieldRef> removeAnyAccess() {publicAccessPathAccessPath<<FieldRefFieldRef>> removeAnyAccessremoveAny(){ if(accesses.length > 0)if(accesses.length>0) return accesses[0];returnaccesses[0]; else else return null;returnnull; return new AccessPath<FieldRef>(new SubAccessPath[0], exclusions);returnnewAccessPath<FieldRef>(newSubAccessPath[0],exclusions); elseelse return this;returnthis; }} public boolean hasEmptyAccessPath() {publicbooleanhasEmptyAccessPath(){ return accesses.length == 0;returnaccesses.length==0; }}}}








src/heros/alias/AccessPathUtil.java








View file @ d3ba7760






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}












src/heros/alias/AccessPathUtil.java








View file @ d3ba7760








src/heros/alias/AccessPathUtil.java










View file @ d3ba7760


d3ba7760



......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}






......@@ -10,9 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import java.util.Set;





















import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;










import com.google.common.collect.Sets;
































public class AccessPathUtil {



......@@ -26,8 +29,7 @@ public class AccessPathUtil {









 










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 





















 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -39,7 +41,7 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 



......@@ -55,4 +57,5 @@ public class AccessPathUtil {









 else










 return fact.cloneWithAccessPath(accPath);










 }










 










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Set;importjava.util.Set;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class AccessPathUtil {publicclassAccessPathUtil{  return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());returnprefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath()); }}   public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact)); if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(summary.getTargetFact());returnOptional.of(summary.getTargetFact());  FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);FieldRef[]delta=abstractAccessPath.getDeltaTo(concreteAccessPath); SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);SubAccessPathSubAccessPath<<FieldRef>[]>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(targetAccessPath.isAccessInExclusions(delta))if(targetAccessPath.isAccessInExclusions(delta)) return Optional.absent();returnOptional.absent();  elseelse return fact.cloneWithAccessPath(accPath);returnfact.cloneWithAccessPath(accPath); }} }}








src/heros/alias/DeltaConstraint.java








View file @ d3ba7760






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......












src/heros/alias/DeltaConstraint.java








View file @ d3ba7760








src/heros/alias/DeltaConstraint.java










View file @ d3ba7760


d3ba7760



......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......






......@@ -14,17 +14,17 @@ import heros.alias.FlowFunction.Constraint;




















public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef[] delta;










 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee); 










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 }





















 @Override



......


public class DeltaConstraint<FieldRef> implements Constraint<FieldRef> {publicclassDeltaConstraint<FieldRef>implementsConstraint<FieldRef>{ private FieldRef[] delta;privateFieldRef[]delta; private SubAccessPath<FieldRef>[] delta;privateSubAccessPathSubAccessPath<<FieldRef>[]>delta; private AccessPath<FieldRef> accPathAtCallee;privateAccessPath<FieldRef>accPathAtCallee; public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {publicDeltaConstraint(AccessPath<FieldRef>accPathAtCaller,AccessPath<FieldRef>accPathAtCallee){ this.accPathAtCallee = accPathAtCallee;this.accPathAtCallee=accPathAtCallee; delta = accPathAtCaller.getDeltaTo(accPathAtCallee); delta=accPathAtCaller.getDeltaTo(accPathAtCallee);  delta = accPathAtCaller.getDeltaTo(accPathAtCallee);delta=accPathAtCaller.getDeltaTo(accPathAtCallee); }} @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return accPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee);returnaccPath.addFieldReference(delta).mergeExcludedFieldReferences(accPathAtCallee); public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact){ return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);returnaccPath.addFieldReference(sourceFactsourceFact,, delta).mergeExcludedFieldReferences(accPathAtCallee); }} @Override@Override








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ d3ba7760








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ d3ba7760


d3ba7760



......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......






......@@ -37,6 +37,7 @@ import org.slf4j.LoggerFactory;









import com.google.common.base.Optional;










import com.google.common.base.Predicate;










import com.google.common.cache.CacheBuilder;










import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;














......@@ -181,6 +182,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 return !worklist.isEmpty();










 }










 










 private int jobCounter = 0;










 private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();










 /**










	 * Runs execution, re-throwing exceptions that might be thrown during its execution.










	 */



......@@ -195,7 +198,25 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);










//		}










 while(!worklist.isEmpty()) {










 worklist.pop().run();










//			if(jobCounter % 100_000 == 0)










 










 PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();










 int size = worklist.size();










 current.run();










 jobCounter++;










 M method = icfg.getMethodOf(current.edge.getTarget());










//			edgesPerMethod.put(method, current.edge);










//			if(edgesPerMethod.get(method).size() > 10_000) {










//				System.out.println(method);










//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {










//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));










//				}










//			}










 










 if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {










 System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +










 String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));










 }










 }










 }














......@@ -293,7 +314,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }





















 private void resumeEdges(M method, D factAtMethodStartPoint) {










 //TODO: Check for concurrency issues










 ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {



......@@ -320,11 +340,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {










 










 propagateConstrained(new ConcretizationPathEdge<>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),










 method,










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));










 applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));










 }










 }










 }



......@@ -458,7 +478,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (ConstrainedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));










 }










 else










 propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);



......@@ -466,11 +486,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 }










 }










 










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));










 }










 










 private boolean propagateConstrained(PathEdge<N, D> pathEdge) {



......@@ -505,11 +525,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {










 










 PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), 










 applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), 










 incEdge.getCallSite(), 










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),










 applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),










 calleeMethod,










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));










 applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));










 visited.put(incEdge.getCallSite(), null);










 boolean result = propagateConstrained(callerEdge, visited);










 visited.put(incEdge.getCallSite(), result);



......@@ -583,6 +603,10 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 propagate(edge, relatedCallSite, true);










 }










 










 private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();










 private int cacheHits = 0;










 private int cacheMerges = 0;










 private int cacheOppositePrefix = 0;










 /**










	 * Propagates the flow further down the exploded super graph. 










	 * @param edge the PathEdge that should be propagated



......@@ -613,12 +637,93 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSen









 existingVal.addNeighbor(edge.factAtTarget());










 }










 else {










 CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());










 if(cache.containsKey(key)) {










 if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {










 System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));










 System.out.println(edge);










 System.out.println(icfg.getMethodOf(edge.getTarget()));










 System.out.println("---");










//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//							System.out.println(cachedEdge);










//						}










 System.out.println("---");










 }










 cacheHits++;










//					boolean opposite = false;










//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {










//						//FIXME: Actually it should be a test for suffix?!










//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {










//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());










//							cacheMerges++;










//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);










//							return;










//						}










//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)










//							opposite=true;










//					}










//					if(opposite)










//						cacheOppositePrefix++;










 } 










 










 cache.put(key, edge);










 scheduleEdgeProcessing(edge);










 if(edge.factAtTarget()!=zeroValue)










 logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);










 }










 }










 }










 










 private static class CacheKey<N, D, BaseValue> {





















 private N target;










 private D factAtSource;










 private BaseValue baseValueAtTarget;





















 public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {










 this.target = target;










 this.factAtSource = factAtSource;










 this.baseValueAtTarget = baseValueAtTarget;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());










 result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());










 result = prime * result + ((target == null) ? 0 : target.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof CacheKey))










 return false;










 CacheKey other = (CacheKey) obj;










 if (baseValueAtTarget == null) {










 if (other.baseValueAtTarget != null)










 return false;










 } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))










 return false;










 if (factAtSource == null) {










 if (other.factAtSource != null)










 return false;










 } else if (!factAtSource.equals(other.factAtSource))










 return false;










 if (target == null) {










 if (other.target != null)










 return false;










 } else if (!target.equals(other.target))










 return false;










 return true;










 }










 










 }





















 private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {










 Set<SummaryEdge<D, N>> map = endSummary.get(m);



......


import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.base.Predicate;importcom.google.common.base.Predicate;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.collect.HashMultimap;importcom.google.common.collect.HashMultimap;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Sets;importcom.google.common.collect.Sets; return !worklist.isEmpty();return!worklist.isEmpty(); }}  private int jobCounter = 0;privateintjobCounter=0; private HashMultimap<M, PathEdge<N, D>> edgesPerMethod = HashMultimap.create();privateHashMultimap<M,PathEdge<N,D>>edgesPerMethod=HashMultimap.create(); /**/**	 * Runs execution, re-throwing exceptions that might be thrown during its execution.	 * Runs execution, re-throwing exceptions that might be thrown during its execution.	 */	 *///			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);//			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.",exception);//		}//		} while(!worklist.isEmpty()) {while(!worklist.isEmpty()){ worklist.pop().run();worklist.pop().run();//			if(jobCounter % 100_000 == 0)//			if(jobCounter % 100_000 == 0)  PathEdgeProcessingTask current = (PathEdgeProcessingTask) worklist.removeLast();PathEdgeProcessingTaskcurrent=(PathEdgeProcessingTask)worklist.removeLast(); int size = worklist.size();intsize=worklist.size(); current.run();current.run(); jobCounter++;jobCounter++; M method = icfg.getMethodOf(current.edge.getTarget());Mmethod=icfg.getMethodOf(current.edge.getTarget());//			edgesPerMethod.put(method, current.edge);//			edgesPerMethod.put(method, current.edge);//			if(edgesPerMethod.get(method).size() > 10_000) {//			if(edgesPerMethod.get(method).size() > 10_000) {//				System.out.println(method);//				System.out.println(method);//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {//				for(PathEdge<N,D> edge : edgesPerMethod.get(method)) {//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));//					System.out.println(String.format("%-50.50s -> %-100.100s @stmt: %s", edge.factAtSource(), edge.factAtTarget(), edge.getTarget()));//				}//				}//			}//			}  if(worklist.size() > size + 100 || jobCounter%100_000 == 0) {if(worklist.size()>size+100||jobCounter%100_000==0){ System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ", size, worklist.size(), jobCounter) +System.err.println(String.format("worklist: %,6d -> %,6d, processed: %,8d ",size,worklist.size(),jobCounter)+ String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s", method, current.edge.factAtSource(), current.edge.factAtTarget(), current.edge.getTarget()));String.format("%-100.100s: %-50.50s -> %-100.100s @stmt: %s",method,current.edge.factAtSource(),current.edge.factAtTarget(),current.edge.getTarget())); }} }} }} }} private void resumeEdges(M method, D factAtMethodStartPoint) {privatevoidresumeEdges(Mmethod,DfactAtMethodStartPoint){ //TODO: Check for concurrency issues//TODO: Check for concurrency issues ConcurrentHashSet<PathEdge<N, D>> edges = pausedEdges.get(method);ConcurrentHashSet<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){ constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())) {constraint.canBeAppliedTo(incomingEdge.getCallerCallSiteFact().getAccessPath())){  propagateConstrained(new ConcretizationPathEdge<>(propagateConstrained(newConcretizationPathEdge<>( applyConstraint(constraint, incomingEdge.getCallerSourceFact()), applyConstraint(constraint,incomingEdge.getCallerSourceFact()), applyConstraint(constraint, incomingEdge.getCallerSourceFact(), true), applyConstraint(constraint,incomingEdge.getCallerSourceFact(),, truetrue), incomingEdge.getCallSite(), incomingEdge.getCallSite(), applyConstraint(constraint, incomingEdge.getCallerCallSiteFact()),applyConstraint(constraint,incomingEdge.getCallerCallSiteFact()), applyConstraint(constraint, incomingEdge.getCallerCallSiteFact(), false),applyConstraint(constraint,incomingEdge.getCallerCallSiteFact(),, falsefalse), method,method, applyConstraint(constraint, incomingEdge.getCalleeSourceFact())));applyConstraint(constraint,incomingEdge.getCalleeSourceFact()))); applyConstraint(constraint, incomingEdge.getCalleeSourceFact(), true)));applyConstraint(constraint,incomingEdge.getCalleeSourceFact(),, truetrue))); }} }} }} Set<ConstrainedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);Set<ConstrainedFact<FieldRef,D>>res=computeNormalFlowFunction(flowFunction,d1,d2); for (ConstrainedFact<FieldRef, D> d3 : res) {for(ConstrainedFact<FieldRef,D>d3:res){ if(d3.getConstraint() != null) {if(d3.getConstraint()!=null){ propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));propagateConstrained(newPathEdge<>(applyConstraint(d3.getConstraint(),d1),m,d3.getFact())); propagateConstrained(new PathEdge<>(applyConstraint(d3.getConstraint(), d1, true), m, d3.getFact()));propagateConstrained(newPathEdge<>(applyConstraint(d3.getConstraint(),d1,, truetrue),m,d3.getFact())); }} elseelse propagate(new PathEdge<>(d1, m, d3.getFact()), null, false);propagate(newPathEdge<>(d1,m,d3.getFact()),null,false); }} }}  private D applyConstraint(Constraint<FieldRef> constraint, D fact) {privateDapplyConstraint(Constraint<FieldRef>constraint,Dfact){ private D applyConstraint(Constraint<FieldRef> constraint, D fact, boolean sourceFact) {privateDapplyConstraint(Constraint<FieldRef>constraint,Dfact,, booleanboolean sourceFactsourceFact){ if(fact.equals(zeroValue))if(fact.equals(zeroValue)) return zeroValue;returnzeroValue; elseelse return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));returnfact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath())); return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(), sourceFact));returnfact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath(),, sourceFactsourceFact)); }}  private boolean propagateConstrained(PathEdge<N, D> pathEdge) {privatebooleanpropagateConstrained(PathEdge<N,D>pathEdge){ callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())) {callerConstraint.canBeAppliedTo(incEdge.getCallerCallSiteFact().getAccessPath())){  PathEdge<N,D> callerEdge = new ConcretizationPathEdge<>(PathEdge<N,D>callerEdge=newConcretizationPathEdge<>( applyConstraint(callerConstraint, incEdge.getCallerSourceFact()), applyConstraint(callerConstraint,incEdge.getCallerSourceFact()), applyConstraint(callerConstraint, incEdge.getCallerSourceFact(), true), applyConstraint(callerConstraint,incEdge.getCallerSourceFact(),, truetrue), incEdge.getCallSite(), incEdge.getCallSite(), applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact()),applyConstraint(callerConstraint,incEdge.getCallerCallSiteFact()), applyConstraint(callerConstraint, incEdge.getCallerCallSiteFact(), false),applyConstraint(callerConstraint,incEdge.getCallerCallSiteFact(),, falsefalse), calleeMethod,calleeMethod, applyConstraint(callerConstraint, incEdge.getCalleeSourceFact()));applyConstraint(callerConstraint,incEdge.getCalleeSourceFact())); applyConstraint(callerConstraint, incEdge.getCalleeSourceFact(), true));applyConstraint(callerConstraint,incEdge.getCalleeSourceFact(),, truetrue)); visited.put(incEdge.getCallSite(), null);visited.put(incEdge.getCallSite(),null); boolean result = propagateConstrained(callerEdge, visited);booleanresult=propagateConstrained(callerEdge,visited); visited.put(incEdge.getCallSite(), result);visited.put(incEdge.getCallSite(),result); propagate(edge, relatedCallSite, true);propagate(edge,relatedCallSite,true); }}  private HashMultimap<CacheKey<N,D,BaseValue>, PathEdge<N,D>> cache = HashMultimap.create();privateHashMultimap<CacheKey<N,D,BaseValue>,PathEdge<N,D>>cache=HashMultimap.create(); private int cacheHits = 0;privateintcacheHits=0; private int cacheMerges = 0;privateintcacheMerges=0; private int cacheOppositePrefix = 0;privateintcacheOppositePrefix=0; /**/**	 * Propagates the flow further down the exploded super graph. 	 * Propagates the flow further down the exploded super graph. 	 * @param edge the PathEdge that should be propagated	 * @param edge the PathEdge that should be propagated existingVal.addNeighbor(edge.factAtTarget());existingVal.addNeighbor(edge.factAtTarget()); }} else {else{ CacheKey<N,D,BaseValue> key = new CacheKey<N,D,BaseValue>(edge.getTarget(), edge.factAtSource(), edge.factAtTarget().getBaseValue());CacheKey<N,D,BaseValue>key=newCacheKey<N,D,BaseValue>(edge.getTarget(),edge.factAtSource(),edge.factAtTarget().getBaseValue()); if(cache.containsKey(key)) {if(cache.containsKey(key)){ if(/*cacheHits % 10_000 == 0 ||*/ cache.get(key).size() > 1000) {if(/*cacheHits % 10_000 == 0 ||*/cache.get(key).size()>1000){ System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d", cacheHits, cache.get(key).size()));System.out.println(String.format("Cache hits: %,8d, Edges at position: %,8d",cacheHits,cache.get(key).size())); System.out.println(edge);System.out.println(edge); System.out.println(icfg.getMethodOf(edge.getTarget()));System.out.println(icfg.getMethodOf(edge.getTarget())); System.out.println("---");System.out.println("---");//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//						for(PathEdge<N,D> cachedEdge : cache.get(key)) {//							System.out.println(cachedEdge);//							System.out.println(cachedEdge);//						}//						} System.out.println("---");System.out.println("---"); }} cacheHits++;cacheHits++;//					boolean opposite = false;//					boolean opposite = false;//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {//					for(PathEdge<N,D> cachedEdge : cache.get(key)) {//						//FIXME: Actually it should be a test for suffix?!//						//FIXME: Actually it should be a test for suffix?!//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {//						if(AccessPathUtil.isPrefixOf(cachedEdge.factAtTarget(), edge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX) {//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());//							cachedEdge.factAtTarget().addNeighbor(edge.factAtTarget());//							cacheMerges++;//							cacheMerges++;//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);//							logger.trace("MERGE: {} with previous edge {}", edge, cachedEdge);//							return;//							return;//						}//						}//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)//						else if(AccessPathUtil.isPrefixOf(edge.factAtTarget(), cachedEdge.factAtTarget()) == PrefixTestResult.GUARANTEED_PREFIX)//							opposite=true;//							opposite=true;//					}//					}//					if(opposite)//					if(opposite)//						cacheOppositePrefix++;//						cacheOppositePrefix++; } }  cache.put(key, edge);cache.put(key,edge); scheduleEdgeProcessing(edge);scheduleEdgeProcessing(edge); if(edge.factAtTarget()!=zeroValue)if(edge.factAtTarget()!=zeroValue) logger.trace("EDGE: {}: {}", icfg.getMethodOf(edge.getTarget()), edge);logger.trace("EDGE: {}: {}",icfg.getMethodOf(edge.getTarget()),edge); }} }} }}  private static class CacheKey<N, D, BaseValue> {privatestaticclassCacheKey<N,D,BaseValue>{ private N target;privateNtarget; private D factAtSource;privateDfactAtSource; private BaseValue baseValueAtTarget;privateBaseValuebaseValueAtTarget; public CacheKey(N target, D factAtSource, BaseValue baseValueAtTarget) {publicCacheKey(Ntarget,DfactAtSource,BaseValuebaseValueAtTarget){ this.target = target;this.target=target; this.factAtSource = factAtSource;this.factAtSource=factAtSource; this.baseValueAtTarget = baseValueAtTarget;this.baseValueAtTarget=baseValueAtTarget; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((baseValueAtTarget == null) ? 0 : baseValueAtTarget.hashCode());result=prime*result+((baseValueAtTarget==null)?0:baseValueAtTarget.hashCode()); result = prime * result + ((factAtSource == null) ? 0 : factAtSource.hashCode());result=prime*result+((factAtSource==null)?0:factAtSource.hashCode()); result = prime * result + ((target == null) ? 0 : target.hashCode());result=prime*result+((target==null)?0:target.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof CacheKey))if(!(objinstanceofCacheKey)) return false;returnfalse; CacheKey other = (CacheKey) obj;CacheKeyother=(CacheKey)obj; if (baseValueAtTarget == null) {if(baseValueAtTarget==null){ if (other.baseValueAtTarget != null)if(other.baseValueAtTarget!=null) return false;returnfalse; } else if (!baseValueAtTarget.equals(other.baseValueAtTarget))}elseif(!baseValueAtTarget.equals(other.baseValueAtTarget)) return false;returnfalse; if (factAtSource == null) {if(factAtSource==null){ if (other.factAtSource != null)if(other.factAtSource!=null) return false;returnfalse; } else if (!factAtSource.equals(other.factAtSource))}elseif(!factAtSource.equals(other.factAtSource)) return false;returnfalse; if (target == null) {if(target==null){ if (other.target != null)if(other.target!=null) return false;returnfalse; } else if (!target.equals(other.target))}elseif(!target.equals(other.target)) return false;returnfalse; return true;returntrue; }}  }} private Set<SummaryEdge<D, N>> endSummary(M m, final D d3) {privateSet<SummaryEdge<D,N>>endSummary(Mm,finalDd3){ Set<SummaryEdge<D, N>> map = endSummary.get(m);Set<SummaryEdge<D,N>>map=endSummary.get(m);








src/heros/alias/FlowFunction.java








View file @ d3ba7760






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}












src/heros/alias/FlowFunction.java








View file @ d3ba7760








src/heros/alias/FlowFunction.java










View file @ d3ba7760


d3ba7760



......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}






......@@ -99,7 +99,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);










 










 boolean canBeAppliedTo(AccessPath<FieldRef> accPath);










 }



......@@ -112,7 +112,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.mergeExcludedFieldReference(fieldRef);










 }










 



......@@ -161,8 +161,8 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef









 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 










 @Override



......@@ -197,7 +197,7 @@ public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef




















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(fieldRef);










 return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));










 }










 }










}


 }}  public interface Constraint<FieldRef> {publicinterfaceConstraint<FieldRef>{ AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);AccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath); AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact);AccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact);  boolean canBeAppliedTo(AccessPath<FieldRef> accPath);booleancanBeAppliedTo(AccessPath<FieldRef>accPath); }} }} @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact){ return accPath.mergeExcludedFieldReference(fieldRef);returnaccPath.mergeExcludedFieldReference(fieldRef); }}  }}  @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return accPath.addFieldReference(fieldRef);returnaccPath.addFieldReference(fieldRef); public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,, booleanboolean sourceFactsourceFact){ return accPath.addFieldReference(!sourceFact, new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));returnaccPath.addFieldReference(!!sourceFactsourceFact,, newnew SubAccessPathSubAccessPath..SpecificFieldAccessSpecificFieldAccess<<FieldRefFieldRef>(>(fieldRef));) }}  @Override@Override @Override@Override public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {publicbooleancanBeAppliedTo(AccessPath<FieldRef>accPath){ return !accPath.isAccessInExclusions(fieldRef);return!accPath.isAccessInExclusions(fieldRef); return !accPath.isAccessInExclusions(new SubAccessPath.SpecificFieldAccess<FieldRef>(fieldRef));return!accPath.isAccessInExclusions(newnew SubAccessPathSubAccessPath..SpecificFieldAccessSpecificFieldAccess<<FieldRefFieldRef>(>(fieldRef));) }} }}}}








src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file












src/heros/alias/SubAccessPath.java



0 → 100644







View file @ d3ba7760








src/heros/alias/SubAccessPath.java



0 → 100644









View file @ d3ba7760


d3ba7760










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.Collection;










import java.util.Collections;










import java.util.HashSet;










import java.util.List;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;










import com.google.common.collect.Sets;
































public interface SubAccessPath<FieldRef> {










 










 boolean contains(FieldRef field);










 










 boolean intersects(SubAccessPath<FieldRef> accPath);





















 Collection<? extends FieldRef> elements();










 










 SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);





















 










 public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {










 private final FieldRef field;










 










 public SpecificFieldAccess(FieldRef field) {










 this.field = field;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return this.field.equals(field);










 }





















 @Override










 public Collection<? extends FieldRef> elements() {










 return Sets.newHashSet(field);










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> set = Sets.newHashSet();










 for(SubAccessPath<FieldRef> f : fields) {










 set.addAll(f.elements());










 }










 return new SetOfPossibleFieldAccesses<>(set);










 }










 










 @Override










 public String toString() {










 return field.toString();










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((field == null) ? 0 : field.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SpecificFieldAccess))










 return false;










 SpecificFieldAccess other = (SpecificFieldAccess) obj;










 if (field == null) {










 if (other.field != null)










 return false;










 } else if (!field.equals(other.field))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 return accPath.contains(field);










 }










 }










 










 public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {










 










 private final Set<FieldRef> set;










 










 public SetOfPossibleFieldAccesses() {










 set = Sets.newHashSet();










 }





















 public SetOfPossibleFieldAccesses(Set<FieldRef> set) {










 this.set = set;










 }





















 @Override










 public boolean contains(FieldRef field) {










 return set.contains(field);










 }










 










 @Override










 public Collection<? extends FieldRef> elements() {










 return set;










 }





















 @Override










 public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {










 HashSet<FieldRef> newSet = Sets.newHashSet(set);










 for(SubAccessPath<FieldRef> f : fields) {










 newSet.addAll(f.elements());










 }










 










 return new SetOfPossibleFieldAccesses<>(newSet);










 }










 










 @Override










 public String toString() {










 return "{"+Joiner.on(",").join(set)+"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((set == null) ? 0 : set.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SetOfPossibleFieldAccesses))










 return false;










 SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;










 if (set == null) {










 if (other.set != null)










 return false;










 } else if (!set.equals(other.set))










 return false;










 return true;










 }





















 @Override










 public boolean intersects(SubAccessPath<FieldRef> accPath) {










 for(FieldRef f:set) {










 if(accPath.contains(f))










 return true;










 }










 return false;










 }










 










 










 }





















}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Arrays;importjava.util.Arrays;import java.util.Collection;importjava.util.Collection;import java.util.Collections;importjava.util.Collections;import java.util.HashSet;importjava.util.HashSet;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public interface SubAccessPath<FieldRef> {publicinterfaceSubAccessPath<FieldRef>{  boolean contains(FieldRef field);booleancontains(FieldReffield);  boolean intersects(SubAccessPath<FieldRef> accPath);booleanintersects(SubAccessPath<FieldRef>accPath); Collection<? extends FieldRef> elements();Collection<?extendsFieldRef>elements();  SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields);SetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields);  public static class SpecificFieldAccess<FieldRef> implements SubAccessPath<FieldRef> {publicstaticclassSpecificFieldAccess<FieldRef>implementsSubAccessPath<FieldRef>{ private final FieldRef field;privatefinalFieldReffield;  public SpecificFieldAccess(FieldRef field) {publicSpecificFieldAccess(FieldReffield){ this.field = field;this.field=field; }} @Override@Override public boolean contains(FieldRef field) {publicbooleancontains(FieldReffield){ return this.field.equals(field);returnthis.field.equals(field); }} @Override@Override public Collection<? extends FieldRef> elements() {publicCollection<?extendsFieldRef>elements(){ return Sets.newHashSet(field);returnSets.newHashSet(field); }} @Override@Override public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {publicSetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields){ HashSet<FieldRef> set = Sets.newHashSet();HashSet<FieldRef>set=Sets.newHashSet(); for(SubAccessPath<FieldRef> f : fields) {for(SubAccessPath<FieldRef>f:fields){ set.addAll(f.elements());set.addAll(f.elements()); }} return new SetOfPossibleFieldAccesses<>(set);returnnewSetOfPossibleFieldAccesses<>(set); }}  @Override@Override public String toString() {publicStringtoString(){ return field.toString();returnfield.toString(); }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((field == null) ? 0 : field.hashCode());result=prime*result+((field==null)?0:field.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof SpecificFieldAccess))if(!(objinstanceofSpecificFieldAccess)) return false;returnfalse; SpecificFieldAccess other = (SpecificFieldAccess) obj;SpecificFieldAccessother=(SpecificFieldAccess)obj; if (field == null) {if(field==null){ if (other.field != null)if(other.field!=null) return false;returnfalse; } else if (!field.equals(other.field))}elseif(!field.equals(other.field)) return false;returnfalse; return true;returntrue; }} @Override@Override public boolean intersects(SubAccessPath<FieldRef> accPath) {publicbooleanintersects(SubAccessPath<FieldRef>accPath){ return accPath.contains(field);returnaccPath.contains(field); }} }}  public static class SetOfPossibleFieldAccesses<FieldRef> implements SubAccessPath<FieldRef> {publicstaticclassSetOfPossibleFieldAccesses<FieldRef>implementsSubAccessPath<FieldRef>{  private final Set<FieldRef> set;privatefinalSet<FieldRef>set;  public SetOfPossibleFieldAccesses() {publicSetOfPossibleFieldAccesses(){ set = Sets.newHashSet();set=Sets.newHashSet(); }} public SetOfPossibleFieldAccesses(Set<FieldRef> set) {publicSetOfPossibleFieldAccesses(Set<FieldRef>set){ this.set = set;this.set=set; }} @Override@Override public boolean contains(FieldRef field) {publicbooleancontains(FieldReffield){ return set.contains(field);returnset.contains(field); }}  @Override@Override public Collection<? extends FieldRef> elements() {publicCollection<?extendsFieldRef>elements(){ return set;returnset; }} @Override@Override public SetOfPossibleFieldAccesses<FieldRef> merge(SubAccessPath<FieldRef>... fields) {publicSetOfPossibleFieldAccesses<FieldRef>merge(SubAccessPath<FieldRef>...fields){ HashSet<FieldRef> newSet = Sets.newHashSet(set);HashSet<FieldRef>newSet=Sets.newHashSet(set); for(SubAccessPath<FieldRef> f : fields) {for(SubAccessPath<FieldRef>f:fields){ newSet.addAll(f.elements());newSet.addAll(f.elements()); }}  return new SetOfPossibleFieldAccesses<>(newSet);returnnewSetOfPossibleFieldAccesses<>(newSet); }}  @Override@Override public String toString() {publicStringtoString(){ return "{"+Joiner.on(",").join(set)+"}";return"{"+Joiner.on(",").join(set)+"}"; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((set == null) ? 0 : set.hashCode());result=prime*result+((set==null)?0:set.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof SetOfPossibleFieldAccesses))if(!(objinstanceofSetOfPossibleFieldAccesses)) return false;returnfalse; SetOfPossibleFieldAccesses other = (SetOfPossibleFieldAccesses) obj;SetOfPossibleFieldAccessesother=(SetOfPossibleFieldAccesses)obj; if (set == null) {if(set==null){ if (other.set != null)if(other.set!=null) return false;returnfalse; } else if (!set.equals(other.set))}elseif(!set.equals(other.set)) return false;returnfalse; return true;returntrue; }} @Override@Override public boolean intersects(SubAccessPath<FieldRef> accPath) {publicbooleanintersects(SubAccessPath<FieldRef>accPath){ for(FieldRef f:set) {for(FieldReff:set){ if(accPath.contains(f))if(accPath.contains(f)) return true;returntrue; }} return false;returnfalse; }}   }}}}








test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}












test/heros/alias/AccessPathTest.java



0 → 100644







View file @ d3ba7760








test/heros/alias/AccessPathTest.java



0 → 100644









View file @ d3ba7760


d3ba7760










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.*;





















import java.util.Set;





















import org.junit.Assert;










import org.junit.Test;





















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;





















@SuppressWarnings("unchecked")










public class AccessPathTest {





















 private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {










 return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));










 }










 










 private static SpecificFieldAccess<String> s(String field) {










 return new SpecificFieldAccess<String>(field);










 }










 










 private static AccessPath<String> ap(SubAccessPath<String>... path) {










 return new AccessPath<String>(path, new Set[0]);










 }










 










 @Test










 public void addAndMergeAll() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));










 }





















 @Test










 public void addAndMergeSuffix() {










 AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");










 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));










 }










 










 @Test










 public void addMergedFields() {










 AccessPath<String> sut = ap(s("a"));










 assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));










 }





















 @Test










 public void addMergedFieldsOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 










 @Test










 public void addFieldThatMerges() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");










 assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField() {










 AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField2() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));










 }










 










 @Test










 public void addFieldThatMergesResultingInExclusionOfMergedField3() {










 AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));










 }










 










 @Test










 public void addOnExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));










 }










 










 @Test










 public void addOnNestedExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");










 assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));










 }





















 @Test(expected=IllegalArgumentException.class)










 public void addMergedFieldsOnSingleExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("a");










 sut.addFieldReference(anyOf("a")); 










 }










 










 @Test










 public void prependWithoutMerge() {










 assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));










 }










 










 @Test










 public void prependWithMerge() {










 assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));










 }










 










 @Test










 public void prependAndMergeWithSet() {










 assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));










 }










 










 @Test










 public void remove() {










 assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));










 }










 










 @Test










 public void dontRemoveMergedFields() {










 assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));










 }










 










 @Test










 public void removeMergedFieldsIfRemovingSuffix() {










 assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));










 }










 










 @Test










 public void deltaDepth1() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void prefixOfMergedField() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void noPrefixOfMergedField() {










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusion() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void prefixOfExclusions() {










 AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));










 assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));










 










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static org.junit.Assert.*;importstaticorg.junit.Assert.*;import java.util.Set;importjava.util.Set;import org.junit.Assert;importorg.junit.Assert;import org.junit.Test;importorg.junit.Test;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.SubAccessPath.*;importheros.alias.SubAccessPath.*;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPathTest {publicclassAccessPathTest{ private static SetOfPossibleFieldAccesses<String> anyOf(String...fields) {privatestaticSetOfPossibleFieldAccesses<String>anyOf(String...fields){ return new SetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields));returnnewSetOfPossibleFieldAccesses<String>(Sets.newHashSet(fields)); }}  private static SpecificFieldAccess<String> s(String field) {privatestaticSpecificFieldAccess<String>s(Stringfield){ return new SpecificFieldAccess<String>(field);returnnewSpecificFieldAccess<String>(field); }}  private static AccessPath<String> ap(SubAccessPath<String>... path) {privatestaticAccessPath<String>ap(SubAccessPath<String>...path){ return new AccessPath<String>(path, new Set[0]);returnnewAccessPath<String>(path,newSet[0]); }}  @Test@Test public void addAndMergeAll() {publicvoidaddAndMergeAll(){ AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");AccessPath<String>sut=AccessPath.<String>empty().addFieldReference("a","b","c"); assertEquals(ap(anyOf("a","b","c")), sut.addFieldReference("a"));assertEquals(ap(anyOf("a","b","c")),sut.addFieldReference("a")); }} @Test@Test public void addAndMergeSuffix() {publicvoidaddAndMergeSuffix(){ AccessPath<String> sut = AccessPath.<String>empty().addFieldReference("a", "b", "c");AccessPath<String>sut=AccessPath.<String>empty().addFieldReference("a","b","c"); assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference("b"));assertEquals(ap(s("a"),anyOf("b","c")),sut.addFieldReference("b")); }}  @Test@Test public void addWithoutMerge() {publicvoidaddWithoutMerge(){ AccessPath<String> sut = ap(s("a"));AccessPath<String>sut=ap(s("a")); assertEquals(ap(s("a"), s("b")), sut.addFieldReference("b"));assertEquals(ap(s("a"),s("b")),sut.addFieldReference("b")); }}  @Test@Test public void addMergedFields() {publicvoidaddMergedFields(){ AccessPath<String> sut = ap(s("a"));AccessPath<String>sut=ap(s("a")); assertEquals(ap(anyOf("a")), sut.addFieldReference(anyOf("a")));assertEquals(ap(anyOf("a")),sut.addFieldReference(anyOf("a"))); }} @Test@Test public void addMergedFieldsOnExclusion() {publicvoidaddMergedFieldsOnExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<String>sut=ap().appendExcludedFieldReference("a"); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}  @Test@Test public void addMergedFieldsOnNestedExclusion() {publicvoidaddMergedFieldsOnNestedExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<String>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}  @Test@Test public void addFieldThatMerges() {publicvoidaddFieldThatMerges(){ AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x");AccessPath<String>sut=ap(s("a"),s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("x"); assertEquals(ap(anyOf("a", "b")).appendExcludedFieldReference("x"), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")).appendExcludedFieldReference("x"),sut.addFieldReference(s("a"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField(){ AccessPath<String> sut = ap(s("a"), s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b");AccessPath<String>sut=ap(s("a"),s("b")).appendExcludedFieldReference("c").appendExcludedFieldReference("b"); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(s("a")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(s("a"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField2() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField2(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<String>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a","c")));assertEquals(ap(anyOf("a","c")),sut.addFieldReference(anyOf("a","c"))); }}  @Test@Test public void addFieldThatMergesResultingInExclusionOfMergedField3() {publicvoidaddFieldThatMergesResultingInExclusionOfMergedField3(){ AccessPath<String> sut = ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<String>sut=ap(s("c")).appendExcludedFieldReference("a").appendExcludedFieldReference("b"); assertEquals(ap(anyOf("c")), sut.addFieldReference(anyOf("c")));assertEquals(ap(anyOf("c")),sut.addFieldReference(anyOf("c"))); }}  @Test@Test public void addOnExclusion() {publicvoidaddOnExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<String>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); assertEquals(ap(s("b")).appendExcludedFieldReference("b"), sut.addFieldReference(s("b")));assertEquals(ap(s("b")).appendExcludedFieldReference("b"),sut.addFieldReference(s("b"))); }}  @Test@Test public void addOnNestedExclusion() {publicvoidaddOnNestedExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b");AccessPath<String>sut=ap().appendExcludedFieldReference("a").appendExcludedFieldReference("b"); assertEquals(ap(anyOf("a", "c")), sut.addFieldReference(anyOf("a", "c")));assertEquals(ap(anyOf("a","c")),sut.addFieldReference(anyOf("a","c"))); }} @Test(expected=IllegalArgumentException.class)@Test(expected=IllegalArgumentException.class) public void addMergedFieldsOnSingleExclusion() {publicvoidaddMergedFieldsOnSingleExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("a");AccessPath<String>sut=ap().appendExcludedFieldReference("a"); sut.addFieldReference(anyOf("a")); sut.addFieldReference(anyOf("a")); }}  @Test@Test public void prependWithoutMerge() {publicvoidprependWithoutMerge(){ assertEquals(ap(s("c"), s("a"), s("b")), ap(s("a"), s("b")).prepend("c"));assertEquals(ap(s("c"),s("a"),s("b")),ap(s("a"),s("b")).prepend("c")); }}  @Test@Test public void prependWithMerge() {publicvoidprependWithMerge(){ assertEquals(ap(anyOf("a"), anyOf("b", "c")), ap(s("a"), anyOf("b", "c")).prepend("a"));assertEquals(ap(anyOf("a"),anyOf("b","c")),ap(s("a"),anyOf("b","c")).prepend("a")); }}  @Test@Test public void prependAndMergeWithSet() {publicvoidprependAndMergeWithSet(){ assertEquals(ap(anyOf("a", "b", "c")), ap(s("a"), anyOf("b", "c")).prepend("b"));assertEquals(ap(anyOf("a","b","c")),ap(s("a"),anyOf("b","c")).prepend("b")); }}  @Test@Test public void remove() {publicvoidremove(){ assertEquals(ap(s("b")), ap(s("a"), s("b")).removeFirst("a"));assertEquals(ap(s("b")),ap(s("a"),s("b")).removeFirst("a")); }}  @Test@Test public void dontRemoveMergedFields() {publicvoiddontRemoveMergedFields(){ assertEquals(ap(anyOf("a", "b")), ap(anyOf("a", "b")).removeFirst("a"));assertEquals(ap(anyOf("a","b")),ap(anyOf("a","b")).removeFirst("a")); }}  @Test@Test public void removeMergedFieldsIfRemovingSuffix() {publicvoidremoveMergedFieldsIfRemovingSuffix(){ assertEquals(ap(), ap(anyOf("a", "b"), s("c")).removeFirst("c"));assertEquals(ap(),ap(anyOf("a","b"),s("c")).removeFirst("c")); }}  @Test@Test public void deltaDepth1() {publicvoiddeltaDepth1(){ SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));SubAccessPath<String>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"))); assertArrayEquals(new SubAccessPath[] { s("b") }, actual);assertArrayEquals(newSubAccessPath[]{s("b")},actual); }}  @Test@Test public void deltaDepth2() {publicvoiddeltaDepth2(){ SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));SubAccessPath<String>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"),s("c"))); assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);assertArrayEquals(newSubAccessPath[]{s("b"),s("c")},actual); }}  @Test@Test public void delta() {publicvoiddelta(){ SubAccessPath<String>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<String>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),anyOf("b"))); assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}  @Test@Test public void delta2() {publicvoiddelta2(){ SubAccessPath<String>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));SubAccessPath<String>[]actual=ap(s("f"),s("g"),s("h")).getDeltaTo(ap(anyOf("f","g"),s("h"))); assertArrayEquals(new SubAccessPath[] { }, actual);assertArrayEquals(newSubAccessPath[]{},actual); }}  @Test@Test public void delta3() {publicvoiddelta3(){ SubAccessPath<String>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));SubAccessPath<String>[]actual=ap(s("f"),s("f")).getDeltaTo(ap(anyOf("f"))); assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);assertArrayEquals(newSubAccessPath[]{anyOf("f")},actual); }}  @Test@Test public void deltaMatchingMergedField() {publicvoiddeltaMatchingMergedField(){ SubAccessPath<String>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<String>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b"))); assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}  @Test@Test public void prefixOfMergedField() {publicvoidprefixOfMergedField(){ assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f")).isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f")).isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f")).isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f")).isPrefixOf(ap(anyOf("f"),s("h")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(s("f"), s("h")).isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(s("f"),s("h")).isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void noPrefixOfMergedField() {publicvoidnoPrefixOfMergedField(){ assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,ap(s("g")).isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.NO_PREFIX, ap(s("g")).isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.NO_PREFIX,ap(s("g")).isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void prefixOfExclusion() {publicvoidprefixOfExclusion(){ AccessPath<String> sut = ap().appendExcludedFieldReference("f");AccessPath<String>sut=ap().appendExcludedFieldReference("f"); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void prefixOfExclusions() {publicvoidprefixOfExclusions(){ AccessPath<String> sut = ap().appendExcludedFieldReference("f", "g");AccessPath<String>sut=ap().appendExcludedFieldReference("f","g"); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f")))); assertEquals(PrefixTestResult.NO_PREFIX, sut.isPrefixOf(ap(anyOf("f", "g"))));assertEquals(PrefixTestResult.NO_PREFIX,sut.isPrefixOf(ap(anyOf("f","g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void mergedFieldsPrefixOf() {publicvoidmergedFieldsPrefixOf(){ assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("f")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("g"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("g")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f")));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f"))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f", "g")));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap().appendExcludedFieldReference("f","g")));  assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f"), s("h")).isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f"),s("h")).isPrefixOf(ap(s("f"),s("h")))); assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).appendExcludedFieldReference("f").isPrefixOf(ap(s("f"),s("h")))); }}}}








test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......












test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ d3ba7760








test/heros/alias/FieldSensitiveIFDSSolverTest.java










View file @ d3ba7760


d3ba7760



......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......






......@@ -37,18 +37,6 @@ public class FieldSensitiveIFDSSolverTest {









 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 



......@@ -185,17 +173,39 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.g")));










 










 helper.runSolver(false, "a");










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");










 }










 










 @Test










 @Ignore("not implemented optimization")










 public void loopAndMergeExclusion() {










 helper.method("foo",










 startPoints("a0"),










 normalStmt("a0").succ("a1", flow("0", "1")),










 callSite("a1").calls("bar", flow("1", "1.f")));










 










 helper.method("bar",










 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1^f")),










 normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 normalStmt("e").succ("f", kill("2")));










 










 










 helper.runSolver(false, "a0");










 }










 










 @Test



......@@ -358,7 +368,7 @@ public class FieldSensitiveIFDSSolverTest {









 }










 










 @Test










 @Ignore("assumes alternative to k-limitting is used")










 @Ignore("not implemented optimization")










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),



......


 };}; };};  @Test@Test @Ignore("assumes k-limiting not used")@Ignore("assumes k-limiting not used") public void mergeWithExistingPrefixFacts() {publicvoidmergeWithExistingPrefixFacts(){ helper.method("foo", helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),normalStmt("b").succ("b",flow("1","1.f")).succ("c",flow("1","2")), normalStmt("c").succ("d", kill("2")));normalStmt("c").succ("d",kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void dontMergeWithExistingNonPrefixFacts() {publicvoiddontMergeWithExistingNonPrefixFacts(){ helper.method("foo", helper.method("foo", }}  @Test@Test @Ignore("assumes k-limiting not used")@Ignore("assumes k-limiting not used") public void loopAndMerge() {publicvoidloopAndMerge(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),normalStmt("b").succ("c",flow("1",readField("f"),"2"),flow("1","1"),flow("2","2")), normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),normalStmt("c").succ("d",flow("1","1","1.f"),flow("2","2")), normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),normalStmt("d").succ("e",flow("1","1"),flow("2","2")).succ("b",flow("1","1"),flow("2","2")), normalStmt("e").succ("f", kill("1"), kill("2")));normalStmt("e").succ("f",kill("1"),kill("2"))); startPoints("a0"),startPoints("a0"), normalStmt("a0").succ("a1", flow("0", "1")),normalStmt("a0").succ("a1",flow("0","1")), callSite("a1").calls("bar", flow("1", "1.g")));callSite("a1").calls("bar",flow("1","1.g")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); helper.method("bar",helper.method("bar", startPoints("b"),startPoints("b"), normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),normalStmt("b").succ("c",flow("1","1","1.f"),flow("1.f","1.f.f"),flow("1.f.f","1.f.f")), normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),normalStmt("c").succ("b",flow("1","1"),flow("1.f","1.f"),flow("1.f.f","1.f.f")).succ("d",flow("1","1"),flow("1.f","1.f"),flow("1.f.f","1.f.f")), normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),normalStmt("d").succ("e",flow("1",readField("f"),"2"),flow("1.f","2"),flow("1.f.f","2.f.f")), normalStmt("e").succ("f", kill("2"), kill("2.f.f")));normalStmt("e").succ("f",kill("2"),kill("2.f.f")));  helper.runSolver(false, "a0");helper.runSolver(false,"a0"); }}  @Test@Test @Ignore("not implemented optimization")@Ignore("not implemented optimization") public void loopAndMergeExclusion() {publicvoidloopAndMergeExclusion(){ helper.method("foo",helper.method("foo", startPoints("a0"),startPoints("a0"), normalStmt("a0").succ("a1", flow("0", "1")),normalStmt("a0").succ("a1",flow("0","1")), callSite("a1").calls("bar", flow("1", "1.f")));callSite("a1").calls("bar",flow("1","1.f")));  helper.method("bar",helper.method("bar", startPoints("b"),startPoints("b"), normalStmt("b").succ("c", flow("1", "1", "1^f")),normalStmt("b").succ("c",flow("1","1","1^f")), normalStmt("c").succ("b", flow("1", "1")).succ("d", flow("1", "1")),normalStmt("c").succ("b",flow("1","1")).succ("d",flow("1","1")), normalStmt("d").succ("e", flow("1", writeField("f"), "2")),normalStmt("d").succ("e",flow("1",writeField("f"),"2")), normalStmt("e").succ("f", kill("2")));normalStmt("e").succ("f",kill("2")));   helper.runSolver(false, "a0");helper.runSolver(false,"a0"); }}  @Test@Test }}  @Test@Test @Ignore("assumes alternative to k-limitting is used")@Ignore("assumes alternative to k-limitting is used"assumes alternative to k-limitting is used) @Ignore("not implemented optimization")@Ignore("not implemented optimization"not implemented optimization) public void mergeExcludedField() {publicvoidmergeExcludedField(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"),








test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}












test/heros/alias/Transition.java



0 → 100644







View file @ d3ba7760








test/heros/alias/Transition.java



0 → 100644









View file @ d3ba7760


d3ba7760










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Collection;










import java.util.Set;





















import com.google.common.base.Optional;





















public interface Transition<FieldRef> {





















 int transitionToIndex();










 










 MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);










 










 










 public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private int transitionToIndex;










 private SubAccessPath<FieldRef> subAccPath;





















 public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {










 this.transitionToIndex = transitionToIndex;










 this.subAccPath = subAccPath;










 










 }





















 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } 










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {










 










 private Set<FieldRef> excludedFields;










 private int transitionToIndex;





















 public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {










 this.transitionToIndex = transitionToIndex;










 this.excludedFields = excludedFields;










 }










 










 @Override










 public int transitionToIndex() {










 return transitionToIndex;










 }





















 @Override










 public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {










 if(t instanceof SubAccessPathTransition) {










 if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))










 return new MatchResult<Transition<FieldRef>>(true, true);










 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 intersection = true;










 else










 containsAll = false;










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 }










 










 return new MatchResult<>(false, false);










 }










 }










 










 public static class MatchResult<T> {










 










 private boolean match;










 private boolean guaranteedMatch;





















 public MatchResult(boolean match, boolean guaranteedMatch) {










 this.match = match;










 this.guaranteedMatch = guaranteedMatch;










 }










 










 public boolean hasMatched() {










 return match;










 }










 










 public boolean isGuaranteedMatch() {










 return guaranteedMatch;










 }










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Collection;importjava.util.Collection;import java.util.Set;importjava.util.Set;import com.google.common.base.Optional;importcom.google.common.base.Optional;public interface Transition<FieldRef> {publicinterfaceTransition<FieldRef>{ int transitionToIndex();inttransitionToIndex();  MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t);MatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t);   public static class SubAccessPathTransition<FieldRef> implements Transition<FieldRef> {publicstaticclassSubAccessPathTransition<FieldRef>implementsTransition<FieldRef>{  private int transitionToIndex;privateinttransitionToIndex; private SubAccessPath<FieldRef> subAccPath;privateSubAccessPath<FieldRef>subAccPath; public SubAccessPathTransition(int transitionToIndex, SubAccessPath<FieldRef> subAccPath) {publicSubAccessPathTransition(inttransitionToIndex,SubAccessPath<FieldRef>subAccPath){ this.transitionToIndex = transitionToIndex;this.transitionToIndex=transitionToIndex; this.subAccPath = subAccPath;this.subAccPath=subAccPath;  }} @Override@Override public int transitionToIndex() {publicinttransitionToIndex(){ return transitionToIndex;returntransitionToIndex; }} @Override@Override public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {publicMatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t){ if(t instanceof SubAccessPathTransition) {if(tinstanceofSubAccessPathTransition){ if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>) t).subAccPath))if(subAccPath.intersects(((SubAccessPathTransition<FieldRef>)t).subAccPath)) return new MatchResult<Transition<FieldRef>>(true, true);returnnewMatchResult<Transition<FieldRef>>(true,true); } }  return new MatchResult<>(false, false);returnnewMatchResult<>(false,false); }} }}  public static class ExclusionPathTransition<FieldRef> implements Transition<FieldRef> {publicstaticclassExclusionPathTransition<FieldRef>implementsTransition<FieldRef>{  private Set<FieldRef> excludedFields;privateSet<FieldRef>excludedFields; private int transitionToIndex;privateinttransitionToIndex; public ExclusionPathTransition(int transitionToIndex, Set<FieldRef> excludedFields) {publicExclusionPathTransition(inttransitionToIndex,Set<FieldRef>excludedFields){ this.transitionToIndex = transitionToIndex;this.transitionToIndex=transitionToIndex; this.excludedFields = excludedFields;this.excludedFields=excludedFields; }}  @Override@Override public int transitionToIndex() {publicinttransitionToIndex(){ return transitionToIndex;returntransitionToIndex; }} @Override@Override public MatchResult<Transition<FieldRef>> isPrefixMatchOf(Transition<FieldRef> t) {publicMatchResult<Transition<FieldRef>>isPrefixMatchOf(Transition<FieldRef>t){ if(t instanceof SubAccessPathTransition) {if(tinstanceofSubAccessPathTransition){ if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>) t).subAccPath.elements()))if(!excludedFields.containsAll(((SubAccessPathTransition<FieldRef>)t).subAccPath.elements())) return new MatchResult<Transition<FieldRef>>(true, true);returnnewMatchResult<Transition<FieldRef>>(true,true); } else {}else{ Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;Set<FieldRef>otherExcludedFields=((ExclusionPathTransition<FieldRef>)t).excludedFields; boolean intersection = false;booleanintersection=false; boolean containsAll = true;booleancontainsAll=true; for(FieldRef field : excludedFields) {for(FieldReffield:excludedFields){ if(otherExcludedFields.contains(field))if(otherExcludedFields.contains(field)) intersection = true;intersection=true; elseelse containsAll = false;containsAll=false; }} return new MatchResult<>(containsAll || !intersection, containsAll);returnnewMatchResult<>(containsAll||!intersection,containsAll); }}  return new MatchResult<>(false, false);returnnewMatchResult<>(false,false); }} }}  public static class MatchResult<T> {publicstaticclassMatchResult<T>{  private boolean match;privatebooleanmatch; private boolean guaranteedMatch;privatebooleanguaranteedMatch; public MatchResult(boolean match, boolean guaranteedMatch) {publicMatchResult(booleanmatch,booleanguaranteedMatch){ this.match = match;this.match=match; this.guaranteedMatch = guaranteedMatch;this.guaranteedMatch=guaranteedMatch; }}  public boolean hasMatched() {publicbooleanhasMatched(){ return match;returnmatch; }}  public boolean isGuaranteedMatch() {publicbooleanisGuaranteedMatch(){ return guaranteedMatch;returnguaranteedMatch; }} }}}}









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






