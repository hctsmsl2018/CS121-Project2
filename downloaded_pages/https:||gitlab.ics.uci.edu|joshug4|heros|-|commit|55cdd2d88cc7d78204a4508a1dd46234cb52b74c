



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

55cdd2d8















Commit
55cdd2d8


authored
Feb 16, 2015
by


Johannes Lerch



Browse files




abstract at return edges







parent
b974b09e













Changes
13




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ 55cdd2d8






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......














src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......














src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8





This diff is collapsed.
Click to expand it.













src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}














src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}














src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......














src/heros/solver/PathEdge.java








View file @ 55cdd2d8






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......














test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}














test/heros/alias/TestHelper.java








View file @ 55cdd2d8






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

55cdd2d8















Commit
55cdd2d8


authored
Feb 16, 2015
by


Johannes Lerch



Browse files




abstract at return edges







parent
b974b09e













Changes
13




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ 55cdd2d8






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......














src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......














src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8





This diff is collapsed.
Click to expand it.













src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}














src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}














src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......














src/heros/solver/PathEdge.java








View file @ 55cdd2d8






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......














test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}














test/heros/alias/TestHelper.java








View file @ 55cdd2d8






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

55cdd2d8







Open sidebar



Joshua Garcia heros
Commits

55cdd2d8




Open sidebar

Joshua Garcia heros
Commits

55cdd2d8


Joshua GarciaherosherosCommits
55cdd2d8








Commit
55cdd2d8


authored
Feb 16, 2015
by


Johannes Lerch



Browse files




abstract at return edges







parent
b974b09e













Changes
13




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ 55cdd2d8






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......














src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......














src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8





This diff is collapsed.
Click to expand it.













src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}














src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}














src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......














src/heros/solver/PathEdge.java








View file @ 55cdd2d8






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......














test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}














test/heros/alias/TestHelper.java








View file @ 55cdd2d8






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
55cdd2d8


authored
Feb 16, 2015
by


Johannes Lerch



Browse files




abstract at return edges







parent
b974b09e













Changes
13




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java








View file @ 55cdd2d8






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......














src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......














src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8





This diff is collapsed.
Click to expand it.













src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}














src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}














src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......














src/heros/solver/PathEdge.java








View file @ 55cdd2d8






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......














test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}














test/heros/alias/TestHelper.java








View file @ 55cdd2d8






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
55cdd2d8


authored
Feb 16, 2015
by


Johannes Lerch



Browse files



Commit
55cdd2d8


authored
Feb 16, 2015
by


Johannes Lerch

55cdd2d8authoredbyJohannes Lerch

abstract at return edges






parent
b974b09e
















parent
b974b09e





parent












Changes
13
13


Expand all
Hide whitespace changes

Inline
Side-by-side






Expand all
Hide whitespace changes

Inline
Side-by-side




Expand all
Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPath.java








View file @ 55cdd2d8






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......














src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......














src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8





This diff is collapsed.
Click to expand it.













src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}














src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}














src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}














src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......














src/heros/solver/PathEdge.java








View file @ 55cdd2d8






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......














test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}














test/heros/alias/TestHelper.java








View file @ 55cdd2d8






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......














src/heros/alias/AccessPath.java








View file @ 55cdd2d8






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}












src/heros/alias/AccessPath.java








View file @ 55cdd2d8








src/heros/alias/AccessPath.java










View file @ 55cdd2d8


55cdd2d8



......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}






......@@ -10,6 +10,7 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;










import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;










import heros.alias.SubAccessPath.SpecificFieldAccess;










import heros.alias.Transition.MatchResult;



......@@ -38,15 +39,18 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 










 private final SubAccessPath<T>[] accesses;










 private final Set<T> exclusions;










 private final SubPathResolver<T> resolver;










 










 public AccessPath() {










 accesses = new SubAccessPath[0];










 exclusions = Sets.newHashSet();










 resolver = null;










 }










 










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {










 AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }





















 public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {



......@@ -63,6 +67,10 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {










 return addFieldReference(true, fieldReferences);










 }





















 public boolean hasAllExclusionsOf(AccessPath<T> accPath) {










 return exclusions.containsAll(accPath.exclusions);










 }










 










 AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))



......@@ -113,7 +121,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public AccessPath<T> build() {










 return new AccessPath<>(newAccesses, newExclusions);










 return new AccessPath<>(newAccesses, newExclusions, resolver);










 }





















 public void removeExclusions() {



......@@ -178,7 +186,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 for(int i=0; i<accesses.length; i++) {










 if(accesses[i].contains(field)) {










 if(accesses[i] instanceof SpecificFieldAccess)










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);










 return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);










 else










 return this;










 }



......@@ -192,11 +200,17 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {










 HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);










 newExclusions.addAll(exclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }





















 public static enum PrefixTestResult {










 GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);










 GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);










 










 private int value;














......@@ -268,7 +282,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return result;










 }










 










 public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {










 public Delta<T> getDeltaTo(AccessPath<T> accPath) {










 int currIndex = 0;










 int otherIndex = 0;










 



......@@ -292,13 +306,57 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 break;










 }










 










 return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);










 return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);










 }










 










 public static class Delta<T extends FieldRef<T>> {










 final SubAccessPath<T>[] accesses;










 final Set<T> exclusions;










 final SubPathResolver<T> resolver;





















 protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 this.resolver = resolver;










 }










 










 public boolean canBeAppliedTo(AccessPath<T> accPath) {










 return !accPath.isAccessInExclusions(accesses);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath) {










 return applyTo(accPath, true);










 }










 










 public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {










 AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);










 if(resolver != null) {










 if(result.hasResolver())










 throw new AssertionError();










 result = result.setResolver(resolver);










 }










 return result;










 }










 










 public static <T extends FieldRef<T>> Delta<T> empty() {










 return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);










 }










 










 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 }










 










 public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {










 HashSet<T> newExclusions = Sets.newHashSet(exclusions);










 newExclusions.addAll(accPath.exclusions);










 return new AccessPath<>(accesses, newExclusions);










 return new AccessPath<>(accesses, newExclusions, resolver);










 }










 










 public boolean mayHaveEmptyAccessPath() {



......@@ -306,7 +364,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }










 










 public boolean isEmpty() {










 return exclusions.isEmpty() && accesses.length == 0;










 return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();










 }










 










 @Override



......@@ -315,6 +373,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -324,7 +383,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 if (getClass() != obj.getClass())










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))



......@@ -334,6 +393,11 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 return false;










 } else if (!exclusions.equals(other.exclusions))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }














......@@ -342,6 +406,8 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 if(!exclusions.isEmpty())










 result += "^" + Joiner.on(",").join(exclusions);










 if(resolver != null)










 result+="["+resolver+"]";










 return result;










 }










 



......@@ -353,12 +419,12 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 Set<U> newExclusions = Sets.newHashSet();










 for(T f : exclusions)










 newExclusions.add(function.apply(f));










 return new AccessPath<U>(newAccesses, newExclusions);










 return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);










 }










 










 public AccessPath<T> removeAnyAccess() {










 if(accesses.length > 0)










 return new AccessPath<T>(new SubAccessPath[0], exclusions);










 return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);










 else










 return this;










 }



......@@ -371,6 +437,14 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 int currIndex = 0;










 int otherIndex = 0;










 










 if(resolver != null) {










 if(!resolver.equals(accPath.resolver)) {










 return false;










 }










 }










 else if(accPath.resolver != null)










 return false;










 










 










 outer: while(true) {










 Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);



......@@ -422,7 +496,7 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 }





















 public AccessPath<T> removeExclusions() {










 return new AccessPath<T>(accesses, Sets.<T>newHashSet());










 return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);










 }





















 public SubAccessPath<T> getFirstAccess() {



......@@ -435,13 +509,79 @@ public class AccessPath<T extends AccessPath.FieldRef<T>> {









 throw new IllegalArgumentException();










 










 if(elements.size() == 1) {










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);










 return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);










 }










 










 HashSet<T> newSet = Sets.newHashSet(elements);










 newSet.remove(field);










 SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);










 newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);










 return new AccessPath<T>(newAccesses, exclusions);










 return new AccessPath<T>(newAccesses, exclusions, resolver);










 }





















 public AccessPath<T> setResolver(SubPathResolver<T> resolver) {










 return new AccessPath<T>(accesses, exclusions, resolver);










 }










 










 public SubPathResolver<T> getResolver() {










 return resolver;










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }










 










 public AccessPath<T> decorateResolver(Constraint<T> constraint) {










 return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));










 }










 










 public class Iterator {










 private int currentIndex = 0;










 










 public boolean hasNext(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field))










 return true;










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return false;










 }










 










 public void next(T field) {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i].contains(field)) {










 currentIndex+=i;










 return;










 }










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 throw new IllegalStateException();










 }










 throw new IllegalStateException();










 }










 










 public boolean maybeAtEnd() {










 for(int i=0; i+currentIndex < accesses.length; i++) {










 if(accesses[currentIndex+i] instanceof SpecificFieldAccess)










 return false;










 }










 return true;










 }










 










 public boolean isExcluded(T field) {










 return exclusions.contains(field);










 }










 










 public boolean hasResolver() {










 return resolver != null;










 }





















 public Object getResolver() {










 return resolver;










 }










 }





















 public AccessPath<T>.Iterator iterator() {










 return new Iterator();










 }










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import heros.alias.SubAccessPath.SetOfPossibleFieldAccesses;importheros.alias.SubAccessPath.SetOfPossibleFieldAccesses;import heros.alias.SubAccessPath.SpecificFieldAccess;importheros.alias.SubAccessPath.SpecificFieldAccess;import heros.alias.Transition.MatchResult;importheros.alias.Transition.MatchResult;  private final SubAccessPath<T>[] accesses;privatefinalSubAccessPath<T>[]accesses; private final Set<T> exclusions;privatefinalSet<T>exclusions; private final SubPathResolver<T> resolver;privatefinalSubPathResolver<T>resolver;  public AccessPath() {publicAccessPath(){ accesses = new SubAccessPath[0];accesses=newSubAccessPath[0]; exclusions = Sets.newHashSet();exclusions=Sets.newHashSet(); resolver = null;resolver=null; }}  AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions) {AccessPath(SubAccessPath<T>[]accesses,Set<T>exclusions){ AccessPath(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {AccessPath(SubAccessPath<T>[]accesses,Set<T>exclusions,, SubPathResolverSubPathResolver<<TT>> resolverresolver){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; this.resolver = resolver;this.resolver=resolver; }} public boolean isAccessInExclusions(SubAccessPath<T>... fieldReferences) {publicbooleanisAccessInExclusions(SubAccessPath<T>...fieldReferences){ public AccessPath<T> addFieldReference(SubAccessPath<T>... fieldReferences) {publicAccessPath<T>addFieldReference(SubAccessPath<T>...fieldReferences){ return addFieldReference(true, fieldReferences);returnaddFieldReference(true,fieldReferences); }} public boolean hasAllExclusionsOf(AccessPath<T> accPath) {publicbooleanhasAllExclusionsOf(AccessPath<T>accPath){ return exclusions.containsAll(accPath.exclusions);returnexclusions.containsAll(accPath.exclusions); }}  AccessPath<T> addFieldReference(boolean merge, SubAccessPath<T>... fieldReferences) {AccessPath<T>addFieldReference(booleanmerge,SubAccessPath<T>...fieldReferences){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) }}  public AccessPath<T> build() {publicAccessPath<T>build(){ return new AccessPath<>(newAccesses, newExclusions);returnnewAccessPath<>(newAccesses,newExclusions); return new AccessPath<>(newAccesses, newExclusions, resolver);returnnewAccessPath<>(newAccesses,newExclusions,, resolverresolver); }} public void removeExclusions() {publicvoidremoveExclusions(){ for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(accesses[i].contains(field)) {if(accesses[i].contains(field)){ if(accesses[i] instanceof SpecificFieldAccess)if(accesses[i]instanceofSpecificFieldAccess) return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions); return new AccessPath<T>(Arrays.copyOfRange(accesses, i+1, accesses.length), exclusions, resolver);returnnewAccessPath<T>(Arrays.copyOfRange(accesses,i+1,accesses.length),exclusions,, resolverresolver); elseelse return this;returnthis; }} public AccessPath<T> appendExcludedFieldReference(T... fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(T...fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,resolver); }} public AccessPath<T> appendExcludedFieldReference(Collection<T> fieldReferences) {publicAccessPath<T>appendExcludedFieldReference(Collection<T>fieldReferences){ HashSet<T> newExclusions = Sets.newHashSet(fieldReferences);HashSet<T>newExclusions=Sets.newHashSet(fieldReferences); newExclusions.addAll(exclusions);newExclusions.addAll(exclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,resolver); }} public static enum PrefixTestResult {publicstaticenumPrefixTestResult{ GUARANTEED_PREFIX(2), POTENTIAL_PREFIX(1), NO_PREFIX(0);GUARANTEED_PREFIX(22),POTENTIAL_PREFIX(1),NO_PREFIX(0); GUARANTEED_PREFIX(3), POTENTIAL_PREFIX(2), NEEDS_RESOLVNG(1), NO_PREFIX(0);GUARANTEED_PREFIX(33),POTENTIAL_PREFIX(22),), NEEDS_RESOLVNGNEEDS_RESOLVNG((1),NO_PREFIX(0);  private int value;privateintvalue; return result;returnresult; }}  public SubAccessPath<T>[] getDeltaTo(AccessPath<T> accPath) {publicSubAccessPathSubAccessPath<T>[][]getDeltaTo(AccessPath<T>accPath){ public Delta<T> getDeltaTo(AccessPath<T> accPath) {publicDeltaDelta<T>getDeltaTo(AccessPath<T>accPath){ int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  break;break; }}  return Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length); return new Delta<T>(Arrays.copyOfRange(accPath.accesses, otherIndex, accPath.accesses.length), accPath.exclusions, accPath.resolver);returnnewDelta<T>(Arrays.copyOfRange(accPath.accesses,otherIndex,accPath.accesses.length),accPath.exclusions,accPath.resolver); }}  public static class Delta<T extends FieldRef<T>> {publicstaticclassDelta<TextendsFieldRef<T>>{ final SubAccessPath<T>[] accesses;finalSubAccessPath<T>[]accesses; final Set<T> exclusions;finalSet<T>exclusions; final SubPathResolver<T> resolver;finalSubPathResolver<T>resolver; protected Delta(SubAccessPath<T>[] accesses, Set<T> exclusions, SubPathResolver<T> resolver) {protectedDelta(SubAccessPath<T>[]accesses,Set<T>exclusions,SubPathResolver<T>resolver){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; this.resolver = resolver;this.resolver=resolver; }}  public boolean canBeAppliedTo(AccessPath<T> accPath) {publicbooleancanBeAppliedTo(AccessPath<T>accPath){ return !accPath.isAccessInExclusions(accesses);return!accPath.isAccessInExclusions(accesses); }}  public AccessPath<T> applyTo(AccessPath<T> accPath) {publicAccessPath<T>applyTo(AccessPath<T>accPath){ return applyTo(accPath, true);returnapplyTo(accPath,true); }}  public AccessPath<T> applyTo(AccessPath<T> accPath, boolean merge) {publicAccessPath<T>applyTo(AccessPath<T>accPath,booleanmerge){ AccessPath<T> result = accPath.addFieldReference(merge, accesses).appendExcludedFieldReference(exclusions);AccessPath<T>result=accPath.addFieldReference(merge,accesses).appendExcludedFieldReference(exclusions); if(resolver != null) {if(resolver!=null){ if(result.hasResolver())if(result.hasResolver()) throw new AssertionError();thrownewAssertionError(); result = result.setResolver(resolver);result=result.setResolver(resolver); }} return result;returnresult; }}  public static <T extends FieldRef<T>> Delta<T> empty() {publicstatic<TextendsFieldRef<T>>Delta<T>empty(){ return new Delta<T>(new SubAccessPath[0], Sets.<T> newHashSet(), null);returnnewDelta<T>(newSubAccessPath[0],Sets.<T>newHashSet(),null); }}  @Override@Override public String toString() {publicStringtoString(){ String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result += "^" + Joiner.on(",").join(exclusions);result+="^"+Joiner.on(",").join(exclusions); if(resolver != null)if(resolver!=null) result+="["+resolver+"]";result+="["+resolver+"]"; return result;returnresult; }} }}  public AccessPath<T> mergeExcludedFieldReferences(AccessPath<T> accPath) {publicAccessPath<T>mergeExcludedFieldReferences(AccessPath<T>accPath){ HashSet<T> newExclusions = Sets.newHashSet(exclusions);HashSet<T>newExclusions=Sets.newHashSet(exclusions); newExclusions.addAll(accPath.exclusions);newExclusions.addAll(accPath.exclusions); return new AccessPath<>(accesses, newExclusions);returnnewAccessPath<>(accesses,newExclusions); return new AccessPath<>(accesses, newExclusions, resolver);returnnewAccessPath<>(accesses,newExclusions,, resolverresolver); }}  public boolean mayHaveEmptyAccessPath() {publicbooleanmayHaveEmptyAccessPath(){ }}  public boolean isEmpty() {publicbooleanisEmpty(){ return exclusions.isEmpty() && accesses.length == 0;returnexclusions.isEmpty()&&accesses.length==0; return exclusions.isEmpty() && accesses.length == 0 && !hasResolver();returnexclusions.isEmpty()&&accesses.length==0 &&&& !!hasResolverhasResolver();() }}  @Override@Override int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses); result = prime * result + ((exclusions == null) ? 0 : exclusions.hashCode());result=prime*result+((exclusions==null)?0:exclusions.hashCode()); result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());result=prime*result+((resolver==null)?0:resolver.hashCode()); return result;returnresult; }} return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof AccessPath))if(!(!(objobj instanceofinstanceof AccessPathAccessPath)) if (getClass() != obj.getClass())if(getClassgetClass()() !=!= objobj..getClassgetClass())( return false;returnfalse; AccessPath other = (AccessPath) obj;AccessPathother=(AccessPath)obj; if (!Arrays.equals(accesses, other.accesses))if(!Arrays.equals(accesses,other.accesses)) return false;returnfalse; } else if (!exclusions.equals(other.exclusions))}elseif(!exclusions.equals(other.exclusions)) return false;returnfalse; if (resolver == null) {if(resolver==null){ if (other.resolver != null)if(other.resolver!=null) return false;returnfalse; } else if (!resolver.equals(other.resolver))}elseif(!resolver.equals(other.resolver)) return false;returnfalse; return true;returntrue; }} String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; if(!exclusions.isEmpty())if(!exclusions.isEmpty()) result += "^" + Joiner.on(",").join(exclusions);result+="^"+Joiner.on(",").join(exclusions); if(resolver != null)if(resolver!=null) result+="["+resolver+"]";result+="["+resolver+"]"; return result;returnresult; }}  Set<U> newExclusions = Sets.newHashSet();Set<U>newExclusions=Sets.newHashSet(); for(T f : exclusions)for(Tf:exclusions) newExclusions.add(function.apply(f));newExclusions.add(function.apply(f)); return new AccessPath<U>(newAccesses, newExclusions);returnnewAccessPath<U>(newAccesses,newExclusions); return new AccessPath<U>(newAccesses, newExclusions, null /*FIXME*/);returnnewAccessPath<U>(newAccesses,newExclusions,, nullnull /*FIXME*//*FIXME*/); }}  public AccessPath<T> removeAnyAccess() {publicAccessPath<T>removeAnyAccess(){ if(accesses.length > 0)if(accesses.length>0) return new AccessPath<T>(new SubAccessPath[0], exclusions);returnnewAccessPath<T>(newSubAccessPath[0],exclusions); return new AccessPath<T>(new SubAccessPath[0], exclusions, resolver);returnnewAccessPath<T>(newSubAccessPath[0],exclusions,, resolverresolver); elseelse return this;returnthis; }} int currIndex = 0;intcurrIndex=0; int otherIndex = 0;intotherIndex=0;  if(resolver != null) {if(resolver!=null){ if(!resolver.equals(accPath.resolver)) {if(!resolver.equals(accPath.resolver)){ return false;returnfalse; }} }} else if(accPath.resolver != null)elseif(accPath.resolver!=null) return false;returnfalse;   outer: while(true) {outer:while(true){ Collection<Transition<T>> transitions = possibleTransitions(currIndex, false);Collection<Transition<T>>transitions=possibleTransitions(currIndex,false); }} public AccessPath<T> removeExclusions() {publicAccessPath<T>removeExclusions(){ return new AccessPath<T>(accesses, Sets.<T>newHashSet());returnnewAccessPath<T>(accesses,Sets.<T>newHashSet()); return new AccessPath<T>(accesses, Sets.<T>newHashSet(), resolver);returnnewAccessPath<T>(accesses,Sets.<T>newHashSet(),, resolverresolver); }} public SubAccessPath<T> getFirstAccess() {publicSubAccessPath<T>getFirstAccess(){ throw new IllegalArgumentException();thrownewIllegalArgumentException();  if(elements.size() == 1) {if(elements.size()==1){ return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions); return new AccessPath<>(Arrays.copyOfRange(accesses, 1, accesses.length), exclusions, resolver);returnnewAccessPath<>(Arrays.copyOfRange(accesses,1,accesses.length),exclusions,, resolverresolver); }}  HashSet<T> newSet = Sets.newHashSet(elements);HashSet<T>newSet=Sets.newHashSet(elements); newSet.remove(field);newSet.remove(field); SubAccessPath<T>[] newAccesses = Arrays.copyOf(accesses, accesses.length);SubAccessPath<T>[]newAccesses=Arrays.copyOf(accesses,accesses.length); newAccesses[0] = new SetOfPossibleFieldAccesses<>(newSet);newAccesses[0]=newSetOfPossibleFieldAccesses<>(newSet); return new AccessPath<T>(newAccesses, exclusions);returnnewAccessPath<T>(newAccesses,exclusions); return new AccessPath<T>(newAccesses, exclusions, resolver);returnnewAccessPath<T>(newAccesses,exclusions,resolver); }} public AccessPath<T> setResolver(SubPathResolver<T> resolver) {publicAccessPath<T>setResolver(SubPathResolver<T>resolver){ return new AccessPath<T>(accesses, exclusions, resolver);returnnewAccessPath<T>(accesses,exclusions,resolver); }}  public SubPathResolver<T> getResolver() {publicSubPathResolver<T>getResolver(){ return resolver;returnresolver; }}  public boolean hasResolver() {publicbooleanhasResolver(){ return resolver != null;returnresolver!=null; }}  public AccessPath<T> decorateResolver(Constraint<T> constraint) {publicAccessPath<T>decorateResolver(Constraint<T>constraint){ return new AccessPath<T>(accesses, exclusions, resolver.decorate(constraint));returnnewAccessPath<T>(accesses,exclusions,resolver.decorate(constraint)); }}  public class Iterator {publicclassIterator{ private int currentIndex = 0;privateintcurrentIndex=0;  public boolean hasNext(T field) {publicbooleanhasNext(Tfield){ for(int i=0; i+currentIndex < accesses.length; i++) {for(inti=0;i+currentIndex<accesses.length;i++){ if(accesses[currentIndex+i].contains(field))if(accesses[currentIndex+i].contains(field)) return true;returntrue; if(accesses[currentIndex+i] instanceof SpecificFieldAccess)if(accesses[currentIndex+i]instanceofSpecificFieldAccess) return false;returnfalse; }} return false;returnfalse; }}  public void next(T field) {publicvoidnext(Tfield){ for(int i=0; i+currentIndex < accesses.length; i++) {for(inti=0;i+currentIndex<accesses.length;i++){ if(accesses[currentIndex+i].contains(field)) {if(accesses[currentIndex+i].contains(field)){ currentIndex+=i;currentIndex+=i; return;return; }} if(accesses[currentIndex+i] instanceof SpecificFieldAccess)if(accesses[currentIndex+i]instanceofSpecificFieldAccess) throw new IllegalStateException();thrownewIllegalStateException(); }} throw new IllegalStateException();thrownewIllegalStateException(); }}  public boolean maybeAtEnd() {publicbooleanmaybeAtEnd(){ for(int i=0; i+currentIndex < accesses.length; i++) {for(inti=0;i+currentIndex<accesses.length;i++){ if(accesses[currentIndex+i] instanceof SpecificFieldAccess)if(accesses[currentIndex+i]instanceofSpecificFieldAccess) return false;returnfalse; }} return true;returntrue; }}  public boolean isExcluded(T field) {publicbooleanisExcluded(Tfield){ return exclusions.contains(field);returnexclusions.contains(field); }}  public boolean hasResolver() {publicbooleanhasResolver(){ return resolver != null;returnresolver!=null; }} public Object getResolver() {publicObjectgetResolver(){ return resolver;returnresolver; }} }} public AccessPath<T>.Iterator iterator() {publicAccessPath<T>.Iteratoriterator(){ return new Iterator();returnnewIterator(); }}}}








src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......












src/heros/alias/AccessPathUtil.java








View file @ 55cdd2d8








src/heros/alias/AccessPathUtil.java










View file @ 55cdd2d8


55cdd2d8



......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......






......@@ -12,6 +12,7 @@ package heros.alias;




















import java.util.Set;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;





















import com.google.common.base.Optional;



......@@ -30,6 +31,24 @@ public class AccessPathUtil {









 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }





















 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(AccessPath.Delta.<FieldRef> empty());





















 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 else










 return Optional.of(delta);










 }










 










 public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));



......@@ -41,13 +60,11 @@ public class AccessPathUtil {









 if(abstractAccessPath.equals(concreteAccessPath))










 return Optional.of(summary.getTargetFact());










 










 SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(!delta.canBeAppliedTo(targetAccessPath))










 return Optional.absent();










 










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }














......


import java.util.Set;importjava.util.Set;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import com.google.common.base.Optional;importcom.google.common.base.Optional; return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());returnprefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath()); }} public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<Delta<FieldRef>> getDelta(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<Delta<FieldRef>>getDelta(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();AccessPath<FieldRef>concreteAccessPath=sourceFact.getAccessPath(); AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();AccessPath<FieldRef>abstractAccessPath=summary.getSourceFact().getAccessPath(); AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();AccessPath<FieldRef>targetAccessPath=summary.getTargetFact().getAccessPath();  if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(AccessPath.Delta.<FieldRef> empty());returnOptional.of(AccessPath.Delta.<FieldRef>empty()); Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);Delta<FieldRef>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(!delta.canBeAppliedTo(targetAccessPath))if(!delta.canBeAppliedTo(targetAccessPath)) return Optional.absent();returnOptional.absent(); elseelse return Optional.of(delta);returnOptional.of(delta); }}  public static <FieldRef extends AccessPath.FieldRef<FieldRef>, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefextendsAccessPath.FieldRef<FieldRef>,DextendsFieldSensitiveFact<?,FieldRef,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX))if(!isPrefixOf(summary.getSourceFact(),sourceFact).atLeast(PrefixTestResult.GUARANTEED_PREFIX)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact)); if(abstractAccessPath.equals(concreteAccessPath))if(abstractAccessPath.equals(concreteAccessPath)) return Optional.of(summary.getTargetFact());returnOptional.of(summary.getTargetFact());  SubAccessPath<FieldRef>[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);SubAccessPathSubAccessPath<FieldRef>[][]delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(targetAccessPath.isAccessInExclusions(delta))if(targetAccessPathtargetAccessPath..isAccessInExclusionsisAccessInExclusions((deltadelta)) Delta<FieldRef> delta = abstractAccessPath.getDeltaTo(concreteAccessPath);DeltaDelta<FieldRef>delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(!delta.canBeAppliedTo(targetAccessPath))if(!!deltadelta..canBeAppliedTocanBeAppliedTo((targetAccessPathtargetAccessPath)) return Optional.absent();returnOptional.absent();  AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);AccessPath<FieldRef>result=targetAccessPath.addFieldReference(delta); result = result.mergeExcludedFieldReferences(concreteAccessPath);result=result.mergeExcludedFieldReferences(concreteAccessPath);  AccessPath<FieldRef> result = delta.applyTo(targetAccessPath);AccessPath<FieldRef>result=delta.applyTo(targetAccessPath); return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result)); }}








src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......












src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java








View file @ 55cdd2d8








src/heros/alias/ConcretizationPathEdge.java

→

src/heros/alias/CallConcretizationPathEdge.java





Call




View file @ 55cdd2d8


55cdd2d8



......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.PathEdge;





















public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {










public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {





















 private M calleeMethod;










 private D calleeSourceFact;





















 public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {










 super(dSource, target, dTarget);










 this.calleeMethod = calleeMethod;










 this.calleeSourceFact = calleeSourceFact;



......@@ -46,9 +46,9 @@ public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {









 return true;










 if (!super.equals(obj))










 return false;










 if (!(obj instanceof ConcretizationPathEdge))










 if (!(obj instanceof CallConcretizationPathEdge))










 return false;










 ConcretizationPathEdge other = (ConcretizationPathEdge) obj;










 CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;



......


import heros.solver.PathEdge;importheros.solver.PathEdge;public class ConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {publicclassConcretizationPathEdge<M,N,D>extendsPathEdge<N,D>{public class CallConcretizationPathEdge<M, N,D> extends PathEdge<N, D> {publicclassCallConcretizationPathEdgeCall<M,N,D>extendsPathEdge<N,D>{ private M calleeMethod;privateMcalleeMethod; private D calleeSourceFact;privateDcalleeSourceFact; public ConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {publicConcretizationPathEdge(DdSource,Ntarget,DdTarget,McalleeMethod,DcalleeSourceFact){ public CallConcretizationPathEdge(D dSource, N target, D dTarget, M calleeMethod, D calleeSourceFact) {publicCallConcretizationPathEdgeCall(DdSource,Ntarget,DdTarget,McalleeMethod,DcalleeSourceFact){ super(dSource, target, dTarget);super(dSource,target,dTarget); this.calleeMethod = calleeMethod;this.calleeMethod=calleeMethod; this.calleeSourceFact = calleeSourceFact;this.calleeSourceFact=calleeSourceFact; return true;returntrue; if (!super.equals(obj))if(!super.equals(obj)) return false;returnfalse; if (!(obj instanceof ConcretizationPathEdge))if(!(objinstanceofConcretizationPathEdge)) if (!(obj instanceof CallConcretizationPathEdge))if(!(objinstanceofCallConcretizationPathEdgeCall)) return false;returnfalse; ConcretizationPathEdge other = (ConcretizationPathEdge) obj;ConcretizationPathEdgeother=(ConcretizationPathEdge)obj; CallConcretizationPathEdge other = (CallConcretizationPathEdge) obj;CallConcretizationPathEdgeCallother=(CallConcretizationPathEdgeCall)obj; if (calleeMethod == null) {if(calleeMethod==null){ if (other.calleeMethod != null)if(other.calleeMethod!=null) return false;returnfalse;








src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}












src/heros/alias/DeltaConstraint.java








View file @ 55cdd2d8








src/heros/alias/DeltaConstraint.java










View file @ 55cdd2d8


55cdd2d8



......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}






......@@ -10,26 +10,29 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {





















 private SubAccessPath<FieldRef>[] delta;










 private AccessPath<FieldRef> accPathAtCallee;










 private Delta<FieldRef> delta;





















 public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {










 this.accPathAtCallee = accPathAtCallee;










 delta = accPathAtCaller.getDeltaTo(accPathAtCallee);










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {










 return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);










 if(accPath.hasResolver()) {










 return delta.applyTo(accPath, sourceFact).decorateResolver(this);










 }










 else










 return delta.applyTo(accPath, sourceFact);










 }





















 @Override










 public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {










 return !accPath.isAccessInExclusions(delta);










 return delta.canBeAppliedTo(accPath);










 }





















}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class DeltaConstraint<FieldRef extends AccessPath.FieldRef<FieldRef>> implements Constraint<FieldRef> {publicclassDeltaConstraint<FieldRefextendsAccessPath.FieldRef<FieldRef>>implementsConstraint<FieldRef>{ private SubAccessPath<FieldRef>[] delta;privateSubAccessPath<FieldRef>[]delta; private AccessPath<FieldRef> accPathAtCallee;privateAccessPath<FieldRef>accPathAtCallee; private Delta<FieldRef> delta;privateDelta<FieldRef>delta; public DeltaConstraint(AccessPath<FieldRef> accPathAtCaller, AccessPath<FieldRef> accPathAtCallee) {publicDeltaConstraint(AccessPath<FieldRef>accPathAtCaller,AccessPath<FieldRef>accPathAtCallee){ this.accPathAtCallee = accPathAtCallee;this.accPathAtCallee=accPathAtCallee; delta = accPathAtCaller.getDeltaTo(accPathAtCallee);delta=accPathAtCaller.getDeltaTo(accPathAtCallee); }} @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath, boolean sourceFact) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath,booleansourceFact){ return accPath.addFieldReference(sourceFact, delta).mergeExcludedFieldReferences(accPathAtCallee);returnaccPath.addFieldReference(sourceFact,delta).mergeExcludedFieldReferences(accPathAtCallee); if(accPath.hasResolver()) {if(accPath.hasResolver()){ return delta.applyTo(accPath, sourceFact).decorateResolver(this);returndelta.applyTo(accPath,sourceFact).decorateResolver(this); }} elseelse return delta.applyTo(accPath, sourceFact);returndelta.applyTo(accPath,sourceFact); }} @Override@Override public boolean canBeAppliedTo(AccessPath<FieldRef> accPath) {publicbooleancanBeAppliedTo(AccessPath<FieldRef>accPath){ return !accPath.isAccessInExclusions(delta);return!!accPathaccPath..isAccessInExclusionsisAccessInExclusions((deltadelta); return delta.canBeAppliedTo(accPath);returndeltadelta..canBeAppliedTocanBeAppliedTo((accPathaccPath); }}}}








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8





This diff is collapsed.
Click to expand it.











src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 55cdd2d8








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ 55cdd2d8


55cdd2d8


This diff is collapsed.
Click to expand it.




This diff is collapsed.
Click to expand it.


This diff is collapsed.
Click to expand it.









src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}












src/heros/alias/HashKey.java



0 → 100644







View file @ 55cdd2d8








src/heros/alias/HashKey.java



0 → 100644









View file @ 55cdd2d8


55cdd2d8










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;





















public class HashKey {





















 private Object[] values;





















 public HashKey(Object...values) {










 this.values = values;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(values);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 HashKey other = (HashKey) obj;










 if (!Arrays.equals(values, other.values))










 return false;










 return true;










 }










 










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Arrays;importjava.util.Arrays;public class HashKey {publicclassHashKey{ private Object[] values;privateObject[]values; public HashKey(Object...values) {publicHashKey(Object...values){ this.values = values;this.values=values; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(values);result=prime*result+Arrays.hashCode(values); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; HashKey other = (HashKey) obj;HashKeyother=(HashKey)obj; if (!Arrays.equals(values, other.values))if(!Arrays.equals(values,other.values)) return false;returnfalse; return true;returntrue; }}  }}








src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}












src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644







View file @ 55cdd2d8








src/heros/alias/ReturnConcretizationPathEdge.java



0 → 100644









View file @ 55cdd2d8


55cdd2d8










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.PathEdge;





















public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {
































 public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {










 super(dSource, target, dTarget);










 }





















 public void propagate() {










 _propagate(dSource, target, dTarget);










 }










 










 protected abstract void _propagate(D dSource, N target, D dTarget);










 










 @Override










 public PathEdge<N, D> copyWithTarget(D dTarget) {










 final ReturnConcretizationPathEdge<N, D> outer = this;










 return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {





















 @Override










 protected void _propagate(D dSource, N target, D dTarget) {










 outer._propagate(dSource, target, dTarget);










 }










 };










 }










 










 @Override










 public String toString() {










 return "ReturnConcretizationPathEdge "+super.toString();










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.solver.PathEdge;importheros.solver.PathEdge;public abstract class ReturnConcretizationPathEdge<N,D> extends PathEdge<N, D> {publicabstractclassReturnConcretizationPathEdge<N,D>extendsPathEdge<N,D>{ public ReturnConcretizationPathEdge(D dSource, N target, D dTarget) {publicReturnConcretizationPathEdge(DdSource,Ntarget,DdTarget){ super(dSource, target, dTarget);super(dSource,target,dTarget); }} public void propagate() {publicvoidpropagate(){ _propagate(dSource, target, dTarget);_propagate(dSource,target,dTarget); }}  protected abstract void _propagate(D dSource, N target, D dTarget);protectedabstractvoid_propagate(DdSource,Ntarget,DdTarget);  @Override@Override public PathEdge<N, D> copyWithTarget(D dTarget) {publicPathEdge<N,D>copyWithTarget(DdTarget){ final ReturnConcretizationPathEdge<N, D> outer = this;finalReturnConcretizationPathEdge<N,D>outer=this; return new ReturnConcretizationPathEdge<N, D>(dSource, target, dTarget) {returnnewReturnConcretizationPathEdge<N,D>(dSource,target,dTarget){ @Override@Override protected void _propagate(D dSource, N target, D dTarget) {protectedvoid_propagate(DdSource,Ntarget,DdTarget){ outer._propagate(dSource, target, dTarget);outer._propagate(dSource,target,dTarget); }} };}; }}  @Override@Override public String toString() {publicStringtoString(){ return "ReturnConcretizationPathEdge "+super.toString();return"ReturnConcretizationPathEdge "+super.toString(); }}}}








src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}












src/heros/alias/SubPathResolver.java



0 → 100644







View file @ 55cdd2d8








src/heros/alias/SubPathResolver.java



0 → 100644









View file @ 55cdd2d8


55cdd2d8










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {





















 SubPathResolver<T> decorate(Constraint<T> constraint);










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public interface SubPathResolver<T extends AccessPath.FieldRef<T>> {publicinterfaceSubPathResolver<TextendsAccessPath.FieldRef<T>>{ SubPathResolver<T> decorate(Constraint<T> constraint);SubPathResolver<T>decorate(Constraint<T>constraint);}}








src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......












src/heros/alias/SummaryEdge.java








View file @ 55cdd2d8








src/heros/alias/SummaryEdge.java










View file @ 55cdd2d8


55cdd2d8



......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......






......@@ -21,6 +21,11 @@ public class SummaryEdge<D, N> {









 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 }





















 @Override










 public int hashCode() {



......


 this.targetStmt = targetStmt;this.targetStmt=targetStmt; this.targetFact = targetFact;this.targetFact=targetFact; }}  @Override@Override public String toString() {publicStringtoString(){ return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";return"[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]"; }} @Override@Override public int hashCode() {publicinthashCode(){








src/heros/solver/PathEdge.java








View file @ 55cdd2d8






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......












src/heros/solver/PathEdge.java








View file @ 55cdd2d8








src/heros/solver/PathEdge.java










View file @ 55cdd2d8


55cdd2d8



......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......






......@@ -57,6 +57,10 @@ public class PathEdge<N,D> {









 return dTarget;










 }





















 public PathEdge<N,D> copyWithTarget(D dTarget) {










 return new PathEdge<>(dSource, target, dTarget);










 }










 










 @Override










 public int hashCode() {










 return hashCode;



......


 return dTarget;returndTarget; }} public PathEdge<N,D> copyWithTarget(D dTarget) {publicPathEdge<N,D>copyWithTarget(DdTarget){ return new PathEdge<>(dSource, target, dTarget);returnnewPathEdge<>(dSource,target,dTarget); }}  @Override@Override public int hashCode() {publicinthashCode(){ return hashCode;returnhashCode;








test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......












test/heros/alias/AccessPathTest.java








View file @ 55cdd2d8








test/heros/alias/AccessPathTest.java










View file @ 55cdd2d8


55cdd2d8



......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......






......@@ -49,7 +49,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 }










 










 @Test



......@@ -84,7 +84,7 @@ public class AccessPathTest {









 










 @Test










 public void addMergedFieldsOnNestedExclusion() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));










 }










 



......@@ -162,37 +162,37 @@ public class AccessPathTest {









 










 @Test










 public void deltaDepth1() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b") }, actual);










 }










 










 @Test










 public void deltaDepth2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;










 assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);










 }










 










 @Test










 public void delta() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 










 @Test










 public void delta2() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;










 assertArrayEquals(new SubAccessPath[] { }, actual);










 }










 










 @Test










 public void delta3() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;










 assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);










 }










 



......


 }}  private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {privatestaticAccessPath<TestFieldRef>ap(SubAccessPath<TestFieldRef>...path){ return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());returnnewAccessPath<TestFieldRef>(path,Sets.<TestFieldRef>newHashSet()); return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);returnnewAccessPath<TestFieldRef>(path,Sets.<TestFieldRef>newHashSet(),, nullnull); }}  @Test@Test  @Test@Test public void addMergedFieldsOnNestedExclusion() {publicvoidaddMergedFieldsOnNestedExclusion(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a")).appendExcludedFieldReference(f("b"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a"))..appendExcludedFieldReferenceappendExcludedFieldReference((ff(("b""b"));)) AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("a"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("a")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(anyOf("a", "b")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(anyOf("a","b"))); }}   @Test@Test public void deltaDepth1() {publicvoiddeltaDepth1(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b")));SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"))); SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b")))..accessesaccesses; assertArrayEquals(new SubAccessPath[] { s("b") }, actual);assertArrayEquals(newSubAccessPath[]{s("b")},actual); }}  @Test@Test public void deltaDepth2() {publicvoiddeltaDepth2(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c")));SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"),s("c"))); SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), s("b"), s("c"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),s("b"),s("c")))..accessesaccesses; assertArrayEquals(new SubAccessPath[] { s("b"), s("c") }, actual);assertArrayEquals(newSubAccessPath[]{s("b"),s("c")},actual); }}  @Test@Test public void delta() {publicvoiddelta(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),anyOf("b"))); SubAccessPath<TestFieldRef>[] actual = ap(s("a")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a")).getDeltaTo(ap(s("a"),anyOf("b")))..accessesaccesses; assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }}  @Test@Test public void delta2() {publicvoiddelta2(){ SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h")));SubAccessPath<TestFieldRef>[]actual=ap(s("f"),s("g"),s("h")).getDeltaTo(ap(anyOf("f","g"),s("h"))); SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("g"), s("h")).getDeltaTo(ap(anyOf("f", "g"), s("h"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("f"),s("g"),s("h")).getDeltaTo(ap(anyOf("f","g"),s("h")))..accessesaccesses; assertArrayEquals(new SubAccessPath[] { }, actual);assertArrayEquals(newSubAccessPath[]{},actual); }}  @Test@Test public void delta3() {publicvoiddelta3(){ SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f")));SubAccessPath<TestFieldRef>[]actual=ap(s("f"),s("f")).getDeltaTo(ap(anyOf("f"))); SubAccessPath<TestFieldRef>[] actual = ap(s("f"), s("f")).getDeltaTo(ap(anyOf("f"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("f"),s("f")).getDeltaTo(ap(anyOf("f")))..accessesaccesses; assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);assertArrayEquals(newSubAccessPath[]{anyOf("f")},actual); }}  @Test@Test public void deltaMatchingMergedField() {publicvoiddeltaMatchingMergedField(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b")));SubAccessPath<TestFieldRef>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b"))); SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b")))..accessesaccesses; assertArrayEquals(new SubAccessPath[] { anyOf("b") }, actual);assertArrayEquals(newSubAccessPath[]{anyOf("b")},actual); }} 








test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}












test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 55cdd2d8








test/heros/alias/FieldSensitiveIFDSSolverTest.java










View file @ 55cdd2d8


55cdd2d8



......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}






......@@ -85,7 +85,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "4")),










 normalStmt("e").succ("f", flow("4","4")),










 exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));










 exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));





















 helper.method("xyz", 










 startPoints("g"),



......@@ -121,7 +121,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo",startPoints("d"),










 normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),










 normalStmt("e").succ("f", flow("3","4"), kill("6")),










 exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));










 exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));










 










 helper.runSolver(false, "a", "g");










 }



......@@ -183,7 +183,7 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("b"),










 normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),










 normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),










 normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),










 normalStmt("e").succ("f", kill("2"), kill("2.f.f")));










 










 helper.runSolver(false, "a0");



......@@ -314,7 +314,7 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -325,12 +325,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 normalStmt("e").succ("f", flow("4", readField("f"), "2")),










 callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......@@ -356,13 +357,13 @@ public class FieldSensitiveIFDSSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 normalStmt("e").succ("f", flow("1", readField("g"), "3")),










 callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); 










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }



......@@ -422,14 +423,14 @@ public class FieldSensitiveIFDSSolverTest {









 helper.method("foo", 










 startPoints("a"),










 callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),










 callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),










 callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),










 normalStmt("c").succ("c0", flow("w", "0")));










 










 helper.method("bar",










 startPoints("d"),










 normalStmt("d").succ("e", flow("x", "z")),










 exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))










 .returns(over("b"), to("c"), flow("z", "w")));










 .returns(over("b"), to("c"), flow(2, "z", "w")));










 










 helper.runSolver(false, "a");










 }



......@@ -631,4 +632,315 @@ public class FieldSensitiveIFDSSolverTest {









 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void unbalancedReturnWithFieldRead() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));










 










 helper.method("xyz",










 startPoints("n/a"),










 exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")),










 normalStmt("e").succ("f", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnReadAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("f"), "4")),










 normalStmt("e").succ("f", kill("4")));










 










 helper.runSolver(true, "a");










 }





















 @Test










 public void unbalancedReturnReadUnwrittenAbstractedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("d", flow("2", "3")),










 normalStmt("d").succ("e", flow("3", readField("h"), "4")),










 normalStmt("e").succ("f"));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnTransitiveAbstraction() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2.f")),










 exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("rs1").succ("d", flow("2", "3.g")),










 exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("rs2").succ("e", flow("4", "5")),










 normalStmt("e").succ("f", flow("5", readField("g"), "6")),










 normalStmt("f").succ("g", flow("6", readField("f"), "7")),










 normalStmt("g").succ("h", kill("7")));










 










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void unbalancedReturnPauseAndResume() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));










 










 helper.method("bar",










 startPoints("unused"),










 normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),










 exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void abstractedReturnUseCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void abstractedReturnDeltaBlockingCallerInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 normalStmt("d").succ("e"));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void abstractedReturnResolveThroughDelta() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")),










 callSite("b1").calls("xyz", flow("1", "1.f")));










 










 helper.method("xyz",










 startPoints("b2"),










 callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),










 normalStmt("c").succ("d", flow("2", readField("h"), "3")),










 normalStmt("d").succ("e", kill("3")));










 










 helper.method("bar",










 startPoints("f"),










 exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "a"); 










 }










 










 @Test










 public void unbalancedAbstractedReturnRecursive() {










 helper.method("bar", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));










 










 helper.method("foo",










 startPoints("unused"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2")),










 normalStmt("d").succ("e", kill("2")));










 










 helper.runSolver(true, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 normalStmt("f").succ("g", flow("3", readField("f"), "4")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),










 normalStmt("g").succ("h", flow("3", readField("f"), "4")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void includeResolversInCallDeltas3() {










 helper.method("main",










 startPoints("m_a"),










 normalStmt("m_a").succ("m_b", flow("0", "1")),










 callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),










 callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),










 normalStmt("m_d").succ("m_e", kill("6")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),










 callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),










 normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),










 exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),










 exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));










 










 helper.method("xyz", 










 startPoints("f"),










 exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));










 










 helper.runSolver(false, "m_a");










 }










 










 @Test










 public void recursiveCallReturnCase() {










 helper.method("xyz",










 startPoints("x"),










 normalStmt("x").succ("y", flow("0", "1")),










 callSite("y").calls("foo", flow("1", "1.g")));










 










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("1", "1")),










 callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),










 callSite("c").calls("bar", flow("2", "2")));










 










 helper.method("bar", 










 startPoints("d"),










 normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),










 exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));










 










 helper.runSolver(false, "x");










 }










 










 @Test










 public void recursivelyUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("h").succ("i"));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),










 exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^f










 










 helper.method("xyz",










 startPoints("x"),










 exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));










 










 helper.runSolver(false, "a");










 }





















 @Test










 public void unbalancedUseIncompatibleReturnResolver() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));










 










 helper.method("bar",










 startPoints("unused1"),










 normalStmt("c").succ("d", flow("1", readField("g"), "1")),










 normalStmt("d").succ("e", flow("1", writeField("f"), "2")),










 exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("unused2"),










 normalStmt("f").succ("g", flow("2", readField("f"), "3")),










 normalStmt("g").succ("h"));










 










 helper.runSolver(true, "a");










 }










}


 helper.method("foo",startPoints("d"),helper.method("foo",startPoints("d"), normalStmt("d").succ("e", flow("3", "4")),normalStmt("d").succ("e",flow("3","4")), normalStmt("e").succ("f", flow("4","4")),normalStmt("e").succ("f",flow("4","4")), exitStmt("f").returns(over("c"), to("retC"), flow("4.field", "5.field")).returns(over("g"), to("retG"), flow("4.anotherField", "6.anotherField")));exitStmt("f").returns(over("c"),to("retC"),flow("4.field".field",, "5.field""5.field)).returns(over("g"),to("retG"),flow("4.anotherField".anotherField",, "6.anotherField""6.anotherField))); exitStmt("f").returns(over("c"), to("retC"), flow("4", "5")).returns(over("g"), to("retG"), flow("4", "6")));exitStmt("f").returns(over("c"),to("retC"),flow("4"",, "5""5)).returns(over("g"),to("retG"),flow("4"",, "6""6))); helper.method("xyz", helper.method("xyz", startPoints("g"),startPoints("g"), helper.method("foo",startPoints("d"),helper.method("foo",startPoints("d"), normalStmt("d").succ("e", flow("3", "3"), flow("3", readField("notfield"), "6")),normalStmt("d").succ("e",flow("3","3"),flow("3",readField("notfield"),"6")), normalStmt("e").succ("f", flow("3","4"), kill("6")),normalStmt("e").succ("f",flow("3","4"),kill("6")), exitStmt("f").returns(over("c"), to("rs"), flow("4.field", "5")));exitStmt("f").returns(over("c"),to("rs"),flow("4.field".field,"5"))); exitStmt("f").returns(over("c"), to("rs"), flow("4", "5")));exitStmt("f").returns(over("c"),to("rs"),flow("4","5")));  helper.runSolver(false, "a", "g");helper.runSolver(false,"a","g"); }} startPoints("b"),startPoints("b"), normalStmt("b").succ("c", flow("1", "1", "1.f"), flow("1.f", "1.f.f"), flow("1.f.f", "1.f.f")),normalStmt("b").succ("c",flow("1","1","1.f"),flow("1.f","1.f.f"),flow("1.f.f","1.f.f")), normalStmt("c").succ("b", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")).succ("d", flow("1", "1"), flow("1.f", "1.f"), flow("1.f.f", "1.f.f")),normalStmt("c").succ("b",flow("1","1"),flow("1.f","1.f"),flow("1.f.f","1.f.f")).succ("d",flow("1","1"),flow("1.f","1.f"),flow("1.f.f","1.f.f")), normalStmt("d").succ("e", /*flow("1", readField("f"), "2"),*/ flow("1.f", "2"), flow("1.f.f", "2.f.f")),normalStmt("d").succ("e",/*flow("1", readField("f"), "2"),*//**/flow("1.f","2"),flow("1.f.f","2.f.f")), normalStmt("d").succ("e", flow("1", readField("f"), "2"), flow("1.f", "2"), flow("1.f.f", "2.f.f")),normalStmt("d").succ("e",flow("1",readField("f"),"2"),flow("1.f","2"),flow("1.f.f","2.f.f")), normalStmt("e").succ("f", kill("2"), kill("2.f.f")));normalStmt("e").succ("f",kill("2"),kill("2.f.f")));  helper.runSolver(false, "a0");helper.runSolver(false,"a0"); helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3.g"), kill("2.g" /* 2^f is back substituted to 2.g*/))); exitStmt("d").returns(over("b"),to("e"),flow("3.f".f,"4")).returns(over("e"),to("f"),kill("3.g".g),kill("2.g".g" /* 2^f is back substituted to 2.g*//* 2^f is back substituted to 2.g*/))); exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3","4")).returns(over("e"),to("f"),kill("3"),kill("2^f"^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),callSite("b").calls("bar",flow("1.f","2.f")).retSite("e",kill("1.f")), callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));callSite("e").calls("bar",flow("4","2")).retSite("f",kill("4"))); normalStmt("e").succ("f", flow("4", readField("f"), "2")),normalStmt("e").succ("f",flow("4",readField("f"),"2")), callSite("f").calls("bar", flow("2", "2")).retSite("g", kill("2")));callSite("f").calls("bar",flow("2","2")).retSite("g",kill("2")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3.f".f,"4")).returns(over("e"e),to("f"f),kill("3"),kill("2^f"))); exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("f"), to("g"), kill("3"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3","4")).returns(over("f"f),to("g"g),kill("3"),kill("2^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.g")),normalStmt("a").succ("b",flow("0","1.g")), callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),callSite("b").calls("bar",flow("1.g","1.g")).retSite("e",kill("1.g")), normalStmt("e").succ("f", flow("1.g", "3")),normalStmt("e").succ("f",flow("1.g".,"3")), normalStmt("e").succ("f", flow("1", readField("g"), "3")),normalStmt("e").succ("f",flow("1"",, readFieldreadField(("g""),)"3")), callSite("f").calls("bar", flow("3", "1")).retSite("g", kill("3"))); callSite("f").calls("bar",flow("3","1")).retSite("g",kill("3")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),normalStmt("c").succ("d",flow("1",readField("f"),"2"),flow("1","1")), exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));exitStmt("d").returns(over("b"),to("e"),flow("1.g".g,"1.g".g)/* ignore fact 2, not possible with this caller ctx*/).returns(over("f"),to("g"),kill("1"),kill("2"))); exitStmt("d").returns(over("b"), to("e"), flow("1", "1") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("2")));exitStmt("d").returns(over("b"),to("e"),flow("1","1")/* ignore fact 2, not possible with this caller ctx*/).returns(over("f"),to("g"),kill("1"),kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} helper.method("foo", helper.method("foo", startPoints("a"),startPoints("a"), callSite("a").calls("bar", flow("0", "x")).retSite("b", flow("0", "y")),callSite("a").calls("bar",flow("0","x")).retSite("b",flow("0","y")), callSite("b").calls("bar", flow("y", "x")).retSite("c", flow("y")),callSite("b").calls("bar",flow("y","x")).retSite("c",flowflow(("y")), callSite("b").calls("bar", flow(2, "y", "x")).retSite("c", kill(2, "y")),callSite("b").calls("bar",flow(22,, "y","x")).retSite("c",killkill((22,, "y")), normalStmt("c").succ("c0", flow("w", "0")));normalStmt("c").succ("c0",flow("w","0")));  helper.method("bar",helper.method("bar", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("x", "z")),normalStmt("d").succ("e",flow("x","z")), exitStmt("e").returns(over("a"), to("b"), flow("z", "y"))exitStmt("e").returns(over("a"),to("b"),flow("z","y")) .returns(over("b"), to("c"), flow("z", "w")));.returns(over("b"),to("c"),flow("z","w"))); .returns(over("b"), to("c"), flow(2, "z", "w")));.returns(over("b"),to("c"),flow(22,, "z","w")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void unbalancedReturnWithFieldRead() {publicvoidunbalancedReturnWithFieldRead(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), exitStmt("b").returns(over("cs"), to("c"), flow("1", "2")));exitStmt("b").returns(over("cs"),to("c"),flow("1","2")));  helper.method("xyz",helper.method("xyz", startPoints("n/a"),startPoints("n/a"), exitStmt("c").returns(over("cs2"), to("d"), flow("2", "2")));exitStmt("c").returns(over("cs2"),to("d"),flow("2","2")));  helper.method("bar",helper.method("bar", startPoints("unused"),startPoints("unused"), normalStmt("d").succ("e", flow("2", readField("f"), "3")),normalStmt("d").succ("e",flow("2",readField("f"),"3")), normalStmt("e").succ("f", kill("3")));normalStmt("e").succ("f",kill("3")));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }}  @Test@Test public void unbalancedReturnAbstraction() {publicvoidunbalancedReturnAbstraction(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", "2.f")),normalStmt("b").succ("c",flow("1","2.f")), exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));exitStmt("c").returns(over("cs"),to("rs"),flow("2.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("unused"),startPoints("unused"), normalStmt("rs").succ("d", flow("2", "3")));normalStmt("rs").succ("d",flow("2","3")));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }}  @Test@Test public void unbalancedReturnReadAbstractedField() {publicvoidunbalancedReturnReadAbstractedField(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", "2.f")),normalStmt("b").succ("c",flow("1","2.f")), exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));exitStmt("c").returns(over("cs"),to("rs"),flow("2.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("unused"),startPoints("unused"), normalStmt("rs").succ("d", flow("2", "3")),normalStmt("rs").succ("d",flow("2","3")), normalStmt("d").succ("e", flow("3", readField("f"), "4")),normalStmt("d").succ("e",flow("3",readField("f"),"4")), normalStmt("e").succ("f", kill("4")));normalStmt("e").succ("f",kill("4")));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }} @Test@Test public void unbalancedReturnReadUnwrittenAbstractedField() {publicvoidunbalancedReturnReadUnwrittenAbstractedField(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", "2.f")),normalStmt("b").succ("c",flow("1","2.f")), exitStmt("c").returns(over("cs"), to("rs"), flow("2.f", "2.f")));exitStmt("c").returns(over("cs"),to("rs"),flow("2.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("unused"),startPoints("unused"), normalStmt("rs").succ("d", flow("2", "3")),normalStmt("rs").succ("d",flow("2","3")), normalStmt("d").succ("e", flow("3", readField("h"), "4")),normalStmt("d").succ("e",flow("3",readField("h"),"4")), normalStmt("e").succ("f"));normalStmt("e").succ("f"));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }}  @Test@Test public void unbalancedReturnTransitiveAbstraction() {publicvoidunbalancedReturnTransitiveAbstraction(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", "2.f")),normalStmt("b").succ("c",flow("1","2.f")), exitStmt("c").returns(over("cs1"), to("rs1"), flow("2.f", "2.f")));exitStmt("c").returns(over("cs1"),to("rs1"),flow("2.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("unused1"),startPoints("unused1"), normalStmt("rs1").succ("d", flow("2", "3.g")),normalStmt("rs1").succ("d",flow("2","3.g")), exitStmt("d").returns(over("cs2"), to("rs2"), flow("3.g", "4.g")));exitStmt("d").returns(over("cs2"),to("rs2"),flow("3.g","4.g")));  helper.method("xyz",helper.method("xyz", startPoints("unused2"),startPoints("unused2"), normalStmt("rs2").succ("e", flow("4", "5")),normalStmt("rs2").succ("e",flow("4","5")), normalStmt("e").succ("f", flow("5", readField("g"), "6")),normalStmt("e").succ("f",flow("5",readField("g"),"6")), normalStmt("f").succ("g", flow("6", readField("f"), "7")),normalStmt("f").succ("g",flow("6",readField("f"),"7")), normalStmt("g").succ("h", kill("7")));normalStmt("g").succ("h",kill("7")));   helper.runSolver(true, "a");helper.runSolver(true,"a"); }}  @Test@Test public void unbalancedReturnPauseAndResume() {publicvoidunbalancedReturnPauseAndResume(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), exitStmt("b").returns(over("cs"), to("rs"), flow("1", "2.g")));exitStmt("b").returns(over("cs"),to("rs"),flow("1","2.g")));  helper.method("bar",helper.method("bar", startPoints("unused"),startPoints("unused"), normalStmt("rs").succ("c", flow("2", "2")).succ("d", flow("2", readField("f"), "3")),normalStmt("rs").succ("c",flow("2","2")).succ("d",flow("2",readField("f"),"3")), exitStmt("c").returns(over("cs2"), to("rs"), flow("2", "2.f")),exitStmt("c").returns(over("cs2"),to("rs"),flow("2","2.f")), normalStmt("d").succ("e", kill("3")));normalStmt("d").succ("e",kill("3")));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }}  @Test@Test public void abstractedReturnUseCallerInterest() {publicvoidabstractedReturnUseCallerInterest(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("c",kill("1")), normalStmt("c").succ("d", flow("2", readField("f"), "3")),normalStmt("c").succ("d",flow("2",readField("f"),"3")), normalStmt("d").succ("e", kill("3")));normalStmt("d").succ("e",kill("3")));  helper.method("bar",helper.method("bar", startPoints("f"),startPoints("f"), exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));exitStmt("f").returns(over("b"),to("c"),flow("2","2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void abstractedReturnDeltaBlockingCallerInterest() {publicvoidabstractedReturnDeltaBlockingCallerInterest(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),callSite("b").calls("bar",flow("1","2.h")).retSite("c",kill("1")), normalStmt("c").succ("d", flow("2", readField("f"), "3")),normalStmt("c").succ("d",flow("2",readField("f"),"3")), normalStmt("d").succ("e"));normalStmt("d").succ("e"));  helper.method("bar",helper.method("bar", startPoints("f"),startPoints("f"), exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));exitStmt("f").returns(over("b"),to("c"),flow("2","2")));  helper.runSolver(false, "a"); helper.runSolver(false,"a"); }}  @Test@Test public void abstractedReturnResolveThroughDelta() {publicvoidabstractedReturnResolveThroughDelta(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b1", flow("0", "1")),normalStmt("a").succ("b1",flow("0","1")), callSite("b1").calls("xyz", flow("1", "1.f")));callSite("b1").calls("xyz",flow("1","1.f")));  helper.method("xyz",helper.method("xyz", startPoints("b2"),startPoints("b2"), callSite("b2").calls("bar", flow("1", "2.h")).retSite("c", kill("1")),callSite("b2").calls("bar",flow("1","2.h")).retSite("c",kill("1")), normalStmt("c").succ("d", flow("2", readField("h"), "3")),normalStmt("c").succ("d",flow("2",readField("h"),"3")), normalStmt("d").succ("e", kill("3")));normalStmt("d").succ("e",kill("3")));  helper.method("bar",helper.method("bar", startPoints("f"),startPoints("f"), exitStmt("f").returns(over("b2"), to("c"), flow("2", "2")));exitStmt("f").returns(over("b2"),to("c"),flow("2","2")));  helper.runSolver(false, "a"); helper.runSolver(false,"a"); }}  @Test@Test public void unbalancedAbstractedReturnRecursive() {publicvoidunbalancedAbstractedReturnRecursive(){ helper.method("bar", helper.method("bar", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), exitStmt("b").returns(over("cs1"), to("b"), flow(2, "1", "1")).returns(over("cs2"), to("c"), flow(2, "1", "1")));exitStmt("b").returns(over("cs1"),to("b"),flow(2,"1","1")).returns(over("cs2"),to("c"),flow(2,"1","1")));  helper.method("foo",helper.method("foo", startPoints("unused"),startPoints("unused"), normalStmt("c").succ("d", flow("1", readField("f"), "2")),normalStmt("c").succ("d",flow("1",readField("f"),"2")), normalStmt("d").succ("e", kill("2")));normalStmt("d").succ("e",kill("2")));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }}  @Test@Test public void includeResolversInCallDeltas() {publicvoidincludeResolversInCallDeltas(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("e",kill("1")), callSite("e").calls("xyz", flow("3", "3")));callSite("e").calls("xyz",flow("3","3")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f")), exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));exitStmt("d").returns(over("b"),to("e"),flow("2^f","3^f")));  helper.method("xyz", helper.method("xyz", startPoints("f"),startPoints("f"), normalStmt("f").succ("g", flow("3", readField("f"), "4")),normalStmt("f").succ("g",flow("3",readField("f"),"4")), normalStmt("g").succ("h"));normalStmt("g").succ("h"));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void includeResolversInCallDeltas2() {publicvoidincludeResolversInCallDeltas2(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("e",kill("1")), callSite("e").calls("xyz", flow("3", "3")).retSite("g", kill("3")),callSite("e").calls("xyz",flow("3","3")).retSite("g",kill("3")), normalStmt("g").succ("h", flow("3", readField("f"), "4")),normalStmt("g").succ("h",flow("3",readField("f"),"4")), normalStmt("h").succ("i"));normalStmt("h").succ("i"));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f")), exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f")));exitStmt("d").returns(over("b"),to("e"),flow("2^f","3^f")));  helper.method("xyz", helper.method("xyz", startPoints("f"),startPoints("f"), exitStmt("f").returns(over("e"), to("g"), flow("3", "3")));exitStmt("f").returns(over("e"),to("g"),flow("3","3")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void includeResolversInCallDeltas3() {publicvoidincludeResolversInCallDeltas3(){ helper.method("main",helper.method("main", startPoints("m_a"),startPoints("m_a"), normalStmt("m_a").succ("m_b", flow("0", "1")),normalStmt("m_a").succ("m_b",flow("0","1")), callSite("m_b").calls("foo", flow("1", "1.g")).retSite("m_c", kill("1")),callSite("m_b").calls("foo",flow("1","1.g")).retSite("m_c",kill("1")), callSite("m_c").calls("foo", flow("5", "1.f")).retSite("m_d", kill("5")),callSite("m_c").calls("foo",flow("5","1.f")).retSite("m_d",kill("5")), normalStmt("m_d").succ("m_e", kill("6")));normalStmt("m_d").succ("m_e",kill("6")));  helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("1", "1")),normalStmt("a").succ("b",flow("1","1")), callSite("b").calls("bar", flow("1", "2")).retSite("e", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("e",kill("1")), callSite("e").calls("xyz", flow(2, "3", "3")).retSite("g", kill(2, "3")),callSite("e").calls("xyz",flow(2,"3","3")).retSite("g",kill(2,"3")), normalStmt("g").succ("h", flow(2, "3", readField("f"), "4"), flow(2, "3", readField("g"), "5")),normalStmt("g").succ("h",flow(2,"3",readField("f"),"4"),flow(2,"3",readField("g"),"5")), exitStmt("h").returns(over("m_c"), to("m_d"), flow("4", "6")).returns(over("m_b"), to("m_c"), flow("5", "5")));exitStmt("h").returns(over("m_c"),to("m_d"),flow("4","6")).returns(over("m_b"),to("m_c"),flow("5","5")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", writeField("g"), "2^g")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2",writeField("g"),"2^g")), exitStmt("d").returns(over("b"), to("e"), flow("2^f", "3^f"), flow("2^g", "3^g")));exitStmt("d").returns(over("b"),to("e"),flow("2^f","3^f"),flow("2^g","3^g")));  helper.method("xyz", helper.method("xyz", startPoints("f"),startPoints("f"), exitStmt("f").returns(over("e"), to("g"), flow(2, "3", "3")));exitStmt("f").returns(over("e"),to("g"),flow(2,"3","3")));  helper.runSolver(false, "m_a");helper.runSolver(false,"m_a"); }}  @Test@Test public void recursiveCallReturnCase() {publicvoidrecursiveCallReturnCase(){ helper.method("xyz",helper.method("xyz", startPoints("x"),startPoints("x"), normalStmt("x").succ("y", flow("0", "1")),normalStmt("x").succ("y",flow("0","1")), callSite("y").calls("foo", flow("1", "1.g")));callSite("y").calls("foo",flow("1","1.g")));  helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("1", "1")),normalStmt("a").succ("b",flow("1","1")), callSite("b").calls("bar", flow("1", "2")).retSite("c", kill("1")),callSite("b").calls("bar",flow("1","2")).retSite("c",kill("1")), callSite("c").calls("bar", flow("2", "2")));callSite("c").calls("bar",flow("2","2")));  helper.method("bar", helper.method("bar", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("2", readField("f"), "3")).succ("f", flow("2", "2")),normalStmt("d").succ("e",flow("2",readField("f"),"3")).succ("f",flow("2","2")), exitStmt("f").returns(over("b"), to("c"), flow("2", "2")));exitStmt("f").returns(over("b"),to("c"),flow("2","2")));  helper.runSolver(false, "x");helper.runSolver(false,"x"); }}  @Test@Test public void recursivelyUseIncompatibleReturnResolver() {publicvoidrecursivelyUseIncompatibleReturnResolver(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "1")).retSite("f", kill("1")),callSite("b").calls("bar",flow("1","1")).retSite("f",kill("1")), normalStmt("f").succ("g", flow("2", readField("f"), "3")),normalStmt("f").succ("g",flow("2",readField("f"),"3")), normalStmt("h").succ("i"));normalStmt("h").succ("i"));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), callSite("c").calls("xyz", flow("1", "1")).retSite("d", kill("1")),callSite("c").calls("xyz",flow("1","1")).retSite("d",kill("1")), normalStmt("d").succ("e", flow("1", writeField("f"), "1^f")),normalStmt("d").succ("e",flow("1",writeField("f"),"1^f")), exitStmt("e").returns(over("b"), to("f"), flow(2, "1^f", "2^f"))); //once per incoming edge: 1 and 1^fexitStmt("e").returns(over("b"),to("f"),flow(2,"1^f","2^f")));//once per incoming edge: 1 and 1^f  helper.method("xyz",helper.method("xyz", startPoints("x"),startPoints("x"), exitStmt("x").returns(over("c"), to("d"), flow("1", "1")));exitStmt("x").returns(over("c"),to("d"),flow("1","1")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }} @Test@Test public void unbalancedUseIncompatibleReturnResolver() {publicvoidunbalancedUseIncompatibleReturnResolver(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), exitStmt("b").returns(over("cs"), to("c"), flow("1", "1")));exitStmt("b").returns(over("cs"),to("c"),flow("1","1")));  helper.method("bar",helper.method("bar", startPoints("unused1"),startPoints("unused1"), normalStmt("c").succ("d", flow("1", readField("g"), "1")),normalStmt("c").succ("d",flow("1",readField("g"),"1")), normalStmt("d").succ("e", flow("1", writeField("f"), "2")),normalStmt("d").succ("e",flow("1",writeField("f"),"2")), exitStmt("e").returns(over("cs2"), to("f"), flow("2", "2")));exitStmt("e").returns(over("cs2"),to("f"),flow("2","2")));  helper.method("xyz",helper.method("xyz", startPoints("unused2"),startPoints("unused2"), normalStmt("f").succ("g", flow("2", readField("f"), "3")),normalStmt("f").succ("g",flow("2",readField("f"),"3")), normalStmt("g").succ("h"));normalStmt("g").succ("h"));  helper.runSolver(true, "a");helper.runSolver(true,"a"); }}}}








test/heros/alias/TestHelper.java








View file @ 55cdd2d8






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......












test/heros/alias/TestHelper.java








View file @ 55cdd2d8








test/heros/alias/TestHelper.java










View file @ 55cdd2d8


55cdd2d8



......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......






......@@ -490,9 +490,14 @@ public class TestHelper {









 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {










 if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {










 if (remainingFlowFunctions.remove(ff)) {










 result.addAll(Sets.newHashSet(ff.targets));










 for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {










 result.add(new ConstrainedFact<TestFieldRef, Fact>(










 target.getFact().cloneWithAccessPath(










 target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), 










 target.getConstraint()));










 }










 found = true;










 } else {










 throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));



......


 Set<ConstrainedFact<TestFieldRef, Fact>> result = Sets.newHashSet();Set<ConstrainedFact<TestFieldRef,Fact>>result=Sets.newHashSet(); boolean found = false;booleanfound=false; for (ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ if (ff.source.equals(source)) {if(ff.source.equals(source)){ if (ff.source.equals(source.cloneWithAccessPath(source.getAccessPath().setResolver(null)))) {if(ff.source.equals(source..cloneWithAccessPathcloneWithAccessPath((sourcesource..getAccessPathgetAccessPath().().setResolversetResolver((nullnull)))))){ if (remainingFlowFunctions.remove(ff)) {if(remainingFlowFunctions.remove(ff)){ result.addAll(Sets.newHashSet(ff.targets));result.addAll(Sets.newHashSet(ff.targets)); for(ConstrainedFact<TestFieldRef, Fact> target : ff.targets) {for(ConstrainedFact<TestFieldRef,Fact>target:ff.targets){ result.add(new ConstrainedFact<TestFieldRef, Fact>(result.add(newConstrainedFact<TestFieldRef,Fact>( target.getFact().cloneWithAccessPath(target.getFact().cloneWithAccessPath( target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), target.getFact().accessPath.setResolver(source.getAccessPath().getResolver())), target.getConstraint()));target.getConstraint())); }} found = true;found=true; } else {}else{ throw new AssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'", ff, edge));thrownewAssertionError(String.format("Flow Function '%s' was used multiple times on edge '%s'",ff,edge));









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






