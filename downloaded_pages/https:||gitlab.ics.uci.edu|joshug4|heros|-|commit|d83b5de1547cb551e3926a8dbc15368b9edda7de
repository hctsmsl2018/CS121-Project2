



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

d83b5de1















Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml














TODO.txt



0 → 100644







View file @ d83b5de1













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?














build.properties



0 → 100644







View file @ d83b5de1













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar














src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}














src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}














src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file














src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}














src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}














src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}














src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}














src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}














src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}














src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}














src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}














src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

d83b5de1















Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml














TODO.txt



0 → 100644







View file @ d83b5de1













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?














build.properties



0 → 100644







View file @ d83b5de1













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar














src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}














src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}














src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file














src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}














src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}














src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}














src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}














src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}














src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}














src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}














src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}














src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

d83b5de1







Open sidebar



Joshua Garcia heros
Commits

d83b5de1




Open sidebar

Joshua Garcia heros
Commits

d83b5de1


Joshua GarciaherosherosCommits
d83b5de1








Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml














TODO.txt



0 → 100644







View file @ d83b5de1













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?














build.properties



0 → 100644







View file @ d83b5de1













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar














src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}














src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}














src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file














src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}














src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}














src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}














src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}














src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}














src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}














src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}














src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}














src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files




initial checkin







parent
56cf8f0e













Changes
42




Hide whitespace changes

Inline
Side-by-side















META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml














TODO.txt



0 → 100644







View file @ d83b5de1













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?














build.properties



0 → 100644







View file @ d83b5de1













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar














src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}














src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}














src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file














src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}














src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}














src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}














src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}














src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}














src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}














src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}














src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}














src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden



Browse files



Commit
d83b5de1


authored
Nov 14, 2012
by


Eric Bodden

d83b5de1authoredbyEric Bodden

initial checkin






parent
56cf8f0e
















parent
56cf8f0e





parent












Changes
42
42


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml














TODO.txt



0 → 100644







View file @ d83b5de1













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?














build.properties



0 → 100644







View file @ d83b5de1













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar














src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}














src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}














src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file














src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}














src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}














src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}














src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file














src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}














src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}














src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}














src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}














src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}














src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file














src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}














src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}









Prev


1


2


3


Next













META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml












META-INF/MANIFEST.MF



0 → 100644







View file @ d83b5de1








META-INF/MANIFEST.MF



0 → 100644









View file @ d83b5de1


d83b5de1










Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml













Manifest-Version: 1.0










Bundle-ManifestVersion: 2










Bundle-Name: soot-ifds










Bundle-SymbolicName: soot-ifds










Bundle-Version: 1.0.0.qualifier










Bundle-ClassPath: soot-ifds.jar,










 guava-13.0.jar,










 soot-trunk.jar










Export-Package: com.google.common.annotations,










 com.google.common.base,










 com.google.common.base.internal,










 com.google.common.cache,










 com.google.common.collect,










 com.google.common.eventbus,










 com.google.common.hash,










 com.google.common.io,










 com.google.common.math,










 com.google.common.net,










 com.google.common.primitives,










 com.google.common.util.concurrent,










 soot,










 soot.JastAddJ,










 soot.baf,










 soot.baf.internal,










 soot.baf.toolkits.base,










 soot.coffi,










 soot.dava,










 soot.dava.internal.AST,










 soot.dava.internal.SET,










 soot.dava.internal.asg,










 soot.dava.internal.javaRep,










 soot.dava.toolkits.base.AST,










 soot.dava.toolkits.base.AST.analysis,










 soot.dava.toolkits.base.AST.interProcedural,










 soot.dava.toolkits.base.AST.structuredAnalysis,










 soot.dava.toolkits.base.AST.transformations,










 soot.dava.toolkits.base.AST.traversals,










 soot.dava.toolkits.base.DavaMonitor,










 soot.dava.toolkits.base.finders,










 soot.dava.toolkits.base.misc,










 soot.dava.toolkits.base.renamer,










 soot.grimp,










 soot.grimp.internal,










 soot.grimp.toolkits.base,










 soot.javaToJimple,










 soot.javaToJimple.jj,










 soot.javaToJimple.jj.ast,










 soot.javaToJimple.jj.types,










 soot.javaToJimple.toolkits,










 soot.jbco,










 soot.jbco.bafTransformations,










 soot.jbco.gui,










 soot.jbco.jimpleTransformations,










 soot.jbco.util,










 soot.jimple,










 soot.jimple.internal,










 soot.jimple.interproc.ifds,










 soot.jimple.interproc.ifds.edgefunc,










 soot.jimple.interproc.ifds.flowfunc,










 soot.jimple.interproc.ifds.problems,










 soot.jimple.interproc.ifds.solver,










 soot.jimple.interproc.ifds.template,










 soot.jimple.paddle,










 soot.jimple.parser,










 soot.jimple.parser.analysis,










 soot.jimple.parser.lexer,










 soot.jimple.parser.node,










 soot.jimple.parser.parser,










 soot.jimple.spark,










 soot.jimple.spark.builder,










 soot.jimple.spark.fieldrw,










 soot.jimple.spark.geom,










 soot.jimple.spark.geom.geomE,










 soot.jimple.spark.geom.geomPA,










 soot.jimple.spark.geom.heapinsE,










 soot.jimple.spark.geom.ptinsE,










 soot.jimple.spark.internal,










 soot.jimple.spark.ondemand,










 soot.jimple.spark.ondemand.genericutil,










 soot.jimple.spark.ondemand.pautil,










 soot.jimple.spark.pag,










 soot.jimple.spark.sets,










 soot.jimple.spark.solver,










 soot.jimple.toolkits.annotation,










 soot.jimple.toolkits.annotation.arraycheck,










 soot.jimple.toolkits.annotation.callgraph,










 soot.jimple.toolkits.annotation.defs,










 soot.jimple.toolkits.annotation.fields,










 soot.jimple.toolkits.annotation.j5anno,










 soot.jimple.toolkits.annotation.liveness,










 soot.jimple.toolkits.annotation.logic,










 soot.jimple.toolkits.annotation.methods,










 soot.jimple.toolkits.annotation.nullcheck,










 soot.jimple.toolkits.annotation.parity,










 soot.jimple.toolkits.annotation.profiling,










 soot.jimple.toolkits.annotation.purity,










 soot.jimple.toolkits.annotation.qualifiers,










 soot.jimple.toolkits.annotation.tags,










 soot.jimple.toolkits.base,










 soot.jimple.toolkits.callgraph,










 soot.jimple.toolkits.graph,










 soot.jimple.toolkits.infoflow,










 soot.jimple.toolkits.invoke,










 soot.jimple.toolkits.pointer,










 soot.jimple.toolkits.pointer.nativemethods,










 soot.jimple.toolkits.pointer.representations,










 soot.jimple.toolkits.pointer.util,










 soot.jimple.toolkits.reflection,










 soot.jimple.toolkits.scalar,










 soot.jimple.toolkits.scalar.pre,










 soot.jimple.toolkits.thread,










 soot.jimple.toolkits.thread.mhp,










 soot.jimple.toolkits.thread.mhp.findobject,










 soot.jimple.toolkits.thread.mhp.pegcallgraph,










 soot.jimple.toolkits.thread.mhp.stmt,










 soot.jimple.toolkits.thread.synchronization,










 soot.jimple.toolkits.typing,










 soot.jimple.toolkits.typing.fast,










 soot.jimple.toolkits.typing.integer,










 soot.options,










 soot.rtlib.tamiflex,










 soot.shimple,










 soot.shimple.internal,










 soot.shimple.toolkits.graph,










 soot.shimple.toolkits.scalar,










 soot.sootify,










 soot.tagkit,










 soot.toolkits.astmetrics,










 soot.toolkits.astmetrics.DataHandlingApplication,










 soot.toolkits.exceptions,










 soot.toolkits.graph,










 soot.toolkits.graph.interaction,










 soot.toolkits.graph.pdg,










 soot.toolkits.scalar,










 soot.tools,










 soot.util,










 soot.util.cfgcmd,










 soot.util.dot,










 soot.util.queue,










 soot.xml


Manifest-Version: 1.0Bundle-ManifestVersion: 2Bundle-Name: soot-ifdsBundle-SymbolicName: soot-ifdsBundle-Version: 1.0.0.qualifierBundle-ClassPath: soot-ifds.jar, guava-13.0.jar, soot-trunk.jarExport-Package: com.google.common.annotations, com.google.common.base, com.google.common.base.internal, com.google.common.cache, com.google.common.collect, com.google.common.eventbus, com.google.common.hash, com.google.common.io, com.google.common.math, com.google.common.net, com.google.common.primitives, com.google.common.util.concurrent, soot, soot.JastAddJ, soot.baf, soot.baf.internal, soot.baf.toolkits.base, soot.coffi, soot.dava, soot.dava.internal.AST, soot.dava.internal.SET, soot.dava.internal.asg, soot.dava.internal.javaRep, soot.dava.toolkits.base.AST, soot.dava.toolkits.base.AST.analysis, soot.dava.toolkits.base.AST.interProcedural, soot.dava.toolkits.base.AST.structuredAnalysis, soot.dava.toolkits.base.AST.transformations, soot.dava.toolkits.base.AST.traversals, soot.dava.toolkits.base.DavaMonitor, soot.dava.toolkits.base.finders, soot.dava.toolkits.base.misc, soot.dava.toolkits.base.renamer, soot.grimp, soot.grimp.internal, soot.grimp.toolkits.base, soot.javaToJimple, soot.javaToJimple.jj, soot.javaToJimple.jj.ast, soot.javaToJimple.jj.types, soot.javaToJimple.toolkits, soot.jbco, soot.jbco.bafTransformations, soot.jbco.gui, soot.jbco.jimpleTransformations, soot.jbco.util, soot.jimple, soot.jimple.internal, soot.jimple.interproc.ifds, soot.jimple.interproc.ifds.edgefunc, soot.jimple.interproc.ifds.flowfunc, soot.jimple.interproc.ifds.problems, soot.jimple.interproc.ifds.solver, soot.jimple.interproc.ifds.template, soot.jimple.paddle, soot.jimple.parser, soot.jimple.parser.analysis, soot.jimple.parser.lexer, soot.jimple.parser.node, soot.jimple.parser.parser, soot.jimple.spark, soot.jimple.spark.builder, soot.jimple.spark.fieldrw, soot.jimple.spark.geom, soot.jimple.spark.geom.geomE, soot.jimple.spark.geom.geomPA, soot.jimple.spark.geom.heapinsE, soot.jimple.spark.geom.ptinsE, soot.jimple.spark.internal, soot.jimple.spark.ondemand, soot.jimple.spark.ondemand.genericutil, soot.jimple.spark.ondemand.pautil, soot.jimple.spark.pag, soot.jimple.spark.sets, soot.jimple.spark.solver, soot.jimple.toolkits.annotation, soot.jimple.toolkits.annotation.arraycheck, soot.jimple.toolkits.annotation.callgraph, soot.jimple.toolkits.annotation.defs, soot.jimple.toolkits.annotation.fields, soot.jimple.toolkits.annotation.j5anno, soot.jimple.toolkits.annotation.liveness, soot.jimple.toolkits.annotation.logic, soot.jimple.toolkits.annotation.methods, soot.jimple.toolkits.annotation.nullcheck, soot.jimple.toolkits.annotation.parity, soot.jimple.toolkits.annotation.profiling, soot.jimple.toolkits.annotation.purity, soot.jimple.toolkits.annotation.qualifiers, soot.jimple.toolkits.annotation.tags, soot.jimple.toolkits.base, soot.jimple.toolkits.callgraph, soot.jimple.toolkits.graph, soot.jimple.toolkits.infoflow, soot.jimple.toolkits.invoke, soot.jimple.toolkits.pointer, soot.jimple.toolkits.pointer.nativemethods, soot.jimple.toolkits.pointer.representations, soot.jimple.toolkits.pointer.util, soot.jimple.toolkits.reflection, soot.jimple.toolkits.scalar, soot.jimple.toolkits.scalar.pre, soot.jimple.toolkits.thread, soot.jimple.toolkits.thread.mhp, soot.jimple.toolkits.thread.mhp.findobject, soot.jimple.toolkits.thread.mhp.pegcallgraph, soot.jimple.toolkits.thread.mhp.stmt, soot.jimple.toolkits.thread.synchronization, soot.jimple.toolkits.typing, soot.jimple.toolkits.typing.fast, soot.jimple.toolkits.typing.integer, soot.options, soot.rtlib.tamiflex, soot.shimple, soot.shimple.internal, soot.shimple.toolkits.graph, soot.shimple.toolkits.scalar, soot.sootify, soot.tagkit, soot.toolkits.astmetrics, soot.toolkits.astmetrics.DataHandlingApplication, soot.toolkits.exceptions, soot.toolkits.graph, soot.toolkits.graph.interaction, soot.toolkits.graph.pdg, soot.toolkits.scalar, soot.tools, soot.util, soot.util.cfgcmd, soot.util.dot, soot.util.queue, soot.xml








TODO.txt



0 → 100644







View file @ d83b5de1













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?












TODO.txt



0 → 100644







View file @ d83b5de1








TODO.txt



0 → 100644









View file @ d83b5de1


d83b5de1










IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?













IFDS:










	Have simpler templates for flow functions.










		Should be efficient, do not create too many sets.	










	Create binary sets.










	Separate normal return from throw flow functions?










	Useful templates










		Template for local-variable tracking analyses		










	Performance optimizations	










	Implement subsumtion as in CC'10 paper










 










	Notes:










		Could it be that RHS even works for infinite domains?


IFDS:	Have simpler templates for flow functions.		Should be efficient, do not create too many sets.		Create binary sets.	Separate normal return from throw flow functions?	Useful templates		Template for local-variable tracking analyses			Performance optimizations		Implement subsumtion as in CC'10 paper 	Notes:		Could it be that RHS even works for infinite domains?








build.properties



0 → 100644







View file @ d83b5de1













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar












build.properties



0 → 100644







View file @ d83b5de1








build.properties



0 → 100644









View file @ d83b5de1


d83b5de1










source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar













source.soot-ifds.jar = src/










bin.includes = META-INF/,\










 soot-ifds.jar,\










 soot-trunk.jar,\










 guava-13.0.jar


source.soot-ifds.jar = src/source.soot-ifds.jar=src/bin.includes = META-INF/,\bin.includes=META-INF/,\ soot-ifds.jar,\soot-ifds.jar,\ soot-trunk.jar,\soot-trunk.jar,\ guava-13.0.jarguava-13.0.jar








src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file












src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/DontSynchronize.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field can remain unsynchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface DontSynchronize{ String value() default ""; }




\ No newline at end of file


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import static java.lang.annotation.ElementType.FIELD;importstaticjava.lang.annotation.ElementType.FIELD;import java.lang.annotation.Target;importjava.lang.annotation.Target;/**	Semantic annotation stating that the annotated field can remain unsynchronized./**	Semantic annotation stating that the annotated field can remain unsynchronized. *  This annotation is meant as a structured comment only, and has no immediate effect. */ *  This annotation is meant as a structured comment only, and has no immediate effect. */@Target(FIELD)@Target(FIELD)public @interface DontSynchronize{ String value() default ""; }public@interfaceDontSynchronize{Stringvalue()default"";}








src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}












src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/EdgeFunction.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}













package soot.jimple.interproc.ifds;
































/**










 * An edge function computes how a V-type value changes when flowing from one










 * super-graph node to another. See Sagiv, Reps, Horwitz 1996.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 *  










 * @param <V> The type of values to be computed along flow edges.










 */










public interface EdgeFunction<V> {





















 /**










	 * Computes the value resulting from applying this function to source.










	 */










 V computeTarget(V source);










 










 /**










	 * Composes this function with the secondFunction, effectively returning










	 * a summary function that maps sources to targets exactly as if










	 * first this function had been applied and then the secondFunction. 










	 */










 EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);










 










 /**










	 * Returns a function that represents that (element-wise) join










	 * of this function with otherFunction. Naturally, this is a










	 * symmetric operation.










	 * @see JoinLattice#join(Object, Object)










	 */










 EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);










 










 /**










	 * Returns true is this function represents exactly the same 










	 * source to target mapping as other.










	 */










 public boolean equalTo(EdgeFunction<V> other);





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;/**/** * An edge function computes how a V-type value changes when flowing from one * An edge function computes how a V-type value changes when flowing from one * super-graph node to another. See Sagiv, Reps, Horwitz 1996. * super-graph node to another. See Sagiv, Reps, Horwitz 1996. *  *  * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads. * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads. * Hence, classes implementing this interface should synchronize accesses to * Hence, classes implementing this interface should synchronize accesses to * any mutable shared state. * any mutable shared state. *   *   * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. */ */public interface EdgeFunction<V> {publicinterfaceEdgeFunction<V>{ /**/**	 * Computes the value resulting from applying this function to source.	 * Computes the value resulting from applying this function to source.	 */	 */ V computeTarget(V source);VcomputeTarget(Vsource);  /**/**	 * Composes this function with the secondFunction, effectively returning	 * Composes this function with the secondFunction, effectively returning	 * a summary function that maps sources to targets exactly as if	 * a summary function that maps sources to targets exactly as if	 * first this function had been applied and then the secondFunction. 	 * first this function had been applied and then the secondFunction. 	 */	 */ EdgeFunction<V> composeWith(EdgeFunction<V> secondFunction);EdgeFunction<V>composeWith(EdgeFunction<V>secondFunction);  /**/**	 * Returns a function that represents that (element-wise) join	 * Returns a function that represents that (element-wise) join	 * of this function with otherFunction. Naturally, this is a	 * of this function with otherFunction. Naturally, this is a	 * symmetric operation.	 * symmetric operation.	 * @see JoinLattice#join(Object, Object)	 * @see JoinLattice#join(Object, Object)	 */	 */ EdgeFunction<V> joinWith(EdgeFunction<V> otherFunction);EdgeFunction<V>joinWith(EdgeFunction<V>otherFunction);  /**/**	 * Returns true is this function represents exactly the same 	 * Returns true is this function represents exactly the same 	 * source to target mapping as other.	 * source to target mapping as other.	 */	 */ public boolean equalTo(EdgeFunction<V> other);publicbooleanequalTo(EdgeFunction<V>other);}}








src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}












src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/EdgeFunctionCache.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {










 










 protected final EdgeFunctions<N, D, M, V> delegate;










 










 protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;










 










 protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;





















 protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;





















 protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;










 










 @SuppressWarnings("unchecked")










 public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(CallKey key) throws Exception {










 return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(ReturnKey key) throws Exception {










 return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {










 public EdgeFunction<V> load(NDNDKey key) throws Exception {










 return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());










 }










 });










 }





















 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {










 return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));










 }





















 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {










 return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));










 }





















 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));










 }





















 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {










 return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));










 }
































 private class NDNDKey {










 private final N n1, n2;










 private final D d1, d2;





















 public NDNDKey(N n1, D d1, N n2, D d2) {










 this.n1 = n1;










 this.n2 = n2;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getN1() {










 return n1;










 }





















 public D getD1() {










 return d1;










 }





















 public N getN2() {










 return n2;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((n1 == null) ? 0 : n1.hashCode());










 result = prime * result + ((n2 == null) ? 0 : n2.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NDNDKey other = (NDNDKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (n1 == null) {










 if (other.n1 != null)










 return false;










 } else if (!n1.equals(other.n1))










 return false;










 if (n2 == null) {










 if (other.n2 != null)










 return false;










 } else if (!n2.equals(other.n2))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callSite;










 private final M calleeMethod;










 private final D d1, d2;





















 public CallKey(N callSite, D d1, M calleeMethod, D d2) {










 this.callSite = callSite;










 this.calleeMethod = calleeMethod;










 this.d1 = d1;










 this.d2 = d2;










 }





















 public N getCallSite() {










 return callSite;










 }





















 public D getD1() {










 return d1;










 }





















 public M getCalleeMethod() {










 return calleeMethod;










 }





















 public D getD2() {










 return d2;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((d1 == null) ? 0 : d1.hashCode());










 result = prime * result + ((d2 == null) ? 0 : d2.hashCode());










 result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());










 result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (d1 == null) {










 if (other.d1 != null)










 return false;










 } else if (!d1.equals(other.d1))










 return false;










 if (d2 == null) {










 if (other.d2 != null)










 return false;










 } else if (!d2.equals(other.d2))










 return false;










 if (callSite == null) {










 if (other.callSite != null)










 return false;










 } else if (!callSite.equals(other.callSite))










 return false;










 if (calleeMethod == null) {










 if (other.calleeMethod != null)










 return false;










 } else if (!calleeMethod.equals(other.calleeMethod))










 return false;










 return true;










 }










 }
































 private class ReturnKey extends CallKey {










 










 private final N exitStmt, returnSite;





















 public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {










 super(callSite, exitNode, calleeMethod, retNode);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }










 










 public N getExitStmt() {










 return exitStmt;










 }










 










 public N getReturnSite() {










 return returnSite;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }
































 public void printStats() {










 System.err.println("Stats for edge-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;importcom.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;importcom.google.common.cache.LoadingCache;public class EdgeFunctionCache<N, D, M, V> implements EdgeFunctions<N, D, M, V> {publicclassEdgeFunctionCache<N,D,M,V>implementsEdgeFunctions<N,D,M,V>{  protected final EdgeFunctions<N, D, M, V> delegate;protectedfinalEdgeFunctions<N,D,M,V>delegate;  protected final LoadingCache<NDNDKey, EdgeFunction<V>> normalCache;protectedfinalLoadingCache<NDNDKey,EdgeFunction<V>>normalCache;  protected final LoadingCache<CallKey, EdgeFunction<V>> callCache;protectedfinalLoadingCache<CallKey,EdgeFunction<V>>callCache; protected final LoadingCache<ReturnKey, EdgeFunction<V>> returnCache;protectedfinalLoadingCache<ReturnKey,EdgeFunction<V>>returnCache; protected final LoadingCache<NDNDKey, EdgeFunction<V>> callToReturnCache;protectedfinalLoadingCache<NDNDKey,EdgeFunction<V>>callToReturnCache;  @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public EdgeFunctionCache(final EdgeFunctions<N, D, M, V> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {publicEdgeFunctionCache(finalEdgeFunctions<N,D,M,V>delegate,@SuppressWarnings("rawtypes")CacheBuilderbuilder){ this.delegate = delegate;this.delegate=delegate;  normalCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {normalCache=builder.build(newCacheLoader<NDNDKey,EdgeFunction<V>>(){ public EdgeFunction<V> load(NDNDKey key) throws Exception {publicEdgeFunction<V>load(NDNDKeykey)throwsException{ return delegate.getNormalEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());returndelegate.getNormalEdgeFunction(key.getN1(),key.getD1(),key.getN2(),key.getD2()); }} });});  callCache = builder.build(new CacheLoader<CallKey, EdgeFunction<V>>() {callCache=builder.build(newCacheLoader<CallKey,EdgeFunction<V>>(){ public EdgeFunction<V> load(CallKey key) throws Exception {publicEdgeFunction<V>load(CallKeykey)throwsException{ return delegate.getCallEdgeFunction(key.getCallSite(), key.getD1(), key.getCalleeMethod(), key.getD2());returndelegate.getCallEdgeFunction(key.getCallSite(),key.getD1(),key.getCalleeMethod(),key.getD2()); }} });});  returnCache = builder.build(new CacheLoader<ReturnKey, EdgeFunction<V>>() {returnCache=builder.build(newCacheLoader<ReturnKey,EdgeFunction<V>>(){ public EdgeFunction<V> load(ReturnKey key) throws Exception {publicEdgeFunction<V>load(ReturnKeykey)throwsException{ return delegate.getReturnEdgeFunction(key.getCallSite(), key.getCalleeMethod(), key.getExitStmt(), key.getD1(), key.getReturnSite(), key.getD2());returndelegate.getReturnEdgeFunction(key.getCallSite(),key.getCalleeMethod(),key.getExitStmt(),key.getD1(),key.getReturnSite(),key.getD2()); }} });});  callToReturnCache = builder.build(new CacheLoader<NDNDKey, EdgeFunction<V>>() {callToReturnCache=builder.build(newCacheLoader<NDNDKey,EdgeFunction<V>>(){ public EdgeFunction<V> load(NDNDKey key) throws Exception {publicEdgeFunction<V>load(NDNDKeykey)throwsException{ return delegate.getCallToReturnEdgeFunction(key.getN1(), key.getD1(), key.getN2(), key.getD2());returndelegate.getCallToReturnEdgeFunction(key.getN1(),key.getD1(),key.getN2(),key.getD2()); }} });}); }} public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode) {publicEdgeFunction<V>getNormalEdgeFunction(Ncurr,DcurrNode,Nsucc,DsuccNode){ return normalCache.getUnchecked(new NDNDKey(curr, currNode, succ, succNode));returnnormalCache.getUnchecked(newNDNDKey(curr,currNode,succ,succNode)); }} public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode) {publicEdgeFunction<V>getCallEdgeFunction(NcallStmt,DsrcNode,MdestinationMethod,DdestNode){ return callCache.getUnchecked(new CallKey(callStmt, srcNode, destinationMethod, destNode));returncallCache.getUnchecked(newCallKey(callStmt,srcNode,destinationMethod,destNode)); }} public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {publicEdgeFunction<V>getReturnEdgeFunction(NcallSite,McalleeMethod,NexitStmt,DexitNode,NreturnSite,DretNode){ return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, exitNode, returnSite, retNode));returnreturnCache.getUnchecked(newReturnKey(callSite,calleeMethod,exitStmt,exitNode,returnSite,retNode)); }} public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode) {publicEdgeFunction<V>getCallToReturnEdgeFunction(NcallSite,DcallNode,NreturnSite,DreturnSideNode){ return callToReturnCache.getUnchecked(new NDNDKey(callSite, callNode, returnSite, returnSideNode));returncallToReturnCache.getUnchecked(newNDNDKey(callSite,callNode,returnSite,returnSideNode)); }} private class NDNDKey {privateclassNDNDKey{ private final N n1, n2;privatefinalNn1,n2; private final D d1, d2;privatefinalDd1,d2; public NDNDKey(N n1, D d1, N n2, D d2) {publicNDNDKey(Nn1,Dd1,Nn2,Dd2){ this.n1 = n1;this.n1=n1; this.n2 = n2;this.n2=n2; this.d1 = d1;this.d1=d1; this.d2 = d2;this.d2=d2; }} public N getN1() {publicNgetN1(){ return n1;returnn1; }} public D getD1() {publicDgetD1(){ return d1;returnd1; }} public N getN2() {publicNgetN2(){ return n2;returnn2; }} public D getD2() {publicDgetD2(){ return d2;returnd2; }} public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((d1 == null) ? 0 : d1.hashCode());result=prime*result+((d1==null)?0:d1.hashCode()); result = prime * result + ((d2 == null) ? 0 : d2.hashCode());result=prime*result+((d2==null)?0:d2.hashCode()); result = prime * result + ((n1 == null) ? 0 : n1.hashCode());result=prime*result+((n1==null)?0:n1.hashCode()); result = prime * result + ((n2 == null) ? 0 : n2.hashCode());result=prime*result+((n2==null)?0:n2.hashCode()); return result;returnresult; }} public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") NDNDKey other = (NDNDKey) obj;NDNDKeyother=(NDNDKey)obj; if (d1 == null) {if(d1==null){ if (other.d1 != null)if(other.d1!=null) return false;returnfalse; } else if (!d1.equals(other.d1))}elseif(!d1.equals(other.d1)) return false;returnfalse; if (d2 == null) {if(d2==null){ if (other.d2 != null)if(other.d2!=null) return false;returnfalse; } else if (!d2.equals(other.d2))}elseif(!d2.equals(other.d2)) return false;returnfalse; if (n1 == null) {if(n1==null){ if (other.n1 != null)if(other.n1!=null) return false;returnfalse; } else if (!n1.equals(other.n1))}elseif(!n1.equals(other.n1)) return false;returnfalse; if (n2 == null) {if(n2==null){ if (other.n2 != null)if(other.n2!=null) return false;returnfalse; } else if (!n2.equals(other.n2))}elseif(!n2.equals(other.n2)) return false;returnfalse; return true;returntrue; }} }}  private class CallKey {privateclassCallKey{ private final N callSite;privatefinalNcallSite; private final M calleeMethod;privatefinalMcalleeMethod; private final D d1, d2;privatefinalDd1,d2; public CallKey(N callSite, D d1, M calleeMethod, D d2) {publicCallKey(NcallSite,Dd1,McalleeMethod,Dd2){ this.callSite = callSite;this.callSite=callSite; this.calleeMethod = calleeMethod;this.calleeMethod=calleeMethod; this.d1 = d1;this.d1=d1; this.d2 = d2;this.d2=d2; }} public N getCallSite() {publicNgetCallSite(){ return callSite;returncallSite; }} public D getD1() {publicDgetD1(){ return d1;returnd1; }} public M getCalleeMethod() {publicMgetCalleeMethod(){ return calleeMethod;returncalleeMethod; }} public D getD2() {publicDgetD2(){ return d2;returnd2; }} public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((d1 == null) ? 0 : d1.hashCode());result=prime*result+((d1==null)?0:d1.hashCode()); result = prime * result + ((d2 == null) ? 0 : d2.hashCode());result=prime*result+((d2==null)?0:d2.hashCode()); result = prime * result + ((callSite == null) ? 0 : callSite.hashCode());result=prime*result+((callSite==null)?0:callSite.hashCode()); result = prime * result + ((calleeMethod == null) ? 0 : calleeMethod.hashCode());result=prime*result+((calleeMethod==null)?0:calleeMethod.hashCode()); return result;returnresult; }} public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") CallKey other = (CallKey) obj;CallKeyother=(CallKey)obj; if (d1 == null) {if(d1==null){ if (other.d1 != null)if(other.d1!=null) return false;returnfalse; } else if (!d1.equals(other.d1))}elseif(!d1.equals(other.d1)) return false;returnfalse; if (d2 == null) {if(d2==null){ if (other.d2 != null)if(other.d2!=null) return false;returnfalse; } else if (!d2.equals(other.d2))}elseif(!d2.equals(other.d2)) return false;returnfalse; if (callSite == null) {if(callSite==null){ if (other.callSite != null)if(other.callSite!=null) return false;returnfalse; } else if (!callSite.equals(other.callSite))}elseif(!callSite.equals(other.callSite)) return false;returnfalse; if (calleeMethod == null) {if(calleeMethod==null){ if (other.calleeMethod != null)if(other.calleeMethod!=null) return false;returnfalse; } else if (!calleeMethod.equals(other.calleeMethod))}elseif(!calleeMethod.equals(other.calleeMethod)) return false;returnfalse; return true;returntrue; }} }} private class ReturnKey extends CallKey {privateclassReturnKeyextendsCallKey{  private final N exitStmt, returnSite;privatefinalNexitStmt,returnSite; public ReturnKey(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode) {publicReturnKey(NcallSite,McalleeMethod,NexitStmt,DexitNode,NreturnSite,DretNode){ super(callSite, exitNode, calleeMethod, retNode);super(callSite,exitNode,calleeMethod,retNode); this.exitStmt = exitStmt;this.exitStmt=exitStmt; this.returnSite = returnSite;this.returnSite=returnSite; }}  public N getExitStmt() {publicNgetExitStmt(){ return exitStmt;returnexitStmt; }}  public N getReturnSite() {publicNgetReturnSite(){ return returnSite;returnreturnSite; }} public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = super.hashCode();intresult=super.hashCode(); result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());result=prime*result+((exitStmt==null)?0:exitStmt.hashCode()); result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());result=prime*result+((returnSite==null)?0:returnSite.hashCode()); return result;returnresult; }} public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (!super.equals(obj))if(!super.equals(obj)) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") ReturnKey other = (ReturnKey) obj;ReturnKeyother=(ReturnKey)obj; if (exitStmt == null) {if(exitStmt==null){ if (other.exitStmt != null)if(other.exitStmt!=null) return false;returnfalse; } else if (!exitStmt.equals(other.exitStmt))}elseif(!exitStmt.equals(other.exitStmt)) return false;returnfalse; if (returnSite == null) {if(returnSite==null){ if (other.returnSite != null)if(other.returnSite!=null) return false;returnfalse; } else if (!returnSite.equals(other.returnSite))}elseif(!returnSite.equals(other.returnSite)) return false;returnfalse; return true;returntrue; }} }} public void printStats() {publicvoidprintStats(){ System.err.println("Stats for edge-function cache:");System.err.println("Stats for edge-function cache:"); System.err.print("Normal:         ");System.err.print("Normal:         "); System.err.println(normalCache.stats());System.err.println(normalCache.stats()); System.err.print("Call:           ");System.err.print("Call:           "); System.err.println(callCache.stats());System.err.println(callCache.stats()); System.err.print("Return:         ");System.err.print("Return:         "); System.err.println(returnCache.stats());System.err.println(returnCache.stats()); System.err.print("Call-to-return: ");System.err.print("Call-to-return: "); System.err.println(callToReturnCache.stats());System.err.println(callToReturnCache.stats()); }}}}








src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file












src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/EdgeFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file













package soot.jimple.interproc.ifds;





















/**










 * Classes implementing this interface provide a range of edge functions used to










 * compute a V-type value for each of the finitely many D-type values reachable










 * in the program.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 * @param <V>










 *            The type of values to be computed along flow edges.










 */










public interface EdgeFunctions<N, D, M, V> {





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from srcNode at statement src to tgtNode at statement










	 * tgt.










	 * 










	 * @param curr










	 *            The statement from which the flow originates.










	 * @param currNode










	 *            The D-type value with which the source value is associated.










	 * @param succ










	 *            The target statement of the flow.










	 * @param succNode










	 *            The D-type value with which the target value will be










	 *            associated.










	 */










 public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method call.










	 * 










	 * @param callStmt










	 *            The call statement from which the flow originates.










	 * @param srcNode










	 *            The D-type value with which the source value is associated.










	 * @param destinationMethod










	 *            A concrete destination method of the call.










	 * @param destNode










	 *            The D-type value with which the target value will be










	 *            associated at the side of the callee.










	 */










 public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated along a method exit (return or throw).










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which we are exiting.










	 * @param exitStmt










	 *            The exit statement from which the flow originates.










	 * @param exitNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a caller to the










	 *            method we are exiting from.










	 * @param tgtNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);





















 /**










	 * Returns the function that computes how the V-typed value changes when










	 * being propagated from a method call to one of its intraprocedural










	 * successor.










	 * 










	 * @param callSite










	 *            The call statement from which the flow originates.










	 * @param callNode










	 *            The D-type value with which the source value is associated.










	 * @param returnSite










	 *            One of the possible successor statements of a call statement.










	 * @param returnSideNode










	 *            The D-type value with which the target value will be










	 *            associated at the returnSite.










	 */










 public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);





















}




\ No newline at end of file


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;/**/** * Classes implementing this interface provide a range of edge functions used to * Classes implementing this interface provide a range of edge functions used to * compute a V-type value for each of the finitely many D-type values reachable * compute a V-type value for each of the finitely many D-type values reachable * in the program. * in the program. *  *  * @param <N> * @param <N> *            The type of nodes in the interprocedural control-flow graph. *            The type of nodes in the interprocedural control-flow graph. *            Typically {@link Unit}. *            Typically {@link Unit}. * @param <D> * @param <D> *            The type of data-flow facts to be computed by the tabulation *            The type of data-flow facts to be computed by the tabulation *            problem. *            problem. * @param <M> * @param <M> *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. * @param <V> * @param <V> *            The type of values to be computed along flow edges. *            The type of values to be computed along flow edges. */ */public interface EdgeFunctions<N, D, M, V> {publicinterfaceEdgeFunctions<N,D,M,V>{ /**/**	 * Returns the function that computes how the V-typed value changes when	 * Returns the function that computes how the V-typed value changes when	 * being propagated from srcNode at statement src to tgtNode at statement	 * being propagated from srcNode at statement src to tgtNode at statement	 * tgt.	 * tgt.	 * 	 * 	 * @param curr	 * @param curr	 *            The statement from which the flow originates.	 *            The statement from which the flow originates.	 * @param currNode	 * @param currNode	 *            The D-type value with which the source value is associated.	 *            The D-type value with which the source value is associated.	 * @param succ	 * @param succ	 *            The target statement of the flow.	 *            The target statement of the flow.	 * @param succNode	 * @param succNode	 *            The D-type value with which the target value will be	 *            The D-type value with which the target value will be	 *            associated.	 *            associated.	 */	 */ public EdgeFunction<V> getNormalEdgeFunction(N curr, D currNode, N succ, D succNode);publicEdgeFunction<V>getNormalEdgeFunction(Ncurr,DcurrNode,Nsucc,DsuccNode); /**/**	 * Returns the function that computes how the V-typed value changes when	 * Returns the function that computes how the V-typed value changes when	 * being propagated along a method call.	 * being propagated along a method call.	 * 	 * 	 * @param callStmt	 * @param callStmt	 *            The call statement from which the flow originates.	 *            The call statement from which the flow originates.	 * @param srcNode	 * @param srcNode	 *            The D-type value with which the source value is associated.	 *            The D-type value with which the source value is associated.	 * @param destinationMethod	 * @param destinationMethod	 *            A concrete destination method of the call.	 *            A concrete destination method of the call.	 * @param destNode	 * @param destNode	 *            The D-type value with which the target value will be	 *            The D-type value with which the target value will be	 *            associated at the side of the callee.	 *            associated at the side of the callee.	 */	 */ public EdgeFunction<V> getCallEdgeFunction(N callStmt, D srcNode, M destinationMethod, D destNode);publicEdgeFunction<V>getCallEdgeFunction(NcallStmt,DsrcNode,MdestinationMethod,DdestNode); /**/**	 * Returns the function that computes how the V-typed value changes when	 * Returns the function that computes how the V-typed value changes when	 * being propagated along a method exit (return or throw).	 * being propagated along a method exit (return or throw).	 * 	 * 	 * @param callSite	 * @param callSite	 *            One of all the call sites in the program that called the	 *            One of all the call sites in the program that called the	 *            method from which the exitStmt is actually returning. This	 *            method from which the exitStmt is actually returning. This	 *            information can be exploited to compute a value that depend on	 *            information can be exploited to compute a value that depend on	 *            information from before the call.	 *            information from before the call.	 * @param calleeMethod	 * @param calleeMethod	 *            The method from which we are exiting.	 *            The method from which we are exiting.	 * @param exitStmt	 * @param exitStmt	 *            The exit statement from which the flow originates.	 *            The exit statement from which the flow originates.	 * @param exitNode	 * @param exitNode	 *            The D-type value with which the source value is associated.	 *            The D-type value with which the source value is associated.	 * @param returnSite	 * @param returnSite	 *            One of the possible successor statements of a caller to the	 *            One of the possible successor statements of a caller to the	 *            method we are exiting from.	 *            method we are exiting from.	 * @param tgtNode	 * @param tgtNode	 *            The D-type value with which the target value will be	 *            The D-type value with which the target value will be	 *            associated at the returnSite.	 *            associated at the returnSite.	 */	 */ public EdgeFunction<V> getReturnEdgeFunction(N callSite, M calleeMethod, N exitStmt, D exitNode, N returnSite, D retNode);publicEdgeFunction<V>getReturnEdgeFunction(NcallSite,McalleeMethod,NexitStmt,DexitNode,NreturnSite,DretNode); /**/**	 * Returns the function that computes how the V-typed value changes when	 * Returns the function that computes how the V-typed value changes when	 * being propagated from a method call to one of its intraprocedural	 * being propagated from a method call to one of its intraprocedural	 * successor.	 * successor.	 * 	 * 	 * @param callSite	 * @param callSite	 *            The call statement from which the flow originates.	 *            The call statement from which the flow originates.	 * @param callNode	 * @param callNode	 *            The D-type value with which the source value is associated.	 *            The D-type value with which the source value is associated.	 * @param returnSite	 * @param returnSite	 *            One of the possible successor statements of a call statement.	 *            One of the possible successor statements of a call statement.	 * @param returnSideNode	 * @param returnSideNode	 *            The D-type value with which the target value will be	 *            The D-type value with which the target value will be	 *            associated at the returnSite.	 *            associated at the returnSite.	 */	 */ public EdgeFunction<V> getCallToReturnEdgeFunction(N callSite, D callNode, N returnSite, D returnSideNode);publicEdgeFunction<V>getCallToReturnEdgeFunction(NcallSite,DcallNode,NreturnSite,DreturnSideNode);}}








src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}












src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/FlowFunction.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}













package soot.jimple.interproc.ifds;





















import java.util.LinkedHashSet;










import java.util.Set;





















/**










 * A flow function computes which of the finitely many D-type values are reachable










 * from the current source values. Typically there will be one such function










 * associated with every possible control flow. 










 * 










 * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that










 * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is










 * because the duration of IDE's fixed point iteration may depend on the iteration order.










 * Within the solver, we have tried to fix this order as much as possible, but the










 * order, in general, does also depend on the order in which the result set










 * of {@link #computeTargets(Object)} is traversed.










 * 










 * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads.










 * Hence, classes implementing this interface should synchronize accesses to










 * any mutable shared state.










 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<D> computeTargets(D source);










}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.Set;importjava.util.Set;/**/** * A flow function computes which of the finitely many D-type values are reachable * A flow function computes which of the finitely many D-type values are reachable * from the current source values. Typically there will be one such function * from the current source values. Typically there will be one such function * associated with every possible control flow.  * associated with every possible control flow.  *  *  * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that * <b>NOTE:</b> To be able to produce <b>deterministic benchmarking results</b>, we have found that * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is * it helps to return {@link LinkedHashSet}s from {@link #computeTargets(Object)}. This is * because the duration of IDE's fixed point iteration may depend on the iteration order. * because the duration of IDE's fixed point iteration may depend on the iteration order. * Within the solver, we have tried to fix this order as much as possible, but the * Within the solver, we have tried to fix this order as much as possible, but the * order, in general, does also depend on the order in which the result set * order, in general, does also depend on the order in which the result set * of {@link #computeTargets(Object)} is traversed. * of {@link #computeTargets(Object)} is traversed. *  *  * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads. * <b>NOTE:</b> Methods defined on this type may be called simultaneously by different threads. * Hence, classes implementing this interface should synchronize accesses to * Hence, classes implementing this interface should synchronize accesses to * any mutable shared state. * any mutable shared state. *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public interface FlowFunction<D> {publicinterfaceFlowFunction<D>{ /**/**	 * Returns the target values reachable from the source.	 * Returns the target values reachable from the source.	 */	 */ Set<D> computeTargets(D source);Set<D>computeTargets(Dsource);}}








src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}












src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/FlowFunctionCache.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}













package soot.jimple.interproc.ifds;





















import com.google.common.cache.CacheBuilder;










import com.google.common.cache.CacheLoader;










import com.google.common.cache.LoadingCache;





















public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {










 










 protected final FlowFunctions<N, D, M> delegate;










 










 protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;










 










 protected final LoadingCache<CallKey, FlowFunction<D>> callCache;





















 protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;





















 protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;





















 @SuppressWarnings("unchecked")










 public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {










 this.delegate = delegate;










 










 normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 










 callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {










 public FlowFunction<D> load(CallKey key) throws Exception {










 return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());










 }










 });










 










 returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {










 public FlowFunction<D> load(ReturnKey key) throws Exception {










 return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());










 }










 });










 










 callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {










 public FlowFunction<D> load(NNKey key) throws Exception {










 return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());










 }










 });










 }










 










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return normalCache.getUnchecked(new NNKey(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));










 }










 










 private class NNKey {










 private final N curr, succ; 





















 private NNKey(N curr, N succ) {










 this.curr = curr;










 this.succ = succ;










 }





















 public N getCurr() {










 return curr;










 }





















 public N getSucc() {










 return succ;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((curr == null) ? 0 : curr.hashCode());










 result = prime * result + ((succ == null) ? 0 : succ.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 NNKey other = (NNKey) obj;










 if (curr == null) {










 if (other.curr != null)










 return false;










 } else if (!curr.equals(other.curr))










 return false;










 if (succ == null) {










 if (other.succ != null)










 return false;










 } else if (!succ.equals(other.succ))










 return false;










 return true;










 }










 }










 










 private class CallKey {










 private final N callStmt;










 private final M destinationMethod; 





















 private CallKey(N callStmt, M destinationMethod) {










 this.callStmt = callStmt;










 this.destinationMethod = destinationMethod;










 }





















 public N getCallStmt() {










 return callStmt;










 }





















 public M getDestinationMethod() {










 return destinationMethod;










 }





















 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());










 result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());










 return result;










 }










 










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 CallKey other = (CallKey) obj;










 if (callStmt == null) {










 if (other.callStmt != null)










 return false;










 } else if (!callStmt.equals(other.callStmt))










 return false;










 if (destinationMethod == null) {










 if (other.destinationMethod != null)










 return false;










 } else if (!destinationMethod.equals(other.destinationMethod))










 return false;










 return true;










 }










 }










 










 private class ReturnKey extends CallKey {





















 private final N exitStmt, returnSite;





















 private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {










 super(callStmt, destinationMethod);










 this.exitStmt = exitStmt;










 this.returnSite = returnSite;










 }





















 public N getExitStmt() {










 return exitStmt;










 }





















 public N getReturnSite() {










 return returnSite;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = super.hashCode();










 result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());










 result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (!super.equals(obj))










 return false;










 if (getClass() != obj.getClass())










 return false;










 @SuppressWarnings("unchecked")










 ReturnKey other = (ReturnKey) obj;










 if (exitStmt == null) {










 if (other.exitStmt != null)










 return false;










 } else if (!exitStmt.equals(other.exitStmt))










 return false;










 if (returnSite == null) {










 if (other.returnSite != null)










 return false;










 } else if (!returnSite.equals(other.returnSite))










 return false;










 return true;










 }










 }










 










 public void printStats() {










 System.err.println("Stats for flow-function cache:");










 System.err.print("Normal:         ");










 System.err.println(normalCache.stats());










 System.err.print("Call:           ");










 System.err.println(callCache.stats());










 System.err.print("Return:         ");










 System.err.println(returnCache.stats());










 System.err.print("Call-to-return: ");










 System.err.println(callToReturnCache.stats());










 }










 





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;importcom.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;importcom.google.common.cache.LoadingCache;public class FlowFunctionCache<N, D, M> implements FlowFunctions<N, D, M> {publicclassFlowFunctionCache<N,D,M>implementsFlowFunctions<N,D,M>{  protected final FlowFunctions<N, D, M> delegate;protectedfinalFlowFunctions<N,D,M>delegate;  protected final LoadingCache<NNKey, FlowFunction<D>> normalCache;protectedfinalLoadingCache<NNKey,FlowFunction<D>>normalCache;  protected final LoadingCache<CallKey, FlowFunction<D>> callCache;protectedfinalLoadingCache<CallKey,FlowFunction<D>>callCache; protected final LoadingCache<ReturnKey, FlowFunction<D>> returnCache;protectedfinalLoadingCache<ReturnKey,FlowFunction<D>>returnCache; protected final LoadingCache<NNKey, FlowFunction<D>> callToReturnCache;protectedfinalLoadingCache<NNKey,FlowFunction<D>>callToReturnCache; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") public FlowFunctionCache(final FlowFunctions<N, D, M> delegate, @SuppressWarnings("rawtypes") CacheBuilder builder) {publicFlowFunctionCache(finalFlowFunctions<N,D,M>delegate,@SuppressWarnings("rawtypes")CacheBuilderbuilder){ this.delegate = delegate;this.delegate=delegate;  normalCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {normalCache=builder.build(newCacheLoader<NNKey,FlowFunction<D>>(){ public FlowFunction<D> load(NNKey key) throws Exception {publicFlowFunction<D>load(NNKeykey)throwsException{ return delegate.getNormalFlowFunction(key.getCurr(), key.getSucc());returndelegate.getNormalFlowFunction(key.getCurr(),key.getSucc()); }} });});  callCache = builder.build(new CacheLoader<CallKey, FlowFunction<D>>() {callCache=builder.build(newCacheLoader<CallKey,FlowFunction<D>>(){ public FlowFunction<D> load(CallKey key) throws Exception {publicFlowFunction<D>load(CallKeykey)throwsException{ return delegate.getCallFlowFunction(key.getCallStmt(), key.getDestinationMethod());returndelegate.getCallFlowFunction(key.getCallStmt(),key.getDestinationMethod()); }} });});  returnCache = builder.build(new CacheLoader<ReturnKey, FlowFunction<D>>() {returnCache=builder.build(newCacheLoader<ReturnKey,FlowFunction<D>>(){ public FlowFunction<D> load(ReturnKey key) throws Exception {publicFlowFunction<D>load(ReturnKeykey)throwsException{ return delegate.getReturnFlowFunction(key.getCallStmt(), key.getDestinationMethod(), key.getExitStmt(), key.getReturnSite());returndelegate.getReturnFlowFunction(key.getCallStmt(),key.getDestinationMethod(),key.getExitStmt(),key.getReturnSite()); }} });});  callToReturnCache = builder.build(new CacheLoader<NNKey, FlowFunction<D>>() {callToReturnCache=builder.build(newCacheLoader<NNKey,FlowFunction<D>>(){ public FlowFunction<D> load(NNKey key) throws Exception {publicFlowFunction<D>load(NNKeykey)throwsException{ return delegate.getCallToReturnFlowFunction(key.getCurr(), key.getSucc());returndelegate.getCallToReturnFlowFunction(key.getCurr(),key.getSucc()); }} });}); }}  public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {publicFlowFunction<D>getNormalFlowFunction(Ncurr,Nsucc){ return normalCache.getUnchecked(new NNKey(curr, succ));returnnormalCache.getUnchecked(newNNKey(curr,succ)); }} public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {publicFlowFunction<D>getCallFlowFunction(NcallStmt,MdestinationMethod){ return callCache.getUnchecked(new CallKey(callStmt, destinationMethod));returncallCache.getUnchecked(newCallKey(callStmt,destinationMethod)); }} public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {publicFlowFunction<D>getReturnFlowFunction(NcallSite,McalleeMethod,NexitStmt,NreturnSite){ return returnCache.getUnchecked(new ReturnKey(callSite, calleeMethod, exitStmt, returnSite));returnreturnCache.getUnchecked(newReturnKey(callSite,calleeMethod,exitStmt,returnSite)); }} public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {publicFlowFunction<D>getCallToReturnFlowFunction(NcallSite,NreturnSite){ return callToReturnCache.getUnchecked(new NNKey(callSite, returnSite));returncallToReturnCache.getUnchecked(newNNKey(callSite,returnSite)); }}  private class NNKey {privateclassNNKey{ private final N curr, succ; privatefinalNcurr,succ; private NNKey(N curr, N succ) {privateNNKey(Ncurr,Nsucc){ this.curr = curr;this.curr=curr; this.succ = succ;this.succ=succ; }} public N getCurr() {publicNgetCurr(){ return curr;returncurr; }} public N getSucc() {publicNgetSucc(){ return succ;returnsucc; }} public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((curr == null) ? 0 : curr.hashCode());result=prime*result+((curr==null)?0:curr.hashCode()); result = prime * result + ((succ == null) ? 0 : succ.hashCode());result=prime*result+((succ==null)?0:succ.hashCode()); return result;returnresult; }}  public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") NNKey other = (NNKey) obj;NNKeyother=(NNKey)obj; if (curr == null) {if(curr==null){ if (other.curr != null)if(other.curr!=null) return false;returnfalse; } else if (!curr.equals(other.curr))}elseif(!curr.equals(other.curr)) return false;returnfalse; if (succ == null) {if(succ==null){ if (other.succ != null)if(other.succ!=null) return false;returnfalse; } else if (!succ.equals(other.succ))}elseif(!succ.equals(other.succ)) return false;returnfalse; return true;returntrue; }} }}  private class CallKey {privateclassCallKey{ private final N callStmt;privatefinalNcallStmt; private final M destinationMethod; privatefinalMdestinationMethod; private CallKey(N callStmt, M destinationMethod) {privateCallKey(NcallStmt,MdestinationMethod){ this.callStmt = callStmt;this.callStmt=callStmt; this.destinationMethod = destinationMethod;this.destinationMethod=destinationMethod; }} public N getCallStmt() {publicNgetCallStmt(){ return callStmt;returncallStmt; }} public M getDestinationMethod() {publicMgetDestinationMethod(){ return destinationMethod;returndestinationMethod; }} public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((callStmt == null) ? 0 : callStmt.hashCode());result=prime*result+((callStmt==null)?0:callStmt.hashCode()); result = prime * result + ((destinationMethod == null) ? 0 : destinationMethod.hashCode());result=prime*result+((destinationMethod==null)?0:destinationMethod.hashCode()); return result;returnresult; }}  public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") CallKey other = (CallKey) obj;CallKeyother=(CallKey)obj; if (callStmt == null) {if(callStmt==null){ if (other.callStmt != null)if(other.callStmt!=null) return false;returnfalse; } else if (!callStmt.equals(other.callStmt))}elseif(!callStmt.equals(other.callStmt)) return false;returnfalse; if (destinationMethod == null) {if(destinationMethod==null){ if (other.destinationMethod != null)if(other.destinationMethod!=null) return false;returnfalse; } else if (!destinationMethod.equals(other.destinationMethod))}elseif(!destinationMethod.equals(other.destinationMethod)) return false;returnfalse; return true;returntrue; }} }}  private class ReturnKey extends CallKey {privateclassReturnKeyextendsCallKey{ private final N exitStmt, returnSite;privatefinalNexitStmt,returnSite; private ReturnKey(N callStmt, M destinationMethod, N exitStmt, N returnSite) {privateReturnKey(NcallStmt,MdestinationMethod,NexitStmt,NreturnSite){ super(callStmt, destinationMethod);super(callStmt,destinationMethod); this.exitStmt = exitStmt;this.exitStmt=exitStmt; this.returnSite = returnSite;this.returnSite=returnSite; }} public N getExitStmt() {publicNgetExitStmt(){ return exitStmt;returnexitStmt; }} public N getReturnSite() {publicNgetReturnSite(){ return returnSite;returnreturnSite; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = super.hashCode();intresult=super.hashCode(); result = prime * result + ((exitStmt == null) ? 0 : exitStmt.hashCode());result=prime*result+((exitStmt==null)?0:exitStmt.hashCode()); result = prime * result + ((returnSite == null) ? 0 : returnSite.hashCode());result=prime*result+((returnSite==null)?0:returnSite.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (!super.equals(obj))if(!super.equals(obj)) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; @SuppressWarnings("unchecked")@SuppressWarnings("unchecked") ReturnKey other = (ReturnKey) obj;ReturnKeyother=(ReturnKey)obj; if (exitStmt == null) {if(exitStmt==null){ if (other.exitStmt != null)if(other.exitStmt!=null) return false;returnfalse; } else if (!exitStmt.equals(other.exitStmt))}elseif(!exitStmt.equals(other.exitStmt)) return false;returnfalse; if (returnSite == null) {if(returnSite==null){ if (other.returnSite != null)if(other.returnSite!=null) return false;returnfalse; } else if (!returnSite.equals(other.returnSite))}elseif(!returnSite.equals(other.returnSite)) return false;returnfalse; return true;returntrue; }} }}  public void printStats() {publicvoidprintStats(){ System.err.println("Stats for flow-function cache:");System.err.println("Stats for flow-function cache:"); System.err.print("Normal:         ");System.err.print("Normal:         "); System.err.println(normalCache.stats());System.err.println(normalCache.stats()); System.err.print("Call:           ");System.err.print("Call:           "); System.err.println(callCache.stats());System.err.println(callCache.stats()); System.err.print("Return:         ");System.err.print("Return:         "); System.err.println(returnCache.stats());System.err.println(returnCache.stats()); System.err.print("Call-to-return: ");System.err.print("Call-to-return: "); System.err.println(callToReturnCache.stats());System.err.println(callToReturnCache.stats()); }} }}








src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}












src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/FlowFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}













package soot.jimple.interproc.ifds;





















import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * Classes implementing this interface provide a factory for a 










 * range of flow functions used to compute which D-type values










 * are reachable along the program's control flow.










 * 










 * @param <N>










 *            The type of nodes in the interprocedural control-flow graph.










 *            Typically {@link Unit}.










 * @param <D>










 *            The type of data-flow facts to be computed by the tabulation










 *            problem.










 * @param <M>










 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<N, D, M> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,










	 * i.e., a statement that is neither a call nor an exit statement.










	 * 










	 * @param curr










	 *            The current statement.










	 * @param succ










	 *            The successor for which the flow is computed. This value can










	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<D> getNormalFlowFunction(N curr, N succ);





















 /**










	 * Returns the flow function that computes the flow for a call statement.










	 * 










	 * @param callStmt










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a










	 * method. An exit can be a return or an exceptional exit. The










	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement










	 * without successors in the intraprocedural control-flow graph.










	 * 










	 * @param callSite










	 *            One of all the call sites in the program that called the










	 *            method from which the exitStmt is actually returning. This










	 *            information can be exploited to compute a value that depend on










	 *            information from before the call.










	 * @param calleeMethod










	 *            The method from which exitStmt returns.










	 * @param exitStmt










	 *            The statement exiting the method, typically a return or throw










	 *            statement.










	 * @param returnSite










	 *            One of the successor statements of the callSite. There may be










	 *            multiple successors in case of possible exceptional flow. This










	 *            method will be called for each such successor.










	 * @return










	 */










 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a










	 * successor statement just after the call. There may be multiple successors










	 * in case of exceptional control flow. In this case this method will be










	 * called for every such successor. Typically, one will propagate into a










	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only










	 * such information that actually concerns the callee method. All other










	 * information, e.g. information that cannot be modified by the call, is










	 * passed along this call-return edge.










	 * 










	 * @param callSite










	 *            The statement containing the invoke expression giving rise to










	 *            this call.










	 * @param returnSite










	 *            The return site to which the information is propagated. For










	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;importsoot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;/**/** * Classes implementing this interface provide a factory for a  * Classes implementing this interface provide a factory for a  * range of flow functions used to compute which D-type values * range of flow functions used to compute which D-type values * are reachable along the program's control flow. * are reachable along the program's control flow. *  *  * @param <N> * @param <N> *            The type of nodes in the interprocedural control-flow graph. *            The type of nodes in the interprocedural control-flow graph. *            Typically {@link Unit}. *            Typically {@link Unit}. * @param <D> * @param <D> *            The type of data-flow facts to be computed by the tabulation *            The type of data-flow facts to be computed by the tabulation *            problem. *            problem. * @param <M> * @param <M> *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. */ */public interface FlowFunctions<N, D, M> {publicinterfaceFlowFunctions<N,D,M>{ /**/**	 * Returns the flow function that computes the flow for a normal statement,	 * Returns the flow function that computes the flow for a normal statement,	 * i.e., a statement that is neither a call nor an exit statement.	 * i.e., a statement that is neither a call nor an exit statement.	 * 	 * 	 * @param curr	 * @param curr	 *            The current statement.	 *            The current statement.	 * @param succ	 * @param succ	 *            The successor for which the flow is computed. This value can	 *            The successor for which the flow is computed. This value can	 *            be used to compute a branched analysis that propagates	 *            be used to compute a branched analysis that propagates	 *            different values depending on where control0flow branches.	 *            different values depending on where control0flow branches.	 */	 */ public FlowFunction<D> getNormalFlowFunction(N curr, N succ);publicFlowFunction<D>getNormalFlowFunction(Ncurr,Nsucc); /**/**	 * Returns the flow function that computes the flow for a call statement.	 * Returns the flow function that computes the flow for a call statement.	 * 	 * 	 * @param callStmt	 * @param callStmt	 *            The statement containing the invoke expression giving rise to	 *            The statement containing the invoke expression giving rise to	 *            this call.	 *            this call.	 * @param destinationMethod	 * @param destinationMethod	 *            The concrete target method for which the flow is computed.	 *            The concrete target method for which the flow is computed.	 */	 */ public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod);publicFlowFunction<D>getCallFlowFunction(NcallStmt,MdestinationMethod); /**/**	 * Returns the flow function that computes the flow for a an exit from a	 * Returns the flow function that computes the flow for a an exit from a	 * method. An exit can be a return or an exceptional exit. The	 * method. An exit can be a return or an exceptional exit. The	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement	 * {@link JimpleBasedInterproceduralCFG} defines an exit simply as a statement	 * without successors in the intraprocedural control-flow graph.	 * without successors in the intraprocedural control-flow graph.	 * 	 * 	 * @param callSite	 * @param callSite	 *            One of all the call sites in the program that called the	 *            One of all the call sites in the program that called the	 *            method from which the exitStmt is actually returning. This	 *            method from which the exitStmt is actually returning. This	 *            information can be exploited to compute a value that depend on	 *            information can be exploited to compute a value that depend on	 *            information from before the call.	 *            information from before the call.	 * @param calleeMethod	 * @param calleeMethod	 *            The method from which exitStmt returns.	 *            The method from which exitStmt returns.	 * @param exitStmt	 * @param exitStmt	 *            The statement exiting the method, typically a return or throw	 *            The statement exiting the method, typically a return or throw	 *            statement.	 *            statement.	 * @param returnSite	 * @param returnSite	 *            One of the successor statements of the callSite. There may be	 *            One of the successor statements of the callSite. There may be	 *            multiple successors in case of possible exceptional flow. This	 *            multiple successors in case of possible exceptional flow. This	 *            method will be called for each such successor.	 *            method will be called for each such successor.	 * @return	 * @return	 */	 */ public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite);publicFlowFunction<D>getReturnFlowFunction(NcallSite,McalleeMethod,NexitStmt,NreturnSite); /**/**	 * Returns the flow function that computes the flow from a call site to a	 * Returns the flow function that computes the flow from a call site to a	 * successor statement just after the call. There may be multiple successors	 * successor statement just after the call. There may be multiple successors	 * in case of exceptional control flow. In this case this method will be	 * in case of exceptional control flow. In this case this method will be	 * called for every such successor. Typically, one will propagate into a	 * called for every such successor. Typically, one will propagate into a	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only	 * method call, using {@link #getCallFlowFunction(Object, Object)}, only	 * such information that actually concerns the callee method. All other	 * such information that actually concerns the callee method. All other	 * information, e.g. information that cannot be modified by the call, is	 * information, e.g. information that cannot be modified by the call, is	 * passed along this call-return edge.	 * passed along this call-return edge.	 * 	 * 	 * @param callSite	 * @param callSite	 *            The statement containing the invoke expression giving rise to	 *            The statement containing the invoke expression giving rise to	 *            this call.	 *            this call.	 * @param returnSite	 * @param returnSite	 *            The return site to which the information is propagated. For	 *            The return site to which the information is propagated. For	 *            exceptional flow, this may actually be the start of an	 *            exceptional flow, this may actually be the start of an	 *            exception handler.	 *            exception handler.	 */	 */ public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite);publicFlowFunction<D>getCallToReturnFlowFunction(NcallSite,NreturnSite);}}








src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file












src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/IDETabulationProblem.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file













package soot.jimple.interproc.ifds;





















/**










 * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996 










 * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem}










 * by allowing additional values to be computed along flow functions: each domain value










 * of type D maps at any program point to a value of type V. The functions describe how










 * values are transformed when moving from one statement to another.










 * 










 * The problem further defines a {@link JoinLattice}, which describes how values of










 * type V are joined (merged) when multiple values are possible.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <V> The type of values to be computed along flow edges.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{





















 /**










	 * Returns the edge functions that describe how V-values are transformed along










	 * flow function edges.










	 */










 EdgeFunctions<N,D,M,V> edgeFunctions();










 










 /**










	 * Returns the lattice describing how values of type V need to be joined.










	 */










 JoinLattice<V> joinLattice();





















 /**










	 * Returns a function mapping everything to top.










	 */ 










 EdgeFunction<V> allTopFunction(); 










}




\ No newline at end of file


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;/**/** * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996  * Defines an IDE tabulation problem as presented in the Sagiv, Reps, Horwitz 1996  * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem} * (SRH96) paper. An IDE tabulation problem extends an {@link IFDSTabulationProblem} * by allowing additional values to be computed along flow functions: each domain value * by allowing additional values to be computed along flow functions: each domain value * of type D maps at any program point to a value of type V. The functions describe how * of type D maps at any program point to a value of type V. The functions describe how * values are transformed when moving from one statement to another. * values are transformed when moving from one statement to another. *  *  * The problem further defines a {@link JoinLattice}, which describes how values of * The problem further defines a {@link JoinLattice}, which describes how values of * type V are joined (merged) when multiple values are possible. * type V are joined (merged) when multiple values are possible. * * * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <V> The type of values to be computed along flow edges. * @param <V> The type of values to be computed along flow edges. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IDETabulationProblem<N,D,M,V,I extends InterproceduralCFG<N,M>> extends IFDSTabulationProblem<N,D,M,I>{publicinterfaceIDETabulationProblem<N,D,M,V,IextendsInterproceduralCFG<N,M>>extendsIFDSTabulationProblem<N,D,M,I>{ /**/**	 * Returns the edge functions that describe how V-values are transformed along	 * Returns the edge functions that describe how V-values are transformed along	 * flow function edges.	 * flow function edges.	 */	 */ EdgeFunctions<N,D,M,V> edgeFunctions();EdgeFunctions<N,D,M,V>edgeFunctions();  /**/**	 * Returns the lattice describing how values of type V need to be joined.	 * Returns the lattice describing how values of type V need to be joined.	 */	 */ JoinLattice<V> joinLattice();JoinLattice<V>joinLattice(); /**/**	 * Returns a function mapping everything to top.	 * Returns a function mapping everything to top.	 */ 	 */ EdgeFunction<V> allTopFunction(); EdgeFunction<V>allTopFunction();}}








src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}












src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/IFDSTabulationProblem.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}













package soot.jimple.interproc.ifds;





















import java.util.Set;





















import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















/**










 * A tabulation problem for solving in an {@link IFDSSolver} as described










 * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper.










 *










 * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}.










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts










	 * along the various kinds of control flows.










     *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.










	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.










	 * 










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 I interproceduralCFG();










 










 /**










	 * Returns initial seeds to be used for the analysis. (a set of statements)










	 */










 Set<N> initialSeeds();










 










 /**










	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>










	 * be part of the domain of data-flow facts. Typically this will be a










	 * singleton object of type {@link D} that is used for nothing else.










	 * It must holds that this object does not equals any object 










	 * within the domain.










	 *










	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 D zeroValue();










}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import java.util.Set;importjava.util.Set;import soot.jimple.interproc.ifds.solver.IFDSSolver;importsoot.jimple.interproc.ifds.solver.IFDSSolver;import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;importsoot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;/**/** * A tabulation problem for solving in an {@link IFDSSolver} as described * A tabulation problem for solving in an {@link IFDSSolver} as described * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper. * by the Reps, Horwitz, Sagiv 1995 (RHS95) paper. * * * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <N> The type of nodes in the interprocedural control-flow graph. Typically {@link Unit}. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IFDSTabulationProblem<N,D,M, I extends InterproceduralCFG<N,M>> {publicinterfaceIFDSTabulationProblem<N,D,M,IextendsInterproceduralCFG<N,M>>{ /**/**	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * along the various kinds of control flows.	 * along the various kinds of control flows.     *     *	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * interface should therefore cache the return value! 	 * interface should therefore cache the return value! 	 */	 */ FlowFunctions<N,D,M> flowFunctions();FlowFunctions<N,D,M>flowFunctions();  /**/**	 * Returns the interprocedural control-flow graph which this problem is computed over.	 * Returns the interprocedural control-flow graph which this problem is computed over.	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.	 * Typically this will be a {@link JimpleBasedInterproceduralCFG}.	 * 	 * 	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * interface should therefore cache the return value! 	 * interface should therefore cache the return value! 	 */	 */ I interproceduralCFG();IinterproceduralCFG();  /**/**	 * Returns initial seeds to be used for the analysis. (a set of statements)	 * Returns initial seeds to be used for the analysis. (a set of statements)	 */	 */ Set<N> initialSeeds();Set<N>initialSeeds();  /**/**	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>	 * This must be a data-flow fact of type {@link D}, but must <i>not</i>	 * be part of the domain of data-flow facts. Typically this will be a	 * be part of the domain of data-flow facts. Typically this will be a	 * singleton object of type {@link D} that is used for nothing else.	 * singleton object of type {@link D} that is used for nothing else.	 * It must holds that this object does not equals any object 	 * It must holds that this object does not equals any object 	 * within the domain.	 * within the domain.	 *	 *	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * interface should therefore cache the return value! 	 * interface should therefore cache the return value! 	 */	 */ D zeroValue();DzeroValue();}}








src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}












src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/InterproceduralCFG.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}













package soot.jimple.interproc.ifds;





















import java.util.List;










import java.util.Set;





















/**










 * An interprocedural control-flow graph.










 * 










 * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block}










 * @param <M> Method representation










 */










public interface InterproceduralCFG<N,M> {










 










 /**










	 * Returns the method containing a node.










	 * @param n The node for which to get the parent method










	 */










 public M getMethodOf(N n);





















 /**










	 * Returns the successor nodes.










	 */










 public List<N> getSuccsOf(N n);





















 /**










	 * Returns all callee methods for a given call.










	 */










 public Set<M> getCalleesOfCallAt(N n);





















 /**










	 * Returns all caller statements/nodes of a given method.










	 */










 public Set<N> getCallersOf(M m);





















 /**










	 * Returns all call sites within a given method.










	 */










 public Set<N> getCallsFromWithin(M m);





















 /**










	 * Returns all start points of a given method. There may be










	 * more than one start point in case of a backward analysis.










	 */










 public Set<N> getStartPointsOf(M m);





















 /**










	 * Returns all statements to which a call could return.










	 * In the RHS paper, for every call there is just one return site.










	 * We, however, use as return site the successor statements, of which










	 * there can be many in case of exceptional flow.










	 */










 public List<N> getReturnSitesOfCallAt(N n);





















 /**










	 * Returns <code>true</code> if the given statement is a call site.










	 */










 public boolean isCallStmt(N stmt);





















 /**










	 * Returns <code>true</code> if the given statement leads to a method return










	 * (exceptional or not). For backward analyses may also be start statements.










	 */










 public boolean isExitStmt(N stmt);










 










 /**










	 * Returns true is this is a method's start statement. For backward analyses










	 * those may also be return or throws statements.










	 */










 public boolean isStartPoint(N stmt);










 










 /**










	 * Returns the set of all nodes that are neither call nor start nodes.










	 */










 public Set<N> allNonCallStartNodes();










 










 /**










	 * Returns whether succ is the fall-through successor of stmt,










	 * i.e., the unique successor that is be reached when stmt










	 * does not branch.










	 */










 public boolean isFallThroughSuccessor(N stmt, N succ);










 










 /**










	 * Returns whether succ is a branch target of stmt. 










	 */










 public boolean isBranchTarget(N stmt, N succ);





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import java.util.List;importjava.util.List;import java.util.Set;importjava.util.Set;/**/** * An interprocedural control-flow graph. * An interprocedural control-flow graph. *  *  * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block} * @param <N> Nodes in the CFG, typically {@link Unit} or {@link Block} * @param <M> Method representation * @param <M> Method representation */ */public interface InterproceduralCFG<N,M> {publicinterfaceInterproceduralCFG<N,M>{  /**/**	 * Returns the method containing a node.	 * Returns the method containing a node.	 * @param n The node for which to get the parent method	 * @param n The node for which to get the parent method	 */	 */ public M getMethodOf(N n);publicMgetMethodOf(Nn); /**/**	 * Returns the successor nodes.	 * Returns the successor nodes.	 */	 */ public List<N> getSuccsOf(N n);publicList<N>getSuccsOf(Nn); /**/**	 * Returns all callee methods for a given call.	 * Returns all callee methods for a given call.	 */	 */ public Set<M> getCalleesOfCallAt(N n);publicSet<M>getCalleesOfCallAt(Nn); /**/**	 * Returns all caller statements/nodes of a given method.	 * Returns all caller statements/nodes of a given method.	 */	 */ public Set<N> getCallersOf(M m);publicSet<N>getCallersOf(Mm); /**/**	 * Returns all call sites within a given method.	 * Returns all call sites within a given method.	 */	 */ public Set<N> getCallsFromWithin(M m);publicSet<N>getCallsFromWithin(Mm); /**/**	 * Returns all start points of a given method. There may be	 * Returns all start points of a given method. There may be	 * more than one start point in case of a backward analysis.	 * more than one start point in case of a backward analysis.	 */	 */ public Set<N> getStartPointsOf(M m);publicSet<N>getStartPointsOf(Mm); /**/**	 * Returns all statements to which a call could return.	 * Returns all statements to which a call could return.	 * In the RHS paper, for every call there is just one return site.	 * In the RHS paper, for every call there is just one return site.	 * We, however, use as return site the successor statements, of which	 * We, however, use as return site the successor statements, of which	 * there can be many in case of exceptional flow.	 * there can be many in case of exceptional flow.	 */	 */ public List<N> getReturnSitesOfCallAt(N n);publicList<N>getReturnSitesOfCallAt(Nn); /**/**	 * Returns <code>true</code> if the given statement is a call site.	 * Returns <code>true</code> if the given statement is a call site.	 */	 */ public boolean isCallStmt(N stmt);publicbooleanisCallStmt(Nstmt); /**/**	 * Returns <code>true</code> if the given statement leads to a method return	 * Returns <code>true</code> if the given statement leads to a method return	 * (exceptional or not). For backward analyses may also be start statements.	 * (exceptional or not). For backward analyses may also be start statements.	 */	 */ public boolean isExitStmt(N stmt);publicbooleanisExitStmt(Nstmt);  /**/**	 * Returns true is this is a method's start statement. For backward analyses	 * Returns true is this is a method's start statement. For backward analyses	 * those may also be return or throws statements.	 * those may also be return or throws statements.	 */	 */ public boolean isStartPoint(N stmt);publicbooleanisStartPoint(Nstmt);  /**/**	 * Returns the set of all nodes that are neither call nor start nodes.	 * Returns the set of all nodes that are neither call nor start nodes.	 */	 */ public Set<N> allNonCallStartNodes();publicSet<N>allNonCallStartNodes();  /**/**	 * Returns whether succ is the fall-through successor of stmt,	 * Returns whether succ is the fall-through successor of stmt,	 * i.e., the unique successor that is be reached when stmt	 * i.e., the unique successor that is be reached when stmt	 * does not branch.	 * does not branch.	 */	 */ public boolean isFallThroughSuccessor(N stmt, N succ);publicbooleanisFallThroughSuccessor(Nstmt,Nsucc);  /**/**	 * Returns whether succ is a branch target of stmt. 	 * Returns whether succ is a branch target of stmt. 	 */	 */ public boolean isBranchTarget(N stmt, N succ);publicbooleanisBranchTarget(Nstmt,Nsucc);}}








src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}












src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/JoinLattice.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}













package soot.jimple.interproc.ifds;





















/**










 * This class defines a lattice in terms of its top and bottom elements










 * and a join operation. 










 *










 * @param <V> The domain type for this lattice.










 */










public interface JoinLattice<V> {










 










 V topElement();










 










 V bottomElement();










 










 V join(V left, V right);





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;/**/** * This class defines a lattice in terms of its top and bottom elements * This class defines a lattice in terms of its top and bottom elements * and a join operation.  * and a join operation.  * * * @param <V> The domain type for this lattice. * @param <V> The domain type for this lattice. */ */public interface JoinLattice<V> {publicinterfaceJoinLattice<V>{  V topElement();VtopElement();  V bottomElement();VbottomElement();  V join(V left, V right);Vjoin(Vleft,Vright);}}








src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}












src/soot/jimple/interproc/ifds/Main.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/Main.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}













package soot.jimple.interproc.ifds;





















import java.util.Map;





















import soot.Local;










import soot.PackManager;










import soot.Scene;










import soot.SceneTransformer;










import soot.SootMethod;










import soot.Transform;










import soot.Unit;










import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;










import soot.jimple.interproc.ifds.solver.IFDSSolver;










import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;





















public class Main {





















 /**










	 * @param args










	 */










 public static void main(String[] args) {










 










 










 PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {










 protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {





















 IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());










 










 IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); 










 solver.solve();










 Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();










 for(Local l: solver.ifdsResultsAt(ret)) {










 System.err.println(l);










 }










 }










 }));










 










 soot.Main.main(args);










 }





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import java.util.Map;importjava.util.Map;import soot.Local;importsoot.Local;import soot.PackManager;importsoot.PackManager;import soot.Scene;importsoot.Scene;import soot.SceneTransformer;importsoot.SceneTransformer;import soot.SootMethod;importsoot.SootMethod;import soot.Transform;importsoot.Transform;import soot.Unit;importsoot.Unit;import soot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;importsoot.jimple.interproc.ifds.problems.IFDSLocalInfoFlow;import soot.jimple.interproc.ifds.solver.IFDSSolver;importsoot.jimple.interproc.ifds.solver.IFDSSolver;import soot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;importsoot.jimple.interproc.ifds.template.JimpleBasedInterproceduralCFG;public class Main {publicclassMain{ /**/**	 * @param args	 * @param args	 */	 */ public static void main(String[] args) {publicstaticvoidmain(String[]args){   PackManager.v().getPack("wjtp").add(new Transform("wjtp.ifds", new SceneTransformer() {PackManager.v().getPack("wjtp").add(newTransform("wjtp.ifds",newSceneTransformer(){ protected void internalTransform(String phaseName, @SuppressWarnings("rawtypes") Map options) {protectedvoidinternalTransform(StringphaseName,@SuppressWarnings("rawtypes")Mapoptions){ IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> problem = new IFDSLocalInfoFlow(new JimpleBasedInterproceduralCFG());IFDSTabulationProblem<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>problem=newIFDSLocalInfoFlow(newJimpleBasedInterproceduralCFG());  IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>> solver = new IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); IFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>solver=newIFDSSolver<Unit,Local,SootMethod,InterproceduralCFG<Unit,SootMethod>>(problem); solver.solve();solver.solve(); Unit ret = Scene.v().getMainMethod().getActiveBody().getUnits().getLast();Unitret=Scene.v().getMainMethod().getActiveBody().getUnits().getLast(); for(Local l: solver.ifdsResultsAt(ret)) {for(Locall:solver.ifdsResultsAt(ret)){ System.err.println(l);System.err.println(l); }} }} }));}));  soot.Main.main(args);soot.Main.main(args); }}}}








src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file












src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/MustSynchronize.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation stating that the annotated field must be synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface MustSynchronize{ String value() default ""; }




\ No newline at end of file


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import static java.lang.annotation.ElementType.FIELD;importstaticjava.lang.annotation.ElementType.FIELD;import java.lang.annotation.Target;importjava.lang.annotation.Target;/**	Semantic annotation stating that the annotated field must be synchronized./**	Semantic annotation stating that the annotated field must be synchronized. *  This annotation is meant as a structured comment only, and has no immediate effect. */ *  This annotation is meant as a structured comment only, and has no immediate effect. */@Target(FIELD)@Target(FIELD)public @interface MustSynchronize{ String value() default ""; }public@interfaceMustSynchronize{Stringvalue()default"";}








src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}












src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/ProfiledFlowFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}













package soot.jimple.interproc.ifds;





















/**










 * A wrapper that can be used to profile flow functions.










 */










public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 










 public long durationNormal, durationCall, durationReturn, durationCallReturn;





















 public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {










 this.delegate = delegate;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 long before = System.currentTimeMillis();










 FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);










 long duration = System.currentTimeMillis() - before;










 durationNormal += duration;










 return ret;










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);










 long duration = System.currentTimeMillis() - before;










 durationCall += duration;










 return res;










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationReturn += duration;










 return res;










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 long before = System.currentTimeMillis();










 FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);










 long duration = System.currentTimeMillis() - before;










 durationCallReturn += duration;










 return res;










 }










 










}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;/**/** * A wrapper that can be used to profile flow functions. * A wrapper that can be used to profile flow functions. */ */public class ProfiledFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {publicclassProfiledFlowFunctions<N,D,M>implementsFlowFunctions<N,D,M>{ protected final FlowFunctions<N, D, M> delegate;protectedfinalFlowFunctions<N,D,M>delegate;  public long durationNormal, durationCall, durationReturn, durationCallReturn;publiclongdurationNormal,durationCall,durationReturn,durationCallReturn; public ProfiledFlowFunctions(FlowFunctions<N, D, M> delegate) {publicProfiledFlowFunctions(FlowFunctions<N,D,M>delegate){ this.delegate = delegate;this.delegate=delegate; }} public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {publicFlowFunction<D>getNormalFlowFunction(Ncurr,Nsucc){ long before = System.currentTimeMillis();longbefore=System.currentTimeMillis(); FlowFunction<D> ret = delegate.getNormalFlowFunction(curr, succ);FlowFunction<D>ret=delegate.getNormalFlowFunction(curr,succ); long duration = System.currentTimeMillis() - before;longduration=System.currentTimeMillis()-before; durationNormal += duration;durationNormal+=duration; return ret;returnret; }} public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {publicFlowFunction<D>getCallFlowFunction(NcallStmt,MdestinationMethod){ long before = System.currentTimeMillis();longbefore=System.currentTimeMillis(); FlowFunction<D> res = delegate.getCallFlowFunction(callStmt, destinationMethod);FlowFunction<D>res=delegate.getCallFlowFunction(callStmt,destinationMethod); long duration = System.currentTimeMillis() - before;longduration=System.currentTimeMillis()-before; durationCall += duration;durationCall+=duration; return res;returnres; }} public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {publicFlowFunction<D>getReturnFlowFunction(NcallSite,McalleeMethod,NexitStmt,NreturnSite){ long before = System.currentTimeMillis();longbefore=System.currentTimeMillis(); FlowFunction<D> res = delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite);FlowFunction<D>res=delegate.getReturnFlowFunction(callSite,calleeMethod,exitStmt,returnSite); long duration = System.currentTimeMillis() - before;longduration=System.currentTimeMillis()-before; durationReturn += duration;durationReturn+=duration; return res;returnres; }} public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {publicFlowFunction<D>getCallToReturnFlowFunction(NcallSite,NreturnSite){ long before = System.currentTimeMillis();longbefore=System.currentTimeMillis(); FlowFunction<D> res = delegate.getCallToReturnFlowFunction(callSite, returnSite);FlowFunction<D>res=delegate.getCallToReturnFlowFunction(callSite,returnSite); long duration = System.currentTimeMillis() - before;longduration=System.currentTimeMillis()-before; durationCallReturn += duration;durationCallReturn+=duration; return res;returnres; }} }}








src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file












src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/SynchronizedBy.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file













package soot.jimple.interproc.ifds;





















import static java.lang.annotation.ElementType.FIELD;





















import java.lang.annotation.Target;





















/**	Semantic annotation that the annotated field is synchronized.










 *  This annotation is meant as a structured comment only, and has no immediate effect. */










@Target(FIELD)










public @interface SynchronizedBy{ String value() default ""; }




\ No newline at end of file


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import static java.lang.annotation.ElementType.FIELD;importstaticjava.lang.annotation.ElementType.FIELD;import java.lang.annotation.Target;importjava.lang.annotation.Target;/**	Semantic annotation that the annotated field is synchronized./**	Semantic annotation that the annotated field is synchronized. *  This annotation is meant as a structured comment only, and has no immediate effect. */ *  This annotation is meant as a structured comment only, and has no immediate effect. */@Target(FIELD)@Target(FIELD)public @interface SynchronizedBy{ String value() default ""; }public@interfaceSynchronizedBy{Stringvalue()default"";}








src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}












src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/ThreadSafe.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}













package soot.jimple.interproc.ifds;





















/**










 * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates. 










 */










public @interface ThreadSafe {










 










 String value() default "";





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;/**/** * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates.  * This annotation tells that the class was designed to be used by multiple threads, with concurrent updates.  */ */public @interface ThreadSafe {public@interfaceThreadSafe{  String value() default "";Stringvalue()default"";}}








src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}












src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644







View file @ d83b5de1








src/soot/jimple/interproc/ifds/ZeroedFlowFunctions.java



0 → 100644









View file @ d83b5de1


d83b5de1










package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}













package soot.jimple.interproc.ifds;





















import java.util.HashSet;










import java.util.LinkedHashSet;










import java.util.Set;





















public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {





















 protected final FlowFunctions<N, D, M> delegate;










 protected final D zeroValue;





















 public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {










 this.delegate = delegate;










 this.zeroValue = zeroValue;










 }





















 public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {










 return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));










 }





















 public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {










 return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));










 }





















 public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {










 return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));










 }





















 public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {










 return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));










 }










 










 protected class ZeroedFlowFunction implements FlowFunction<D> {





















 protected FlowFunction<D> del;





















 private ZeroedFlowFunction(FlowFunction<D> del) {










 this.del = del;










 } 










 










 @Override










 public Set<D> computeTargets(D source) {










 if(source==zeroValue) {










 HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));










 res.add(zeroValue);










 return res;










 } else {










 return del.computeTargets(source);










 }










 }










 










 }










 





















}


package soot.jimple.interproc.ifds;packagesoot.jimple.interproc.ifds;import java.util.HashSet;importjava.util.HashSet;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.Set;importjava.util.Set;public class ZeroedFlowFunctions<N, D, M> implements FlowFunctions<N, D, M> {publicclassZeroedFlowFunctions<N,D,M>implementsFlowFunctions<N,D,M>{ protected final FlowFunctions<N, D, M> delegate;protectedfinalFlowFunctions<N,D,M>delegate; protected final D zeroValue;protectedfinalDzeroValue; public ZeroedFlowFunctions(FlowFunctions<N, D, M> delegate, D zeroValue) {publicZeroedFlowFunctions(FlowFunctions<N,D,M>delegate,DzeroValue){ this.delegate = delegate;this.delegate=delegate; this.zeroValue = zeroValue;this.zeroValue=zeroValue; }} public FlowFunction<D> getNormalFlowFunction(N curr, N succ) {publicFlowFunction<D>getNormalFlowFunction(Ncurr,Nsucc){ return new ZeroedFlowFunction(delegate.getNormalFlowFunction(curr, succ));returnnewZeroedFlowFunction(delegate.getNormalFlowFunction(curr,succ)); }} public FlowFunction<D> getCallFlowFunction(N callStmt, M destinationMethod) {publicFlowFunction<D>getCallFlowFunction(NcallStmt,MdestinationMethod){ return new ZeroedFlowFunction(delegate.getCallFlowFunction(callStmt, destinationMethod));returnnewZeroedFlowFunction(delegate.getCallFlowFunction(callStmt,destinationMethod)); }} public FlowFunction<D> getReturnFlowFunction(N callSite, M calleeMethod, N exitStmt, N returnSite) {publicFlowFunction<D>getReturnFlowFunction(NcallSite,McalleeMethod,NexitStmt,NreturnSite){ return new ZeroedFlowFunction(delegate.getReturnFlowFunction(callSite, calleeMethod, exitStmt, returnSite));returnnewZeroedFlowFunction(delegate.getReturnFlowFunction(callSite,calleeMethod,exitStmt,returnSite)); }} public FlowFunction<D> getCallToReturnFlowFunction(N callSite, N returnSite) {publicFlowFunction<D>getCallToReturnFlowFunction(NcallSite,NreturnSite){ return new ZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite, returnSite));returnnewZeroedFlowFunction(delegate.getCallToReturnFlowFunction(callSite,returnSite)); }}  protected class ZeroedFlowFunction implements FlowFunction<D> {protectedclassZeroedFlowFunctionimplementsFlowFunction<D>{ protected FlowFunction<D> del;protectedFlowFunction<D>del; private ZeroedFlowFunction(FlowFunction<D> del) {privateZeroedFlowFunction(FlowFunction<D>del){ this.del = del;this.del=del; } }  @Override@Override public Set<D> computeTargets(D source) {publicSet<D>computeTargets(Dsource){ if(source==zeroValue) {if(source==zeroValue){ HashSet<D> res = new LinkedHashSet<D>(del.computeTargets(source));HashSet<D>res=newLinkedHashSet<D>(del.computeTargets(source)); res.add(zeroValue);res.add(zeroValue); return res;returnres; } else {}else{ return del.computeTargets(source);returndel.computeTargets(source); }} }}  }} }}



Prev


1


2


3


Next





Prev

1

2

3

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






