



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

7527a0d4















Commit
7527a0d4


authored
Dec 10, 2014
by


Johannes Lerch



Browse files




Bug/test fixes







parent
8d40408f













Changes
5




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}














src/heros/alias/FieldReference.java








View file @ 7527a0d4






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......














test/heros/alias/Fact.java








View file @ 7527a0d4






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

7527a0d4















Commit
7527a0d4


authored
Dec 10, 2014
by


Johannes Lerch



Browse files




Bug/test fixes







parent
8d40408f













Changes
5




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}














src/heros/alias/FieldReference.java








View file @ 7527a0d4






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......














test/heros/alias/Fact.java








View file @ 7527a0d4






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

7527a0d4







Open sidebar



Joshua Garcia heros
Commits

7527a0d4




Open sidebar

Joshua Garcia heros
Commits

7527a0d4


Joshua GarciaherosherosCommits
7527a0d4








Commit
7527a0d4


authored
Dec 10, 2014
by


Johannes Lerch



Browse files




Bug/test fixes







parent
8d40408f













Changes
5




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}














src/heros/alias/FieldReference.java








View file @ 7527a0d4






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......














test/heros/alias/Fact.java








View file @ 7527a0d4






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
7527a0d4


authored
Dec 10, 2014
by


Johannes Lerch



Browse files




Bug/test fixes







parent
8d40408f













Changes
5




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}














src/heros/alias/FieldReference.java








View file @ 7527a0d4






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......














test/heros/alias/Fact.java








View file @ 7527a0d4






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
7527a0d4


authored
Dec 10, 2014
by


Johannes Lerch



Browse files



Commit
7527a0d4


authored
Dec 10, 2014
by


Johannes Lerch

7527a0d4authoredbyJohannes Lerch

Bug/test fixes






parent
8d40408f
















parent
8d40408f





parent












Changes
5
5


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}














src/heros/alias/FieldReference.java








View file @ 7527a0d4






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......














test/heros/alias/Fact.java








View file @ 7527a0d4






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......














src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}












src/heros/alias/AccessPathUtil.java








View file @ 7527a0d4








src/heros/alias/AccessPathUtil.java










View file @ 7527a0d4


7527a0d4



......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}






......@@ -75,4 +75,10 @@ public class AccessPathUtil {









 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










}


  return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);returnincomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath); }}  public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {publicstaticFieldReference[]getAccessPathDelta(FieldReference[]prefixAccessPath,FieldReference[]accessPath){ FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];FieldReference[]result=newFieldReference[accessPath.length-prefixAccessPath.length]; System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);System.arraycopy(accessPath,prefixAccessPath.length,result,0,result.length); return result;returnresult; }}}}








src/heros/alias/FieldReference.java








View file @ 7527a0d4






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......












src/heros/alias/FieldReference.java








View file @ 7527a0d4








src/heros/alias/FieldReference.java










View file @ 7527a0d4


7527a0d4



......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......






......@@ -13,6 +13,7 @@ package heros.alias;









import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















public interface FieldReference {



......@@ -20,9 +21,20 @@ public interface FieldReference {









 public static class Any implements FieldReference {










 Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 @Override










 public String toString() {










 return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override



......


import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public interface FieldReference {publicinterfaceFieldReference{ public static class Any implements FieldReference {publicstaticclassAnyimplementsFieldReference{ Set<String> excludedFieldNames = Sets.newHashSet();Set<String>excludedFieldNames=Sets.newHashSet();  public Any(String...excludedFieldNames) {publicAny(String...excludedFieldNames){ for (int i = 0; i < excludedFieldNames.length; i++) {for(inti=0;i<excludedFieldNames.length;i++){ this.excludedFieldNames.add(excludedFieldNames[i]);this.excludedFieldNames.add(excludedFieldNames[i]); }} }}  @Override@Override public String toString() {publicStringtoString(){ return "*" +(excludedFieldNames.isEmpty() ?"" : "\\{" + excludedFieldNames.toString() +"}");return"*"+(excludedFieldNames.isEmpty()?"":"\\{"+excludedFieldNames.toString()+"}"); if(excludedFieldNames.size() == 0)if(excludedFieldNames.size()==0) return "";return""; else if (excludedFieldNames.size() == 1)elseif(excludedFieldNames.size()==1) return "^" + excludedFieldNames.iterator().next();return"^"+excludedFieldNames.iterator().next(); elseelse return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";return"^{"+Joiner.on(",").join(excludedFieldNames)+"}"; }} @Override@Override








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 7527a0d4








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ 7527a0d4


7527a0d4



......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......






......@@ -240,6 +240,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 continue;










 










 resumeEdges(sCalledProcN, d3.getFact());










 registerInterestedCaller(sCalledProcN, incomingEdge);










 










 










 //line 15.2










 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());



......@@ -263,20 +265,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 } else {










 // incoming fact is prefix of summary: create new edge on caller side with complemented access path 










 D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());










 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);










 }










 }










 }










 } 










 }










 }










 }



......@@ -294,7 +283,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {










 if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {










 if(edges.remove(edge)) {










 logger.trace("RESUME-EDGE: {}", edge);










 propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);



......@@ -303,6 +292,28 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 }










 










 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 }










 }










 }










 }





















 /**










	 * Computes the call flow function for the given call-site abstraction



......@@ -374,16 +385,6 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }










 }










 else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);





















 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());










 propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);










 }










 } 










 }










 }










 



......@@ -475,11 +476,12 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 }





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {










 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 



......@@ -510,7 +512,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 return false;










 }










 










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {










 private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);










 return !incomingEdges.isEmpty();



......@@ -562,9 +564,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 /* deliberately exposed to clients */ boolean isUnbalancedReturn) {










 final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);










 final D existingVal = jumpFn.addFunction(edge);










 //TODO: Merge d.* and d.x for arbitrary x as d.*










 //TODO: Merge d.* and d.*\{x} as d.*










 //TODO: Merge d.*\{a} and d.*/{b} as d.*










 if (existingVal != null) {










 if (existingVal != targetVal)










 existingVal.addNeighbor(targetVal);



......


 continue;continue;  resumeEdges(sCalledProcN, d3.getFact());resumeEdges(sCalledProcN,d3.getFact()); registerInterestedCaller(sCalledProcN, incomingEdge);registerInterestedCaller(sCalledProcN,incomingEdge);   //line 15.2//line 15.2 Set<SummaryEdge<D, N>> endSumm = endSummary(sCalledProcN, d3.getFact());Set<SummaryEdge<D,N>>endSumm=endSummary(sCalledProcN,d3.getFact()); propagate(d1, retSiteN, d5p_restoredCtx, n, false);propagate(d1,retSiteN,d5p_restoredCtx,n,false); }} }} } else {}else{ // incoming fact is prefix of summary: create new edge on caller side with complemented access path // incoming fact is prefix of summary: create new edge on caller side with complemented access path  D d1_concretized = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, d3.getFact());Dd1_concretized=AccessPathUtil.concretizeCallerSourceFact(incomingEdge,d3.getFact()); //for each return site//for each return site for(N retSiteN: returnSiteNs) {for(NretSiteN:returnSiteNs){ //compute return-flow function//compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN); //for each target value of the function//for each target value of the function for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, summary.getTargetFact(), n)) {for(AnnotatedFact<D>d5:computeReturnFlowFunction(retFunction,summary.getTargetFact(),n)){ D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());Dd5p_restoredCtx=restoreContextOnReturnedFact(d2,d5.getFact()); propagate(d1_concretized, retSiteN, d5p_restoredCtx, n, false);propagate(d1_concretized,retSiteN,d5p_restoredCtx,n,false); }} }} }} } } }} }} }} Set<PathEdge<N, D>> edges = pausedEdges.get(method);Set<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){ if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint) || AccessPathUtil.isPrefixOf(factAtMethodStartPoint, edge.factAtSource())) {if(AccessPathUtil.isPrefixOf(edge.factAtSource(),factAtMethodStartPoint) |||| AccessPathUtilAccessPathUtil..isPrefixOfisPrefixOf((factAtMethodStartPointfactAtMethodStartPoint,, edgeedge..factAtSourcefactAtSource()))()){ if(AccessPathUtil.isPrefixOf(edge.factAtSource(), factAtMethodStartPoint)) {if(AccessPathUtil.isPrefixOf(edge.factAtSource(),factAtMethodStartPoint)){ if(edges.remove(edge)) {if(edges.remove(edge)){ logger.trace("RESUME-EDGE: {}", edge);logger.trace("RESUME-EDGE: {}",edge); propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);propagate(edge.factAtSource(),edge.getTarget(),edge.factAtTarget(),null,false); }} }} }}  private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {privatevoidregisterInterestedCaller(Mmethod,IncomingEdge<D,N>incomingEdge){ Set<PathEdge<N, D>> edges = pausedEdges.get(method);Set<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){ if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(),edge.factAtSource())){ logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}",edge,incomingEdge);  FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(FieldReference[]accessPathDelta=AccessPathUtil.getAccessPathDelta( incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());incomingEdge.getCalleeSourceFact().getAccessPath(),edge.factAtSource().getAccessPath());  if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(),incomingEdge.getCallSite(),accessPathDelta)){ propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), propagate(zeroValue.equals(incomingEdge.getCallerSourceFact())?zeroValue:AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),accessPathDelta), incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);incomingEdge.getCallSite(),AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),accessPathDelta),null,false); } else {}else{ pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),accessPathDelta), incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));incomingEdge.getCallSite(),AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),accessPathDelta)); }} }} }} }} }} /**/**	 * Computes the call flow function for the given call-site abstraction	 * Computes the call flow function for the given call-site abstraction propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);propagate(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact,callSite,false); }} }} else if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), d1)) {elseif(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(),d1)){ Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, d2, callSite);Set<AnnotatedFact<D>>callerTargetFacts=computeReturnFlowFunction(retFunction,d2,callSite); // for each incoming-call value// for each incoming-call value for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {for(AnnotatedFact<D>callerTargetAnnotatedFact:callerTargetFacts){ D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact()); D callerSourceFact = AccessPathUtil.concretizeCallerSourceFact(incomingEdge, summaryEdge.getSourceFact());DcallerSourceFact=AccessPathUtil.concretizeCallerSourceFact(incomingEdge,summaryEdge.getSourceFact()); propagate(callerSourceFact, retSiteC, callerTargetFact, callSite, false);propagate(callerSourceFact,retSiteC,callerTargetFact,callSite,false); }} } } }} }}  private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {privatevoidpauseEdge(DsourceValue,NtargetStmt,DtargetValue){ M method = icfg.getMethodOf(targetStmt);Mmethod=icfg.getMethodOf(targetStmt); Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());Set<PathEdge<N,D>>edges=pausedEdges.putIfAbsentElseGet(method,newConcurrentHashSet<PathEdge<N,D>>()); edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue));edges.add(newPathEdge<N,D>(sourceValue,targetStmt,targetValue)); logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);logger.trace("PAUSED: <{},{}> -> <{},{}>",method,sourceValue,targetStmt,targetValue); if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {if(edges.add(newPathEdge<N,D>(sourceValue,targetStmt,targetValue))){ logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);logger.trace("PAUSED: <{},{}> -> <{},{}>",method,sourceValue,targetStmt,targetValue); }} }} private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, SpecificFieldReference fieldRef) {privatebooleancheckForInterestedCallers(DcalleeSourceFact,NtargetStmt,SpecificFieldReferenceSpecificfieldRef){ private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {privatebooleancheckForInterestedCallers(DcalleeSourceFact,NtargetStmt,FieldReference......fieldRef){ M calleeMethod = icfg.getMethodOf(targetStmt);McalleeMethod=icfg.getMethodOf(targetStmt); logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);logger.trace("Checking interest at method {} in fact {} with field access {}",calleeMethod,calleeSourceFact,fieldRef);  return false;returnfalse; }}  private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, SpecificFieldReference fieldRef) {privatebooleanhasInterestedCallers(DcalleeSourceFact,McalleeMethod,SpecificFieldReferenceSpecificfieldRef){ private boolean hasInterestedCallers(D calleeSourceFact, M calleeMethod, FieldReference... fieldRef) {privatebooleanhasInterestedCallers(DcalleeSourceFact,McalleeMethod,FieldReference......fieldRef){ D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact,fieldRef); Set<IncomingEdge<D, N>> incomingEdges = incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue);Set<IncomingEdge<D,N>>incomingEdges=incomingEdgesPrefixedWith(calleeMethod,concretizedSourceValue); return !incomingEdges.isEmpty();return!incomingEdges.isEmpty(); /* deliberately exposed to clients */ boolean isUnbalancedReturn) {/* deliberately exposed to clients */booleanisUnbalancedReturn){ final PathEdge<N,D> edge = new PathEdge<N,D>(sourceVal, target, targetVal);finalPathEdge<N,D>edge=newPathEdge<N,D>(sourceVal,target,targetVal); final D existingVal = jumpFn.addFunction(edge);finalDexistingVal=jumpFn.addFunction(edge); //TODO: Merge d.* and d.x for arbitrary x as d.*//TODO: Merge d.* and d.x for arbitrary x as d.* //TODO: Merge d.* and d.*\{x} as d.*//TODO: Merge d.* and d.*\{x} as d.* //TODO: Merge d.*\{a} and d.*/{b} as d.*//TODO: Merge d.*\{a} and d.*/{b} as d.* if (existingVal != null) {if(existingVal!=null){ if (existingVal != targetVal)if(existingVal!=targetVal) existingVal.addNeighbor(targetVal);existingVal.addNeighbor(targetVal);








test/heros/alias/Fact.java








View file @ 7527a0d4






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......












test/heros/alias/Fact.java








View file @ 7527a0d4








test/heros/alias/Fact.java










View file @ 7527a0d4


7527a0d4



......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......






......@@ -11,9 +11,13 @@









package heros.alias;
































import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {



......@@ -22,12 +26,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 public final FieldReference[] accessPath;










 










 public Fact(String name) {










 String[] split = name.split("\\.");










 baseValue = split[0];










 accessPath = new FieldReference[split.length-1];










 for (int i = 1; i < split.length; i++) {










 accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 } else {










 accessPath.add(new FieldReference.Any(identifier));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {



......


package heros.alias;packageheros.alias;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Arrays;importjava.util.Arrays;import java.util.regex.Matcher;importjava.util.regex.Matcher;import java.util.regex.Pattern;importjava.util.regex.Pattern;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;public class Fact implements FieldSensitiveFact<String, Fact> {publicclassFactimplementsFieldSensitiveFact<String,Fact>{ public final FieldReference[] accessPath;publicfinalFieldReference[]accessPath;  public Fact(String name) {publicFact(Stringname){ String[] split = name.split("\\.");String[]split=name.split("\\."); baseValue = split[0];baseValue=split[0]; accessPath = new FieldReference[split.length-1];accessPath=newFieldReference[split.length-1]; for (int i = 1; i < split.length; i++) {for(inti=1;i<split.length;i++){ accessPath[i-1] = new FieldReference.SpecificFieldReference(split[i]);accessPath[i-1]=newFieldReference.SpecificFieldReference(split[i]); Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)([^\\.\\^]+)"); Matcher matcher = pattern.matcher(name);Matchermatcher=pattern.matcher(name); ArrayList<FieldReference> accessPath = Lists.newArrayList();ArrayList<FieldReference>accessPath=Lists.newArrayList();  int firstSeparator = matcher.find() ? matcher.start() : name.length();intfirstSeparator=matcher.find()?matcher.start():name.length(); baseValue = name.substring(0, firstSeparator);baseValue=name.substring(0,firstSeparator); matcher.reset();matcher.reset();  while(matcher.find()) {while(matcher.find()){ String separator = matcher.group(1);Stringseparator=matcher.group(1); String identifier = matcher.group(2);Stringidentifier=matcher.group(2);  if(separator.equals(".")) {if(separator.equals(".")){ accessPath.add(new FieldReference.SpecificFieldReference(identifier));accessPath.add(newFieldReference.SpecificFieldReference(identifier)); } else {}else{ accessPath.add(new FieldReference.Any(identifier));accessPath.add(newFieldReference.Any(identifier)); }} }} this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);this.accessPath=accessPath.toArray(newFieldReference[accessPath.size()]); }}  public Fact(String baseValue, FieldReference[] accessPath) {publicFact(StringbaseValue,FieldReference[]accessPath){








test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......












test/heros/alias/FieldSensitiveSolverTest.java








View file @ 7527a0d4








test/heros/alias/FieldSensitiveSolverTest.java










View file @ 7527a0d4


7527a0d4



......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......






......@@ -13,7 +13,10 @@ package heros.alias;































import org.junit.Before;










import org.junit.Ignore;










import org.junit.Rule;










import org.junit.Test;










import org.junit.rules.TestWatcher;





















import static heros.alias.TestHelper.*;














......@@ -23,9 +26,40 @@ public class FieldSensitiveSolverTest {




















 @Before










 public void before() {










 System.err.println("-----");










 helper = new TestHelper();










 }










 










 @Rule










 public TestWatcher watcher = new TestWatcher() {










 protected void failed(Throwable e, org.junit.runner.Description description) {










 System.err.println("---failed: "+description.getMethodName()+" ----");










 };










 };










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void mergeWithExistingPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void dontMergeWithExistingNonPrefixFacts() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void fieldReadAndWrite() {










 helper.method("bar", 



......@@ -124,48 +158,185 @@ public class FieldSensitiveSolverTest {









 }










 










 @Test










 public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {










 public void prefixFactOfSummaryIgnored() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g"));










 










 helper.method("bar", 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void prefixFactOfSummaryIncoming_ProcessCallCase() {










 public void doNotPauseZeroSources() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0","1")),










 callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),










 normalStmt("f").succ("g", kill("5")));










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 @Ignore("assumes k-limiting not used")










 public void loopAndMerge() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),










 normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),










 normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),










 normalStmt("e").succ("f", kill("1"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotMergePrefixFacts() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),










 normalStmt("b1").succ("c", flow("1", "1")),










 normalStmt("b2").succ("c", flow("1", "1.f")),










 normalStmt("c").succ("d", kill("1"), kill("1.f")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnOverwrittenFieldOfInterest() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", readField("f"), "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseZeroSources() {










 public void pauseOnOverwrittenFieldOfInterest2() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),










 normalStmt("b").succ("c", kill("1.f")));










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f.g")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reached










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),










 normalStmt("d").succ("e", kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void registerPausedEdgeInLateCallers() {










 helper.method("foo", 










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.g")),










 callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),










 normalStmt("e").succ("f", flow("1.g", "3")),










 callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),










 exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void mergeExcludedField() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1")),










 normalStmt("b").succ("c", flow("1", "2", "2^f")),










 normalStmt("c").succ("d", kill("2")));










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeOnTransitiveInterestedCaller() {










 helper.method("foo",










 startPoints("sp"),










 normalStmt("sp").succ("a", flow("0", "1.f")),










 callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),










 callSite("f").calls("bar", flow("2", "1.g")));










 










 helper.method("bar",










 startPoints("b"),










 callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),










 exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));










 










 helper.method("xyz",










 startPoints("c"),










 normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),










 exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));










 










 










 helper.runSolver(false, "sp");










 }










 










 @Test










 public void happyPath() {










 helper.method("bar", 



......


import org.junit.Before;importorg.junit.Before;import org.junit.Ignore;importorg.junit.Ignore;import org.junit.Rule;importorg.junit.Rule;import org.junit.Test;importorg.junit.Test;import org.junit.rules.TestWatcher;importorg.junit.rules.TestWatcher;import static heros.alias.TestHelper.*;importstaticheros.alias.TestHelper.*; @Before@Before public void before() {publicvoidbefore(){ System.err.println("-----");System.err.println("-----"); helper = new TestHelper();helper=newTestHelper(); }}  @Rule@Rule public TestWatcher watcher = new TestWatcher() {publicTestWatcherwatcher=newTestWatcher(){ protected void failed(Throwable e, org.junit.runner.Description description) {protectedvoidfailed(Throwablee,org.junit.runner.Descriptiondescription){ System.err.println("---failed: "+description.getMethodName()+" ----");System.err.println("---failed: "+description.getMethodName()+" ----"); };}; };};  @Test@Test @Ignore("assumes k-limiting not used")@Ignore("assumes k-limiting not used") public void mergeWithExistingPrefixFacts() {publicvoidmergeWithExistingPrefixFacts(){ helper.method("foo", helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("b", flow("1", "1.f")).succ("c", flow("1", "2")),normalStmt("b").succ("b",flow("1","1.f")).succ("c",flow("1","2")), normalStmt("c").succ("d", kill("2")));normalStmt("c").succ("d",kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void dontMergeWithExistingNonPrefixFacts() {publicvoiddontMergeWithExistingNonPrefixFacts(){ helper.method("foo", helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), normalStmt("b").succ("b", flow("1.f", "1"), kill("1")).succ("c", flow("1.f", "2"), kill("1")),normalStmt("b").succ("b",flow("1.f","1"),kill("1")).succ("c",flow("1.f","2"),kill("1")), normalStmt("c").succ("d", kill("2")));normalStmt("c").succ("d",kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void fieldReadAndWrite() {publicvoidfieldReadAndWrite(){ helper.method("bar", helper.method("bar", }}  @Test@Test public void prefixFactOfOnHoldFactIncoming_ProcessExitCase() {publicvoidprefixFactOfOnHoldFactIncoming_ProcessExitCaseOnHoldFactIncoming_ProcessExitCase(){ public void prefixFactOfSummaryIgnored() {publicvoidprefixFactOfSummaryIgnoredSummaryIgnored(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0", "1")), normalStmt("a").succ("b", flow("0","1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),callSite("b").calls("bar",flow("1","2.f")).retSite("e",kill("1")), callSite("e").calls("bar", flow("2", "2")).retSite("g", kill("2")));callSite("e").calls("bar",flow("2","2")).retSite("g",kill("2"))); callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),callSite("e").calls("bar",flow("4","2")).retSite("f",kill("4")), normalStmt("f").succ("g"));normalStmt("f").succ("g"));  helper.method("bar", helper.method("bar",  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", readField("g"), "3"), flow("2", "2")),normalStmt("c").succ("d",flow("2",readField("g"g),"3"),, flowflow(("2""2",, "2""2")),) exitStmt("d").returns(over("b"), to("e"), flow("2.f", "2")).returns(over("e"), to("g"), kill("2"), kill("3")));exitStmt("d").returns(over("b"),to("e"),flow("2.f"2.f,"2"2)).returns(over("e"),to("g"g"),), killkill(("2""2"),), killkill(("3""3))); normalStmt("c").succ("d", flow("2", readField("f"), "3")),normalStmt("c").succ("d",flow("2",readField("f"f),"3")), exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f")));exitStmt("d").returns(over("b"),to("e"),flow("3"3,"4"4)).returns(over("e"),to("f"f)));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void prefixFactOfSummaryIncoming_ProcessCallCase() {publicvoidprefixFactOfSummaryIncoming_ProcessCallCaseprefixFactOfSummaryIncoming_ProcessCallCase(){ public void doNotPauseZeroSources() {publicvoiddoNotPauseZeroSourcesdoNotPauseZeroSources(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0","1")),normalStmt("a").succ("b",flow("0","1")), callSite("b").calls("bar", flow("1", "2.f")).retSite("e", kill("1")),callSite("b").calls("bar",flow("1","2.f")).retSite("e",kill("1")), callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")),callSite("e").calls("bar",flow("4","2")).retSite("f",kill("4")), normalStmt("f").succ("g", kill("5")));normalStmt("f").succ("g",kill("5"))); normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),normalStmt("a").succ("b",flow("0",readField("f"),"1.f")), normalStmt("b").succ("c", kill("1.f")));normalStmt("b").succ("c",kill("1.f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test @Ignore("assumes k-limiting not used")@Ignore("assumes k-limiting not used") public void loopAndMerge() {publicvoidloopAndMerge(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", readField("f"), "2"), flow("1", "1"), flow("2", "2")),normalStmt("b").succ("c",flow("1",readField("f"),"2"),flow("1","1"),flow("2","2")), normalStmt("c").succ("d", flow("1", "1", "1.f"), flow("2", "2")),normalStmt("c").succ("d",flow("1","1","1.f"),flow("2","2")), normalStmt("d").succ("e", flow("1", "1"), flow("2", "2")).succ("b", flow("1", "1"), flow("2", "2")),normalStmt("d").succ("e",flow("1","1"),flow("2","2")).succ("b",flow("1","1"),flow("2","2")), normalStmt("e").succ("f", kill("1"), kill("2")));normalStmt("e").succ("f",kill("1"),kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void doNotMergePrefixFacts() {publicvoiddoNotMergePrefixFacts(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b1", flow("0", "1")).succ("b2", flow("0", "1")),normalStmt("a").succ("b1",flow("0","1")).succ("b2",flow("0","1")), normalStmt("b1").succ("c", flow("1", "1")),normalStmt("b1").succ("c",flow("1","1")), normalStmt("b2").succ("c", flow("1", "1.f")),normalStmt("b2").succ("c",flow("1","1.f")), normalStmt("c").succ("d", kill("1"), kill("1.f")));normalStmt("c").succ("d",kill("1"),kill("1.f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void pauseOnOverwrittenFieldOfInterest() {publicvoidpauseOnOverwrittenFieldOfInterest(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")));callSite("b").calls("bar",flow("1.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", readField("f"), "3")),normalStmt("c").succ("d",flow("2",readFieldread("f"),"3"3)), exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), flow("3", "5")));exitStmtexit("d").returnsreturns((overover(("b""b"),), toto(("e""e"),), flowflow(("3""3",, "4""4")).)).returnsreturns((overover(("e""e"),), toto(("f""f"),), flowflow(("3""3",, "5""5")));))); normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),normalStmt("c").succ("d",flow("2",writeFieldwrite("f"),"2^f"2^f)), normalStmt("d").succ("e")); //only interested in 2.f, but f excluded so this should not be reachednormalStmtnormal("d").succsucc(("e""e"));)); //only interested in 2.f, but f excluded so this should not be reached//only interested in 2.f, but f excluded so this should not be reached  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void doNotPauseZeroSources() {publicvoiddoNotPauseZeroSourcesdoNotPauseZeroSources(){ public void pauseOnOverwrittenFieldOfInterest2() {publicvoidpauseOnOverwrittenFieldOfInterest2pauseOnOverwrittenFieldOfInterest2(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", readField("f"), "1.f")),normalStmt("a").succ("b",flow("0",readField("f"),"1.f")), normalStmt("b").succ("c", kill("1.f")));normalStmt("b").succ("c",kill("1.f"))); normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f.g")));callSite("b").calls("bar",flow("1.f","2.f.g")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f")), normalStmt("d").succ("e")); //only interested in 2.f.g, but f excluded so this should not be reachednormalStmt("d").succ("e"));//only interested in 2.f.g, but f excluded so this should not be reached  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void doNotPauseOnOverwrittenFieldOfInterestedPrefix() {publicvoiddoNotPauseOnOverwrittenFieldOfInterestedPrefix(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2")));callSite("b").calls("bar",flow("1.f","2")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f")), normalStmt("d").succ("e", kill("2^f"))); normalStmt("d").succ("e",kill("2^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void resumeEdgePausedOnOverwrittenField() {publicvoidresumeEdgePausedOnOverwrittenField(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),callSite("b").calls("bar",flow("1.f","2.f")).retSite("e",kill("1.f")), callSite("e").calls("bar", flow("4", "2.g")).retSite("f", kill("4")));callSite("e").calls("bar",flow("4","2.g")).retSite("f",kill("4")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3","4")).returns(over("e"),to("f"),kill("2^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void resumeEdgePausedOnOverwrittenFieldForPrefixes() {publicvoidresumeEdgePausedOnOverwrittenFieldForPrefixes(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),callSite("b").calls("bar",flow("1.f","2.f")).retSite("e",kill("1.f")), callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));callSite("e").calls("bar",flow("4","2")).retSite("f",kill("4")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3", "4")).returns(over("e"), to("f"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3","4")).returns(over("e"),to("f"),kill("2^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void registerPausedEdgeInLateCallers() {publicvoidregisterPausedEdgeInLateCallers(){ helper.method("foo", helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.g")),normalStmt("a").succ("b",flow("0","1.g")), callSite("b").calls("bar", flow("1.g", "1.g")).retSite("e", kill("1.g")),callSite("b").calls("bar",flow("1.g","1.g")).retSite("e",kill("1.g")), normalStmt("e").succ("f", flow("1.g", "3")),normalStmt("e").succ("f",flow("1.g","3")), callSite("f").calls("bar", flow("3", "1"), flow("3.f", "1.f")).retSite("g", kill("3"), kill("3.f") /* TODO: we want to get rid of kill(3.f) */)); //0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller sidecallSite("f").calls("bar",flow("3","1"),flow("3.f","1.f")).retSite("g",kill("3"),kill("3.f")/* TODO: we want to get rid of kill(3.f) */));//0->3 at f, should generate 0->3.f as well, because 1.f is paused on caller side  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("1", readField("f"), "2"), flow("1", "1")),normalStmt("c").succ("d",flow("1",readField("f"),"2"),flow("1","1")), exitStmt("d").returns(over("b"), to("e"), flow("1.g", "1.g") /* ignore fact 2, not possible with this caller ctx*/).returns(over("f"), to("g"), kill("1"), kill("1.f"), kill("2")));exitStmt("d").returns(over("b"),to("e"),flow("1.g","1.g")/* ignore fact 2, not possible with this caller ctx*/).returns(over("f"),to("g"),kill("1"),kill("1.f"),kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void mergeExcludedField() {publicvoidmergeExcludedField(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1")),normalStmt("a").succ("b",flow("0","1")), normalStmt("b").succ("c", flow("1", "2", "2^f")),normalStmt("b").succ("c",flow("1","2","2^f")), normalStmt("c").succ("d", kill("2")));normalStmt("c").succ("d",kill("2")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void resumeOnTransitiveInterestedCaller() {publicvoidresumeOnTransitiveInterestedCaller(){ helper.method("foo",helper.method("foo", startPoints("sp"),startPoints("sp"), normalStmt("sp").succ("a", flow("0", "1.f")),normalStmt("sp").succ("a",flow("0","1.f")), callSite("a").calls("bar", flow("1.f", "1.f")).retSite("f", kill("1.f")),callSite("a").calls("bar",flow("1.f","1.f")).retSite("f",kill("1.f")), callSite("f").calls("bar", flow("2", "1.g")));callSite("f").calls("bar",flow("2","1.g")));  helper.method("bar",helper.method("bar", startPoints("b"),startPoints("b"), callSite("b").calls("xyz", flow("1", "1"), flow("1.f", "1.f"), flow("1.g", "1.g")).retSite("e", kill("1"), kill("1.f"), kill("1.g")),callSite("b").calls("xyz",flow("1","1"),flow("1.f","1.f"),flow("1.g","1.g")).retSite("e",kill("1"),kill("1.f"),kill("1.g")), exitStmt("e").returns(over("a"), to("f"), flow("2", "2")));exitStmt("e").returns(over("a"),to("f"),flow("2","2")));  helper.method("xyz",helper.method("xyz", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("1", readField("g"), "3"), flow("1", readField("f"), "2")),normalStmt("c").succ("d",flow("1",readField("g"),"3"),flow("1",readField("f"),"2")), exitStmt("d").returns(over("b"), to("e"), flow("2", "2"), kill("3")));exitStmt("d").returns(over("b"),to("e"),flow("2","2"),kill("3")));   helper.runSolver(false, "sp");helper.runSolver(false,"sp"); }}  @Test@Test public void happyPath() {publicvoidhappyPath(){ helper.method("bar", helper.method("bar",









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






